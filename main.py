version = "1.0.9"

import os
import logging
import re
from datetime import datetime
from datetime import timezone, timedelta
import zipfile
import glob
import requests
import platform
import pygame
import customtkinter
import tkinter as _tk
import base64
import pickle
import json
import shutil
import subprocess
import psutil
import locale
import random
import math
import time
import secrets
import ctypes
import threading
import queue
import pyperclip
import sys
import inspect
import distro

pygame.init()

pygame.mixer.init(channels = 4096)

try:
    import platform as _platform_mod

    _orig_ctk_sf_init = getattr(customtkinter.CTkScrollableFrame, "__init__", None)

    def _find_scrollable_canvas(widget):
        try:

            queue =[widget]
            while queue:
                w = queue.pop(0)
                if hasattr(w, "yview_scroll"):
                    return w
                try:
                    queue.extend(w.winfo_children())
                except Exception:
                    pass
        except Exception:
            pass
        return None

    def _ctk_scrollableframe_init_wrapper(self, *a, **k):
        if _orig_ctk_sf_init:
            _orig_ctk_sf_init(self, *a, **k)

        def _on_mousewheel_global(event):
            try:
                c = _find_scrollable_canvas(self)
                if not c:
                    return
                sys_platform = _platform_mod.system()

                if hasattr(event, 'num')and event.num in(4, 5):
                    if event.num ==4:
                        c.yview_scroll(-1, "units")
                    else:
                        c.yview_scroll(1, "units")
                else:
                    delta = getattr(event, 'delta', 0)
                    if sys_platform =="Windows":
                        lines = int(-1 *(delta /120))if delta else 0
                    elif sys_platform =="Darwin":
                        lines = int(-1 *delta)if delta else 0
                    else:

                        try:
                            lines = int(-1 *(delta /120))
                        except Exception:
                            lines = 0
                    if lines:
                        c.yview_scroll(lines, "units")
            except Exception:
                pass

        try:

            def _bt4(ev):
                try:

                    x = getattr(ev, 'x_root', None)
                    y = getattr(ev, 'y_root', None)
                    target = None
                    if x is not None and y is not None:
                        try:
                            target = self._parent_canvas.winfo_containing(x, y)
                        except Exception:
                            target = None
                    if target is None:
                        target = getattr(ev, 'widget', None)
                    if not target:
                        return
                    if not self.check_if_master_is_canvas(target):
                        return
                    class _E:pass
                    e = _E()
                    e.widget = getattr(self, "_parent_canvas", None)
                    e.delta = 1
                    e.num = 4
                except Exception:
                    e = ev
                try:
                    self._mouse_wheel_all(e)
                except Exception:
                    pass

            def _bt5(ev):
                try:
                    x = getattr(ev, 'x_root', None)
                    y = getattr(ev, 'y_root', None)
                    target = None
                    if x is not None and y is not None:
                        try:
                            target = self._parent_canvas.winfo_containing(x, y)
                        except Exception:
                            target = None
                    if target is None:
                        target = getattr(ev, 'widget', None)
                    if not target:
                        return
                    if not self.check_if_master_is_canvas(target):
                        return
                    class _E:pass
                    e = _E()
                    e.widget = getattr(self, "_parent_canvas", None)
                    e.delta = -1
                    e.num = 5
                except Exception:
                    e = ev
                try:
                    self._mouse_wheel_all(e)
                except Exception:
                    pass

            self.bind_all("<Button-4>", _bt4, add = "+")
            self.bind_all("<Button-5>", _bt5, add = "+")
        except Exception:
            pass

    try:
        customtkinter.CTkScrollableFrame.__init__ = _ctk_scrollableframe_init_wrapper
    except Exception:
        pass
except Exception:
    pass

try:
    _orig_focus = getattr(_tk.Misc, 'focus', None)
    _orig_focus_set = getattr(_tk.Misc, 'focus_set', None)
    _orig_focus_force = getattr(_tk.Misc, 'focus_force', None)

    def _wrapped_focus(self, *a, **k):
        try:
            if getattr(self, 'winfo_exists', lambda:False)():
                if _orig_focus:
                    return _orig_focus(self, *a, **k)
        except Exception:
            pass

    def _wrapped_focus_set(self, *a, **k):
        try:
            self_obj = a[0]if a else None
        except Exception:
            self_obj = None
        try:
            widget = self_obj if self_obj is not None else None
            if widget is None:
                widget = getattr(k.get('self', None), 'winfo_exists', None)
        except Exception:
            widget = None
        try:

            obj = getattr(self_obj, '__self__', None)or self_obj
            if obj and getattr(obj, 'winfo_exists', lambda:False)():
                if _orig_focus_set:
                    return _orig_focus_set(obj, *a[1:], **k)if a else _orig_focus_set(obj, **k)
        except Exception:
            try:
                if getattr(self, 'winfo_exists', lambda:False)():
                    if _orig_focus_set:
                        return _orig_focus_set(self, *a, **k)
            except Exception:
                pass

    def _wrapped_focus_force(self, *a, **k):
        try:
            if getattr(self, 'winfo_exists', lambda:False)():
                if _orig_focus_force:
                    return _orig_focus_force(self, *a, **k)
        except Exception:
            pass

    try:
        if _orig_focus is not None:
            _tk.Misc.focus = _wrapped_focus
    except Exception:
        pass
    try:
        if _orig_focus_set is not None:
            _tk.Misc.focus_set = _wrapped_focus_set
    except Exception:
        pass
    try:
        if _orig_focus_force is not None:
            _tk.Misc.focus_force = _wrapped_focus_force
    except Exception:
        pass
except Exception:
    pass

class ColoredFormatter(logging.Formatter):
    COLORS = {
    'DEBUG':'\033[36m',
    'INFO':'\033[32m',
    'WARNING':'\033[33m',
    'ERROR':'\033[31m',
    'CRITICAL':'\033[35m',
    }
    RESET = '\033[0m'

    def format(self, record):
        orig_level = record.levelname
        color = self.COLORS.get(orig_level, '')

        formatted = super().format(record)

        if orig_level in('WARNING', 'ERROR', 'CRITICAL', 'DEBUG')and color:
            return f"{color}{formatted}{self.RESET}"

        if orig_level =='INFO'and color:
            try:
                return formatted.replace(orig_level, f"{color}{orig_level}{self.RESET}", 1)
            except Exception:
                return formatted
        return formatted

class StripAnsiFormatter(logging.Formatter):

    ANSI_RE = re.compile(r"\x1b\[[0-9;]*m")

    def format(self, record):

        formatted = super().format(record)
        return self.ANSI_RE.sub('', formatted)

os.makedirs("logs", exist_ok = True)
os.makedirs("logs/archive", exist_ok = True)

log_files = glob.glob("logs/*.log")
if len(log_files)>=50:
    archive_name = f"logs/archive/logs_archive_{datetime.now().strftime('%Y%m%d_%H%M%S')}.zip"
    with zipfile.ZipFile(archive_name, 'w', zipfile.ZIP_DEFLATED)as zipf:
        for log_file in log_files:
            zipf.write(log_file, os.path.basename(log_file))
            os.remove(log_file)

existing_logs = glob.glob("logs/log_*.log")
log_number = len(existing_logs)+1

log_filename = f"logs/log_{log_number}_{datetime.now().strftime('%A_%B_%d_%Y_%H_%M_%S_%f')[:-3]}.log"

file_formatter = logging.Formatter('%(asctime)s | %(levelname)s | %(message)s')
console_formatter = ColoredFormatter('%(asctime)s | %(levelname)s | %(message)s')

file_handler = logging.FileHandler(log_filename)
file_handler.setFormatter(StripAnsiFormatter('%(asctime)s | %(levelname)s | %(message)s'))

console_handler = logging.StreamHandler()
console_handler.setFormatter(console_formatter)

logging.basicConfig(
level = logging.INFO,
handlers =[file_handler, console_handler]
)

dev_log_counters = {
'DEBUG':0,
'INFO':0,
'WARNING':0,
'ERROR':0,
'CRITICAL':0,
}

class DevLogCounter(logging.Handler):

    def emit(self, record:logging.LogRecord)->None:
        try:
            lvl = record.levelname
            if lvl in dev_log_counters:
                dev_log_counters[lvl]+=1
        except Exception:
            pass

try:
    logging.getLogger().addHandler(DevLogCounter())
except Exception:
    pass

ANSI_COLORS = {
'black':'\033[30m',
'red':'\033[31m',
'green':'\033[32m',
'yellow':'\033[33m',
'blue':'\033[34m',
'magenta':'\033[35m',
'cyan':'\033[36m',
'white':'\033[37m',
}

def color_text(text:str, color:str |None)->str:
    if not color:
        return text
    prefix = ANSI_COLORS.get(color, '')
    if not prefix:
        return text
    return f"{prefix}{text}\033[0m"

def strip_ansi(text:str)->str:
    return StripAnsiFormatter.ANSI_RE.sub('', text)

def log_console_colored(logger:logging.Logger, level:int, msg:str, color:str |None = None):

    plain = strip_ansi(msg)
    for h in getattr(logger, 'handlers', []):
        try:

            if isinstance(h, logging.FileHandler):
                rec = logging.LogRecord(logger.name, level, pathname = '', lineno = 0, msg = plain, args =(), exc_info = None)
                try:
                    h.handle(rec)
                except Exception:

                    try:
                        h.emit(rec)
                    except Exception:
                        pass

            elif isinstance(h, logging.StreamHandler):
                rec = logging.LogRecord(logger.name, level, pathname = '', lineno = 0, msg = plain, args =(), exc_info = None)
                try:
                    formatted = h.format(rec)
                except Exception:
                    formatted = plain
                if color:
                    try:
                        formatted = formatted.replace(plain, color_text(plain, color), 1)
                    except Exception:
                        pass
                try:
                    stream = h.stream
                    stream.write(formatted +getattr(h, 'terminator', '\n'))
                    stream.flush()
                except Exception:
                    pass
            else:

                rec = logging.LogRecord(logger.name, level, pathname = '', lineno = 0, msg = plain, args =(), exc_info = None)
                try:
                    h.handle(rec)
                except Exception:
                    try:
                        h.emit(rec)
                    except Exception:
                        pass
        except Exception:
            pass

def log_with_colored_substring(logger:logging.Logger, level:int, plain_msg:str, substring:str, color:str):

    plain = strip_ansi(plain_msg)
    logger.log(level, plain, extra = {"suppress_console":True})

    colored_sub = color_text(substring, color)
    for h in getattr(logger, 'handlers', []):
        try:
            if isinstance(h, logging.StreamHandler)and not isinstance(h, logging.FileHandler):
                try:
                    rec = logging.LogRecord(logger.name, level, pathname = '', lineno = 0, msg = plain, args =(), exc_info = None)
                    formatted = h.format(rec)

                    formatted = formatted.replace(substring, colored_sub, 1)
                    stream = h.stream
                    stream.write(formatted +(getattr(h, 'terminator', '\n')))
                    stream.flush()
                except Exception:
                    pass
        except Exception:
            pass

class ConsoleFilter(logging.Filter):

    def filter(self, record:logging.LogRecord)->bool:
        return not getattr(record, 'suppress_console', False)

try:
    console_handler.addFilter(ConsoleFilter())
except Exception:
    pass
import warnings

logging.captureWarnings(True)
def handle_exception(exc_type, exc_value, exc_traceback):
    if issubclass(exc_type, KeyboardInterrupt):
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
        return
    logging.critical(
    "Uncaught exception",
    exc_info =(exc_type, exc_value, exc_traceback)
    )
import sys

sys.excepthook = handle_exception

def _thread_exception_handler(args):
    try:
        if issubclass(args.exc_type, KeyboardInterrupt):
            return
    except Exception:
        pass
    logging.critical("Uncaught thread exception", exc_info =(args.exc_type, args.exc_value, args.exc_traceback))

try:
    threading.excepthook = _thread_exception_handler
except Exception:

    pass

os.system('cls'if os.name =='nt'else 'clear')

logging.info(f"DOOM Tools, version {version}")
try:
    response = requests.get("https://uselessfacts.jsph.pl/random.json?language=en")
    response.raise_for_status()
    fact = response.json().get("text", "No fact retrieved")
    logging.info(f"{fact}")
except requests.RequestException as e:
    logging.warning(f"Failed to fetch random fact: {e}")

logging.info("Start system information dump")
logging.info(f"Platform: {platform.platform()}")
logging.info(f"Processor: {platform.processor()}")
logging.info(f"Python version: {platform.python_version()}")
distribution_info = "Unknown"
try:
    if os.name !='nt':
        import distro
        distribution_info = f"{distro.name()} {distro.version()}({distro.codename()})"
    else:
        distribution_info = platform.platform()
except ImportError:
    logging.info("distro module not installed; skipping Linux distribution info")
logging.info(f"Distribution: {distribution_info}")
try:
    try:
        locale.setlocale(locale.LC_ALL, '')
    except Exception as e:
        logging.debug(f"Failed to set locale from environment: {e}")
    loc = None
    try:
        loc = locale.getlocale()
    except Exception as e:
        logging.debug(f"locale.getlocale() failed: {e}")
    enc = None
    if hasattr(locale, "getencoding"):
        try:
            enc = locale.getencoding()
        except Exception as e:
            logging.debug(f"locale.getencoding() failed: {e}")
    if not enc:
        try:
            enc = locale.getpreferredencoding(False)
        except Exception as e:
            logging.debug(f"locale.getpreferredencoding() failed: {e}")
    logging.info(f"Locale: {loc}, encoding: {enc}")
except Exception as e:
    logging.warning(f"Failed to determine locale information: {e}")
logging.info(f"CPU count: {psutil.cpu_count(logical = True)}")
logging.info(f"Total RAM: {round(psutil.virtual_memory().total /(1024 **3), 2)} GB")
logging.info(f"Available RAM: {round(psutil.virtual_memory().available /(1024 **3), 2)} GB")
logging.info(f"Python executable: {sys.executable}")
logging.info(f"Current working directory: {os.getcwd()}")
logging.info("End system information dump")

global_variables = {
"devmode":{"value":False, "forced":False},
"dmmode":{"value":False, "forced":False},
"debugmode":{"value":False, "forced":False},
"current_table":None,
"ide":False,
"table_extension":".sldtbl",
"save_extension":".sldsv",
"lootcrate_extension":".sldlct",
"transfer_extension":".sldtrf",
"enemyloot_extension":".sldenlt",
}

def get_current_table_path():

    current_tbl = global_variables.get('current_table')
    if current_tbl:
        return os.path.join("tables", current_tbl)
    table_files = sorted(glob.glob(os.path.join("tables", f"*{global_variables.get('table_extension', '.sldtbl')}")))
    if table_files:
        return table_files[0]
    return None

try:
    tfiles = sorted(glob.glob(os.path.join(os.getcwd(), 'tables', f"*{global_variables.get('table_extension', '.sldtbl')}")))
    if tfiles:
        with open(tfiles[0], 'r', encoding = 'utf-8')as _tf:
            _td = json.load(_tf)
        globals()['table_data']= _td
        global_variables['current_table']= os.path.basename(tfiles[0])
        logging.info(f"Loaded global table_data from {os.path.basename(tfiles[0])}")
except Exception:

    pass

def show_error_dialog(title, message):

    try:
        if os.name =='nt':
            try:
                ctypes.windll.user32.MessageBoxW(0, str(message), str(title), 0x10)
                return
            except Exception:

                pass
    except Exception:
        pass

    try:
        if shutil.which('zenity'):
            subprocess.run(['zenity', '--error', '--title', str(title), '--text', str(message)])
            return
        if shutil.which('kdialog'):
            subprocess.run(['kdialog', '--title', str(title), '--error', str(message)])
            return
        if shutil.which('notify-send'):
            subprocess.run(['notify-send', str(title), str(message)])
            return
    except Exception:
        pass

    try:
        import tkinter as _tk
        from tkinter import messagebox as _mb
        _root = _tk.Tk()
        _root.withdraw()
        _mb.showerror(str(title), str(message))
        try:
            _root.destroy()
        except Exception:
            pass
        return
    except Exception:
        logging.error("Unable to display GUI error dialog: %s - %s", title, message)
        logging.info(f"Linux distribution: {distribution_info}")

def show_table_selection_dialog():

    try:
        tfiles = sorted(glob.glob(os.path.join(os.getcwd(), 'tables', f"*{global_variables.get('table_extension', '.sldtbl')}")))
        if len(tfiles)<=1:
            return None

        table_info =[]
        for tpath in tfiles:
            try:
                with open(tpath, 'r', encoding = 'utf-8')as f:
                    tdata = json.load(f)
                prettyname = tdata.get('prettyname', os.path.basename(tpath))
                table_info.append({'path':tpath, 'filename':os.path.basename(tpath), 'prettyname':prettyname})
            except Exception:
                table_info.append({'path':tpath, 'filename':os.path.basename(tpath), 'prettyname':os.path.basename(tpath)})

        selected_table =[None]

        root = customtkinter.CTk()
        root.title("Select Data Table")
        root.geometry("500x400")
        root.resizable(False, False)

        try:
            root.attributes('-topmost', True)
        except Exception:
            pass

        title = customtkinter.CTkLabel(root, text = "Select Data Table", font = customtkinter.CTkFont(size = 20, weight = "bold"))
        title.pack(pady = 20)

        subtitle = customtkinter.CTkLabel(root, text = "Multiple data tables detected.Please select which table to use:", font = customtkinter.CTkFont(size = 12))
        subtitle.pack(pady =(0, 15))

        scroll_frame = customtkinter.CTkScrollableFrame(root, width = 450, height = 200)
        scroll_frame.pack(pady = 10, padx = 20)

        def select_table(info):
            selected_table[0]= info
            root.quit()
            root.destroy()

        for info in table_info:
            btn_frame = customtkinter.CTkFrame(scroll_frame, fg_color = "transparent")
            btn_frame.pack(fill = "x", pady = 5)

            btn = customtkinter.CTkButton(
            btn_frame,
            text = f"{info['prettyname']}\n({info['filename']})",
            command = lambda i = info:select_table(i),
            width = 420,
            height = 50,
            font = customtkinter.CTkFont(size = 14)
            )
            btn.pack()

        cancel_btn = customtkinter.CTkButton(root, text = "Exit", command = lambda:sys.exit(0), width = 150, height = 40, fg_color = "#666666")
        cancel_btn.pack(pady = 20)

        root.mainloop()

        if selected_table[0]:
            try:
                with open(selected_table[0]['path'], 'r', encoding = 'utf-8')as f:
                    globals()['table_data']= json.load(f)
                global_variables['current_table']= selected_table[0]['filename']
                logging.info(f"User selected table: {selected_table[0]['filename']}")
            except Exception as e:
                logging.error(f"Failed to load selected table: {e}")
        return selected_table[0]
    except Exception as e:
        logging.exception(f"Table selection dialog failed: {e}")
        return None

possible_flags =["--dev", "--dm", "--debug", "--force", "-debug"]

for flag in possible_flags:
    if flag in sys.argv:
        if flag =="--dev":
            global_variables["devmode"]["value"]= True
            logging.info("Development mode activated via command-line flag.")
        elif flag =="--dm":
            global_variables["dmmode"]["value"]= True
            logging.info("DM mode activated via command-line flag.")
        elif flag in("--debug", "-debug"):
            global_variables["debugmode"]["value"]= True
            logging.info("Debug mode activated via command-line flag.")
        elif flag =="--force":
            for var in global_variables:
                if isinstance(global_variables[var], dict)and "forced"in global_variables[var]:
                                    global_variables[var]["forced"]= True
            logging.info("Force flag applied to all modes.")

if global_variables["debugmode"]["value"]:
    logging.getLogger().setLevel(logging.DEBUG)
    logging.info("Debug mode enabled.Logging level set to DEBUG.")
    logging.info("Starting debug tests")
    logging.debug("Debug level test")
    logging.info("Info level test")
    logging.warning("Warning level test")
    logging.error("Error level test")
    logging.critical("Critical level test")
    logging.info("Debug tests complete")

appearance_settings = {
"appearance_mode":"system",
"color_theme":"dark-blue",
"resolution":"1920x1080",
"fullscreen":False,
"borderless":False,
"units":"imperial",
"auto_set_units":False,
"sound_volume":100
}

folders =[
{"name":"logs", "ignore_gitignore":False},
{"name":"sounds", "ignore_gitignore":False},
{"name":"tables", "ignore_gitignore":True},
{"name":"transfers", "ignore_gitignore":False},
{"name":"lootcrates", "ignore_gitignore":False},
{"name":"enemyloot", "ignore_gitignore":False},
{"name":"themes", "ignore_gitignore":False},
{"name":"combatreports", "ignore_gitignore":False},
]

themes_dir = "themes"
os.makedirs(themes_dir, exist_ok = True)

tmp_zip = None
extract_dir = None

try:
    if not any(os.scandir(themes_dir)):
        logging.info("Themes folder is empty.Downloading CTkThemesPack...")
        tmp_zip = "CTkThemesPack.zip"
        extract_dir = "CTkThemesPack_src"

        response = requests.get("https://github.com/a13xe/CTkThemesPack/archive/refs/heads/main.zip", timeout = 30)
        response.raise_for_status()
        with open(tmp_zip, "wb")as f:
            f.write(response.content)

        os.makedirs(extract_dir, exist_ok = True)
        with zipfile.ZipFile(tmp_zip, "r")as zip_ref:
            zip_ref.extractall(extract_dir)

        extracted_roots =[d for d in os.listdir(extract_dir)if os.path.isdir(os.path.join(extract_dir, d))]
        if extracted_roots:
            src_theme_dir = os.path.join(extract_dir, extracted_roots[0], "themes")
            if os.path.isdir(src_theme_dir):
                for entry in os.listdir(src_theme_dir):
                    src_path = os.path.join(src_theme_dir, entry)
                    dst_path = os.path.join(themes_dir, entry)
                    if os.path.isdir(src_path):
                        shutil.copytree(src_path, dst_path, dirs_exist_ok = True)
                    else:
                        shutil.copy2(src_path, dst_path)
                logging.info("Themes downloaded and installed successfully.")
            else:
                logging.warning("No 'themes' directory found in downloaded package.")
        else:
            logging.warning("Failed to locate extracted CTkThemesPack directory.")

except Exception as e:
    logging.error(f"Failed to populate themes: {e}")

ide_indicators =[
'PYCHARM_HOSTED',
'VSCODE_PID',
'SPYDER_KERNELS_NAMESPACE',
'PYDEVD_USE_FRAME_EVAL',
'TERM_PROGRAM',
'JUPYTER_RUNTIME_DIR',
'JPY_PARENT_PID',
'IPYTHONDIR',
'PYCHARM_MATPLOTLIB_INTERACTIVE',
'PYCHARM_DISPLAY_PORT',
'INTELLIJ_ENVIRONMENT_READER',
'IDEA_INITIAL_DIRECTORY',
'PYTHONIOENCODING',
'PYDEV_CONSOLE_ENCODING',
'VSCODE_CLI',
'VSCODE_GIT_ASKPASS_NODE',
'VSCODE_INJECTION'
]

try:
    _debugger_attached = sys.gettrace()is not None
except Exception:
    _debugger_attached = False
if not _debugger_attached:
    _debugger_attached = any(m in sys.modules for m in('pydevd', 'debugpy', 'ptvsd'))
if _debugger_attached:
    if('-debug'not in sys.argv)and('--debug'not in sys.argv):
        sys.argv.append('-debug')
        logging.info('Debugger detected; added -debug to argv')

dm_users =["bGlseQ==", "amFjemk=", "cGhvbmU=", "YWlkZW4="]

if any(indicator in os.environ for indicator in ide_indicators):
    if not global_variables["devmode"]["value"]and not global_variables["devmode"]["forced"]:
        global_variables["devmode"]["value"]= True
        logging.info("Development mode activated due to IDE environment detection.")
    elif global_variables["devmode"]["value"]:
        logging.info("IDE environment detected, but development mode is already set.")
    else:
        logging.info("IDE environment detected, but development mode is forced off.")
    logging.info(f"Trigger: {[key for key in os.environ if key in ide_indicators]}")
    global_variables["ide"]= True
    try:

            try:
                from scripts import generate_requirements
                generate_requirements.generate_requirements(ide_mode = True)
            except Exception:
                logging.exception('Failed to refresh requirements.txt in IDE mode')
    except Exception:
        pass
    for folder_entry in folders:
        folder = folder_entry["name"]
        ignore_gitignore = folder_entry.get("ignore_gitignore", False)

        if not os.path.exists(folder):
            os.makedirs(folder)
            logging.info(f"Created missing folder: {folder}")
        if ignore_gitignore:
            logging.info(f"Skipped.gitignore addition for '{folder}'(ignore_gitignore=True)")
            continue

        with open('.gitignore', 'a')as gitignore:
            existing_gitignore = set()
            try:
                with open('.gitignore', 'r')as read_gitignore:
                    existing_gitignore = set(line.strip()for line in read_gitignore)
            except FileNotFoundError:
                pass
            entry = f'/{folder}/'
            if entry not in existing_gitignore:
                gitignore.write(f'{entry}\n')
                logging.info(f"Added '{entry}' to.gitignore")
            else:
                logging.info(f"'{entry}' already exists in.gitignore")
    try:
        from scripts import generate_requirements
        generate_requirements.generate_requirements(ide_mode = False)
    except Exception as e:
        logging.warning(f"Failed to update requirements.txt: {e}")

saves_folder = "saves"

if not global_variables["devmode"]["value"]:
    logging.info("Running in production mode.")
    if os.name =='nt':
        base_ld = os.getenv('LOCALAPPDATA')or os.path.expanduser('~')
        saves_folder = os.path.join(base_ld, 'soli_dstate', 'DOOM-Tools', 'saves')
    else:
        saves_folder = os.path.expanduser('~/.local/share/soli_dstate/DOOM-Tools/saves')
else:
    logging.info("Running in development mode.")
    saves_folder = "saves"
    folders.append({"name":"saves", "ignore_gitignore":False})

for folder_entry in folders:
    folder = folder_entry["name"]
    if not os.path.exists(folder):
        os.makedirs(folder)
        logging.info(f"Created missing folder: {folder}")

os.makedirs(saves_folder or "saves", exist_ok = True)

try:
    appearance_settings_path = os.path.join(saves_folder, "appearance_settings.sldsv")
    if os.path.exists(appearance_settings_path):
        with open(appearance_settings_path, 'r')as f:
            loaded_settings = json.load(f)
        appearance_settings.update(loaded_settings)
        logging.info(f"Appearance settings loaded from {appearance_settings_path}")
except Exception as e:
    logging.warning(f"Failed to load appearance settings: {e}")

try:
    settings_path = os.path.join(saves_folder, "settings.sldsv")
    if os.path.exists(settings_path):
        with open(settings_path, 'r')as f:
            loaded_globals = json.load(f)

        for key, value in loaded_globals.items():
            if key in global_variables:
                if isinstance(global_variables[key], dict)and isinstance(value, dict):
                    global_variables[key].update(value)
                else:
                    global_variables[key]= value
            else:
                global_variables[key]= value
        logging.info(f"Global settings loaded from {settings_path}")
except Exception as e:
    logging.warning(f"Failed to load global settings: {e}")

def _sync_remote_table():
    try:
        table_dir = os.path.join(os.getcwd(), "tables")
        if not os.path.isdir(table_dir):
            logging.info("No tables directory present; skipping remote table sync")
            return

        local_tables = sorted(glob.glob(os.path.join("tables", f"*{global_variables.get('table_extension', '.sldtbl')}")))
        if not local_tables:
            logging.info("No local table files found; skipping remote table sync")
            return

        target_local = None
        cur_tbl = global_variables.get("current_table")
        if cur_tbl:
            for f in local_tables:
                if os.path.abspath(f).endswith(cur_tbl)or os.path.basename(f)==cur_tbl:
                    target_local = f
                    break

        if not target_local:
            target_local = local_tables[0]

        basename = os.path.basename(target_local)
        raw_base = "https://raw.githubusercontent.com/soli-dstate/DOOM-Tools/master/tables/"
        remote_url = raw_base +basename

        logging.info(f"Checking remote table for updates: {remote_url}")
        resp = requests.get(remote_url, timeout = 15)
        if resp.status_code !=200:
            logging.info(f"Remote table not found(status {resp.status_code}): {remote_url}")
            return

        remote_text = resp.text
        try:
            with open(target_local, 'r', encoding = 'utf-8')as f:
                local_text = f.read()
        except Exception as e:
            logging.warning(f"Failed to read local table {target_local}: {e}")
            local_text = None

        if local_text is None or local_text !=remote_text:
            if global_variables.get("devmode", {}).get("value", False):
                logging.info("Devmode enabled: remote table differs but will not replace local file")
                return

            name_root, _ = os.path.splitext(basename)
            backup_name = name_root +".backup"
            backup_path = os.path.join(table_dir, backup_name)
            try:
                if os.path.exists(target_local):
                    shutil.move(target_local, backup_path)
                    logging.info(f"Backed up local table {target_local} -> {backup_path}")

                with open(target_local, 'w', encoding = 'utf-8')as f:
                    f.write(remote_text)
                logging.info(f"Replaced local table with remote version: {target_local}")
            except Exception as e:
                logging.error(f"Failed to replace local table with remote version: {e}")
        else:
            logging.info("Local table matches remote; no update needed")
    except Exception as e:
        logging.error(f"Error during remote table sync: {e}")

if not global_variables.get("devmode", {}).get("value", False):
    logging.info("Remote table sync active, syncing...")
    _sync_remote_table()
    logging.info("Remote table sync complete.")
else:
    logging.info("Remote table sync active, skipped due to devmode.")

def suggest_magazine_for_weapon_static(weapon):

    try:
        name =(weapon.get('name')or '').strip()
    except Exception:
        name = ''
    try:
        calib_raw = weapon.get('caliber')
        if isinstance(calib_raw, (list, tuple))and calib_raw:
            calib = str(calib_raw[0])
        else:
            calib = str(calib_raw or '')
    except Exception:
        calib = ''

    results = {
    'weapon_name':name,
    'caliber':calib,
    'wiki_matches':[],
    'suggested_capacities':[],
    'suggested_mag_item':None,
    'next_id':0,
    'notes':[]
    }

    caliber_map = {
    '9x19':[15, 17, 30],
    '9mm':[15, 17, 30],
    '5.56x45':[30],
    '5.56':[30],
    '7.62x39':[30],
    '7.62x51':[20, 30],
    '7.62':[20, 30],
    '.45 acp':[7, 8, 10],
    '.45':[7, 8, 10],
    '.308':[10, 20, 30],
    '.30-06':[5, 10],
    '12 gauge':[1, 4, 5, 8],
    '40mm':[1]
    }

    def _norm(s):
        try:
            return re.sub(r"[^0-9a-zA-Z\.x\-\s]", '', str(s or '')).strip().lower()
        except Exception:
            return ''

    capacities_meta =[]
    try:
        session = requests.Session()
        session.headers.update({'User-Agent':'DOOM-Tools/1.0(https://example.local)'})
        wiki_candidates =[]

        def _safe_wiki_get(url, params = None, timeout = 8):
            try:
                r = session.get(url, params = params, timeout = timeout)
            except Exception as e:
                logging.warning("suggest_magazine_for_weapon_static: HTTP request failed(%s): %s", url, e)
                return None
            if r is None:
                return None
            text =(r.text or '').strip()
            if not text:
                logging.warning("suggest_magazine_for_weapon_static: Empty response from %s", url)
                return None
            try:
                return r.json()
            except ValueError:

                try:
                    logging.warning("suggest_magazine_for_weapon_static: Non-JSON response from %s: %s", url, text[:400].replace('\n', ' '))
                except Exception:
                    pass
                return None

        if name:
            url = 'https://en.wikipedia.org/w/api.php'
            params = {'action':'query', 'list':'search', 'srsearch':name, 'format':'json', 'srlimit':4}
            j = _safe_wiki_get(url, params = params)
            if j:
                for s in j.get('query', {}).get('search', [])or[]:
                    wiki_candidates.append(s.get('title'))
        if calib:
            url = 'https://en.wikipedia.org/w/api.php'
            params = {'action':'query', 'list':'search', 'srsearch':calib, 'format':'json', 'srlimit':4}
            j = _safe_wiki_get(url, params = params)
            if j:
                for s in j.get('query', {}).get('search', [])or[]:
                    if s.get('title')not in wiki_candidates:
                        wiki_candidates.append(s.get('title'))

        capacities_found =[]
        api = 'https://en.wikipedia.org/w/api.php'
        for title in wiki_candidates[:4]:
            try:
                params = {'action':'query', 'prop':'extracts', 'explaintext':1, 'titles':title, 'format':'json', 'exintro':1}
                j = _safe_wiki_get(api, params = params)
                text = ''
                if j:
                    pages = j.get('query', {}).get('pages', {})or {}
                    for p in pages.values():
                        text = p.get('extract')or ''
                        break

                try:
                    wt_params = {'action':'query', 'prop':'revisions', 'rvprop':'content', 'rvslots':'main', 'titles':title, 'format':'json'}
                    jwt = _safe_wiki_get(api, params = wt_params)
                    wikitext = ''
                    if jwt:
                        pages2 = jwt.get('query', {}).get('pages', {})or {}
                        for p2 in pages2.values():
                            revs = p2.get('revisions')or[]
                            if revs:

                                r0 = revs[0]
                                if isinstance(r0, dict):
                                    if 'slots'in r0 and isinstance(r0.get('slots'), dict):
                                        main_slot = r0.get('slots', {}).get('main', {})or {}
                                        wikitext = main_slot.get('*')or ''
                                    if not wikitext:
                                        wikitext = r0.get('*')or r0.get('content')or ''
                            break
                    if wikitext:

                        for m in re.finditer(r"\|\s*(feed(?:_system)?|feed_system|magazine|capacity|feeds?)\s*=\s*(.*?)(?=\n\s*\||\n\s*\}\})", wikitext, flags = re.IGNORECASE |re.DOTALL):
                            raw_block =(m.group(2)or '').strip()
                            if not raw_block:
                                continue

                            lines =[ln.strip()for ln in raw_block.splitlines()if ln.strip()]
                            for ln in lines:

                                ln2 = re.sub(r"^[\*\u2022\-\:\;\s]+", '', ln)
                                if not ln2:
                                    continue

                                nums = re.findall(r"(\d{1, 3})\s*(?:-round|rounds|round|rnd|rd|rds)\b", ln2, flags = re.IGNORECASE)

                                nums +=re.findall(r"(\d{1, 3})\s*\+\s*1", ln2)

                                if not nums and re.search(r"magazin|feed|capac|round", ln2, flags = re.IGNORECASE):
                                    nums = re.findall(r"(\d{1, 3})", ln2)

                                for n in nums:
                                    try:
                                        iv = int(n)
                                        if 1 <=iv <=200:

                                            try:
                                                if calib and calib.lower()in ln2.lower():
                                                    capacities_found.extend([iv, iv])
                                                else:
                                                    capacities_found.append(iv)
                                            except Exception:
                                                capacities_found.append(iv)
                                    except Exception:
                                        pass

                            if not capacities_found:
                                try:
                                    logging.debug("suggest_magazine_for_weapon_static: no numeric capacities parsed from infobox block for %s: %s", title, raw_block[:300].replace('\n', ' '))
                                except Exception:
                                    pass
                        if capacities_found:
                            try:
                                logging.info("suggest_magazine_for_weapon_static: infobox feed capacities for %s: %s", title, capacities_found)
                                results['notes'].append(f"infobox_feed_caps: {capacities_found}")
                            except Exception:
                                pass
                except Exception:
                    pass

                if not text:
                    try:
                        rest_url = f"https://en.wikipedia.org/api/rest_v1/page/summary/{requests.utils.requote_uri(title)}"
                        r2 = session.get(rest_url, timeout = 8)
                        if r2 and r2.status_code ==200:
                            try:
                                j2 = r2.json()
                                text =(j2.get('extract')or '')
                            except ValueError:
                                logging.warning("suggest_magazine_for_weapon_static: REST summary non-JSON for %s: %s", title, (r2.text or '')[:200])
                        else:
                            logging.warning("suggest_magazine_for_weapon_static: REST summary failed for %s: status %s", title, getattr(r2, 'status_code', None))
                    except Exception as e:
                        logging.warning("suggest_magazine_for_weapon_static: REST summary request failed for %s: %s", title, e)
                if not text:
                    continue
                results['wiki_matches'].append({'title':title, 'snippet':text[:600]})
                lower = text.lower()
                for m in re.finditer(r"magazine|capacity|standard|commonly|usually", lower):
                    start = max(0, m.start()-120)
                    end = min(len(lower), m.end()+120)
                    ctx = lower[start:end]
                    nums = re.findall(r"(\d{1, 3})\s*(?:-round|rounds|round|rnd|rd)", ctx)
                    for n in nums:
                        try:
                            capacities_meta.append((int(n), ctx))
                        except Exception:
                            pass
                nums2 = re.findall(r"(\d{1, 3})\s*-?\s*round(?:s)?", lower)
                for n in nums2:
                    try:
                        capacities_meta.append((int(n), lower))
                    except Exception:
                        pass
            except Exception:
                continue
    except Exception as e:
        results['notes'].append('Wikipedia lookup failed or timed out')
        logging.warning("suggest_magazine_for_weapon_static: Wikipedia lookup error for '%s' calib='%s': %s", name, calib, e)

    caps =[]

    if capacities_meta:
        try:
            raw_caps =[c for c, _ in capacities_meta]
            logging.debug("suggest_magazine_for_weapon_static: raw capacities_meta for '%s'(calib=%s): %s", name, calib, raw_caps)
        except Exception:
            raw_caps =[c for c, _ in capacities_meta]

        def _norm_for_match(s:str)->str:
            try:
                s2 = str(s or '').lower()
                s2 = s2.replace('\u00d7', 'x').replace('Ã—', 'x')
                s2 = re.sub(r"[^0-9a-zx]+", ' ', s2)
                return s2
            except Exception:
                return str(s or '').lower()

        calib_norm = _norm_for_match(calib)
        calib_freq = {}
        overall_freq = {}
        for iv, src in capacities_meta:
            overall_freq[iv]= overall_freq.get(iv, 0)+1
            try:
                if calib and calib_norm and calib_norm in _norm_for_match(src):
                    calib_freq[iv]= calib_freq.get(iv, 0)+1
            except Exception:
                pass

        if calib_freq:
            caps = sorted(calib_freq.keys(), key = lambda x:(-calib_freq[x], -overall_freq.get(x, 0), x))[:5]
        else:
            caps = sorted(overall_freq.keys(), key = lambda x:(-overall_freq[x], x))[:5]
        try:
            logging.info("suggest_magazine_for_weapon_static: Wikipedia capacities for '%s'(calib=%s): %s(raw=%s)", name, calib, caps, raw_caps)
            results['notes'].append(f"wikipedia_caps: {caps}")
        except Exception:
            pass

    if not caps and calib:
        ncal = _norm(calib)

        ncal_tokens = set(re.findall(r"\w+", ncal))
        for k, v in caliber_map.items():
            nk = _norm(k)
            k_tokens = set(re.findall(r"\w+", nk))

            if ncal_tokens &k_tokens:
                caps = v[:3]
                try:
                    logging.info("suggest_magazine_for_weapon_static: used caliber_map fallback for '%s'(calib=%s): %s(matched_key=%s)", name, calib, caps, k)
                    results['notes'].append(f"fallback_caliber_map: {caps}(matched {k})")
                except Exception:
                    pass
                break

    if not caps:
        caps =[10, 20, 30]
        try:
            logging.info("suggest_magazine_for_weapon_static: using default capacities for '%s'(calib=%s): %s", name, calib, caps)
            results['notes'].append('fallback_default_caps')
        except Exception:
            pass

    results['suggested_capacities']= caps

    try:
        table_files = glob.glob(os.path.join('tables', '*.sldtbl'))
        maxid = 0
        for tf in table_files:
            try:
                with open(tf, 'r', encoding = 'utf-8')as fh:
                    td = json.load(fh)
                for items in(td.get('tables')or {}).values():
                    if isinstance(items, list):
                        for it in items:
                            if isinstance(it, dict)and 'id'in it:
                                iid = it.get('id')
                                try:
                                    if iid is None:
                                        continue
                                    iv = int(iid)
                                    if iv >maxid:
                                        maxid = iv
                                except Exception:
                                    pass
            except Exception:
                continue
        next_id = maxid +1
    except Exception:
        next_id = 0

    results['next_id']= next_id

    try:
        cap0 = caps[0]if caps else 30
        mag_item = {'id':next_id, 'name':f"Synthetic Mag({cap0})", 'capacity':int(cap0), 'magazinetype':weapon.get('magazinetype')or 'detachable box', 'magazinesystem':weapon.get('magazinesystem')or weapon.get('magazinetype')or '', 'rounds':[]}
        round_name =(calib or 'Unknown')+' | FMJ'
        for i in range(int(cap0)):
            mag_item['rounds'].append({'name':round_name, 'caliber':calib or None, 'variant':'FMJ'})
        results['suggested_mag_item']= mag_item
    except Exception:
        results['notes'].append('Failed to build mag item')

    return results

def validate_table_ids():

    tables_dir = "tables"
    if not os.path.isdir(tables_dir):
        logging.warning(f"Tables directory '{tables_dir}' not found, skipping validation.")
        return

    table_files =[f for f in os.listdir(tables_dir)if f.endswith(".sldtbl")]
    if not table_files:
        logging.info("No table files found to validate.")
        return

    global_id_map = {}

    magazine_errors =[]
    magazine_errors_details =[]
    table_sequence_errors =[]
    table_sequence_details =[]
    ammo_errors =[]
    ammo_errors_details =[]

    referenced_slots = set()
    all_table_items =[]

    for table_file in sorted(table_files):
        table_path = os.path.join(tables_dir, table_file)
        try:
            with open(table_path, 'r', encoding = 'utf-8')as f:
                table_data = json.load(f)

            table_name = table_data.get("prettyname", table_file)
            tables = table_data.get("tables", {})

            try:
                magazine_items =[]
                if isinstance(tables, dict):
                    magazine_items = tables.get("magazines", [])or[]

                magazine_systems = set()
                for mag in magazine_items:
                    if isinstance(mag, dict):
                        ms = mag.get("magazinesystem")
                        if ms is None:
                            continue
                        if isinstance(ms, list):
                            for m in ms:
                                magazine_systems.add(str(m))
                        else:
                            magazine_systems.add(str(ms))

                for subtable_name_check, items_check in tables.items():
                    if not isinstance(items_check, list):
                        continue
                    for item_check in items_check:
                        if not isinstance(item_check, dict):
                            continue
                        if item_check.get("firearm")and str(item_check.get("magazinetype", "")).lower()=="detachable box":
                            f_ms = item_check.get("magazinesystem")
                            friendly = f"Table '{table_name}': Firearm '{item_check.get('name')}'(ID {item_check.get('id')})"

                            if item_check.get('has_magazine_in_pool')is False:
                                continue

                            if f_ms is None:
                                msg = f"{friendly} missing 'magazinesystem' field"
                                logging.error(msg)
                                magazine_errors.append(msg)
                                try:
                                    magazine_errors_details.append({'table':table_name, 'weapon':item_check, 'reason':'missing_magazinesystem', 'message':msg})
                                except Exception:
                                    pass
                                continue

                            needed =[f_ms]if not isinstance(f_ms, list)else f_ms

                            needed =[str(n)for n in needed]
                            compatible = any(n in magazine_systems for n in needed)
                            if not compatible:
                                msg = f"{friendly} has no magazines matching magazinesystem(s): {needed}"
                                magazine_errors.append(msg)
                                try:
                                    magazine_errors_details.append({'table':table_name, 'weapon':item_check, 'reason':'no_compatible_magazines', 'message':msg})
                                except Exception:
                                    pass
            except Exception as e:
                logging.warning(f"Failed to perform magazine compatibility check for '{table_file}': {e}")

            file_ids =[]

            for subtable_name, items in tables.items():
                if not isinstance(items, list):
                    continue
                for idx, item in enumerate(items):
                    if isinstance(item, dict)and "id"in item:
                        item_id = item["id"]
                        file_ids.append(item_id)

                        entry =(table_file, subtable_name, item.get("name")or f"index_{idx}")
                        global_id_map.setdefault(item_id, []).append(entry)

                    if isinstance(item, dict):
                        all_table_items.append((item, table_file, subtable_name))

                        try:
                            accs = item.get('accessories')or[]
                            if isinstance(accs, list):
                                for a in accs:
                                    if isinstance(a, dict)and a.get('slot'):
                                        referenced_slots.add(str(a.get('slot')).strip())
                        except Exception:
                            pass

                        try:
                            subs = item.get('subslots')or[]
                            if isinstance(subs, list):
                                for s in subs:
                                    if isinstance(s, dict)and s.get('slot'):
                                        referenced_slots.add(str(s.get('slot')).strip())
                        except Exception:
                            pass

            if not file_ids:
                logging.info(f"Table '{table_name}': No items with IDs found.")
                continue

            file_ids.sort()
            min_id = file_ids[0]
            max_id = file_ids[-1]
            next_id = max_id +1

            expected_ids = set(range(min_id, max_id +1))
            actual_ids = set(file_ids)
            if expected_ids ==actual_ids:
                plain = f"Table '{table_name}': IDs valid(sequential from {min_id} to {max_id}).Next ID: {next_id}"
                log_with_colored_substring(logging.getLogger(), logging.INFO, plain, str(next_id), 'blue')
            else:
                missing_ids = sorted(expected_ids -actual_ids)

                logging.error(f"Table '{table_name}': ID sequence broken(details collected for dialog).")

                try:
                    file_entries =[]
                    for iid in sorted(actual_ids):
                        locs = global_id_map.get(iid, [])
                        for f, sub, name in locs:
                            if f ==table_file:
                                file_entries.append((iid, sub, name))
                                break
                    suggested_lines =[]
                    new_id = min_id
                    for old_id, sub, name in file_entries:
                        if old_id !=new_id:
                            suggested_lines.append(f"Change ID {old_id}({sub}:{name}) -> {new_id}")
                        new_id +=1
                except Exception:
                    suggested_lines =["Unable to build suggested ID changes."]

                id_msg_lines =[
                f"Table: {table_name}",
                "ID sequence broken:",
                f" Missing IDs: {missing_ids}",
                f" Last ID: {max_id}",
                f" Next ID: {next_id}",
                ]
                if suggested_lines:
                    id_msg_lines.append("")
                    id_msg_lines.append("Suggested changes to fix IDs:")
                    id_msg_lines.extend([f" {l}"for l in suggested_lines])

                seq_msg = "\n".join(id_msg_lines)
                table_sequence_errors.append(seq_msg)
                try:
                    table_sequence_details.append({'table':table_name, 'missing_ids':missing_ids, 'last_id':max_id, 'next_id':next_id, 'suggested_changes':suggested_lines})
                except Exception:
                    table_sequence_details.append({'table':table_name, 'message':seq_msg})
                logging.error("Table '%s': ID sequence error detected(collected, continuing checks).", table_name)

        except Exception as e:
            logging.error(f"Failed to validate table '{table_file}': {e}")

    ammo_names_present = set()
    ammo_calibers_present = set()
    try:
        for item, tf, sub in all_table_items:
            try:
                if isinstance(sub, str)and sub.lower()in('ammunition', 'ammo'):
                    name = item.get('name')
                    if name:
                        ammo_names_present.add(str(name).strip().lower())
                    calib = item.get('caliber')
                    if calib:
                        ammo_calibers_present.add(str(calib).strip().lower())
            except Exception:
                continue
    except Exception:
        pass

    try:
        for item, tf, sub in all_table_items:
            try:
                if not isinstance(item, dict):
                    continue
                if item.get('firearm'):
                    name = item.get('name')or '<unnamed>'

                    calib = item.get('caliber')
                    if calib:
                        if str(calib).strip().lower()not in ammo_calibers_present:
                            msg = f"Firearm '{name}' in table '{tf}' references caliber '{calib}' but no ammunition with that caliber found."
                            ammo_errors.append(msg)
                            try:
                                ammo_errors_details.append({'table':tf, 'weapon':item, 'reason':'missing_ammo_caliber', 'caliber':calib})
                            except Exception:
                                pass

                    ammo_type = item.get('ammo_type')or item.get('ammunition')
                    if ammo_type:
                        if str(ammo_type).strip().lower()not in ammo_names_present:
                            msg = f"Firearm '{name}' in table '{tf}' references ammunition '{ammo_type}' but no matching ammunition entry found."
                            ammo_errors.append(msg)
                            try:
                                ammo_errors_details.append({'table':tf, 'weapon':item, 'reason':'missing_ammo_name', 'ammo':ammo_type})
                            except Exception:
                                pass
            except Exception:
                continue
    except Exception:
        pass

    duplicates = {}
    for item_id, locations in global_id_map.items():
        by_file = {}
        for f, sub, name in locations:
            by_file.setdefault(f, []).append((f, sub, name))
        for file_locs in by_file.values():
            if len(file_locs)>1:
                duplicates.setdefault(item_id, []).extend(file_locs)
    duplicate_errors =[]

    duplicate_suggestions =[]
    if duplicates:
        for dup_id, locations in duplicates.items():
            loc_str = "; ".join([f"{f}:{sub}:{name}"for f, sub, name in locations])
            msg = f"Duplicate ID detected: {dup_id} used in: {loc_str}"
            duplicate_errors.append(msg)
            try:

                max_id = max(global_id_map.keys())if global_id_map else dup_id
                for idx, (f, sub, name)in enumerate(locations):
                    if idx ==0:

                        continue
                    max_id +=1
                    duplicate_suggestions.append(f"Change ID {dup_id}({f}:{sub}:{name}) -> {max_id}")
            except Exception:
                duplicate_suggestions.append(f"Unable to suggest fixes for duplicate ID {dup_id}.")

    try:
        missing_slots =[]
        if referenced_slots:

            def item_matches_slot(item, slot_name):
                try:

                    if isinstance(item, (list, tuple))and item:
                        item = item[0]
                    if not isinstance(item, dict):
                        return False

                    for v in item.values():
                        if isinstance(v, str)and v.strip().lower()==slot_name.lower():
                            return True
                        if isinstance(v, (list, tuple)):
                            for e in v:
                                try:
                                    if isinstance(e, str)and e.strip().lower()==slot_name.lower():
                                        return True
                                except Exception:
                                    continue

                    if isinstance(item.get('slot'), str)and item.get('slot').strip().lower()==slot_name.lower():
                        return True
                except Exception:
                    pass
                return False

            for slot in sorted(referenced_slots):

                try:
                    if isinstance(slot, str)and slot.strip().lower()=='weapon_slot':
                        continue
                except Exception:
                    pass

                found = any(item_matches_slot(it, slot)for it in all_table_items)
                if not found:
                    missing_slots.append(slot)
        if missing_slots:
            for s in missing_slots:
                logging.warning(f"Referenced slot '{s}' has no items available in tables to populate it.")
    except Exception:
        pass

    all_errors = duplicate_errors +magazine_errors +table_sequence_errors
    if all_errors:

        for err in all_errors:
            logging.error(err)

        displayed = all_errors[:10]
        numbered =[f"{i +1}.{e}"for i, e in enumerate(displayed)]
        preview = "\n\n".join(numbered)
        more_count = len(all_errors)-len(displayed)
        if more_count >0:
            preview +=f"\n\n...and {more_count} more errors"

        try:
            if duplicate_suggestions:
                preview +="\n\nSuggested duplicate ID fixes:\n"
                preview +="\n".join([f" {s}"for s in duplicate_suggestions])
        except Exception:
            pass

        try:
            if magazine_errors_details:
                preview +="\n\nSuggested magazine entries for problematic firearms:\n"

                try:
                    max_existing = 0
                    for k in list(global_id_map.keys()):
                        try:
                            iv = int(k)
                            if iv >max_existing:
                                max_existing = iv
                        except Exception:
                            continue
                    next_sugg_id = max_existing +1
                except Exception:
                    next_sugg_id = 1

                for det in magazine_errors_details[:8]:
                    weapon = det.get('weapon')or {}
                    table = det.get('table')or '<unknown table>'
                    wname = weapon.get('name')or weapon.get('prettyname')or '<unnamed>'
                    try:
                        sug = suggest_magazine_for_weapon_static(weapon)
                        caps = sug.get('suggested_capacities')or[10]
                        wiki = sug.get('wiki_matches')or[]

                        ms = weapon.get('magazinesystem')or weapon.get('magazinetype')
                        req_count = 1
                        if isinstance(ms, list)and ms:
                            req_count = len(ms)

                        assigned =[]
                        for i in range(req_count):
                            cap = caps[i]if i <len(caps)else caps[0]
                            assigned_id = next_sugg_id
                            next_sugg_id +=1
                            assigned.append((assigned_id, cap))

                        entries_str = ", ".join([f"ID {aid}(cap {cap})"for aid, cap in assigned])
                        preview +=f"- {table}: {wname} -> suggested magazines: {entries_str}\n"

                        if wiki:
                            try:
                                first = wiki[0]
                                t = first.get('title')
                                try:
                                    link = f"https://en.wikipedia.org/wiki/{requests.utils.requote_uri(t.replace(' ', '_'))}"
                                except Exception:
                                    link = f"https://en.wikipedia.org/wiki/{t.replace(' ', '_')}"
                                preview +=f" Information derived from: {link}\n"
                            except Exception:
                                pass

                        preview +="\n"
                    except Exception:
                        preview +=f"- {table}: {wname} -> suggestion unavailable\n\n"
                if len(magazine_errors_details)>8:
                    preview +=f"...and {len(magazine_errors_details)-8} more magazine issues\n"
        except Exception:
            pass

        try:
            if table_sequence_details:
                preview +="\n\nID sequence issues detected in tables:\n"
                for det in table_sequence_details[:8]:
                    try:
                        preview +=f"- Table: {det.get('table')} Missing IDs: {det.get('missing_ids')} Last ID: {det.get('last_id')} Next ID: {det.get('next_id')}\n"
                        sug = det.get('suggested_changes')or[]
                        if sug:
                            preview +=" Suggested changes:\n"
                            for s in sug[:6]:
                                preview +=f" {s}\n"
                            if len(sug)>6:
                                preview +=f"...and {len(sug)-6} more suggested changes\n"
                    except Exception:
                        preview +="-(unable to render table sequence detail)\n"
                if len(table_sequence_details)>8:
                    preview +=f"...and {len(table_sequence_details)-8} more table sequence issues\n"
        except Exception:
            pass

        title = f"Table Validation Errors({len(all_errors)})"
        full_msg = f"Errors detected during table validation:\n\n{preview}\n\nSee logs for full details."
        show_error_dialog(title, full_msg)
        logging.critical("Aborting startup due to table validation errors.")
        raise SystemExit("Format for table tables is broken due to validation errors; aborting startup.Please fix/update the table(s).")

validate_table_ids()

currentsave = None

emptysave = {
"charactername":"",
"stats":{
"Aim":0,
"Strength":0,
"Agility":0,
"Intelligence":0,
"Charisma":0,
"Perception":0,
"Resistance":0,
"Stealth":0,
"Luck":0
},
"hands":{
"encumbrance_modifier":0.5,
"capacity":50,
"items":[]
},
"equipment":{
"head":None,
"face":None,
"torso":None,
"left wrist":None,
"right wrist":None,
"left hand":None,
"right hand":None,
"legs":None,
"feet":None,
"neck":None,
"chest":None,
"back":None,
"waist":None,
"waistband":None,
"left shoulder":None,
"right shoulder":None,
"left arm":None,
"right arm":None,
"left leg":None,
"right leg":None
},
"encumbrance":0,
"encumbered_threshold":50,
"encumbered":{"value":False, "level":0},
"storage":[],
"money":0
}

def populate_equipment_with_subslots(save_data):

    try:
        tbl_path = get_current_table_path()
        if not tbl_path or not os.path.exists(tbl_path):
            return save_data

        with open(tbl_path, 'r')as f:
            table_data = json.load(f)

        equipment_items = table_data.get("tables", {}).get("equipment", [])
        equipment_map = {item.get("id"):item for item in equipment_items}

        for slot_name, equipped_item in save_data.get("equipment", {}).items():

            items_to_process =[]
            if isinstance(equipped_item, dict):
                items_to_process =[equipped_item]
            elif isinstance(equipped_item, list):
                items_to_process =[it for it in equipped_item if isinstance(it, dict)]

            for eq in items_to_process:
                try:
                    item_id = eq.get("id")
                    if item_id is not None and item_id in equipment_map:
                        table_item = equipment_map[item_id]
                        if "subslots"in table_item and "subslots"not in eq:
                            eq["subslots"]=[{
                            "name":subslot.get("name"),
                            "slot":subslot.get("slot"),
                            "current":None
                            }for subslot in table_item["subslots"]]
                            logging.debug(f"Added {len(eq['subslots'])} subslots to equipped item ID {item_id} in slot {slot_name}")

                            for sub in eq.get("subslots", []):
                                try:
                                    cur = sub.get("current")
                                    if isinstance(cur, dict):
                                        add_subslots_to_item(cur)
                                except Exception:
                                    pass

                            try:
                                for sub in eq.get("subslots", [])or[]:
                                    try:
                                        s_slot = sub.get('slot')

                                        for candidate in equipment_items:
                                            try:
                                                if isinstance(candidate, dict)and candidate.get('slot')==s_slot and 'subslots'in candidate:
                                                    nested =[]
                                                    for ss in candidate.get('subslots', [])or[]:
                                                        try:
                                                            nested.append({'name':ss.get('name'), 'slot':ss.get('slot'), 'current':None})
                                                        except Exception:
                                                            pass
                                                    if nested:
                                                        sub.setdefault('subslots', nested)
                                                        logging.debug(f"Added {len(nested)} nested subslots to subslot '{sub.get('name')}' on item ID {item_id}")

                                                        for nsub in sub.get('subslots', [])or[]:
                                                            try:
                                                                cur2 = nsub.get('current')
                                                                if isinstance(cur2, dict):
                                                                    add_subslots_to_item(cur2)
                                                            except Exception:
                                                                pass
                                                    break
                                            except Exception:
                                                pass
                                    except Exception:
                                        pass
                            except Exception:
                                pass

                            for acc in eq.get("accessories", [])or[]:
                                try:
                                    cur = acc.get("current")
                                    if isinstance(cur, dict):
                                        add_subslots_to_item(cur)
                                except Exception:
                                    pass

                            try:
                                eq.setdefault('accessories', [])
                                for sub in eq.get('subslots', [])or[]:
                                    try:
                                        s_slot = sub.get('slot')
                                        s_name = sub.get('name')or s_slot
                                        exists = False
                                        for a in eq.get('accessories', [])or[]:
                                            try:
                                                if a and isinstance(a, dict)and(a.get('slot')==s_slot or a.get('name')==s_name):
                                                    exists = True
                                                    break
                                            except Exception:
                                                pass
                                        if not exists:
                                            try:
                                                eq['accessories'].append({'name':s_name, 'slot':s_slot, 'current':sub.get('current'), 'attachment':True})
                                            except Exception:
                                                pass
                                    except Exception:
                                        pass
                            except Exception:
                                pass
                except Exception:
                    pass

        for item in save_data.get("storage", []):
            if isinstance(item, dict):
                add_subslots_to_item(item)
                for acc in item.get("accessories", [])or[]:
                    try:
                        cur = acc.get("current")
                        if isinstance(cur, dict):
                            _add_attachment_subslots_to_weapon(item, acc, cur)
                    except Exception:
                        pass

        if "hands"in save_data and "items"in save_data["hands"]:
            for item in save_data["hands"]["items"]:
                if isinstance(item, dict):
                    add_subslots_to_item(item)
                    for acc in item.get("accessories", [])or[]:
                        try:
                            cur = acc.get("current")
                            if isinstance(cur, dict):
                                _add_attachment_subslots_to_weapon(item, acc, cur)
                        except Exception:
                            pass

        for slot_name, equipped_item in save_data.get("equipment", {}).items():
            if equipped_item and isinstance(equipped_item, dict):
                for acc in equipped_item.get("accessories", [])or[]:
                    try:
                        cur = acc.get("current")
                        if isinstance(cur, dict):
                            add_subslots_to_item(cur)
                            _add_attachment_subslots_to_weapon(equipped_item, acc, cur)
                    except Exception:
                        pass

        for slot_name, equipped_item in save_data.get("equipment", {}).items():
            if equipped_item and isinstance(equipped_item, dict)and "items"in equipped_item:
                for item in equipped_item["items"]:
                    if isinstance(item, dict):
                        add_subslots_to_item(item)
                        for acc in item.get("accessories", [])or[]:
                            try:
                                cur = acc.get("current")
                                if isinstance(cur, dict):
                                    _add_attachment_subslots_to_weapon(item, acc, cur)
                            except Exception:
                                pass

    except Exception as e:
        logging.warning(f"Failed to populate equipment subslots: {e}")

    return save_data

def _add_attachment_subslots_to_weapon(weapon, parent_accessory, attachment):

    try:
        if not weapon or not isinstance(weapon, dict):
            return
        if not attachment or not isinstance(attachment, dict):
            return

        attachment_subslots = attachment.get('subslots', [])or[]
        if not attachment_subslots:
            return

        weapon.setdefault('accessories', [])
        parent_slot = parent_accessory.get('slot')
        attachment_name = attachment.get('name', 'Attachment')

        for sub in attachment_subslots:
            try:
                s_slot = sub.get('slot')
                s_name = sub.get('name')or s_slot
                display_name = f"{attachment_name} â†’ {s_name}"

                exists = False
                for a in weapon.get('accessories', [])or[]:
                    try:
                        if a and isinstance(a, dict):
                            if a.get('_is_attachment_subslot')and a.get('_parent_accessory_slot')==parent_slot and a.get('_subslot_slot')==s_slot:
                                exists = True
                                a['current']= sub.get('current')
                                a['name']= display_name
                                break
                    except Exception:
                        pass

                if not exists:
                    weapon['accessories'].append({
                    'name':display_name,
                    'slot':s_slot,
                    'current':sub.get('current'),
                    'attachment':True,
                    '_parent_accessory_slot':parent_slot,
                    '_subslot_slot':s_slot,
                    '_is_attachment_subslot':True
                    })
            except Exception:
                pass
    except Exception:
        pass

def add_subslots_to_item(item):

    try:
        return _add_subslots_to_item_recursive(item, seen = None)
    except Exception as e:
        logging.warning(f"Failed to add subslots to item: {e}")
        return item

def _add_subslots_to_item_recursive(item, seen = None):
    if not item or not isinstance(item, dict):
        return item

    if seen is None:
        seen = set()

    obj_id = id(item)
    if obj_id in seen:
        return item
    seen.add(obj_id)

    try:

        if "subslots"not in item:
            table_files = sorted(glob.glob(os.path.join("tables", f"*{global_variables.get('table_extension', '.sldtbl')}")))
            if table_files:
                item_id = item.get("id")
                if item_id is not None:
                    found = False
                    for tf in table_files:
                        try:
                            with open(tf, 'r', encoding = 'utf-8')as f:
                                table_data = json.load(f)
                        except Exception:
                            continue
                        tables = table_data.get("tables", {})
                        for tbl_items in tables.values():
                            if not isinstance(tbl_items, list):
                                continue
                            for it in tbl_items:
                                try:
                                    if isinstance(it, dict)and it.get("id")==item_id:
                                        table_item = it
                                        if "subslots"in table_item:

                                            resolved_subslots =[]
                                            for subslot in table_item["subslots"]:
                                                cur = subslot.get("current", None)
                                                resolved_cur = cur
                                                if cur is not None and(isinstance(cur, int)or(isinstance(cur, str)and str(cur).isdigit())):
                                                    try:
                                                        iid = int(cur)

                                                        for _tf in table_files:
                                                            try:
                                                                with open(_tf, 'r', encoding = 'utf-8')as _f:
                                                                    _td = json.load(_f)
                                                            except Exception:
                                                                continue
                                                            for arr in _td.get('tables', {}).values():
                                                                if isinstance(arr, list):
                                                                    for candidate in arr:
                                                                        if isinstance(candidate, dict)and candidate.get('id')==iid:
                                                                            resolved_cur = candidate.copy()
                                                                            break
                                                                    if isinstance(resolved_cur, dict):
                                                                        break
                                                            if isinstance(resolved_cur, dict):
                                                                break
                                                    except Exception:
                                                        resolved_cur = cur

                                                current_val = resolved_cur if isinstance(resolved_cur, dict)else None

                                                resolved_subslots.append({
                                                "name":subslot.get("name"),
                                                "slot":subslot.get("slot"),
                                                "current":current_val
                                                })

                                            try:
                                                if isinstance(item, dict):
                                                    item.setdefault('accessories', [])
                                                    for sub in resolved_subslots:
                                                        try:
                                                            s_slot = sub.get('slot')
                                                            s_name = sub.get('name')or s_slot
                                                            found = False
                                                            for a in item.get('accessories', [])or[]:
                                                                try:
                                                                    if a and isinstance(a, dict)and(a.get('slot')==s_slot or a.get('name')==s_name):
                                                                        found = True
                                                                        break
                                                                except Exception:
                                                                    pass
                                                            if not found:
                                                                try:
                                                                    item['accessories'].append({'name':s_name, 'slot':s_slot, 'current':None, 'attachment':True})
                                                                except Exception:
                                                                    pass
                                                        except Exception:
                                                            pass
                                            except Exception:
                                                pass
                                            item["subslots"]= resolved_subslots
                                            logging.debug(f"Added {len(item['subslots'])} subslots to item ID {item_id}({item.get('name')})")
                                        found = True
                                        break
                                except Exception:
                                    continue
                            if found:
                                break
                        if found:
                            break
    except Exception:
        pass

    try:

        for sub in item.get("items", [])or[]:
            try:
                if isinstance(sub, dict):
                    _add_subslots_to_item_recursive(sub, seen)
            except Exception:
                pass

        for subslot in item.get("subslots", [])or[]:
            try:
                cur = subslot.get("current")
                if isinstance(cur, dict):
                    _add_subslots_to_item_recursive(cur, seen)
            except Exception:
                pass

        for acc in item.get("accessories", [])or[]:
            try:
                cur = acc.get("current")
                if isinstance(cur, dict):
                    _add_subslots_to_item_recursive(cur, seen)
            except Exception:
                pass
    except Exception:
        pass

    return item

def update_item_keys_from_table(save_data):

    try:
        table_files = sorted(glob.glob(os.path.join("tables", f"*{global_variables.get('table_extension', '.sldtbl')}")))
        if not table_files:
            logging.warning("No table files found for item key update")
            return save_data

        cur_tbl = global_variables.get("current_table")
        target_file = None
        if cur_tbl:
            for fpath in table_files:
                if os.path.abspath(fpath).endswith(cur_tbl)or os.path.basename(fpath)==cur_tbl:
                    target_file = fpath
                    break

        if not target_file:
            target_file = table_files[0]

        try:
            with open(target_file, 'r', encoding = 'utf-8')as f:
                table_data = json.load(f)
        except Exception as e:
            logging.error(f"Failed to load table file for item key update: {target_file}: {e}")
            return save_data

        all_items_map = {}
        for table_name, items in table_data.get("tables", {}).items():
            if isinstance(items, list):
                for item in items:
                    if isinstance(item, dict)and "id"in item:
                        all_items_map[item["id"]]= item

        variable_keys = {
        "quantity", "current", "items", "subslots", "uses_left", "hits_left",
        "battery_life", "loaded", "chambered", "rounds",
        "accessories", "attachment"
        }

        changed_any = False

        def update_item(item):
            nonlocal changed_any
            """Update a single item's keys from table"""
            if not isinstance(item, dict)or "id"not in item:
                return item

            item_id = item.get("id")
            if item_id not in all_items_map:
                return item

            table_item = all_items_map[item_id]

            preserved_data = {key:item[key]for key in variable_keys if key in item}

            synced_keys =[]
            for key, value in table_item.items():
                if key in variable_keys:
                    continue
                if isinstance(key, str)and key.startswith("_"):
                    continue

                local_val = item.get(key, None)
                try:
                    different = local_val !=value
                except Exception:
                    different = True

                if different:
                    item[key]= value
                    synced_keys.append(key)

            if synced_keys:
                logging.info(f"Updated item id={item_id} name={item.get('name', '<unknown>')} keys_synced={synced_keys}")
                changed_any = True

            for key, value in preserved_data.items():
                item[key]= value

            if "subslots"in item:
                for subslot in item["subslots"]:
                    if isinstance(subslot, dict)and subslot.get("current"):
                        update_item(subslot["current"])

            if "items"in item and isinstance(item["items"], list):
                for contained_item in item["items"]:
                    update_item(contained_item)

            return item

        for item in save_data.get("storage", []):
            update_item(item)

        if "hands"in save_data and "items"in save_data["hands"]:
            for item in save_data["hands"]["items"]:
                update_item(item)

        for slot_name, equipped_item in save_data.get("equipment", {}).items():
            if isinstance(equipped_item, dict):
                update_item(equipped_item)
            elif isinstance(equipped_item, list):
                for it in equipped_item:
                    if isinstance(it, dict):
                        update_item(it)

        if changed_any:
            logging.info(f"Item keys successfully synced from table {os.path.join('tables', os.path.basename(target_file))}")
        else:
            logging.info(f"Item keys updated from table data: no changes detected in {os.path.join('tables', os.path.basename(target_file))}")

    except Exception as e:
        logging.error(f"Failed to update item keys from table: {e}")

    return save_data

persistentdata = {
"last_loaded_save":None,
"save_uuids":{},
"lootcrate_uuids":{},
"transfer_uuids":{}
}

ATTACHMENTS_VERSION = 0

dm_users =[base64.b64decode(user).decode('utf-8').lower()for user in dm_users]

for user in dm_users:
    if user in os.getlogin().lower():
        if not global_variables["dmmode"]["value"]and not global_variables["dmmode"]["forced"]:
            global_variables["dmmode"]["value"]= True
            logging.info(f"DM user '{user}' detected.DM mode toggled on.")
        elif global_variables["dmmode"]["value"]:
            logging.info(f"DM user '{user}' detected.DM mode already active.")
        else:
            logging.info(f"DM user '{user}' detected.DM mode is forced off.")

        def _console_command_loop():
            try:
                log_console_colored(logging.getLogger(), logging.INFO, "Console command thread started.Type 'help' for commands.", 'cyan')
            except Exception:
                pass

            import ast

            ALLOWED_FUNCS = {
            'len':len, 'str':str, 'int':int, 'float':float, 'bool':bool,
            'sum':sum, 'min':min, 'max':max, 'sorted':sorted, 'repr':repr,
            'json':json
            }

            ALLOWED_NAMES = {
            'dm_users':dm_users,
            'global_variables':global_variables,
            }

            ALLOWED_NODE_TYPES =(
            ast.Expression, ast.Tuple, ast.List, ast.Dict, ast.Set,
            ast.Load, ast.Constant, ast.BinOp, ast.UnaryOp, ast.BoolOp,
            ast.Compare, ast.IfExp, ast.Subscript, ast.Slice, ast.Index,
            ast.Name, ast.Call, ast.Attribute, ast.ListComp, ast.DictComp,
            ast.comprehension
            )

            def _is_ast_safe(node):

                if not isinstance(node, ALLOWED_NODE_TYPES):
                    return False
                for child in ast.iter_child_nodes(node):
                    if isinstance(child, ast.Name):
                        if child.id in('True', 'False', 'None'):
                            continue
                        if child.id not in ALLOWED_NAMES and child.id not in ALLOWED_FUNCS:
                            return False
                    if isinstance(child, ast.Call):

                        func = child.func
                        if isinstance(func, ast.Name):
                            if func.id not in ALLOWED_FUNCS:
                                return False
                        elif isinstance(func, ast.Attribute):

                            value = func.value
                            if not(isinstance(value, ast.Name)and value.id in ALLOWED_FUNCS):
                                return False
                        else:
                            return False
                    if not _is_ast_safe(child):
                        return False
                return True

            def safe_eval(expr:str):
                try:
                    parsed = ast.parse(expr, mode = 'eval')
                except Exception as e:
                    raise ValueError(f"Invalid expression: {e}")
                if not _is_ast_safe(parsed):
                    raise ValueError("Expression contains disallowed operations or names")
                env = {}
                env.update(ALLOWED_FUNCS)
                env.update(ALLOWED_NAMES)
                return eval(compile(parsed, '<safe_eval>', 'eval'), {'__builtins__':{}}, env)

            while True:
                try:
                    try:

                        prompt = f"{os.getlogin()}:~ "
                        try:
                            cmd = input(prompt)
                        except EOFError:
                            time.sleep(0.25)
                            continue
                        except Exception:
                            logging.exception('Console input error')
                            continue
                    except Exception:
                        logging.exception('Console prompt error')
                    if not cmd:
                        continue
                    cmd = cmd.strip()
                    dev_ok = bool(global_variables.get('devmode', {}).get('value'))or bool(global_variables.get('devmode', {}).get('forced'))
                    if not dev_ok:
                        log_console_colored(logging.getLogger(), logging.WARNING, "Console commands are disabled(devmode off).", 'yellow')
                        continue

                    lower = cmd.lower()
                    if lower in('help', '?'):
                        out = "Commands: help, print dm users, print globals, print global <key>, gil, exit, pause <secs>, eval <expr>"
                        log_console_colored(logging.getLogger(), logging.INFO, out, 'green')
                        continue

                    if lower in('print dm users', 'print dm_users', 'print dmusers'):
                        try:
                            log_console_colored(logging.getLogger(), logging.INFO, f"dm_users(decoded): {dm_users}", 'cyan')
                        except Exception:
                            logging.exception('Failed to print dm_users')
                        continue

                    if lower in('print globals', 'print global_variables'):
                        try:
                            safe = json.dumps(global_variables, indent = 2, default = str)
                            log_console_colored(logging.getLogger(), logging.INFO, safe, 'cyan')
                        except Exception:
                            logging.exception('Failed to print global_variables')
                        continue

                    if lower =='gil':
                        try:
                            is_gil_fn = getattr(sys, '_is_gil_enabled', None) # type: ignore
                            if callable(is_gil_fn):
                                try:
                                    gil_enabled = bool(is_gil_fn())
                                    if gil_enabled:
                                        log_console_colored(logging.getLogger(), logging.INFO, "GIL is enabled(sys._is_gil_enabled() returned True)", 'cyan')
                                    else:
                                        log_console_colored(logging.getLogger(), logging.INFO, "GIL is disabled(sys._is_gil_enabled() returned False)", 'yellow')
                                except Exception:
                                    logging.exception('sys._is_gil_enabled() raised an exception')
                            else:

                                impl = platform.python_implementation()
                                gil_enabled =(impl =='CPython')
                                if gil_enabled:
                                    log_console_colored(logging.getLogger(), logging.INFO, f"GIL is likely enabled(implementation: {impl})", 'cyan')
                                else:
                                    log_console_colored(logging.getLogger(), logging.INFO, f"GIL is likely not present(implementation: {impl})", 'yellow')
                        except Exception:
                            logging.exception('Failed to check GIL')
                        continue

                    if lower.startswith('print global '):
                        key = cmd[len('print global '):].strip()
                        try:
                            val = global_variables.get(key)
                            log_console_colored(logging.getLogger(), logging.INFO, f"global {key}: {val}", 'cyan')
                        except Exception:
                            logging.exception('Failed to print global %s', key)
                        continue

                    if lower in('exit', 'quit'):
                        try:
                            log_console_colored(logging.getLogger(), logging.INFO, 'Exit requested from console â€” attempting graceful shutdown', 'green')
                        except Exception:
                            pass
                        try:

                            app_obj = globals().get('app')
                            if app_obj and hasattr(app_obj, '_safe_exit'):
                                try:
                                    app_obj._safe_exit()
                                except Exception:
                                    logging.exception('App._safe_exit() raised an exception')

                                time.sleep(0.25)
                                if 'os'in globals():
                                    globals()['os']._exit(0)
                                else:
                                    import os as _os
                                    _os._exit(0)
                            else:

                                safe_fn = globals().get('safe_exit')or globals().get('_safe_exit')
                                if callable(safe_fn):
                                    try:
                                        safe_fn()
                                    except Exception:
                                        logging.exception('Module-level safe exit raised an exception')
                                    time.sleep(0.25)
                                    if 'os'in globals():
                                        globals()['os']._exit(0)
                                    else:
                                        import os as _os
                                        _os._exit(0)
                                else:

                                    if 'os'in globals():
                                        globals()['os']._exit(0)
                                    else:
                                        import os as _os
                                        _os._exit(0)
                        except Exception:
                            try:
                                import sys
                                sys.exit(0)
                            except Exception:
                                return

                    if lower.startswith('pause ')or lower.startswith('sleep '):
                        try:
                            parts = cmd.split()
                            secs = float(parts[1])if len(parts)>1 else 1.0
                            log_console_colored(logging.getLogger(), logging.INFO, f'Pausing for {secs} seconds', 'green')
                            time.sleep(max(0.0, secs))
                        except Exception:
                            log_console_colored(logging.getLogger(), logging.WARNING, 'Usage: pause <seconds>', 'yellow')
                        continue

                    if lower.startswith('eval '):
                        expr = cmd[len('eval '):].strip()
                        try:
                            res = safe_eval(expr)
                            log_console_colored(logging.getLogger(), logging.INFO, f"=> {repr(res)}", 'cyan')
                        except Exception as e:
                            log_console_colored(logging.getLogger(), logging.WARNING, f"Eval error: {e}", 'yellow')
                        continue

                    try:
                        res = safe_eval(cmd)
                        log_console_colored(logging.getLogger(), logging.INFO, f"=> {repr(res)}", 'cyan')
                        continue
                    except Exception:
                        pass

                    log_console_colored(logging.getLogger(), logging.WARNING, f"Unknown or disallowed command: {cmd}", 'yellow')

                except Exception:
                    try:
                        logging.exception('Console command loop error')
                    except Exception:
                        pass

        try:
            t = threading.Thread(target = _console_command_loop, daemon = True)
            t.start()
        except Exception:
            logging.exception('Failed to start console command thread')

def send_windows_notification(title:str, message:str):

    if os.name !='nt':
        return
    try:
        from winotify import Notification, audio
        global version
        toast = Notification(
        app_id = f"DOOM Tools {version}",
        title = title,
        msg = message,
        duration = "short"
        )
        toast.set_audio(audio.Default, loop = False)
        toast.show()
    except ImportError:
        try:
            ps_script = f'''
            [Windows.UI.Notifications.ToastNotificationManager, Windows.UI.Notifications, ContentType = WindowsRuntime]| Out-Null
            [Windows.Data.Xml.Dom.XmlDocument, Windows.Data.Xml.Dom.XmlDocument, ContentType = WindowsRuntime]| Out-Null
            $template = @"
            <toast>
                <visual>
                    <binding template="ToastText02">
                        <text id="1">{title}</text>
                        <text id="2">{message}</text>
                    </binding>
                </visual>
                <audio src="ms-winsoundevent:Notification.Default"/>
            </toast>
"@
            $xml = New-Object Windows.Data.Xml.Dom.XmlDocument
            $xml.LoadXml($template)
            $toast =[Windows.UI.Notifications.ToastNotification]::new($xml)
            [Windows.UI.Notifications.ToastNotificationManager]::CreateToastNotifier("DOOM-Tools").Show($toast)
            '''
            subprocess.run(['powershell', '-Command', ps_script], capture_output = True)
        except Exception:
            pass

class App:

    PLATFORM_DEFAULTS = {
    "M203":{"ammo_type":"40mm_grenade", "capacity":1, "reload_sound_folder":"m203"}
    }

    def _save_persistent_data(self):

        try:
            persistent_path = os.path.join(saves_folder or "saves", "persistent_data.sldsv")
            pickled_persistent = pickle.dumps(persistentdata)
            encoded_persistent = base64.b85encode(pickled_persistent).decode('utf-8')
            with open(persistent_path, 'w')as f:
                f.write(encoded_persistent)
            logging.info(f"Persistent data saved to {persistent_path}")
        except Exception as e:
            logging.error(f"Failed to save persistent data: {e}")
    def _format_item_name(self, item):
        try:
            if not isinstance(item, dict):
                return str(item)
            base = item.get('name', 'Unknown')
            arm = item.get('_from_armory')
            if arm:
                return f"{base}(Armory: {arm})"
            return base
        except Exception:
            try:
                return item.get('name', 'Unknown')
            except Exception:
                return 'Unknown'
    def _safe_focus(self, widget):

        try:
            if widget and getattr(widget, 'winfo_exists', lambda:False)():
                try:
                    widget.focus()
                except Exception:
                    try:
                        widget.focus_set()
                    except Exception:
                        pass
        except Exception:
            pass
    def _write_save_to_path(self, path, data):
        try:
            if not path.endswith(global_variables.get("save_extension", ".sldsv")):
                path +=global_variables.get("save_extension", ".sldsv")

            filename = os.path.basename(path)
            excluded_from_backup = {"persistent_data.sldsv", "settings.sldsv", "appearance_settings.sldsv", "dm_settings.sldsv"}
            if filename not in excluded_from_backup and isinstance(data, dict):
                try:
                    char_name = data.get("charactername", "Unknown")
                    safe_char_name = "".join(c if c.isalnum()or c in " _-"else "_"for c in char_name).strip()
                    if not safe_char_name:
                        safe_char_name = "Unknown"

                    backup_folder = os.path.join(saves_folder or "saves", "backups", safe_char_name)
                    archive_folder = os.path.join(backup_folder, "archive")
                    os.makedirs(backup_folder, exist_ok = True)
                    os.makedirs(archive_folder, exist_ok = True)

                    backup_files = sorted(glob.glob(os.path.join(backup_folder, "*.sldsv")))
                    if len(backup_files)>=50:
                        archive_name = os.path.join(archive_folder, f"backups_archive_{datetime.now().strftime('%Y%m%d_%H%M%S')}.zip")
                        with zipfile.ZipFile(archive_name, 'w', zipfile.ZIP_DEFLATED)as zipf:
                            for backup_file in backup_files:
                                zipf.write(backup_file, os.path.basename(backup_file))
                                os.remove(backup_file)
                        logging.info(f"Archived {len(backup_files)} backups to {archive_name}")

                    backup_filename = f"backup_{datetime.now().strftime('%Y%m%d_%H%M%S_%f')}.sldsv"
                    backup_path = os.path.join(backup_folder, backup_filename)

                    if os.path.exists(path):
                        try:
                            import shutil
                            shutil.copy2(path, backup_path)
                            logging.info(f"Created backup at {backup_path}")
                        except Exception as backup_err:
                            logging.warning(f"Failed to create backup copy: {backup_err}")
                    else:
                        pickled_backup = pickle.dumps(data)
                        encoded_backup = base64.b85encode(pickled_backup).decode('utf-8')
                        with open(backup_path, 'w', encoding = 'utf-8')as bf:
                            bf.write(encoded_backup)
                        logging.info(f"Created backup at {backup_path}")
                except Exception as backup_err:
                    logging.warning(f"Failed to create backup: {backup_err}")

            pickled = pickle.dumps(data)
            encoded = base64.b85encode(pickled).decode('utf-8')
            with open(path, 'w', encoding = 'utf-8')as f:
                f.write(encoded)
            logging.info(f"Data written to {path}")
        except Exception as e:
            logging.error(f"Failed to write save to {path}: {e}")

    def _read_save_from_path(self, path):
        try:
            if not path.endswith(global_variables.get("save_extension", ".sldsv")):
                path +=global_variables.get("save_extension", ".sldsv")
            if not os.path.exists(path):
                logging.error(f"Save file '{path}' does not exist.")
                return None
            with open(path, 'r', encoding = 'utf-8')as f:
                text = f.read()

            try:
                pickled = base64.b85decode(text.encode('utf-8'))
                data = pickle.loads(pickled)
                if isinstance(data, dict):
                    logging.info(f"Loaded save from {path}")
                    return data
            except Exception:
                pass

            try:
                data = json.loads(text)
                if isinstance(data, dict):
                    logging.info(f"Loaded save from {path}(json)")
                    return data
            except Exception:
                pass
            logging.error(f"Failed to parse save file: {path}")
            return None
        except Exception as e:
            logging.error(f"Failed to read save from {path}: {e}")
    def _save_file(self, data):
        if currentsave is None:
            logging.error("No current save file to save data to.")
            return
        else:

            try:
                if isinstance(data, dict):
                    tbl = None

                    ct = global_variables.get('current_table')
                    if ct:
                        tbl = ct
                    else:

                        tfiles = sorted(glob.glob(os.path.join('tables', f"*{global_variables.get('table_extension', '.sldtbl')}")))
                        if tfiles:
                            tbl = os.path.basename(tfiles[0])
                    if tbl:
                        data.setdefault('_table', tbl)
            except Exception:
                pass

            if os.path.isabs(currentsave):
                save_path = currentsave
            else:
                save_path = os.path.join(saves_folder or "saves", currentsave or "")
            try:

                try:
                    if isinstance(data, dict):
                        if 'save_data'in globals():
                            outer = globals().get('save_data')
                            if isinstance(outer, dict)and outer is not data:
                                try:
                                    outer.clear()
                                    outer.update(data)
                                    globals()['save_data']= outer
                                except Exception:
                                    globals()['save_data']= data
                            else:
                                globals()['save_data']= data
                        else:
                            globals()['save_data']= data
                except Exception:
                    pass
                try:
                    setattr(self, '_current_save_data', data)
                except Exception:
                    pass

                self._write_save_to_path(save_path, data)
            except Exception as e:
                logging.error(f"Failed to save data to {currentsave}: {e}")
        self._save_persistent_data()
    def _load_file(self, save_filename):

        try:
            persistent_path = os.path.join(saves_folder or "saves", "persistent_data.sldsv")
            if os.path.exists(persistent_path):
                with open(persistent_path, 'r')as f:
                    encoded_persistent = f.read()
                pickled_persistent = base64.b85decode(encoded_persistent.encode('utf-8'))
                loaded_persistent = pickle.loads(pickled_persistent)
                if isinstance(loaded_persistent, dict):
                    persistentdata.update(loaded_persistent)
                    logging.info(f"Persistent data loaded from {persistent_path}")
                else:
                    logging.warning(f"Persistent data in {persistent_path} is not a dict; got {type(loaded_persistent)}")
            else:
                logging.info("No persistent data file found, using defaults")
        except Exception as e:
            logging.warning(f"Failed to load persistent data: {e}")

        if save_filename is None:
            return None

        if os.path.isabs(save_filename):
            save_path = save_filename
        else:
            save_path = os.path.join(saves_folder or "saves", save_filename)
        if not save_path.endswith('.sldsv'):
            save_path +='.sldsv'
        if not os.path.exists(save_path):
            logging.error(f"Save file '{save_path}' does not exist.")
            return None

        try:

            data = self._read_save_from_path(save_path)
            if data is None:
                logging.error(f"Failed to load data from {save_path}")
                return None
            if not isinstance(data, dict):
                logging.error(f"Loaded data from {save_path} is not a dict; got {type(data)}")
                return None
            logging.info(f"Data loaded from {save_path}")

            try:
                table_from_save = None
                if isinstance(data, dict):
                    table_from_save = data.get('_table')or data.get('table')

                current_table = global_variables.get('current_table')

                if table_from_save and current_table:
                    current_table_base = os.path.splitext(current_table)[0]
                    save_table_base = os.path.splitext(table_from_save)[0]
                    if current_table_base !=save_table_base and current_table !=table_from_save:
                        logging.error(f"Save '{save_path}' was created with table '{table_from_save}' but current table is '{current_table}'.Load aborted.")
                        return None

                if table_from_save:

                    matches = sorted(glob.glob(os.path.join('tables', f"*{global_variables.get('table_extension', '.sldtbl')}")))
                    found = None
                    for fpath in matches:
                        try:
                            b = os.path.basename(fpath)
                            name_no_ext = os.path.splitext(b)[0]
                            absf = os.path.abspath(fpath)

                            if(
                            b ==table_from_save
                            or name_no_ext ==table_from_save
                            or absf.endswith(table_from_save)
                            or absf.endswith(table_from_save +global_variables.get('table_extension', '.sldtbl'))
                            ):
                                found = fpath
                                break
                        except Exception:
                            continue
                    if not found:
                        logging.error(f"Save '{save_path}' requires table '{table_from_save}' which is not present locally.Load aborted.")
                        return None
                else:

                    try:
                        cur_tbl = global_variables.get('current_table')
                        if not cur_tbl:
                            tfiles = sorted(glob.glob(os.path.join('tables', f"*{global_variables.get('table_extension', '.sldtbl')}")))
                            if tfiles:
                                cur_tbl = os.path.basename(tfiles[0])
                                global_variables['current_table']= cur_tbl
                                try:
                                    with open(tfiles[0], 'r', encoding = 'utf-8')as tf:
                                        globals()['table_data']= json.load(tf)
                                except Exception:
                                    pass

                        if isinstance(data, dict)and cur_tbl:
                            data.setdefault('_table', cur_tbl)
                    except Exception:
                        pass
            except Exception:
                logging.debug('Table metadata handling failed during load, continuing')
            if save_path.endswith('.sldsv'):
                parts = os.path.basename(save_path).rsplit('_', 1)
                if len(parts)==2:
                    uuid_part = parts[1].replace('.sldsv', '')
                    persistentdata["last_loaded_save"]= uuid_part
                    logging.debug(f"Updated last_loaded_save to UUID: {uuid_part}")

            data = populate_equipment_with_subslots(data)

            data = update_item_keys_from_table(data)

            try:
                data = self._normalize_save_data(data)
                try:
                    data = self._sync_equipment_slots(data)
                except Exception:
                    logging.exception("Failed to sync equipment slots after normalization")
            except Exception as e:
                logging.warning(f"Failed to normalize save data: {e}")
            try:
                # process paychecks for this save on load
                try:
                    self._award_paychecks_for_save(data, save_path)
                except Exception:
                    pass
            except Exception:
                pass
            return data
        except Exception as e:
            logging.error(f"Failed to load data from '{save_path}': {e}")
            return None

    def _get_ammo_table_data(self):
        try:
            tbl_path = get_current_table_path()
            if tbl_path and os.path.exists(tbl_path):
                with open(tbl_path, 'r')as f:
                    table_data = json.load(f)
                return table_data.get("tables", {}).get("ammunition", [])
        except Exception:
            pass
        return[]

    def _ensure_round_variant(self, round_data, ammo_table = None):
        if not isinstance(round_data, dict):
            return round_data

        if round_data.get("variant")and round_data.get("variant")not in["Unknown", "unknown", None, ""]:
            return round_data

        if ammo_table is None:
            ammo_table = self._get_ammo_table_data()

        caliber = round_data.get("caliber")
        if not caliber:
            name = round_data.get("name", "")
            if " | "in name:
                parts = name.split(" | ", 1)
                caliber = parts[0]
                round_data["caliber"]= caliber

        if caliber:
            for ammo in ammo_table:
                ammo_cal = ammo.get("caliber")
                cal_match = False
                if isinstance(ammo_cal, list):
                    cal_match = caliber in ammo_cal
                else:
                    cal_match = ammo_cal ==caliber

                if cal_match:
                    variants = ammo.get("variants", [])
                    if variants:
                        first_variant = variants[0]
                        round_data["variant"]= first_variant.get("name", "FMJ")
                        if first_variant.get("type"):
                            round_data["type"]= first_variant.get("type")
                        if first_variant.get("pen"):
                            round_data["pen"]= first_variant.get("pen")
                        if first_variant.get("tip"):
                            round_data["tip"]= first_variant.get("tip")
                        if first_variant.get("modifiers"):
                            round_data["modifiers"]= first_variant.get("modifiers")
                        return round_data
                    break

        if not round_data.get("variant"):
            round_data["variant"]= "FMJ"

        return round_data

    def _normalize_save_data(self, data):

        ammo_table = self._get_ammo_table_data()

        def normalize_round(r):
            if isinstance(r, dict):
                return self._ensure_round_variant(r, ammo_table)
            if isinstance(r, str):
                parts = r.split(" | ", 1)
                if len(parts)==2:
                    caliber, variant = parts
                    return {"name":r, "caliber":caliber, "variant":variant}
                round_data = {"name":r}
                return self._ensure_round_variant(round_data, ammo_table)
            round_data = {"name":str(r)}
            return self._ensure_round_variant(round_data, ammo_table)

        def normalize_mag(mag):
            if not isinstance(mag, dict):
                return {"name":str(mag), "rounds":[]}
            if "rounds"in mag and isinstance(mag["rounds"], list):
                mag["rounds"]=[normalize_round(rr)for rr in mag["rounds"]]
            return mag

        for slot_name, item in(data.get("equipment")or {}).items():

            if isinstance(item, dict):
                items_iter =[item]
            elif isinstance(item, list):
                items_iter =[it for it in item if isinstance(it, dict)]
            else:
                items_iter =[]

            for it in items_iter:
                if it.get("loaded"):
                    it["loaded"]= normalize_mag(it["loaded"])

                if it.get("rounds")and isinstance(it.get("rounds"), list):
                    it["rounds"]=[normalize_round(rr)for rr in it.get("rounds", [])]

                if it.get("chambered")and isinstance(it.get("chambered"), str):
                    it["chambered"]= normalize_round(it.get("chambered"))

                if "subslots"in it and isinstance(it["subslots"], list):
                    for sub in it["subslots"]:
                        curr = sub.get("current")
                        if isinstance(curr, dict):
                            if curr.get("loaded"):
                                curr["loaded"]= normalize_mag(curr["loaded"])
                            if curr.get("rounds")and isinstance(curr.get("rounds"), list):
                                curr["rounds"]=[normalize_round(rr)for rr in curr.get("rounds", [])]
                            if curr.get("chambered")and isinstance(curr.get("chambered"), str):
                                curr["chambered"]= normalize_round(curr.get("chambered"))

        hands = data.get("hands")or {}
        if isinstance(hands, dict)and isinstance(hands.get("items"), list):
            new_items =[]
            for it in hands.get("items", []):
                if isinstance(it, dict):
                    if it.get("rounds")and isinstance(it.get("rounds"), list):
                        it["rounds"]=[normalize_round(rr)for rr in it.get("rounds", [])]
                    new_items.append(it)
                elif isinstance(it, str):
                    new_items.append({"name":it})
                else:
                    new_items.append({"name":str(it)})
            hands["items"]= new_items

        for slot_name, item in(data.get("equipment")or {}).items():

            items_iter =[]
            if isinstance(item, dict):
                items_iter =[item]
            elif isinstance(item, list):
                items_iter =[it for it in item if isinstance(it, dict)]

            for it in items_iter:
                if "items"in it and isinstance(it["items"], list):
                    new_items =[]
                    for subit in it["items"]:
                        if isinstance(subit, dict):
                            if subit.get("rounds")and isinstance(subit.get("rounds"), list):
                                subit["rounds"]=[normalize_round(rr)for rr in subit.get("rounds", [])]
                            new_items.append(subit)
                        elif isinstance(subit, str):
                            new_items.append({"name":subit})
                        else:
                            new_items.append({"name":str(subit)})
                    it["items"]= new_items

        storage = data.get("storage")or {}
        if isinstance(storage, dict):
            for k, v in storage.items():
                if isinstance(v, list):
                    new_items =[]
                    for it in v:
                        if isinstance(it, dict):
                            if it.get("rounds")and isinstance(it.get("rounds"), list):
                                it["rounds"]=[normalize_round(rr)for rr in it.get("rounds", [])]
                            new_items.append(it)
                        elif isinstance(it, str):
                            new_items.append({"name":it})
                        else:
                            new_items.append({"name":str(it)})
                    storage[k]= new_items

        return data
    def _get_local_central_tz(self):
        try:
            from zoneinfo import ZoneInfo
            return ZoneInfo("America/Chicago")
        except Exception:
            try:
                return timezone(timedelta(hours=-6))
            except Exception:
                return None

    def _award_paychecks_for_save(self, save_data, save_path):
        try:
            if not isinstance(save_data, dict):
                return
            tbl_name = (save_data.get('_table') or save_data.get('table'))
            # load table data for this save if possible
            table_path = None
            if tbl_name:
                matches = sorted(glob.glob(os.path.join('tables', f"*{global_variables.get('table_extension', '.sldtbl')}")))
                for fpath in matches:
                    try:
                        b = os.path.basename(fpath)
                        name_no_ext = os.path.splitext(b)[0]
                        absf = os.path.abspath(fpath)
                        if (
                            b == tbl_name
                            or name_no_ext == tbl_name
                            or absf.endswith(tbl_name)
                            or absf.endswith(tbl_name + global_variables.get('table_extension', '.sldtbl'))
                        ):
                            table_path = fpath
                            break
                    except Exception:
                        continue
            table_data = None
            if table_path and os.path.exists(table_path):
                try:
                    with open(table_path, 'r', encoding='utf-8') as tf:
                        table_data = json.load(tf)
                except Exception:
                    table_data = None

            addl = (table_data or {}).get('additional_settings', {})
            if not addl.get('paycheck'):
                return

            pay_amount = int(addl.get('paycheck_amount', 0) or 0)
            period = (addl.get('pay_period') or '').lower()
            if pay_amount <= 0 or period not in ('daily', 'weekly', 'biweekly', 'monthly'):
                return

            tz = self._get_local_central_tz() or timezone.utc
            now = datetime.now(tz)

            # determine save uuid
            uuid_val = None
            try:
                if save_path and os.path.exists(save_path):
                    parts = os.path.basename(save_path).rsplit('_', 1)
                    if len(parts) == 2:
                        uuid_val = parts[1].replace('.sldsv', '')
            except Exception:
                uuid_val = None
            if not uuid_val:
                uuid_val = save_data.get('uuid') or save_data.get('id') or save_data.get('charactername')

            persistentdata.setdefault('paychecks', {})
            last_paid_iso = persistentdata['paychecks'].get(uuid_val)
            last_paid = None
            if last_paid_iso:
                try:
                    last_paid = datetime.fromisoformat(last_paid_iso)
                    if last_paid.tzinfo is None:
                        last_paid = last_paid.replace(tzinfo=tz)
                except Exception:
                    last_paid = None

            def make_dt(year, month, day, hour=19, minute=0):
                try:
                    return datetime(year, month, day, hour, minute, tzinfo=tz)
                except Exception:
                    return None

            awarded = 0

            # helper to write save and notify
            def _apply_payment(dt_when):
                nonlocal awarded, save_data, save_path, pay_amount, uuid_val
                try:
                    save_data['money'] = int(save_data.get('money', 0)) + pay_amount
                except Exception:
                    save_data['money'] = (save_data.get('money', 0) or 0) + pay_amount
                awarded += 1
                persistentdata['paychecks'][uuid_val] = dt_when.isoformat()
                try:
                    self._write_save_to_path(save_path, save_data)
                except Exception:
                    try:
                        # fallback: attempt to save via _save_file if this is the currently loaded save
                        if currentsave and os.path.basename(save_path).startswith(currentsave):
                            self._save_file(save_data)
                    except Exception:
                        pass
                try:
                    title = "Paycheck Received"
                    charname = save_data.get('charactername') or save_data.get('character_name') or 'Character'
                    message = f"{charname} received ${pay_amount}."
                    try:
                        self._popup_show_info(title, message, sound='success')
                    except Exception:
                        pass
                    try:
                        send_windows_notification(title, message)
                    except Exception:
                        pass
                except Exception:
                    pass

            # If no last_paid -> treat as new save: give the previous scheduled payment once
            if last_paid is None:
                # determine the most recent scheduled time before now
                if period == 'daily':
                    cand = now.replace(hour=19, minute=0, second=0, microsecond=0)
                    if cand > now:
                        cand = cand - timedelta(days=1)
                    if cand <= now:
                        _apply_payment(cand)
                elif period == 'weekly':
                    # find most recent Friday
                    days_back = (now.weekday() - 4) % 7
                    cand = (now - timedelta(days=days_back)).replace(hour=19, minute=0, second=0, microsecond=0)
                    if cand > now:
                        cand -= timedelta(weeks=1)
                    if cand <= now:
                        _apply_payment(cand)
                elif period == 'biweekly':
                    # find most recent Friday and apply one
                    days_back = (now.weekday() - 4) % 7
                    cand = (now - timedelta(days=days_back)).replace(hour=19, minute=0, second=0, microsecond=0)
                    if cand > now:
                        cand -= timedelta(weeks=1)
                    if cand <= now:
                        _apply_payment(cand)
                elif period == 'monthly':
                    # first of this month at 19:00; if in future, use previous month
                    cand = make_dt(now.year, now.month, 1)
                    if cand and cand > now:
                        # previous month
                        prev_month = now.month - 1 or 12
                        year = now.year if now.month != 1 else now.year - 1
                        cand = make_dt(year, prev_month, 1)
                    if cand and cand <= now:
                        _apply_payment(cand)
            else:
                # iterate from last_paid forward according to period
                cursor = last_paid
                # ensure tz-aware
                if cursor.tzinfo is None:
                    cursor = cursor.replace(tzinfo=tz)
                # compute next due
                if period == 'daily':
                    next_due = cursor + timedelta(days=1)
                    next_due = next_due.replace(hour=19, minute=0, second=0, microsecond=0)
                    while next_due <= now:
                        _apply_payment(next_due)
                        next_due = next_due + timedelta(days=1)
                elif period == 'weekly':
                    # advance by weeks until > now
                    # align to Friday 19:00
                    # find next Friday after cursor
                    next_due = cursor
                    # move to next scheduled Friday
                    next_due = next_due + timedelta(days=((4 - next_due.weekday()) % 7))
                    next_due = next_due.replace(hour=19, minute=0, second=0, microsecond=0)
                    if next_due <= cursor:
                        next_due += timedelta(weeks=1)
                    while next_due <= now:
                        _apply_payment(next_due)
                        next_due += timedelta(weeks=1)
                elif period == 'biweekly':
                    # add 14-day increments from last_paid
                    next_due = cursor
                    # align to Friday
                    next_due = next_due + timedelta(days=((4 - next_due.weekday()) % 7))
                    next_due = next_due.replace(hour=19, minute=0, second=0, microsecond=0)
                    if next_due <= cursor:
                        next_due += timedelta(weeks=2)
                    while next_due <= now:
                        _apply_payment(next_due)
                        next_due += timedelta(weeks=2)
                elif period == 'monthly':
                    # add months iteratively
                    def add_month(dt):
                        y = dt.year + (dt.month // 12)
                        m = dt.month % 12 + 1
                        try:
                            return dt.replace(year=y, month=m, day=1, hour=19, minute=0, second=0, microsecond=0)
                        except Exception:
                            return None
                    # move to first-of-month after cursor
                    next_due = cursor.replace(day=1, hour=19, minute=0, second=0, microsecond=0)
                    if next_due <= cursor:
                        nd = add_month(next_due)
                        if nd:
                            next_due = nd
                    while next_due and next_due <= now:
                        _apply_payment(next_due)
                        next_due = add_month(next_due)

            if awarded:
                try:
                    self._save_persistent_data()
                except Exception:
                    pass
        except Exception:
            logging.exception('Paycheck processing failed')
    def _sync_equipment_slots(self, data):

        try:
            if not isinstance(data, dict):
                return data

            equip = data.setdefault('equipment', {})or {}
            empty_equip = emptysave.get('equipment', {})if isinstance(emptysave, dict)else {}

            hands = data.setdefault('hands', {})or {}
            hands_items = hands.setdefault('items', [])if isinstance(hands, dict)else[]

            extra_slots =[k for k in list(equip.keys())if k not in empty_equip]
            for slot in extra_slots:
                val = equip.pop(slot, None)
                if not val:
                    continue
                if isinstance(val, dict):
                    hands_items.append(val)
                elif isinstance(val, list):
                    for it in val:
                        if isinstance(it, dict):
                            hands_items.append(it)
                        else:
                            hands_items.append({'name':str(it)})
                else:
                    hands_items.append({'name':str(val)})

            for slot in empty_equip.keys():
                if slot not in equip:
                    equip[slot]= None

            new_equip = {}
            for slot in empty_equip.keys():
                new_equip[slot]= equip.get(slot)
            data['equipment']= new_equip

            return data
        except Exception:
            logging.exception('Error while syncing equipment slots')
            return data
    def __init__(self):
        customtkinter.set_appearance_mode(appearance_settings["appearance_mode"])

        theme_name = appearance_settings["color_theme"]
        builtin_themes =["dark-blue", "blue", "green"]
        if theme_name not in builtin_themes:

            custom_theme_path = os.path.join(os.getcwd(), "themes", f"{theme_name}.json")
            if os.path.exists(custom_theme_path):
                customtkinter.set_default_color_theme(custom_theme_path)
            else:
                logging.warning(f"Custom theme '{custom_theme_path}' not found, falling back to dark-blue")
                appearance_settings["color_theme"]= "dark-blue"
                customtkinter.set_default_color_theme("dark-blue")
        else:
            customtkinter.set_default_color_theme(theme_name)
        # Override Tk's class-level exception reporter to suppress noisy Tcl/Tk
        # "invalid command name" messages originating from expired `after` callbacks.
        try:
            import tkinter as _tk
            _orig_tk_report = getattr(_tk.Tk, 'report_callback_exception', None)
            def _tk_suppress(self, exc_type, exc_value, exc_tb):
                try:
                    msg = str(exc_value)
                    import re
                    if "invalid command name" in msg and ("after" in msg or re.search(r'\d{6,}', msg)):
                        return
                except Exception:
                    pass
                if _orig_tk_report:
                    try:
                        return _orig_tk_report(self, exc_type, exc_value, exc_tb)
                    except Exception:
                        pass
            _tk.Tk.report_callback_exception = _tk_suppress
        except Exception:
            pass

        self.root = customtkinter.CTk()
        self.root.title("DOOM Tools")
        self.root.geometry(appearance_settings["resolution"])
        self.root.resizable(False, False)

        _original_report = self.root.report_callback_exception
        def _suppress_after_errors(exc_type, exc_value, exc_tb):
            msg = str(exc_value)
            try:
                import re
                if "invalid command name" in msg:
                    if re.search(r'"\d+(?:check_dpi_scaling|_click_animation|update)"', msg) or "after" in msg:
                        return
            except Exception:
                pass
            _original_report(exc_type, exc_value, exc_tb)
        self.root.report_callback_exception = _suppress_after_errors

        try:
            self.root.protocol("WM_DELETE_WINDOW", self._on_window_close)
        except Exception:
            pass

        self.root.attributes('-fullscreen', appearance_settings.get("fullscreen", False))

        try:
            if appearance_settings.get("borderless")and not appearance_settings.get("fullscreen"):
                self.root.overrideredirect(True)
        except Exception:
            pass

        self._sound_cache = {}

        self._load_file(None)
        if persistentdata.get("last_loaded_save"):
            last_save_uuid = persistentdata["last_loaded_save"]
            last_save_name = persistentdata.get("save_uuids", {}).get(last_save_uuid)
            if not last_save_name:

                pattern = os.path.join(saves_folder or "saves", f"*_{last_save_uuid}.sldsv")
                matches = glob.glob(pattern)
                if matches:
                    last_save_name = os.path.basename(matches[0]).replace(f"_{last_save_uuid}.sldsv", "")
                    persistentdata["save_uuids"][last_save_uuid]= last_save_name
                    self._save_persistent_data()
                else:
                    logging.warning(f"Last save UUID {last_save_uuid} not found in save_uuids")
            if last_save_name:
                save_filename = f"{last_save_name}_{last_save_uuid}.sldsv"
                loaded_data = self._load_file(save_filename)
                if loaded_data:
                    current_table = global_variables.get('current_table')
                    save_table = loaded_data.get('_table')or loaded_data.get('table')

                    table_compatible = True
                    if current_table and save_table:
                        current_table_base = os.path.splitext(current_table)[0]
                        save_table_base = os.path.splitext(save_table)[0]
                        if current_table_base !=save_table_base and current_table !=save_table:
                            table_compatible = False
                            logging.warning(f"Last save '{save_filename}' uses table '{save_table}' but current table is '{current_table}'.Not auto-loading.")

                    if table_compatible:
                        try:
                            globals()['save_data']= loaded_data
                        except Exception:
                            pass
                        try:
                            self._current_save_data = loaded_data
                        except Exception:
                            pass
                        global currentsave
                        currentsave = save_filename.replace(".sldsv", "")
                        logging.info(f"Automatically loaded last save: {save_filename}")
                else:
                    logging.warning(f"Failed to load last save: {save_filename}")
        self._build_main_menu()

        try:
            if global_variables.get("devmode", {}).get("value"):
                try:
                    self._create_dev_toolbar()
                except Exception:
                    logging.exception("Failed to initialize dev toolbar")
        except Exception:
            pass
        try:
            def _bg_pay_worker():
                try:
                    while True:
                        try:
                            saves_dir = saves_folder or 'saves'
                            pattern = os.path.join(saves_dir, "*_*.sldsv")
                            files = glob.glob(pattern)
                            for fpath in files:
                                try:
                                    data = self._read_save_from_path(fpath)
                                    if data:
                                        try:
                                            self._award_paychecks_for_save(data, fpath)
                                        except Exception:
                                            logging.exception('Error awarding paychecks for %s', fpath)
                                except Exception:
                                    logging.exception('Failed processing save for paychecks: %s', fpath)
                        except Exception:
                            logging.exception('Background paycheck loop error')
                        time.sleep(60)
                except Exception:
                    logging.exception('Background paycheck worker exiting')
            threading.Thread(target=_bg_pay_worker, daemon=True).start()
        except Exception:
            logging.exception('Failed to start background paycheck worker')
        self.root.mainloop()
    def _play_ui_sound(self, sound_filename):
        sound_path = os.path.join("sounds", "ui", sound_filename +".ogg")
        if os.path.exists(sound_path):
            try:
                sound = pygame.mixer.Sound(sound_path)
                sound.play()
                logging.debug(f"Played UI sound: {sound_filename}")
            except Exception as e:
                logging.warning(f"Failed to play sound '{sound_filename}': {e}")
    def _create_sound_button(self, parent, text, command, **kwargs):
        def safe_command():
            try:
                self._play_ui_sound("click")
                command()
            except Exception as e:
                logging.exception("Button command failed for '%s': %s", text, e)
        button = customtkinter.CTkButton(
        parent, text = text, command = safe_command, **kwargs
        )
        def on_hover(e):
            if button.cget("state")!="disabled":
                self._play_ui_sound("hover")
        button.bind("<Enter>", on_hover)
        return button
    def _start_title_easter_egg(self, label):
        try:
            if getattr(self, '_title_easter_active', False):
                return
            self._title_easter_active = True

            try:
                orig_color = label.cget('text_color')
            except Exception:
                orig_color = None

            try:
                sound_path = os.path.join('sounds', 'firearms', 'universal', 'largestgunintheworld.ogg')
                threading.Thread(target = lambda:self._safe_sound_play('', sound_path, block = False), daemon = True).start()
            except Exception:
                logging.exception('Failed to start easter egg sound')

            colors =['red', 'orange', 'yellow', 'green', 'cyan', 'blue', 'magenta']
            interval = 120
            duration_ms = 8000
            steps = max(1, duration_ms //interval)

            def _cycle(i = 0, remaining = steps):
                try:
                    if remaining <=0:
                        try:
                            if orig_color is not None:
                                label.configure(text_color = orig_color)
                            else:
                                label.configure(text_color = None)
                        except Exception:
                            pass
                        self._title_easter_active = False
                        return
                    color = colors[i %len(colors)]
                    try:
                        label.configure(text_color = color)
                    except Exception:
                        try:
                            label.configure(fg_color = color)
                        except Exception:
                            pass
                    self.root.after(interval, lambda:_cycle(i +1, remaining -1))
                except Exception:
                    self._title_easter_active = False

            self.root.after(0, lambda:_cycle(0, steps))
        except Exception:
            logging.exception('Easter egg failed')

    def _parse_version(self, v:str):
        try:
            parts = re.findall(r"\d+", str(v))
            return tuple(int(p)for p in parts)
        except Exception:
            return()

    def _check_remote_version(self, label):
        try:
            raw_url = 'https://raw.githubusercontent.com/soli-dstate/DOOM-Tools/master/main.py'
            try:
                resp = requests.get(raw_url, timeout = 5)
                if resp.status_code !=200:
                    return
                text = resp.text
            except Exception:
                return

            m = re.search(r"^version\s*=\s*[\"']([^\"']+)[\"']", text, re.MULTILINE)
            if not m:
                return
            remote_ver = m.group(1)
            local_ver = version

            lp = self._parse_version(local_ver)
            rp = self._parse_version(remote_ver)

            def _pad(a, b):
                la = list(a)
                lb = list(b)
                L = max(len(la), len(lb))
                while len(la)<L:
                    la.append(0)
                while len(lb)<L:
                    lb.append(0)
                return tuple(la), tuple(lb)

            lp, rp = _pad(lp, rp)

            if lp >rp:
                try:
                    label.configure(text = f"Version: {local_ver}[PRE-RELEASE]")
                    try:
                        label.configure(text_color = 'cyan')
                    except Exception:
                        pass
                except Exception:
                    pass
                try:
                    logging.warning("Running pre-release version, do not report any issues to GitHub")
                except Exception:
                    pass
                try:
                    self._update_available = False
                except Exception:
                    pass
            elif lp <rp:
                try:
                    label.configure(text = f"Version: {local_ver}[UPDATE AVAILABLE]")
                    try:
                        label.configure(text_color = 'red')
                    except Exception:
                        pass
                except Exception:
                    pass
                try:
                    logging.warning("A newer version of DOOM Tools is available.Please visit the GitHub page to download the latest version.")
                except Exception:
                    pass
                try:
                    self._update_available = True
                except Exception:
                    pass

                try:
                    self._start_version_flash(label)
                except Exception:
                    pass
            else:
                try:
                    self._update_available = False
                except Exception:
                    pass
        except Exception:
            logging.exception('Remote version check failed')

    def _start_version_flash(self, label):
        try:
            if getattr(self, '_version_flash_active', False):
                return
            self._version_flash_active = True
            try:
                orig = label.cget('text_color')
            except Exception:
                orig = None

            def _step():
                try:
                    if not getattr(self, '_version_flash_active', False):
                        try:
                            if orig is not None:
                                label.configure(text_color = orig)
                            else:
                                label.configure(text_color = None)
                        except Exception:
                            pass
                        return
                    try:
                        cur = label.cget('text_color')
                    except Exception:
                        cur = None
                    try:
                        next_color = 'red'if cur !='red'else(orig or 'black')
                        label.configure(text_color = next_color)
                    except Exception:
                        pass
                    self.root.after(400, _step)
                except Exception:
                    self._version_flash_active = False

            self.root.after(0, _step)
        except Exception:
            logging.exception('Failed to start version flash')
    def _safe_sound_play(self, directory, sound_filename, block = False):

        if os.path.isabs(sound_filename)or sound_filename.endswith((".wav", ".ogg")):
            sound_path = sound_filename
        else:
            sound_path = os.path.join("sounds", directory, sound_filename +".ogg")

        try:
            exists = os.path.exists(sound_path)
        except Exception:
            exists = False
        logging.debug(f"_safe_sound_play: resolved '{sound_filename}' -> '{sound_path}', exists={exists}, block={block}")

        if os.path.exists(sound_path):
            try:

                if not hasattr(self, "_sound_cache"):
                    self._sound_cache = {}
                cache = self._sound_cache
                sound = cache.get(sound_path)
                if sound is None:
                    try:
                        sound = pygame.mixer.Sound(sound_path)
                    except Exception as e:
                        logging.warning(f"Failed to load sound '{sound_path}': {e}")
                        return
                    cache[sound_path]= sound

                if not hasattr(self, '_muffled_sound_cache'):
                    try:
                        self._muffled_sound_cache = {}
                    except Exception:
                        self._muffled_sound_cache = {}

                try:
                    vol = 1.0

                    if getattr(self, '_flashbang_mute', False):
                        base = os.path.basename(sound_path).lower()

                        if('ring'in base)or('explosion'in base)or('flashbang'in base):
                            vol = 1.0
                        else:
                            vol = float(getattr(self, '_flashbang_volume', 0.0))

                    try:
                        if getattr(self, '_bang_muffle', False):
                            base = os.path.basename(sound_path).lower()
                            is_bang =('explosion'in base)or('flashbang'in base)or('bang'in base)
                            logging.debug(f"_safe_sound_play: bang_muffle active, filename='{base}', is_bang={is_bang}")
                            if is_bang:
                                muffled = None
                                try:
                                    mcache = getattr(self, '_muffled_sound_cache', {})
                                    muffled = mcache.get(sound_path)
                                except Exception:
                                    muffled = None

                                if muffled is None:
                                    try:
                                        import numpy as _np
                                        from numpy.fft import rfft, irfft, fftfreq
                                        snd_arr = None
                                        try:
                                            snd_arr = pygame.sndarray.array(sound)
                                        except Exception:
                                            snd_arr = None

                                        if snd_arr is None:
                                            muffled = None
                                        else:
                                            try:
                                                mixer_info = pygame.mixer.get_init()
                                                sr = int(mixer_info[0])if mixer_info and mixer_info[0]else 44100
                                            except Exception:
                                                sr = 44100

                                            orig_dtype = snd_arr.dtype
                                            snd_float = snd_arr.astype(_np.float32)
                                            if snd_float.ndim ==1:
                                                channels = 1
                                                channels_data =[snd_float]
                                            else:
                                                channels = snd_float.shape[1]
                                                channels_data =[snd_float[:, c]for c in range(channels)]

                                            processed =[]
                                            cutoff = float(getattr(self, '_bang_muffle_cutoff', 3000.0))
                                            for chdata in channels_data:
                                                n = chdata.size
                                                spec = rfft(chdata)
                                                freqs = fftfreq(n, 1.0 /sr)[:spec.size]
                                                spec[freqs >cutoff]= 0
                                                proc = irfft(spec)
                                                ir_len = int(0.03 *sr)
                                                if ir_len >1:
                                                    ir = _np.exp(-_np.linspace(0, 4, ir_len))
                                                    ir = ir /(ir.sum()+1e-9)
                                                    try:
                                                        proc = _np.convolve(proc, ir, mode = 'same')
                                                    except Exception:
                                                        pass
                                                processed.append(proc)

                                            if channels ==1:
                                                proc_arr = processed[0]
                                            else:
                                                proc_arr = _np.vstack(processed).T

                                            try:
                                                if _np.issubdtype(orig_dtype, _np.integer):
                                                    info = _np.iinfo(orig_dtype)
                                                    proc_arr = _np.clip(proc_arr, info.min, info.max)
                                                else:
                                                    proc_arr = _np.clip(proc_arr, -1.0, 1.0)
                                                proc_arr = proc_arr.astype(orig_dtype)
                                            except Exception:
                                                try:
                                                    proc_arr = proc_arr.astype(orig_dtype)
                                                except Exception:
                                                    pass

                                            try:
                                                muffled_sound = pygame.sndarray.make_sound(proc_arr)
                                                try:
                                                    self._muffled_sound_cache[sound_path]= muffled_sound
                                                except Exception:
                                                    pass
                                                muffled = muffled_sound
                                            except Exception:
                                                muffled = None
                                    except Exception:
                                        muffled = None

                                if muffled is not None:
                                    sound = muffled
                                    logging.debug(f"_safe_sound_play: using synthesized muffled sound for {sound_path}")
                                else:
                                    mv = float(getattr(self, '_bang_muffle_volume', 0.45))
                                    vol = min(vol, mv)
                                    logging.debug(f"_safe_sound_play: no synthesized muffled sound, capping vol to {vol}")
                    except Exception:
                        logging.exception('_safe_sound_play: error during muffle handling')
                        pass
                    final_vol = max(0.0, min(1.0, vol))
                    try:
                        sound.set_volume(final_vol)
                    except Exception:
                        logging.debug('_safe_sound_play: failed to set volume on sound object')
                    logging.debug(f"_safe_sound_play: final volume set to {final_vol} for '{sound_path}'(flashbang_mute={getattr(self, '_flashbang_mute', False)}, bang_muffle={getattr(self, '_bang_muffle', False)})")
                except Exception:
                    pass

                try:
                    ch = sound.play()
                    if ch is None:

                        ch = pygame.mixer.find_channel(True)
                        if ch:
                            ch.play(sound)
                            logging.debug(f"Played sound(forced channel) file: {sound_path}")
                        else:
                            logging.warning(f"No channel available to play sound: {sound_path}")
                    else:
                        logging.debug(f"Played sound file: {sound_path}")

                    if block:
                        try:
                            length = sound.get_length()
                        except Exception:
                            length = None
                        if length and length >0:
                            time.sleep(length)
                        else:

                            try:
                                if ch:
                                    while ch.get_busy():
                                        time.sleep(0.01)
                            except Exception:
                                pass
                except Exception as e:
                    logging.warning(f"Failed to play sound '{sound_path}': {e}")
            except Exception as e:
                logging.warning(f"Failed to play sound '{sound_path}': {e}")

    def _add_item_to_container(self, container_items, item_to_add, force_no_stack = False):

        if not isinstance(container_items, list):
            return False
        if not isinstance(item_to_add, dict):
            container_items.append(item_to_add)
            return False

        if force_no_stack or item_to_add.get("can_stack")==False:
            container_items.append(item_to_add)
            return False

        non_stackable_keys =["magazinesystem", "capacity", "firearm", "attachment", "subslots", "loaded", "chambered"]
        if any(k in item_to_add for k in non_stackable_keys):
            container_items.append(item_to_add)
            return False

        def items_match_for_stacking(existing, new_item):

            if existing.get("name")!=new_item.get("name"):
                return False
            if existing.get("id")!=new_item.get("id"):
                return False

            if existing.get("caliber")!=new_item.get("caliber"):
                return False

            if existing.get("variant")!=new_item.get("variant"):
                return False

            if existing.get("can_stack")==False:
                return False

            if any(k in existing for k in non_stackable_keys):
                return False
            return True

        for existing_item in container_items:
            if not isinstance(existing_item, dict):
                continue
            if items_match_for_stacking(existing_item, item_to_add):

                existing_qty = existing_item.get("quantity", 1)
                new_qty = item_to_add.get("quantity", 1)
                try:
                    existing_qty = int(existing_qty)if existing_qty else 1
                    new_qty = int(new_qty)if new_qty else 1
                except(ValueError, TypeError):
                    existing_qty = 1
                    new_qty = 1
                existing_item["quantity"]= existing_qty +new_qty
                return True

        container_items.append(item_to_add)
        return False

    def _add_rounds_to_container(self, container_items, rounds_list):

        if not isinstance(container_items, list)or not isinstance(rounds_list, list):
            return

        round_groups = {}
        for r in rounds_list:
            if not isinstance(r, dict):
                continue
            caliber = r.get("caliber", "Unknown")
            variant = r.get("variant", "Unknown")
            key =(str(caliber), str(variant))
            if key not in round_groups:
                round_groups[key]=[]
            round_groups[key].append(r)

        for(caliber, variant), group_rounds in round_groups.items():

            sample = group_rounds[0]if group_rounds else {}
            stack_item = {
            "name":sample.get("name", f"{caliber} | {variant}"),
            "caliber":caliber,
            "variant":variant,
            "quantity":len(group_rounds)
            }

            for k in["type", "pen", "modifiers", "tip", "rarity"]:
                if k in sample:
                    stack_item[k]= sample[k]

            self._add_item_to_container(container_items, stack_item)

    def _center_popup_on_window(self, popup, width = None, height = None):

        try:
            popup.update_idletasks()

            if width is None:
                width = popup.winfo_reqwidth()
            if height is None:
                height = popup.winfo_reqheight()

            root_x = self.root.winfo_x()
            root_y = self.root.winfo_y()
            root_width = self.root.winfo_width()
            root_height = self.root.winfo_height()

            x = root_x +(root_width //2)-(width //2)
            y = root_y +(root_height //2)-(height //2)

            screen_width = popup.winfo_screenwidth()
            screen_height = popup.winfo_screenheight()
            x = max(0, min(x, screen_width -width))
            y = max(0, min(y, screen_height -height))

            popup.geometry(f"{width}x{height}+{x}+{y}")
        except Exception:

            try:
                popup.geometry("+100+100")
            except Exception:
                pass

    def _popup_show_info(self, title, message, sound = "popup"):
        self._play_ui_sound(sound)

        try:
            theme = customtkinter.ThemeManager.theme
            toplevel_fg = theme.get("CTkToplevel", {}).get("fg_color")
            label_text_color = theme.get("CTkLabel", {}).get("text_color")
            button_fg = theme.get("CTkButton", {}).get("fg_color")
            button_text = theme.get("CTkButton", {}).get("text_color")
        except Exception:
            toplevel_fg = None
            label_text_color = None
            button_fg = None
            button_text = None

        if toplevel_fg:
            popup = customtkinter.CTkToplevel(self.root, fg_color = toplevel_fg)
        else:
            popup = customtkinter.CTkToplevel(self.root)
        popup.title(title)
        popup.transient(self.root)

        try:
            screen_w = self.root.winfo_screenwidth()
            wraplength = min(1000, max(300, screen_w -200))
        except Exception:
            wraplength = 400

        label_kwargs = {"text":message, "wraplength":wraplength, "font":customtkinter.CTkFont(size = 13)}
        if label_text_color:
            label_kwargs["text_color"]= label_text_color
        label = customtkinter.CTkLabel(popup, **label_kwargs)
        label.pack(pady = 30, padx = 20)

        def close_popup():
            self._play_ui_sound("click")
            popup.destroy()

        btn_kwargs = {"text":"OK", "command":close_popup, "width":120, "height":35}
        if button_fg:
            btn_kwargs["fg_color"]= button_fg
        if button_text:
            btn_kwargs["text_color"]= button_text
        ok_button = customtkinter.CTkButton(popup, **btn_kwargs)
        ok_button.pack(pady = 10)

        popup.update_idletasks()

        try:
            req_w = popup.winfo_reqwidth()
            req_h = popup.winfo_reqheight()
            screen_w = popup.winfo_screenwidth()
            screen_h = popup.winfo_screenheight()
            max_w = max(200, screen_w -100)
            max_h = max(150, screen_h -100)
            final_w = min(req_w, max_w)
            final_h = min(req_h, max_h)
            self._center_popup_on_window(popup, final_w, final_h)
        except Exception:
            try:
                popup.geometry("+100+100")
            except Exception:
                pass

        popup.deiconify()
        popup.grab_set()
        popup.lift()
        self._safe_focus(popup)

    def _popup_progress(self, title, message):

        self._play_ui_sound("popup")
        try:
            theme = customtkinter.ThemeManager.theme
            toplevel_fg = theme.get("CTkToplevel", {}).get("fg_color")
            label_text_color = theme.get("CTkLabel", {}).get("text_color")
        except Exception:
            toplevel_fg = None
            label_text_color = None

        if toplevel_fg:
            popup = customtkinter.CTkToplevel(self.root, fg_color = toplevel_fg)
        else:
            popup = customtkinter.CTkToplevel(self.root)
        popup.title(title)
        popup.geometry("450x120")
        popup.transient(self.root)

        label_kwargs = {"text":message, "wraplength":400, "font":customtkinter.CTkFont(size = 13)}
        if label_text_color:
            label_kwargs["text_color"]= label_text_color
        label = customtkinter.CTkLabel(popup, **label_kwargs)
        label.pack(pady = 20, padx = 20)

        def update(text):
            try:
                label.configure(text = text)
                popup.update_idletasks()
            except Exception:
                pass

        def close():
            try:
                self._play_ui_sound("click")
            except Exception:
                pass
            try:
                popup.destroy()
            except Exception:
                pass

        self._center_popup_on_window(popup, 450, 120)
        popup.deiconify()
        popup.lift()
        return {"update":update, "close":close, "popup":popup}

    def _popup_confirm(self, title, message, on_confirm):
        self._play_ui_sound("popup")
        popup = customtkinter.CTkToplevel(self.root)
        popup.title(title)
        popup.geometry("450x220")
        popup.transient(self.root)

        label = customtkinter.CTkLabel(popup, text = message, wraplength = 400, font = customtkinter.CTkFont(size = 13))
        label.pack(pady = 30, padx = 20)

        button_frame = customtkinter.CTkFrame(popup, fg_color = "transparent")
        button_frame.pack(pady = 10)

        def confirm():
            self._play_ui_sound("click")
            popup.destroy()

            try:
                on_confirm(True)
            except TypeError:
                on_confirm()

        def cancel():
            self._play_ui_sound("click")
            popup.destroy()

            try:
                on_confirm(False)
            except TypeError:
                pass

        yes_button = customtkinter.CTkButton(button_frame, text = "Yes", command = confirm, width = 120, height = 35)
        yes_button.pack(side = "left", padx = 10)
        no_button = customtkinter.CTkButton(button_frame, text = "No", command = cancel, width = 120, height = 35)
        no_button.pack(side = "left", padx = 10)

        self._center_popup_on_window(popup, 450, 220)
        popup.deiconify()
        popup.lift()
        try:
            self._safe_focus(popup)
        except Exception:
            pass
        try:
            popup.grab_set()
        except Exception:
            pass
        try:
            popup.wait_window()
        except Exception:
            pass

    def _popup_ask_integer(self, title, prompt, initial_value = 1, min_value = 1, max_value = 100, on_result = None):

        self._play_ui_sound("popup")
        popup = customtkinter.CTkToplevel(self.root)
        popup.title(title)
        popup.geometry("400x180")
        popup.transient(self.root)

        label = customtkinter.CTkLabel(popup, text = prompt, wraplength = 380, font = customtkinter.CTkFont(size = 13))
        label.pack(pady =(16, 8), padx = 16)

        input_frame = customtkinter.CTkFrame(popup, fg_color = "transparent")
        input_frame.pack(fill = "x", padx = 16, pady =(0, 8))

        try:
            iv = int(initial_value)
        except Exception:
            iv = min_value
        if iv <min_value:
            iv = min_value
        if iv >max_value:
            iv = max_value

        value_var = customtkinter.IntVar(value = iv)

        entry = customtkinter.CTkEntry(input_frame, width = 80, textvariable = value_var)
        entry.pack(side = "left", padx =(0, 10))

        slider = None
        if max_value >min_value:

            steps = max_value -min_value
            slider = customtkinter.CTkSlider(
            input_frame,
            from_ = min_value,
            to = max_value,
            number_of_steps = steps,
            variable = value_var,
            width = 200
            )
            slider.pack(side = "left", fill = "x", expand = True)

        min_label = customtkinter.CTkLabel(input_frame, text = f"({min_value}-{max_value})", font = customtkinter.CTkFont(size = 11), text_color = "gray")
        min_label.pack(side = "left", padx =(10, 0))

        result:dict = {"value":None}

        def validate_and_confirm():
            try:
                val = int(value_var.get())
                if val <min_value:
                    val = min_value
                elif val >max_value:
                    val = max_value
                result["value"]= val
                self._play_ui_sound("click")
                popup.destroy()
                if on_result:
                    on_result(val)
            except(ValueError, TypeError):
                self._popup_show_info("Invalid Input", "Please enter a valid number")

        def cancel():
            self._play_ui_sound("click")
            result["value"]= None
            popup.destroy()
            if on_result:
                on_result(None)

        button_frame = customtkinter.CTkFrame(popup, fg_color = "transparent")
        button_frame.pack(pady =(8, 12))

        ok_btn = customtkinter.CTkButton(button_frame, text = "OK", command = validate_and_confirm, width = 120, height = 34)
        ok_btn.pack(side = "left", padx = 8)

        cancel_btn = customtkinter.CTkButton(button_frame, text = "Cancel", command = cancel, width = 120, height = 34, fg_color = "#444444")
        cancel_btn.pack(side = "left", padx = 8)

        entry.bind("<Return>", lambda e:validate_and_confirm())
        popup.bind("<Escape>", lambda e:cancel())

        self._center_popup_on_window(popup, 400, 180)
        popup.deiconify()
        popup.lift()
        popup.grab_set()
        self._safe_focus(entry)

        if on_result is None:

            popup.wait_window()
            return result.get("value")

    def _popup_select_option(self, title, prompt, options):

        self._play_ui_sound("popup")
        popup = customtkinter.CTkToplevel(self.root)
        popup.title(title)
        popup.geometry("480x160")
        popup.transient(self.root)

        label = customtkinter.CTkLabel(popup, text = prompt, wraplength = 440, font = customtkinter.CTkFont(size = 13))
        label.pack(pady =(16, 8), padx = 16)

        sel_var = customtkinter.StringVar(value =(options[0]if options else ""))
        opt = customtkinter.CTkOptionMenu(popup, values = options, variable = sel_var)
        opt.pack(pady =(0, 12), padx = 16, fill = "x")

        result = {"value":None}

        def confirm():
            try:
                self._play_ui_sound("click")
            except Exception:
                pass
            result["value"]= sel_var.get()# type: ignore
            popup.destroy()

        def cancel():
            try:
                self._play_ui_sound("click")
            except Exception:
                pass
            result["value"]= None
            popup.destroy()

        button_frame = customtkinter.CTkFrame(popup, fg_color = "transparent")
        button_frame.pack(pady =(4, 12))
        ok_btn = customtkinter.CTkButton(button_frame, text = "OK", command = confirm, width = 120, height = 34)
        ok_btn.pack(side = "left", padx = 8)
        cancel_btn = customtkinter.CTkButton(button_frame, text = "Cancel", command = cancel, width = 120, height = 34)
        cancel_btn.pack(side = "left", padx = 8)

        self._center_popup_on_window(popup, 480, 160)
        popup.deiconify()
        popup.lift()

        popup.grab_set()
        popup.wait_window()
        return result.get("value")
    def _clear_window(self):
        for widget in self.root.winfo_children():
            try:

                if getattr(widget, "_is_dev_toolbar", False):
                    continue
                if getattr(widget, "_is_persistent_window", False):
                    continue
            except Exception:
                pass
            try:
                widget.destroy()
            except Exception:
                pass
        logging.debug("Cleared window called")
    def _build_main_menu(self):
        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)
        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew")
        title_label = customtkinter.CTkLabel(main_frame, text = "DOOM Tools", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title_label.pack(pady = 20)
        try:
            title_label.bind("<Button-1>", lambda e:self._start_title_easter_egg(title_label))
        except Exception:
            pass
        version_label = customtkinter.CTkLabel(main_frame, text = f"Version: {version}", font = customtkinter.CTkFont(size = 16))
        version_label.pack()
        try:
            import webbrowser
            def _open_releases(ev = None):
                try:

                    if not getattr(self, '_update_available', False):
                        return
                    try:
                        self._version_flash_active = False
                    except Exception:
                        pass
                    webbrowser.open('https://github.com/soli-dstate/DOOM-Tools/releases')
                except Exception:
                    logging.exception('Failed to open releases')

            version_label.bind("<Button-1>", _open_releases)
        except Exception:
            pass
        try:
            threading.Thread(target = lambda:self._check_remote_version(version_label), daemon = True).start()
        except Exception:
            pass
        current_character = customtkinter.CTkLabel(main_frame, text = f"Current Character: {currentsave if currentsave else 'None'}", font = customtkinter.CTkFont(size = 14))
        current_character.pack(pady = 10)
        current_table = customtkinter.CTkLabel(main_frame, text = f"Current Data Table: {global_variables.get('current_table', 'Default')}", font = customtkinter.CTkFont(size = 14))
        current_table.pack(pady = 5)
        loot_button = self._create_sound_button(main_frame, "Looting", self._open_loot_tool, width = 500, height = 50, font = customtkinter.CTkFont(size = 16), state = "disabled"if currentsave is None else "normal")
        loot_button.pack(pady = 10)
        business_button = self._create_sound_button(main_frame, "Businesses", self._open_business_tool, width = 500, height = 50, font = customtkinter.CTkFont(size = 16), state = "disabled"if currentsave is None else "normal")
        business_button.pack(pady = 10)
        inventoryman_button = self._create_sound_button(main_frame, "Inventory Manager", self._open_inventory_manager_tool, width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        inventoryman_button.pack(pady = 10)
        combatmode_button = self._create_sound_button(main_frame, "Combat Mode", self._open_combat_mode_tool, width = 500, height = 50, font = customtkinter.CTkFont(size = 16), state = "disabled"if currentsave is None else "normal")
        combatmode_button.pack(pady = 10)
        exitb_button = self._create_sound_button(main_frame, "Exit", self._safe_exit, width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        exitb_button.pack(pady = 10)
        settings_button = self._create_sound_button(main_frame, "Settings", self._open_settings, width = 500, height = 50, font = customtkinter.CTkFont(size = 16), state = "normal")
        settings_button.pack(pady = 10)
        # enable combat reports button only if the active table requests it
        try:
            tbl_addl = globals().get('table_data', {}).get('additional_settings', {})
            combat_reports_enabled = bool(tbl_addl.get('combat_repots') or tbl_addl.get('combat_reports'))
        except Exception:
            combat_reports_enabled = False
        combat_reports_button = self._create_sound_button(main_frame, "Combat Reports", self._open_combat_reports_menu, width = 500, height = 50, font = customtkinter.CTkFont(size = 16), state = "normal" if combat_reports_enabled else "disabled")
        combat_reports_button.pack(pady = 10)
        if global_variables["devmode"]["value"]:
            devtools_button = self._create_sound_button(main_frame, "Developer Tools", self._open_dev_tools, width = 500, height = 50, font = customtkinter.CTkFont(size = 16), state = "disabled"if currentsave is None else "normal")
            devtools_button.pack(pady = 10)
        else:
            devtools_button = customtkinter.CTkButton(main_frame, text = "Developer Tools", width = 500, height = 50, font = customtkinter.CTkFont(size = 16), state = "disabled")
            devtools_button.pack(pady = 10)
        if global_variables["dmmode"]["value"]:
            dmmode_button = self._create_sound_button(main_frame, "DM Tools", self._open_dm_tools, width = 500, height = 50, font = customtkinter.CTkFont(size = 16), state = "disabled"if currentsave is None else "normal")
            dmmode_button.pack(pady = 10)
        else:
            dmmode_button = customtkinter.CTkButton(main_frame, text = "DM Tools", width = 500, height = 50, font = customtkinter.CTkFont(size = 16), state = "disabled")
            dmmode_button.pack(pady = 10)
        if currentsave is None:
            currentsave_label = customtkinter.CTkLabel(main_frame, text = "No save loaded.Please load a save to enable tools.", font = customtkinter.CTkFont(size = 14), text_color = "red")
            currentsave_label.pack(pady = 20)

    def _create_dev_toolbar(self):
        try:

            if not getattr(self, "_dev_toolbar_frame", None):

                top = customtkinter.CTkToplevel()

                try:
                    top._is_dev_toolbar = True
                except Exception:
                    pass
                top.title("devtools")
                top.resizable(True, True)

                try:
                    top.configure(fg_color = "#1f1f1f")
                except Exception:
                    pass

                font_large = customtkinter.CTkFont(size = 16)
                content = customtkinter.CTkFrame(top, fg_color = "#1f1f1f")
                try:
                    content.pack(fill = "both", expand = True, padx = 8, pady = 8)
                except Exception:
                    content.grid(row = 0, column = 0, sticky = "nsew", padx = 8, pady = 8)

                cpu_row = customtkinter.CTkFrame(content, fg_color = "transparent")
                cpu_row.pack(anchor = "w")
                self._dev_cpu_text = customtkinter.CTkLabel(cpu_row, text = "CPU/MEM:", font = customtkinter.CTkFont(size = 13), anchor = "w")
                self._dev_cpu_text.pack(side = "left")
                self._dev_cpu_value = customtkinter.CTkLabel(cpu_row, text = "initializing", font = font_large, text_color = "cyan", anchor = "w")
                self._dev_cpu_value.pack(side = "left", padx =(6, 0))

                gpu_row = customtkinter.CTkFrame(content, fg_color = "transparent")
                gpu_row.pack(anchor = "w", pady =(2, 0))
                self._dev_gpu_text = customtkinter.CTkLabel(gpu_row, text = "GPU:", font = customtkinter.CTkFont(size = 13), anchor = "w")
                self._dev_gpu_text.pack(side = "left")
                self._dev_gpu_value = customtkinter.CTkLabel(gpu_row, text = "N/A", font = font_large, text_color = "cyan", anchor = "w")
                self._dev_gpu_value.pack(side = "left", padx =(6, 0))

                self._dev_thread_lbl = customtkinter.CTkLabel(content, text = "Threads: N/A", font = font_large, anchor = "w")
                self._dev_thread_lbl.pack(anchor = "w", pady =(4, 0))

                logs_row = customtkinter.CTkFrame(content, fg_color = "transparent")
                logs_row.pack(anchor = "w", pady =(6, 0))
                small_font = customtkinter.CTkFont(size = 14)

                def _make_counter(parent, text, color):
                    t = customtkinter.CTkLabel(parent, text = text, font = small_font)
                    v = customtkinter.CTkLabel(parent, text = "0", font = small_font, text_color = color)
                    container = customtkinter.CTkFrame(parent, fg_color = "transparent")
                    t.pack(in_ = container, side = "left")
                    v.pack(in_ = container, side = "left", padx =(4, 8))
                    container.pack(side = "left")
                    return t, v

                _, self._dev_log_info_lbl = _make_counter(logs_row, "INFO:", "green")
                _, self._dev_log_warn_lbl = _make_counter(logs_row, "WARN:", "yellow")
                _, self._dev_log_err_lbl = _make_counter(logs_row, "ERR:", "red")
                _, self._dev_log_dbg_lbl = _make_counter(logs_row, "DBG:", "cyan")
                _, self._dev_log_crit_lbl = _make_counter(logs_row, "CRIT:", "magenta")

                table_row = customtkinter.CTkFrame(content, fg_color = "transparent")
                table_row.pack(anchor = "w", pady =(6, 0))
                self._dev_tables_lbl = customtkinter.CTkLabel(table_row, text = "Tables: 0 Items: 0 IDs: 0 Dups: 0", font = small_font, anchor = "w")
                self._dev_tables_lbl.pack(side = "left")
                nid_text = customtkinter.CTkLabel(table_row, text = "Next ID:", font = small_font)
                nid_text.pack(side = "left", padx =(12, 2))
                self._dev_nextid_lbl = customtkinter.CTkLabel(table_row, text = "N/A", font = small_font, text_color = "#7EC8FF")
                self._dev_nextid_lbl.pack(side = "left")

                defs_frame = customtkinter.CTkScrollableFrame(content, height = 220)
                defs_frame.pack(fill = "both", expand = False, pady =(8, 0))
                defs_label_title = customtkinter.CTkLabel(defs_frame, text = "Loaded Definitions:", font = small_font, anchor = "w")
                defs_label_title.pack(anchor = "w", pady =(4, 2), padx = 4)
                self._dev_defs_lbl = customtkinter.CTkLabel(defs_frame, text = "(refreshing...)", font = customtkinter.CTkFont(size = 13), anchor = "w", justify = "left")
                self._dev_defs_lbl.pack(fill = "both", expand = True, padx = 4, pady =(0, 4))

                try:
                    inspect_btn = customtkinter.CTkButton(content, text = "Inspect Tables/Strings", command = self._open_dev_data_viewer, width = 240, height = 36, fg_color = "#2f2f2f")
                    inspect_btn.pack(anchor = "w", pady =(8, 0))
                except Exception:
                    pass

                try:
                    self._dev_logs_summary = customtkinter.CTkLabel(content, text = "", font = small_font, anchor = "w")
                    self._dev_logs_summary.pack(anchor = "w", pady =(4, 0))
                except Exception:
                    self._dev_logs_summary = None

                try:
                    try:
                        content.update_idletasks()
                    except Exception:
                        top.update_idletasks()

                    try:
                        req_w = content.winfo_reqwidth()+16
                        req_h = content.winfo_reqheight()+16
                    except Exception:
                        req_w = top.winfo_reqwidth()
                        req_h = top.winfo_reqheight()
                    req_w = max(req_w, 320)
                    req_h = max(req_h, 240)
                    try:
                        top.minsize(req_w, req_h)
                        top.geometry(f"{req_w}x{req_h}")
                    except Exception:
                        pass
                except Exception:
                    pass

                self._dev_toolbar_frame = top

                try:
                    import GPUtil
                    self._gputil = GPUtil
                except Exception:
                    self._gputil = None

                try:
                    self._dev_proc = psutil.Process()
                except Exception:
                    self._dev_proc = None

                try:
                    self._dev_queue = queue.Queue(maxsize = 1)
                except Exception:
                    self._dev_queue = None
                try:
                    self._dev_worker_running = True
                except Exception:
                    self._dev_worker_running = False

                try:
                    def _on_dev_close():
                        try:
                            self._dev_worker_running = False
                        except Exception:
                            pass
                        try:
                            if getattr(top, 'destroy', None):
                                top.destroy()
                        except Exception:
                            pass
                        try:
                            self._dev_toolbar_frame = None
                        except Exception:
                            pass
                    top.protocol("WM_DELETE_WINDOW", _on_dev_close)
                except Exception:
                    pass

                try:
                    if getattr(self, '_dev_worker_thread', None)is None:
                        self._dev_worker_thread = threading.Thread(target = self._dev_toolbar_worker, name = 'DevToolbarWorker', daemon = True)
                        self._dev_worker_thread.start()
                except Exception:
                    pass

                try:
                    self._update_dev_toolbar()
                except Exception:
                    pass
        except Exception:
            logging.exception("Failed to create dev toolbar")

    def _open_dev_data_viewer(self):
        try:
            top = customtkinter.CTkToplevel()
            top.title("Dev Data Explorer")
            top.transient(self.root)
            self._center_popup_on_window(top, 1000, 600)
            try:
                top.configure(fg_color = "#1f1f1f")
            except Exception:
                pass

            left = customtkinter.CTkFrame(top, width = 300)
            left.pack(side = "left", fill = "y", padx = 6, pady = 6)
            right = customtkinter.CTkFrame(top)
            right.pack(side = "right", fill = "both", expand = True, padx = 6, pady = 6)

            lbl = customtkinter.CTkLabel(left, text = "In-memory data:", anchor = "w")
            lbl.pack(anchor = "w", pady =(4, 2))

            listbox_frame = customtkinter.CTkFrame(left, fg_color = "transparent")
            listbox_frame.pack(fill = "both", expand = True)

            lb = _tk.Listbox(listbox_frame, width = 48, exportselection = False)
            sb = _tk.Scrollbar(listbox_frame, command = lb.yview)
            lb.config(yscrollcommand = sb.set)
            lb.pack(side = "left", fill = "both", expand = True)
            sb.pack(side = "right", fill = "y")

            tbl_map =[]
            try:
                if globals().get('table_data')is not None:
                    lb.insert(_tk.END, "global_table_data")
                    tbl_map.append(("global_table_data", globals().get('table_data')))
            except Exception:
                pass
            try:
                if globals().get('all_table_items')is not None:
                    lb.insert(_tk.END, "all_table_items")
                    tbl_map.append(("all_table_items", globals().get('all_table_items')))
            except Exception:
                pass

            try:
                extras =[
                ("currentsave", globals().get('currentsave')),
                ("save_data", globals().get('save_data')),
                ("self._current_save_data", getattr(self, '_current_save_data', None)),
                ("global_variables", globals().get('global_variables')),
                ("appearance_settings", globals().get('appearance_settings')),
                ("folders", globals().get('folders')),
                ]
                for name, val in extras:
                    try:
                        if val is not None:
                            lb.insert(_tk.END, name)
                            tbl_map.append((name, val))
                    except Exception:
                        pass
            except Exception:
                pass
            try:
                cur = global_variables.get('current_table')
                if cur:
                    lb.insert(_tk.END, f"current_table: {cur}")

                    tbl_map.append((f"current_table: {cur}", globals().get('table_data')))
            except Exception:
                pass

            top_row = customtkinter.CTkFrame(right, fg_color = "transparent")
            top_row.pack(fill = "x")

            sub_lbl = customtkinter.CTkLabel(top_row, text = "Subtable:")
            sub_lbl.pack(side = "left", padx =(4, 8))

            sub_var = customtkinter.StringVar(value = "(none)")
            sub_menu = customtkinter.CTkOptionMenu(top_row, values =["(none)"], variable = sub_var, width = 240)
            sub_menu.pack(side = "left")

            def _show_content_from_selection():
                try:
                    sel = lb.curselection()
                    if not sel:
                        return
                    idx = sel[0]
                    name, obj = tbl_map[idx]

                    data = None
                    if isinstance(obj, str)and os.path.isfile(obj):
                        try:
                            with open(obj, 'r', encoding = 'utf-8')as f:
                                data = json.load(f)
                        except Exception as e:
                            txt.delete('1.0', _tk.END)
                            txt.insert(_tk.END, f"Failed to load file: {e}")
                            return
                    else:
                        data = obj

                    choice = sub_var.get()

                    if isinstance(data, dict):
                        if name =='global_table_data'or name.startswith('current_table'):

                            content = data.get('tables', data)

                            if choice and choice !='(none)':
                                content = content.get(choice, {})
                        else:
                            if choice and choice !="(none)":
                                content = data.get('tables', {}).get(choice, data.get(choice, {}))
                            else:
                                content = data
                    else:
                        content = data

                    txt.delete('1.0', _tk.END)
                    try:
                        txt.insert(_tk.END, json.dumps(content, indent = 2, ensure_ascii = False, default = str))
                    except Exception:
                        txt.insert(_tk.END, str(content))
                except Exception as e:
                    txt.delete('1.0', _tk.END)
                    txt.insert(_tk.END, f"Failed to load: {e}")

            view_btn = customtkinter.CTkButton(top_row, text = "Refresh / Show", command = lambda:(_populate_submenu(), _show_content_from_selection()), width = 140)
            view_btn.pack(side = "left", padx = 8)

            def _open_strings_window():
                try:
                    found =[]
                    def _collect(o):
                        try:
                            if isinstance(o, str):

                                try:
                                    ext = str(global_variables.get('table_extension', '.sldtbl')).lower()
                                except Exception:
                                    ext = '.sldtbl'
                                low = o.lower()
                                if ext and ext in low:
                                    return
                                if re.search(r"\.sldtbl\b", low):
                                    return
                                found.append(o)
                            elif isinstance(o, dict):
                                for v in o.values():
                                    _collect(v)
                            elif isinstance(o, list)or isinstance(o, tuple):
                                for v in o:
                                    _collect(v)
                        except Exception:
                            pass

                    for name, obj in tbl_map:
                        _collect(obj)

                    uniq =[]
                    seen = set()
                    for s in found:
                        if s and s not in seen:
                            seen.add(s)
                            uniq.append(s)

                    sw = customtkinter.CTkToplevel()
                    sw.title('Strings Explorer')
                    sw.geometry('700x500')
                    lf = customtkinter.CTkFrame(sw)
                    lf.pack(fill = 'both', expand = True, padx = 6, pady = 6)
                    lbox = _tk.Listbox(lf)
                    lbox.pack(side = 'left', fill = 'y')
                    scr = _tk.Scrollbar(lf, command = lbox.yview)
                    scr.pack(side = 'left', fill = 'y')
                    lbox.config(yscrollcommand = scr.set)
                    txtw = _tk.Text(sw)
                    txtw.pack(side = 'right', fill = 'both', expand = True)
                    for s in uniq:
                        try:
                            lbox.insert(_tk.END, s[:120])
                        except Exception:
                            lbox.insert(_tk.END, str(s))

                    def _on_string_select(evt = None):
                        try:
                            sel = lbox.curselection()
                            if not sel:
                                return
                            idx = sel[0]
                            s = uniq[idx]
                            txtw.delete('1.0', _tk.END)
                            txtw.insert(_tk.END, s)
                        except Exception:
                            pass

                    lbox.bind('<<ListboxSelect>>', _on_string_select)
                except Exception:
                    logging.exception('Failed opening strings window')

            strings_btn = customtkinter.CTkButton(top_row, text = "Show Strings", command = _open_strings_window, width = 140)
            strings_btn.pack(side = "right", padx = 8)

            txt = _tk.Text(right)
            txt.pack(fill = "both", expand = True)

            def _populate_submenu():
                try:
                    sel = lb.curselection()
                    if not sel:
                        sub_menu.configure(values =["(none)"], variable = sub_var)
                        return
                    idx = sel[0]
                    _, path = tbl_map[idx]

                    data = None
                    if isinstance(path, str)and os.path.isfile(path):
                        try:
                            with open(path, 'r', encoding = 'utf-8')as f:
                                data = json.load(f)
                        except Exception:
                            data = None
                    else:
                        data = path
                    keys =[]
                    if isinstance(data, dict):

                        if 'tables'in data and isinstance(data['tables'], dict):
                            keys = sorted(list(data['tables'].keys()))
                        else:
                            keys = sorted(list(data.keys()))
                    if not keys:
                        keys =["(none)"]
                    sub_menu.configure(values =["(none)"]+keys)
                except Exception:
                    sub_menu.configure(values =["(none)"])

            lb.bind('<<ListboxSelect>>', lambda evt:(_populate_submenu(), _show_content_from_selection()))

            try:
                if tbl_map:
                    lb.selection_set(0)
                    _populate_submenu()
                    _show_content_from_selection()
            except Exception:
                pass

        except Exception:
            logging.exception('Failed opening Dev Data Explorer')

    def _dev_toolbar_worker(self):

        try:
            while getattr(self, '_dev_worker_running', False):
                snap = {}
                try:
                    snap['sys_cpu']= psutil.cpu_percent(interval = None)
                except Exception:
                    snap['sys_cpu']= 0.0
                try:
                    proc = getattr(self, "_dev_proc", None)or psutil.Process()
                    snap['app_cpu']= proc.cpu_percent(interval = None)
                except Exception:
                    snap['app_cpu']= 0.0
                try:
                    vm = psutil.virtual_memory()
                    snap['sys_mem_pct']= vm.percent
                    snap['sys_total_mb']= int(vm.total /(1024 *1024))
                except Exception:
                    snap['sys_mem_pct']= 0.0
                    snap['sys_total_mb']= 0
                try:
                    app_rss = proc.memory_info().rss if proc else 0
                    snap['app_rss_mb']= int(app_rss /(1024 *1024))
                except Exception:
                    snap['app_rss_mb']= 0
                try:
                    snap['app_mem_pct']= round((snap.get('app_rss_mb', 0)/snap.get('sys_total_mb', 1))*100, 1)if snap.get('sys_total_mb')else 0.0
                except Exception:
                    snap['app_mem_pct']= 0.0
                try:
                    snap['threads']= proc.num_threads()if proc else threading.active_count()
                except Exception:
                    snap['threads']= threading.active_count()

                try:
                    gput = getattr(self, "_gputil", None)
                    got = False
                    gpu_str = "N/A"
                    if gput:
                        try:
                            gpus = gput.getGPUs()
                            if gpus:
                                g = gpus[0]
                                gpu_str = f"GPU {g.id}: {int(g.load *100)}% {int(g.memoryUsed)}/{int(g.memoryTotal)}MB"
                                got = True
                        except Exception:
                            got = False
                    if not got:
                        try:
                            if shutil.which("nvidia-smi"):
                                out = subprocess.check_output([
                                "nvidia-smi",
                                "--query-gpu=utilization.gpu, memory.used, memory.total",
                                "--format=csv, noheader, nounits"
                                ], text = True, stderr = subprocess.DEVNULL)
                                line = out.strip().splitlines()[0]
                                parts =[p.strip()for p in line.split(', ')]
                                if len(parts)>=3:
                                    util, used, total = parts[0], parts[1], parts[2]
                                    gpu_str = f"GPU 0: {util}% {used}/{total}MB"
                        except Exception:
                            pass
                    snap['gpu_str']= gpu_str
                except Exception:
                    snap['gpu_str']= 'N/A'

                try:
                    snap['info_ct']= dev_log_counters.get('INFO', 0)
                    snap['warn_ct']= dev_log_counters.get('WARNING', 0)
                    snap['err_ct']= dev_log_counters.get('ERROR', 0)
                    snap['dbg_ct']= dev_log_counters.get('DEBUG', 0)
                    snap['crt_ct']= dev_log_counters.get('CRITICAL', 0)
                except Exception:
                    snap['info_ct']= snap['warn_ct']= snap['err_ct']= snap['dbg_ct']= snap['crt_ct']= 0

                try:
                    table_files = glob.glob(os.path.join('tables', '*.sldtbl'))
                    snap['tbl_count']= len(table_files)
                    total_items = 0
                    id_map = {}
                    for tf in table_files:
                        try:
                            with open(tf, 'r', encoding = 'utf-8')as fh:
                                td = json.load(fh)
                            tables = td.get('tables', {})
                            for sub, items in tables.items():
                                if isinstance(items, list):
                                    for it in items:
                                        total_items +=1
                                        if isinstance(it, dict)and 'id'in it:
                                            iid = it.get('id')
                                            id_map[iid]= id_map.get(iid, 0)+1
                        except Exception:
                            continue
                    snap['total_items']= total_items
                    snap['duplicate_ids']= sum(1 for k, v in id_map.items()if v >1)
                    snap['total_ids']= len(id_map)
                    snap['id_map']= id_map
                except Exception:
                    snap['tbl_count']= snap['total_items']= snap['duplicate_ids']= snap['total_ids']= 0
                    snap['id_map']= {}

                try:
                    ths = threading.enumerate()
                    snap['thread_names']=[t.name for t in ths][:8]
                except Exception:
                    snap['thread_names']=[]

                try:
                    defs_list =[]
                    repo_root = os.path.abspath(os.getcwd())
                    main_mod = sys.modules.get('__main__')
                    if main_mod:
                        for n, o in inspect.getmembers(main_mod):
                            try:
                                if inspect.isfunction(o):
                                    defs_list.append(f"fn: {n}")
                                elif inspect.isclass(o):
                                    defs_list.append(f"class: {n}")
                            except Exception:
                                continue
                    for mname, mod in list(sys.modules.items()):
                        try:
                            mf = getattr(mod, '__file__', None)
                            if not mf:
                                continue
                            mf_abs = os.path.abspath(mf)
                            if not mf_abs.startswith(repo_root):
                                continue
                            for n, o in inspect.getmembers(mod):
                                try:
                                    if inspect.isfunction(o):
                                        defs_list.append(f"{mname}.fn:{n}")
                                    elif inspect.isclass(o):
                                        defs_list.append(f"{mname}.class:{n}")
                                except Exception:
                                    continue
                        except Exception:
                            continue
                    defs_list = sorted(set(defs_list))[:400]
                    snap['defs_text']= "\n".join(defs_list)if defs_list else '(no definitions found)'
                except Exception:
                    snap['defs_text']= '(error collecting definitions)'

                try:
                    q = getattr(self, '_dev_queue', None)
                    if q is not None:
                        try:

                            while not q.empty():
                                try:
                                    q.get_nowait()
                                except Exception:
                                    break
                            q.put_nowait(snap)
                        except Exception:
                            pass
                except Exception:
                    pass

                try:
                    time.sleep(1.0)
                except Exception:
                    break
        except Exception:
            logging.exception('Dev toolbar worker crashed')

    def _update_dev_toolbar(self):
        try:

            try:
                if global_variables.get("devmode", {}).get("value")and not getattr(self, "_dev_toolbar_frame", None):
                    try:
                        self._create_dev_toolbar()
                    except Exception:
                        pass
                elif getattr(self, "_dev_toolbar_frame", None):
                    try:
                        if not getattr(self._dev_toolbar_frame, 'winfo_exists', lambda:True)():

                            self._create_dev_toolbar()
                    except Exception:
                        pass
            except Exception:
                pass

            snap = None
            try:
                if getattr(self, '_dev_queue', None):
                    try:
                        snap = self._dev_queue.get_nowait()
                    except Exception:
                        snap = None
            except Exception:
                snap = None

            if snap:

                sys_cpu = snap.get('sys_cpu', 0.0)
                app_cpu = snap.get('app_cpu', 0.0)
                sys_mem_pct = snap.get('sys_mem_pct', 0.0)
                sys_total_mb = snap.get('sys_total_mb', 0)
                app_rss_mb = snap.get('app_rss_mb', 0)
                app_mem_pct = snap.get('app_mem_pct', 0.0)
                threads = snap.get('threads', 0)
                gpu_str = snap.get('gpu_str', 'N/A')
                info_ct = snap.get('info_ct', 0)
                warn_ct = snap.get('warn_ct', 0)
                err_ct = snap.get('err_ct', 0)
                dbg_ct = snap.get('dbg_ct', 0)
                crt_ct = snap.get('crt_ct', 0)
                tbl_count = snap.get('tbl_count', 0)
                total_items = snap.get('total_items', 0)
                duplicate_ids = snap.get('duplicate_ids', 0)
                total_ids = snap.get('total_ids', 0)
                thread_names = snap.get('thread_names', [])
                defs_text = snap.get('defs_text', '(no definitions found)')
                id_map = snap.get('id_map', {})
            else:

                try:
                    sys_cpu = psutil.cpu_percent(interval = None)
                except Exception:
                    sys_cpu = 0.0
                try:
                    proc = getattr(self, "_dev_proc", None)or psutil.Process()
                    app_cpu = proc.cpu_percent(interval = None)
                except Exception:
                    app_cpu = 0.0
                try:
                    vm = psutil.virtual_memory()
                    sys_mem_pct = vm.percent
                    sys_total_mb = int(vm.total /(1024 *1024))
                except Exception:
                    vm = None
                    sys_mem_pct = 0.0
                    sys_total_mb = 0
                try:
                    app_rss = proc.memory_info().rss if proc else 0
                    app_rss_mb = int(app_rss /(1024 *1024))
                except Exception:
                    app_rss_mb = 0
                try:
                    app_mem_pct = round((app_rss_mb /sys_total_mb)*100, 1)if sys_total_mb else 0.0
                except Exception:
                    app_mem_pct = 0.0
                try:
                    threads = proc.num_threads()if proc else threading.active_count()
                except Exception:
                    threads = threading.active_count()
                gpu_str = "N/A"
                try:
                    gput = getattr(self, "_gputil", None)
                    got = False
                    if gput:
                        try:
                            gpus = gput.getGPUs()
                            if gpus:
                                g = gpus[0]
                                gpu_str = f"GPU {g.id}: {int(g.load *100)}% {int(g.memoryUsed)}/{int(g.memoryTotal)}MB"
                                got = True
                        except Exception:
                            got = False
                    if not got:
                        try:
                            if shutil.which("nvidia-smi"):
                                out = subprocess.check_output([
                                "nvidia-smi",
                                "--query-gpu=utilization.gpu, memory.used, memory.total",
                                "--format=csv, noheader, nounits"
                                ], text = True, stderr = subprocess.DEVNULL)
                                line = out.strip().splitlines()[0]
                                parts =[p.strip()for p in line.split(', ')]
                                if len(parts)>=3:
                                    util, used, total = parts[0], parts[1], parts[2]
                                    gpu_str = f"GPU 0: {util}% {used}/{total}MB"
                                    got = True
                        except Exception:
                            pass
                except Exception:
                    gpu_str = "N/A"
                try:
                    info_ct = dev_log_counters.get('INFO', 0)
                    warn_ct = dev_log_counters.get('WARNING', 0)
                    err_ct = dev_log_counters.get('ERROR', 0)
                    dbg_ct = dev_log_counters.get('DEBUG', 0)
                    crt_ct = dev_log_counters.get('CRITICAL', 0)
                except Exception:
                    info_ct = warn_ct = err_ct = dbg_ct = crt_ct = 0
                try:
                    table_files = glob.glob(os.path.join('tables', '*.sldtbl'))
                    tbl_count = len(table_files)
                    total_items = 0
                    id_map = {}
                    for tf in table_files:
                        try:
                            with open(tf, 'r', encoding = 'utf-8')as fh:
                                td = json.load(fh)
                            tables = td.get('tables', {})
                            for sub, items in tables.items():
                                if isinstance(items, list):
                                    for it in items:
                                        total_items +=1
                                        if isinstance(it, dict)and 'id'in it:
                                            iid = it.get('id')
                                            id_map[iid]= id_map.get(iid, 0)+1
                        except Exception:
                            continue
                    duplicate_ids = sum(1 for k, v in id_map.items()if v >1)
                    total_ids = len(id_map)
                except Exception:
                    tbl_count = total_items = duplicate_ids = total_ids = 0
                try:
                    ths = threading.enumerate()
                    thread_names =[t.name for t in ths][:8]
                except Exception:
                    thread_names =[]
                try:

                    defs_list =[]
                    main_mod = sys.modules.get('__main__')
                    if main_mod:
                        for n, o in inspect.getmembers(main_mod):
                            try:
                                if inspect.isfunction(o):
                                    defs_list.append(f"fn: {n}")
                                elif inspect.isclass(o):
                                    defs_list.append(f"class: {n}")
                            except Exception:
                                continue
                    defs_list = sorted(set(defs_list))[:400]
                    defs_text = "\n".join(defs_list)if defs_list else "(no definitions found)"
                except Exception:
                    defs_text = "(error collecting definitions)"

            try:

                if getattr(self, "_dev_cpu_value", None):

                    try:
                        if sys_total_mb >=1024:
                            sys_gb = math.ceil(sys_total_mb /1024)
                            sys_mem_repr = f"{sys_total_mb}MB({sys_gb}GB) {int(sys_mem_pct)}%"
                        else:
                            sys_mem_repr = f"{sys_total_mb}MB {int(sys_mem_pct)}%"
                    except Exception:
                        sys_mem_repr = f"{int(sys_mem_pct)}%"

                    try:
                        if app_rss_mb >=1024:
                            app_gb = math.ceil(app_rss_mb /1024)
                            app_mem_repr = f"{app_rss_mb}MB({app_gb}GB) {app_mem_pct}%"
                        else:
                            app_mem_repr = f"{app_rss_mb}MB {app_mem_pct}%"
                    except Exception:
                        app_mem_repr = f"{app_rss_mb}MB"

                    self._dev_cpu_value.configure(text = f"SYS CPU: {int(sys_cpu)}% APP CPU: {int(app_cpu)}% SYS MEM: {sys_mem_repr} APP MEM: {app_mem_repr}")
            except Exception:
                pass
            try:

                if getattr(self, "_dev_gpu_value", None):
                    self._dev_gpu_value.configure(text = f"{gpu_str}")
            except Exception:
                pass
            try:

                if getattr(self, "_dev_thread_lbl", None):
                    self._dev_thread_lbl.configure(text = f"Threads: {threads} Names: {', '.join(thread_names)if thread_names else 'N/A'}")
            except Exception:
                pass
            try:

                if getattr(self, "_dev_log_info_lbl", None):
                    self._dev_log_info_lbl.configure(text = f"{info_ct}")
                if getattr(self, "_dev_log_warn_lbl", None):
                    self._dev_log_warn_lbl.configure(text = f"{warn_ct}")
                if getattr(self, "_dev_log_err_lbl", None):
                    self._dev_log_err_lbl.configure(text = f"{err_ct}")
                if getattr(self, "_dev_log_dbg_lbl", None):
                    self._dev_log_dbg_lbl.configure(text = f"{dbg_ct}")
                if getattr(self, "_dev_log_crit_lbl", None):
                    self._dev_log_crit_lbl.configure(text = f"{crt_ct}")

                if getattr(self, "_dev_logs_summary", None):
                    try:
                        self._dev_logs_summary.configure(text = f"INFO:{info_ct} WARN:{warn_ct} ERR:{err_ct} DBG:{dbg_ct} CRIT:{crt_ct}")
                    except Exception:
                        pass
            except Exception:
                pass
            try:

                if getattr(self, "_dev_tables_lbl", None):
                    self._dev_tables_lbl.configure(text = f"Tables: {tbl_count} Items: {total_items} IDs: {total_ids} Duplicate IDs: {duplicate_ids}")
                if getattr(self, "_dev_nextid_lbl", None):
                    try:
                        next_id_val =(max(id_map.keys())+1)if id_map else 0
                    except Exception:
                        next_id_val = 0
                    self._dev_nextid_lbl.configure(text = f"{next_id_val}")

                if getattr(self, "_dev_defs_lbl", None):
                    try:
                        self._dev_defs_lbl.configure(text = defs_text)
                    except Exception:
                        pass
            except Exception:
                pass
        except Exception:
            logging.exception("Failed to update dev toolbar stats")
        finally:
            try:

                if getattr(self, "_dev_toolbar_frame", None):
                    try:
                        self._dev_toolbar_frame.after(1000, self._update_dev_toolbar)
                    except Exception:

                        try:
                            self.root.after(1000, self._update_dev_toolbar)
                        except Exception:
                            pass
                else:
                    try:
                        self.root.after(1000, self._update_dev_toolbar)
                    except Exception:
                        pass
            except Exception:
                pass
    def _open_loot_tool(self):
        logging.info("Looting definition called")
        self._clear_window()

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew")

        title_label = customtkinter.CTkLabel(main_frame, text = "Looting", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title_label.pack(pady = 20)

        try:
            tbl_path = get_current_table_path()
            if not tbl_path or not os.path.exists(tbl_path):
                self._popup_show_info("Error", "No table files found.", sound = "error")
                return

            with open(tbl_path, 'r')as f:
                table_data = json.load(f)

            lootcrates = table_data.get("lootcrates", [])

            crate_files = glob.glob(os.path.join("lootcrates", f"*{global_variables['lootcrate_extension']}"))
            for crate_file in crate_files:
                try:
                    with open(crate_file, 'r')as cf:
                        encoded_data = cf.read()
                    pickled_data = base64.b85decode(encoded_data.encode('utf-8'))
                    crate_data = pickle.loads(pickled_data)
                    crate_data["_file_path"]= crate_file
                    lootcrates.append(crate_data)
                    logging.info(f"Loaded custom loot crate: {crate_data.get('name', os.path.basename(crate_file))}")
                except Exception as e:
                    logging.warning(f"Failed to load loot crate file {crate_file}: {e}")

            enemyloots =[]
            enemyloot_files = glob.glob(os.path.join("enemyloot", "*.sldenlt"))
            for el_file in enemyloot_files:
                try:
                    with open(el_file, 'rb')as ef:
                        encoded_data = ef.read()
                    pickled_data = base64.b85decode(encoded_data)
                    el_data = pickle.loads(pickled_data)
                    el_data["_file_path"]= el_file
                    enemyloots.append(el_data)
                    logging.info(f"Loaded enemy loot: {el_data.get('enemy_name', os.path.basename(el_file))}")
                except Exception as e:
                    logging.warning(f"Failed to load enemy loot file {el_file}: {e}")

            if not lootcrates and not enemyloots:
                error_label = customtkinter.CTkLabel(main_frame, text = "No loot crates or enemy loot available.", font = customtkinter.CTkFont(size = 14), text_color = "orange")
                error_label.pack(pady = 20)
                back_button = self._create_sound_button(main_frame, "Back", lambda:[self._clear_window(), self._build_main_menu()], width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
                back_button.pack(pady = 20)
                return

            scroll_frame = customtkinter.CTkScrollableFrame(main_frame)
            scroll_frame.pack(fill = "both", expand = True, padx = 20, pady = 20)

            def loot_crate(crate, crate_file_path = None):

                try:

                    if crate.get("locked", False):
                        logging.info(f"Crate '{crate.get('name')}' is locked but lockpicking not implemented yet")
                        self._popup_show_info("Locked", "This crate is locked.Lockpicking not implemented yet.", sound = "error")
                        return

                    save_path = os.path.join(saves_folder or "", (currentsave or "")+".sldsv")
                    save_data = self._load_file((currentsave or "")+".sldsv")
                    if save_data is None:
                        raise RuntimeError("Failed to load current save for add_item")

                    if crate.get("generated_items"):

                        available_items = crate.get("generated_items", [])
                        logging.info(f"Using {len(available_items)} pre-generated items from crate '{crate.get('name')}'")
                    else:

                        loot_table = crate.get("loot_table", [])
                        pulls = crate.get("pulls", 3)
                        if isinstance(pulls, dict):
                            num_pulls = random.randint(pulls.get("min", 1), pulls.get("max", 3))
                        else:
                            num_pulls = int(pulls)

                        rarity_weights = table_data.get("rarity_weights", {})

                        luck_stat = save_data.get("stats", {}).get("luck", 0)if save_data else 0
                        luck_effect = rarity_weights.get("Luck Effect", 1.5)

                        available_items =[]
                        for _ in range(num_pulls):

                            weighted_entries =[]
                            for entry in loot_table:
                                entry_rarity = entry.get("rarity", "Common")
                                base_weight = rarity_weights.get(entry_rarity, 1)

                                if luck_stat >0:
                                    weight = base_weight *(1 +(luck_stat *luck_effect /100))
                                else:
                                    weight = base_weight

                                weight = max(1, int(weight))
                                weighted_entries.extend([entry]*weight)

                            if weighted_entries:
                                selected_entry = random.choice(weighted_entries)
                                items_to_add = self._resolve_loot_entry(selected_entry, table_data, save_data)
                                for item in items_to_add:
                                    item_copy = {k:v for k, v in item.items()if k !="table_category"}
                                    item_copy = add_subslots_to_item(item_copy)
                                    available_items.append(item_copy)

                        if crate_file_path and available_items:
                            updated_crate = crate.copy()
                            updated_crate["generated_items"]= available_items
                            updated_crate.pop("loot_table", None)
                            try:
                                pickled_crate = pickle.dumps(updated_crate)
                                encoded_crate = base64.b85encode(pickled_crate).decode('utf-8')
                                with open(crate_file_path, 'w')as cf:
                                    cf.write(encoded_crate)
                                logging.info(f"Saved {len(available_items)} generated items to crate file: {crate_file_path}")

                                crate["generated_items"]= available_items
                                crate.pop("loot_table", None)
                            except Exception as e:
                                logging.error(f"Failed to save generated items to crate file: {e}")

                    self._open_loot_selection_menu(crate, available_items, save_data, save_path, crate_file_path, table_data)

                except Exception as e:
                    logging.error(f"Failed to open loot crate: {e}")
                    self._popup_show_info("Error", f"Failed to open loot crate: {e}", sound = "error")

            if lootcrates:
                crate_section_label = customtkinter.CTkLabel(
                scroll_frame,
                text = "Loot Crates",
                font = customtkinter.CTkFont(size = 18, weight = "bold")
                )
                crate_section_label.pack(pady =(10, 10), anchor = "w", padx = 10)

            for crate in lootcrates:
                crate_frame = customtkinter.CTkFrame(scroll_frame)
                crate_frame.pack(fill = "x", pady = 10, padx = 10)
                crate_frame.grid_columnconfigure(1, weight = 1)

                header_frame = customtkinter.CTkFrame(crate_frame, fg_color = "transparent")
                header_frame.grid(row = 0, column = 0, columnspan = 2, sticky = "ew", pady =(0, 10))
                header_frame.grid_columnconfigure(0, weight = 1)

                name_label = customtkinter.CTkLabel(
                header_frame,
                text = crate.get("name", "Unknown Crate"),
                font = customtkinter.CTkFont(size = 14, weight = "bold"),
                anchor = "w"
                )
                name_label.grid(row = 0, column = 0, sticky = "w")

                rarity_label = customtkinter.CTkLabel(
                header_frame,
                text = f"Rarity: {crate.get('rarity', 'N/A')}",
                font = customtkinter.CTkFont(size = 11),
                text_color = "gray",
                anchor = "e"
                )
                rarity_label.grid(row = 0, column = 1, sticky = "e", padx =(10, 0))

                if "description"in crate and crate["description"]:
                    desc_label = customtkinter.CTkLabel(
                    crate_frame,
                    text = crate["description"],
                    font = customtkinter.CTkFont(size = 11),
                    text_color = "gray",
                    wraplength = 400,
                    justify = "left",
                    anchor = "w"
                    )
                    desc_label.grid(row = 1, column = 0, columnspan = 2, sticky = "ew", pady =(0, 10), padx = 10)

                contents_text = self._get_loot_crate_contents_preview(crate, table_data)
                if contents_text:
                    contents_label = customtkinter.CTkLabel(
                    crate_frame,
                    text = contents_text,
                    font = customtkinter.CTkFont(size = 10),
                    text_color = "orange",
                    wraplength = 400,
                    justify = "left",
                    anchor = "w"
                    )
                    contents_label.grid(row = 2, column = 0, columnspan = 2, sticky = "ew", pady =(0, 10), padx = 10)

                crate_file = crate.get("_file_path")
                loot_button = self._create_sound_button(
                crate_frame,
                "Loot Crate",
                lambda c = crate, f = crate_file:loot_crate(c, f),
                width = 150,
                height = 40,
                font = customtkinter.CTkFont(size = 12)
                )
                loot_button.grid(row = 3, column = 0, columnspan = 2, sticky = "ew", padx = 10, pady = 10)

            if enemyloots:
                enemy_section_label = customtkinter.CTkLabel(
                scroll_frame,
                text = "Enemy Loot",
                font = customtkinter.CTkFont(size = 18, weight = "bold")
                )
                enemy_section_label.pack(pady =(20, 10), anchor = "w", padx = 10)

                def loot_enemy(el_data, el_file_path = None):
                    try:
                        save_path = os.path.join(saves_folder or "", (currentsave or "")+".sldsv")
                        save_data = self._load_file((currentsave or "")+".sldsv")
                        if save_data is None:
                            raise RuntimeError("Failed to load current save for enemy loot")

                        available_items =[]
                        for item in el_data.get("items", []):
                            if isinstance(item, dict):
                                item_copy = {k:v for k, v in item.items()if k !="table_category"}
                                item_copy = add_subslots_to_item(item_copy)
                                available_items.append(item_copy)

                        pseudo_crate = {
                        "name":f"Enemy Loot: {el_data.get('enemy_name', 'Unknown')}",
                        "description":f"Loot from {el_data.get('enemy_name', 'Unknown')} - {el_data.get('timestamp', 'Unknown time')}"
                        }
                        self._open_loot_selection_menu(pseudo_crate, available_items, save_data, save_path, el_file_path, table_data)

                    except Exception as e:
                        logging.error(f"Failed to open enemy loot: {e}")
                        self._popup_show_info("Error", f"Failed to open enemy loot: {e}", sound = "error")

                for el in enemyloots:
                    el_frame = customtkinter.CTkFrame(scroll_frame)
                    el_frame.pack(fill = "x", pady = 10, padx = 10)
                    el_frame.grid_columnconfigure(1, weight = 1)

                    enemy_name = el.get("enemy_name", "Unknown Enemy")
                    timestamp = el.get("timestamp", "")
                    items_list = el.get("items", [])
                    item_count = len(items_list)

                    header_frame = customtkinter.CTkFrame(el_frame, fg_color = "transparent")
                    header_frame.grid(row = 0, column = 0, columnspan = 2, sticky = "ew", pady =(0, 5))
                    header_frame.grid_columnconfigure(0, weight = 1)

                    name_label = customtkinter.CTkLabel(
                    header_frame,
                    text = f"Loot from: {enemy_name}",
                    font = customtkinter.CTkFont(size = 14, weight = "bold"),
                    anchor = "w"
                    )
                    name_label.grid(row = 0, column = 0, sticky = "w")

                    items_label = customtkinter.CTkLabel(
                    header_frame,
                    text = f"{item_count} item(s)",
                    font = customtkinter.CTkFont(size = 11),
                    text_color = "gray",
                    anchor = "e"
                    )
                    items_label.grid(row = 0, column = 1, sticky = "e", padx =(10, 0))

                    if timestamp:
                        try:
                            from datetime import datetime as dt
                            ts_parsed = dt.fromisoformat(timestamp)
                            ts_display = ts_parsed.strftime("%Y-%m-%d %H:%M")
                        except Exception:
                            ts_display = timestamp
                        ts_label = customtkinter.CTkLabel(
                        el_frame,
                        text = f"Generated: {ts_display}",
                        font = customtkinter.CTkFont(size = 10),
                        text_color = "gray",
                        anchor = "w"
                        )
                        ts_label.grid(row = 1, column = 0, columnspan = 2, sticky = "w", padx = 10)

                    if items_list:
                        preview_items = items_list[:3]
                        preview_names =[it.get("name", "Unknown")if isinstance(it, dict)else "Unknown"for it in preview_items]
                        preview_text = ", ".join(preview_names)
                        if len(items_list)>3:
                            preview_text +=f", ...(+{len(items_list)-3} more)"
                        preview_label = customtkinter.CTkLabel(
                        el_frame,
                        text = preview_text,
                        font = customtkinter.CTkFont(size = 10),
                        text_color = "orange",
                        anchor = "w",
                        wraplength = 400
                        )
                        preview_label.grid(row = 2, column = 0, columnspan = 2, sticky = "w", padx = 10, pady =(5, 0))

                    el_file = el.get("_file_path")
                    loot_btn = self._create_sound_button(
                    el_frame,
                    "Loot",
                    lambda e = el, f = el_file:loot_enemy(e, f),
                    width = 150,
                    height = 40,
                    font = customtkinter.CTkFont(size = 12)
                    )
                    loot_btn.grid(row = 3, column = 0, columnspan = 2, sticky = "ew", padx = 10, pady = 10)

            back_button = self._create_sound_button(main_frame, "Back to Main Menu", lambda:[self._clear_window(), self._build_main_menu()], width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
            back_button.pack(pady = 20)

        except Exception as e:
            logging.error(f"Failed to load loot tool: {e}")
            self._popup_show_info("Error", f"Failed to load loot tool: {e}", sound = "error")

    def _resolve_loot_entry(self, entry, table_data, save_data = None):

        items =[]
        debug_info =[]
        try:
            if entry.get("type")=="table":

                table_name = entry.get("table")
                entry_rarity = entry.get("rarity", "Common")
                table = table_data.get("tables", {}).get(table_name, [])

                luck_stat = 0
                if save_data:
                    luck_stat = save_data.get("stats", {}).get("luck", 0)

                rarity_weights = table_data.get("rarity_weights", {})
                special_chance = rarity_weights.get("Special Chance", 0)
                luck_effect = rarity_weights.get("Luck Effect", 1.5)

                if global_variables.get("devmode", {}).get("value", False):
                    debug_info.append(f"[DEBUG]Resolving table entry: {table_name}")
                    debug_info.append(f" Entry rarity(selection weight): {entry_rarity}")
                    debug_info.append(f" Luck stat: {luck_stat}")
                    debug_info.append(f" Luck effect multiplier: {luck_effect}")
                    debug_info.append(f" Special chance: {special_chance}%")
                    debug_info.append(f" Available items in table: {len(table)}")

                special_roll = random.random()*100
                if global_variables.get("devmode", {}).get("value", False):
                    debug_info.append(f" Special roll: {special_roll:.2f}(needs < {special_chance} for special)")

                if special_roll <special_chance:

                    special_table = table_data.get("tables", {}).get("special_items", [])
                    if special_table:
                        selected_item = random.choice(special_table)
                        item_copy = selected_item.copy()
                        item_copy["table_category"]= "special_items"
                        if global_variables.get("devmode", {}).get("value", False):
                            debug_info.append(f" â˜… SPECIAL ITEM TRIGGERED! Selected: {selected_item.get('name', 'Unknown')}")
                            item_copy["_debug_info"]= "\n".join(debug_info)
                        items.append(item_copy)
                        return self._apply_random_quantity(items, table_data)

                weighted_pool =[]
                rarity_counts = {}
                for item in table:
                    item_rarity = item.get("rarity", "Common")
                    weight = rarity_weights.get(item_rarity, 1)

                    if luck_stat >0:
                        weight = weight *(1 +(luck_stat *luck_effect /100))

                    count = max(1, int(weight))
                    weighted_pool.extend([item]*count)
                    rarity_counts[item_rarity]= rarity_counts.get(item_rarity, 0)+count

                if global_variables.get("devmode", {}).get("value", False):
                    debug_info.append(f" Weighted pool breakdown:")
                    for rarity, count in sorted(rarity_counts.items(), key = lambda x:-x[1]):
                        base_w = rarity_weights.get(rarity, 1)
                        pct =(count /len(weighted_pool)*100)if weighted_pool else 0
                        debug_info.append(f" {rarity}: {count} entries({pct:.1f}%)[base weight: {base_w}]")
                    debug_info.append(f" Total pool size: {len(weighted_pool)}")

                if weighted_pool:
                    selected_item = random.choice(weighted_pool)
                    item_copy = selected_item.copy()
                    item_copy["table_category"]= table_name
                    if global_variables.get("devmode", {}).get("value", False):
                        debug_info.append(f" â†’ Selected: {selected_item.get('name', 'Unknown')}({selected_item.get('rarity', 'Unknown')})")
                        item_copy["_debug_info"]= "\n".join(debug_info)
                    items.append(item_copy)

            elif isinstance(entry.get("type"), list)and "table"in entry.get("type")and "id"in entry.get("type"):

                table_name = entry.get("table")
                item_id = entry.get("id")
                requested_rarity = entry.get("rarity")
                multi_type = entry.get("multi_type", "or")
                spawn_magazine = entry.get("spawn_magazine", False)
                magazines_to_spawn = entry.get("magazines_to_spawn", 1)
                loading_type = entry.get("loading", "full")

                if global_variables.get("devmode", {}).get("value", False):
                    debug_info.append(f"[DEBUG]Resolving table+id entry: table={table_name}, id={item_id}")
                    if requested_rarity:
                        debug_info.append(f" Requested rarity: {requested_rarity}")
                    if spawn_magazine:
                        debug_info.append(f" Spawn magazines: {spawn_magazine}, count: {magazines_to_spawn}, loading: {loading_type}")

                def spawn_magazines_for_item_tableid(firearm_item, table_data, debug_info):
                    spawned_mags =[]
                    mag_system = firearm_item.get("magazinesystem")
                    caliber = firearm_item.get("caliber")

                    if not mag_system:
                        if global_variables.get("devmode", {}).get("value", False):
                            debug_info.append(f" âš  No magazinesystem found for {firearm_item.get('name', 'Unknown')}")
                        return spawned_mags

                    if isinstance(caliber, str):
                        caliber =[caliber]

                    magazines_table = table_data.get("tables", {}).get("magazines", [])
                    compatible_mags =[]
                    for mag in magazines_table:
                        if mag.get("magazinesystem")==mag_system:
                            mag_caliber = mag.get("caliber")
                            if isinstance(mag_caliber, str):
                                mag_caliber =[mag_caliber]

                            if caliber and mag_caliber and any(c in mag_caliber for c in caliber):
                                compatible_mags.append(mag)

                    if not compatible_mags:
                        if global_variables.get("devmode", {}).get("value", False):
                            debug_info.append(f" âš  No compatible magazines found for {mag_system}")
                        return spawned_mags

                    if isinstance(magazines_to_spawn, dict):
                        num_mags = random.randint(magazines_to_spawn.get("min", 1), magazines_to_spawn.get("max", 1))
                    else:
                        num_mags = int(magazines_to_spawn)

                    if global_variables.get("devmode", {}).get("value", False):
                        debug_info.append(f" Spawning {num_mags} magazine(s) for {firearm_item.get('name', 'Unknown')}")

                    ammo_table = table_data.get("tables", {}).get("ammunition", [])
                    ammo_def = None
                    first_variant = None
                    for ammo in ammo_table:
                        ammo_caliber = ammo.get("caliber")
                        if isinstance(ammo_caliber, str):
                            ammo_caliber =[ammo_caliber]
                        if caliber and ammo_caliber and any(c in ammo_caliber for c in caliber):
                            ammo_def = ammo
                            variants = ammo.get("variants", [])
                            if variants:
                                first_variant = variants[0]
                            break

                    for i in range(num_mags):
                        mag_template = random.choice(compatible_mags)
                        mag_copy = json.loads(json.dumps(mag_template))
                        mag_copy["table_category"]= "magazines"
                        mag_copy["rounds"]=[]

                        capacity = mag_copy.get("capacity", 30)

                        if loading_type =="full":
                            rounds_to_load = capacity
                        elif loading_type =="random":
                            if random.random()<0.5:
                                rounds_to_load = capacity
                            else:
                                rounds_to_load = random.randint(1, capacity)
                        else:
                            rounds_to_load = capacity

                        if ammo_def and first_variant:
                            for _ in range(rounds_to_load):
                                round_data = {
                                "name":ammo_def.get("name"),
                                "caliber":caliber[0]if caliber else ammo_def.get("caliber"),
                                "variant":first_variant.get("name"),
                                "type":first_variant.get("type"),
                                "pen":first_variant.get("pen"),
                                "modifiers":first_variant.get("modifiers"),
                                "tip":first_variant.get("tip")
                                }
                                mag_copy["rounds"].append(round_data)

                        if global_variables.get("devmode", {}).get("value", False):
                            debug_info.append(f" â†’ Spawned {mag_copy.get('name')} with {len(mag_copy['rounds'])}/{capacity} rounds({first_variant.get('name')if first_variant else 'unknown variant'})")

                        spawned_mags.append(mag_copy)

                    return spawned_mags

                table = table_data.get("tables", {}).get(table_name, [])

                if isinstance(item_id, list):

                    matching_items =[]
                    for single_id in item_id:
                        for item in table:
                            if item.get("id")==single_id:
                                if not requested_rarity or item.get("rarity")==requested_rarity:
                                    matching_items.append(item)
                                    if global_variables.get("devmode", {}).get("value", False):
                                        debug_info.append(f" Found ID {single_id} in '{table_name}': {item.get('name', 'Unknown')}")
                                break

                    if matching_items:
                        if multi_type =="or":

                            chosen_item = random.choice(matching_items)
                            item_copy = chosen_item.copy()
                            item_copy["table_category"]= table_name
                            if global_variables.get("devmode", {}).get("value", False):
                                debug_info.append(f" â†’ OR logic: randomly selected '{chosen_item.get('name', 'Unknown')}'")
                                item_copy["_debug_info"]= "\n".join(debug_info)
                            items.append(item_copy)

                            if spawn_magazine and item_copy.get("firearm"):
                                spawned_mags = spawn_magazines_for_item_tableid(item_copy, table_data, debug_info)
                                items.extend(spawned_mags)
                        elif multi_type =="and":

                            if global_variables.get("devmode", {}).get("value", False):
                                debug_info.append(f" â†’ AND logic: giving all {len(matching_items)} items")
                            for idx, matched_item in enumerate(matching_items):
                                item_copy = matched_item.copy()
                                item_copy["table_category"]= table_name
                                if global_variables.get("devmode", {}).get("value", False)and idx ==0:
                                    item_copy["_debug_info"]= "\n".join(debug_info)
                                items.append(item_copy)

                                if spawn_magazine and item_copy.get("firearm"):
                                    spawned_mags = spawn_magazines_for_item_tableid(item_copy, table_data, debug_info)
                                    items.extend(spawned_mags)
                else:

                    for item in table:
                        if item.get("id")==item_id:
                            if not requested_rarity or item.get("rarity")==requested_rarity:
                                item_copy = item.copy()
                                item_copy["table_category"]= table_name
                                if global_variables.get("devmode", {}).get("value", False):
                                    debug_info.append(f" Found ID {item_id} in '{table_name}': {item.get('name', 'Unknown')}")
                                    item_copy["_debug_info"]= "\n".join(debug_info)
                                items.append(item_copy)

                                if spawn_magazine and item_copy.get("firearm"):
                                    spawned_mags = spawn_magazines_for_item_tableid(item_copy, table_data, debug_info)
                                    items.extend(spawned_mags)
                            break

                return self._apply_random_quantity(items, table_data)

            elif entry.get("type")=="id":

                item_id = entry.get("id")
                multi_type = entry.get("multi_type", "or")
                spawn_magazine = entry.get("spawn_magazine", False)
                magazines_to_spawn = entry.get("magazines_to_spawn", 1)
                loading_type = entry.get("loading", "full")

                if global_variables.get("devmode", {}).get("value", False):
                    if isinstance(item_id, list):
                        debug_info.append(f"[DEBUG]Resolving multi-ID entry: {item_id}")
                        debug_info.append(f" Multi-type: {multi_type}({'pick one'if multi_type =='or'else 'give all'})")
                    else:
                        debug_info.append(f"[DEBUG]Resolving ID entry: {item_id}")
                    if spawn_magazine:
                        debug_info.append(f" Spawn magazines: {spawn_magazine}, count: {magazines_to_spawn}, loading: {loading_type}")

                def spawn_magazines_for_item(firearm_item, table_data, debug_info):
                    spawned_mags =[]
                    mag_system = firearm_item.get("magazinesystem")
                    caliber = firearm_item.get("caliber")

                    if not mag_system:
                        if global_variables.get("devmode", {}).get("value", False):
                            debug_info.append(f" âš  No magazinesystem found for {firearm_item.get('name', 'Unknown')}")
                        return spawned_mags

                    if isinstance(caliber, str):
                        caliber =[caliber]

                    magazines_table = table_data.get("tables", {}).get("magazines", [])
                    compatible_mags =[]
                    for mag in magazines_table:
                        if mag.get("magazinesystem")==mag_system:
                            mag_caliber = mag.get("caliber")
                            if isinstance(mag_caliber, str):
                                mag_caliber =[mag_caliber]

                            if caliber and mag_caliber and any(c in mag_caliber for c in caliber):
                                compatible_mags.append(mag)

                    if not compatible_mags:
                        if global_variables.get("devmode", {}).get("value", False):
                            debug_info.append(f" âš  No compatible magazines found for {mag_system}")
                        return spawned_mags

                    if isinstance(magazines_to_spawn, dict):
                        num_mags = random.randint(magazines_to_spawn.get("min", 1), magazines_to_spawn.get("max", 1))
                    else:
                        num_mags = int(magazines_to_spawn)

                    if global_variables.get("devmode", {}).get("value", False):
                        debug_info.append(f" Spawning {num_mags} magazine(s) for {firearm_item.get('name', 'Unknown')}")

                    ammo_table = table_data.get("tables", {}).get("ammunition", [])
                    ammo_def = None
                    first_variant = None
                    for ammo in ammo_table:
                        ammo_caliber = ammo.get("caliber")
                        if isinstance(ammo_caliber, str):
                            ammo_caliber =[ammo_caliber]
                        if caliber and ammo_caliber and any(c in ammo_caliber for c in caliber):
                            ammo_def = ammo

                            variants = ammo.get("variants", [])
                            if variants:
                                first_variant = variants[0]
                            break

                    for i in range(num_mags):

                        mag_template = random.choice(compatible_mags)
                        mag_copy = json.loads(json.dumps(mag_template))
                        mag_copy["table_category"]= "magazines"
                        mag_copy["rounds"]=[]

                        capacity = mag_copy.get("capacity", 30)

                        if loading_type =="full":
                            rounds_to_load = capacity
                        elif loading_type =="random":

                            if random.random()<0.5:
                                rounds_to_load = capacity
                            else:
                                rounds_to_load = random.randint(1, capacity)
                        else:
                            rounds_to_load = capacity

                        if ammo_def and first_variant:
                            for _ in range(rounds_to_load):
                                round_data = {
                                "name":ammo_def.get("name"),
                                "caliber":caliber[0]if caliber else ammo_def.get("caliber"),
                                "variant":first_variant.get("name"),
                                "type":first_variant.get("type"),
                                "pen":first_variant.get("pen"),
                                "modifiers":first_variant.get("modifiers"),
                                "tip":first_variant.get("tip")
                                }
                                mag_copy["rounds"].append(round_data)

                        if global_variables.get("devmode", {}).get("value", False):
                            debug_info.append(f" â†’ Spawned {mag_copy.get('name')} with {len(mag_copy['rounds'])}/{capacity} rounds({first_variant.get('name')if first_variant else 'unknown variant'})")

                        spawned_mags.append(mag_copy)

                    return spawned_mags

                if isinstance(item_id, list):

                    matching_items =[]
                    for single_id in item_id:
                        for table_name, table_items in table_data.get("tables", {}).items():
                            if not isinstance(table_items, list):
                                continue
                            for item in table_items:
                                if not isinstance(item, dict):
                                    continue
                                if item.get("id")==single_id:
                                    matching_items.append((item, table_name))
                                    if global_variables.get("devmode", {}).get("value", False):
                                        debug_info.append(f" Found ID {single_id} in '{table_name}': {item.get('name', 'Unknown')}")
                                    break

                    if matching_items:
                        if multi_type =="or":

                            chosen_item, chosen_table = random.choice(matching_items)
                            item_copy = chosen_item.copy()
                            item_copy["table_category"]= chosen_table
                            if global_variables.get("devmode", {}).get("value", False):
                                debug_info.append(f" â†’ OR logic: randomly selected '{chosen_item.get('name', 'Unknown')}'")
                                item_copy["_debug_info"]= "\n".join(debug_info)
                            items.append(item_copy)

                            if spawn_magazine and item_copy.get("firearm"):
                                spawned_mags = spawn_magazines_for_item(item_copy, table_data, debug_info)
                                items.extend(spawned_mags)
                        elif multi_type =="and":

                            if global_variables.get("devmode", {}).get("value", False):
                                debug_info.append(f" â†’ AND logic: giving all {len(matching_items)} items")
                            for idx, (matched_item, matched_table)in enumerate(matching_items):
                                item_copy = matched_item.copy()
                                item_copy["table_category"]= matched_table
                                if global_variables.get("devmode", {}).get("value", False)and idx ==0:
                                    item_copy["_debug_info"]= "\n".join(debug_info)
                                items.append(item_copy)

                                if spawn_magazine and item_copy.get("firearm"):
                                    spawned_mags = spawn_magazines_for_item(item_copy, table_data, debug_info)
                                    items.extend(spawned_mags)
                    return self._apply_random_quantity(items, table_data)
                else:

                    for table_name, table_items in table_data.get("tables", {}).items():
                        if not isinstance(table_items, list):
                            continue
                        for item in table_items:
                            if not isinstance(item, dict):
                                continue
                            if item.get("id")==item_id:
                                item_copy = item.copy()
                                item_copy["table_category"]= table_name
                                if global_variables.get("devmode", {}).get("value", False):
                                    debug_info.append(f" Found in table '{table_name}': {item.get('name', 'Unknown')}")
                                    item_copy["_debug_info"]= "\n".join(debug_info)
                                items.append(item_copy)

                                if spawn_magazine and item_copy.get("firearm"):
                                    spawned_mags = spawn_magazines_for_item(item_copy, table_data, debug_info)
                                    items.extend(spawned_mags)
                                return self._apply_random_quantity(items, table_data)
        except Exception as e:
            logging.error(f"Failed to resolve loot entry {entry}: {e}")

        return self._apply_random_quantity(items, table_data)

    def _apply_random_quantity(self, items, table_data = None):

        for item in items:
            if not isinstance(item, dict):
                continue

            rq = item.get("random_quantity")
            if rq and isinstance(rq, dict):
                min_qty = rq.get("min", 1)
                max_qty = rq.get("max", 1)
                try:
                    actual_qty = random.randint(int(min_qty), int(max_qty))
                except(ValueError, TypeError):
                    actual_qty = 1
                item["quantity"]= actual_qty
                del item["random_quantity"]
                logging.debug(f"Applied random_quantity to {item.get('name', 'Unknown')}: {actual_qty}(range {min_qty}-{max_qty})")

            if table_data and item.get("capacity")and item.get("magazinesystem")and not item.get("firearm"):

                if not item.get("rounds"):
                    item["rounds"]=[]
                if len(item.get("rounds", []))==0:
                    caliber = item.get("caliber")
                    if isinstance(caliber, str):
                        caliber =[caliber]

                    capacity = item.get("capacity", 30)

                    rounds_to_load = random.randint(max(1, capacity //4), capacity)

                    ammo_table = table_data.get("tables", {}).get("ammunition", [])
                    ammo_def = None
                    first_variant = None
                    for ammo in ammo_table:
                        ammo_caliber = ammo.get("caliber")
                        if isinstance(ammo_caliber, str):
                            ammo_caliber =[ammo_caliber]
                        if caliber and ammo_caliber and any(c in ammo_caliber for c in caliber):
                            ammo_def = ammo
                            variants = ammo.get("variants", [])
                            if variants:
                                first_variant = variants[0]
                            break

                    if ammo_def and first_variant:
                        for _ in range(rounds_to_load):
                            round_data = {
                            "name":ammo_def.get("name"),
                            "caliber":caliber[0]if caliber else ammo_def.get("caliber"),
                            "variant":first_variant.get("name"),
                            "type":first_variant.get("type"),
                            "pen":first_variant.get("pen"),
                            "modifiers":first_variant.get("modifiers"),
                            "tip":first_variant.get("tip")
                            }
                            item["rounds"].append(round_data)
                        logging.debug(f"Loaded magazine {item.get('name', 'Unknown')} with {rounds_to_load}/{capacity} rounds")

            if table_data and item.get("firearm")and item.get("magazinesystem")and not item.get("loaded"):

                if random.random()<0.4:
                    mag_system = item.get("magazinesystem")
                    caliber = item.get("caliber")
                    if isinstance(caliber, str):
                        caliber =[caliber]

                    magazines_table = table_data.get("tables", {}).get("magazines", [])
                    compatible_mags =[]
                    for mag in magazines_table:
                        if mag.get("magazinesystem")==mag_system:
                            mag_caliber = mag.get("caliber")
                            if isinstance(mag_caliber, str):
                                mag_caliber =[mag_caliber]
                            if caliber and mag_caliber and any(c in mag_caliber for c in caliber):
                                compatible_mags.append(mag)

                    if compatible_mags:
                        mag_template = random.choice(compatible_mags)
                        mag_copy = json.loads(json.dumps(mag_template))
                        mag_copy["table_category"]= "magazines"
                        mag_copy["rounds"]=[]

                        capacity = mag_copy.get("capacity", 30)

                        rounds_to_load = random.randint(max(1, capacity //4), capacity)

                        ammo_table = table_data.get("tables", {}).get("ammunition", [])
                        ammo_def = None
                        first_variant = None
                        for ammo in ammo_table:
                            ammo_caliber = ammo.get("caliber")
                            if isinstance(ammo_caliber, str):
                                ammo_caliber =[ammo_caliber]
                            if caliber and ammo_caliber and any(c in ammo_caliber for c in caliber):
                                ammo_def = ammo
                                variants = ammo.get("variants", [])
                                if variants:
                                    first_variant = variants[0]
                                break

                        if ammo_def and first_variant:
                            for _ in range(rounds_to_load):
                                round_data = {
                                "name":ammo_def.get("name"),
                                "caliber":caliber[0]if caliber else ammo_def.get("caliber"),
                                "variant":first_variant.get("name"),
                                "type":first_variant.get("type"),
                                "pen":first_variant.get("pen"),
                                "modifiers":first_variant.get("modifiers"),
                                "tip":first_variant.get("tip")
                                }
                                mag_copy["rounds"].append(round_data)

                        item["loaded"]= mag_copy
                        logging.debug(f"Loaded firearm {item.get('name', 'Unknown')} with {mag_copy.get('name')}({rounds_to_load}/{capacity} rounds)")

        return items

    def _get_loot_crate_contents_preview(self, crate, table_data):

        info_lines =[]
        try:

            locked_status = "Locked"if crate.get("locked", False)else "Unlocked"
            pulls = crate.get("pulls", 3)
            if isinstance(pulls, dict):
                pulls_text = f"{pulls.get('min')}-{pulls.get('max')}"
            else:
                pulls_text = str(pulls)
            info_lines.append(f"{locked_status} | Pulls: {pulls_text}")

            num_entries = len(crate.get("loot_table", []))
            info_lines.append(f"Loot entries: {num_entries}")
        except Exception as e:
            logging.error(f"Failed to generate loot preview: {e}")

        if info_lines:
            return "\n".join(info_lines)
        return ""

    def _open_loot_selection_menu(self, crate, available_items, save_data, save_path, crate_file_path, table_data):

        self._clear_window()

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew")

        title_label = customtkinter.CTkLabel(
        main_frame,
        text = f"Loot: {crate.get('name', 'Unknown Crate')}",
        font = customtkinter.CTkFont(size = 20, weight = "bold")
        )
        title_label.pack(pady = 20)

        def get_loot_containers():
            containers =[]
            equipment = save_data.get("equipment", {})

            containers.append({"name":"Hands", "location":"hands"})

            for slot, item in equipment.items():

                if item and isinstance(item, dict):
                    if "capacity"in item and "items"in item:
                        containers.append({
                        "name":f"{item.get('name', 'Container')}({slot})",
                        "location":f"equipment.{slot}"
                        })

                    if "subslots"in item:
                        for subslot_idx, subslot_data in enumerate(item["subslots"]):
                            subslot_item = subslot_data.get("current")
                            if subslot_item and isinstance(subslot_item, dict):
                                if "capacity"in subslot_item and "items"in subslot_item:
                                    subslot_name = subslot_data.get("name", f"Subslot {subslot_idx}")
                                    containers.append({
                                    "name":f"{subslot_item.get('name', 'Container')}({slot} â†’ {subslot_name})",
                                    "location":f"equipment.{slot}.subslot.{subslot_idx}"
                                    })

                elif isinstance(item, list):
                    for idx, subitem in enumerate(item):
                        try:
                            if subitem and isinstance(subitem, dict)and "capacity"in subitem and "items"in subitem:
                                containers.append({
                                "name":f"{subitem.get('name', 'Container')}({slot}#{idx})",
                                "location":f"equipment.{slot}.list.{idx}"
                                })

                            if subitem and isinstance(subitem, dict)and "subslots"in subitem:
                                for subslot_idx, subslot_data in enumerate(subitem.get("subslots", [])):
                                    subslot_item = subslot_data.get("current")
                                    if subslot_item and isinstance(subslot_item, dict):
                                        if "capacity"in subslot_item and "items"in subslot_item:
                                            subslot_name = subslot_data.get("name", f"Subslot {subslot_idx}")
                                            containers.append({
                                            "name":f"{subslot_item.get('name', 'Container')}({slot}#{idx} â†’ {subslot_name})",
                                            "location":f"equipment.{slot}.list.{idx}.subslot.{subslot_idx}"
                                            })
                        except Exception:
                            pass

            return containers

        loot_containers = get_loot_containers()
        container_names =[c["name"]for c in loot_containers]

        def get_container_items_local(location):
            if location =="hands":
                return save_data["hands"].get("items", [])
            elif location.startswith("equipment."):
                parts = location.split(".")
                slot = parts[1]
                item = save_data["equipment"].get(slot)
                if item is None:
                    return[]
                if len(parts)>2 and parts[2]=="subslot":
                    subslot_idx = int(parts[3])
                    if isinstance(item, dict)and "subslots"in item and subslot_idx <len(item["subslots"]):
                        subslot_item = item["subslots"][subslot_idx].get("current")
                        if subslot_item and isinstance(subslot_item, dict):
                            return subslot_item.get("items", [])
                if len(parts)>2 and parts[2]=="list":
                    list_idx = int(parts[3])
                    if isinstance(item, list)and 0 <=list_idx <len(item):
                        subitem = item[list_idx]
                        if len(parts)>4 and parts[4]=="subslot":
                            subslot_idx = int(parts[5])
                            if "subslots"in subitem and subslot_idx <len(subitem["subslots"]):
                                subslot_item = subitem["subslots"][subslot_idx].get("current")
                                if subslot_item and isinstance(subslot_item, dict):
                                    return subslot_item.get("items", [])
                        return subitem.get("items", [])if isinstance(subitem, dict)else[]
                if isinstance(item, dict):
                    return item.get("items", [])
            return[]

        def set_container_items_local(location, items):
            if location =="hands":
                save_data["hands"]["items"]= items
            elif location.startswith("equipment."):
                parts = location.split(".")
                slot = parts[1]
                if slot in save_data["equipment"]and save_data["equipment"][slot]:
                    item = save_data["equipment"][slot]
                    if len(parts)>2 and parts[2]=="subslot":
                        subslot_idx = int(parts[3])
                        if isinstance(item, dict)and "subslots"in item and subslot_idx <len(item["subslots"]):
                            subslot_item = item["subslots"][subslot_idx].get("current")
                            if subslot_item and isinstance(subslot_item, dict):
                                subslot_item["items"]= items
                    elif len(parts)>2 and parts[2]=="list":
                        list_idx = int(parts[3])
                        if isinstance(item, list)and 0 <=list_idx <len(item):
                            subitem = item[list_idx]
                            if len(parts)>4 and parts[4]=="subslot":
                                subslot_idx = int(parts[5])
                                if "subslots"in subitem and subslot_idx <len(subitem["subslots"]):
                                    subslot_item = subitem["subslots"][subslot_idx].get("current")
                                    if subslot_item and isinstance(subslot_item, dict):
                                        subslot_item["items"]= items
                            else:
                                if isinstance(subitem, dict):
                                    subitem["items"]= items
                    else:
                        if isinstance(item, dict):
                            item["items"]= items

        def get_container_capacity_local(location):
            if location =="hands":
                base_capacity = save_data.get("hands", {}).get("capacity", 50)
                strength = save_data.get("stats", {}).get("Strength", 0)

                return base_capacity *(1 +strength *0.1)
            if location.startswith("equipment."):
                parts = location.split(".")
                slot = parts[1]
                equip = save_data.get("equipment", {}).get(slot)
                if equip:
                    if len(parts)>2 and parts[2]=="subslot":
                        subslot_idx = int(parts[3])
                        if isinstance(equip, dict)and "subslots"in equip and subslot_idx <len(equip["subslots"]):
                            subslot_item = equip["subslots"][subslot_idx].get("current")
                            if subslot_item and isinstance(subslot_item, dict):
                                return subslot_item.get("capacity")
                            return None
                    if len(parts)>2 and parts[2]=="list":
                        list_idx = int(parts[3])
                        if isinstance(equip, list)and 0 <=list_idx <len(equip):
                            subitem = equip[list_idx]
                            if len(parts)>4 and parts[4]=="subslot":
                                subslot_idx = int(parts[5])
                                if "subslots"in subitem and subslot_idx <len(subitem["subslots"]):
                                    subslot_item = subitem["subslots"][subslot_idx].get("current")
                                    if subslot_item and isinstance(subslot_item, dict):
                                        return subslot_item.get("capacity")
                                return None
                            return subitem.get("capacity")if isinstance(subitem, dict)else None
                    return equip.get("capacity")if isinstance(equip, dict)else None
            return None

        container_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        container_frame.pack(fill = "x", padx = 20, pady =(0, 10))

        customtkinter.CTkLabel(
        container_frame,
        text = "Put items into:",
        font = customtkinter.CTkFont(size = 12)
        ).pack(side = "left", padx =(0, 10))

        container_selector = customtkinter.CTkOptionMenu(
        container_frame,
        values = container_names if container_names else["Hands"],
        width = 350,
        font = customtkinter.CTkFont(size = 12)
        )
        container_selector.pack(side = "left")
        container_selector.set(container_names[0]if container_names else "Hands")

        scroll_frame = customtkinter.CTkScrollableFrame(main_frame)
        scroll_frame.pack(fill = "both", expand = True, padx = 20, pady = 20)

        if global_variables.get("devmode", {}).get("value", False)and available_items:

            all_debug =[]
            for item in available_items:
                if item.get("_debug_info"):
                    all_debug.append(item.get("_debug_info"))
                    all_debug.append("")

            if all_debug:
                debug_frame = customtkinter.CTkFrame(scroll_frame, fg_color = "#1a1a2e")
                debug_frame.pack(fill = "x", pady =(0, 15), padx = 5)

                customtkinter.CTkLabel(
                debug_frame,
                text = "ðŸ”§ LOOT RESOLUTION DEBUG",
                font = customtkinter.CTkFont(size = 12, weight = "bold"),
                text_color = "#00ff88"
                ).pack(anchor = "w", padx = 10, pady =(10, 5))

                debug_text = customtkinter.CTkTextbox(
                debug_frame,
                height = 200,
                font = customtkinter.CTkFont(family = "Consolas", size = 10),
                fg_color = "#0d0d1a",
                text_color = "#88ff88"
                )
                debug_text.pack(fill = "x", padx = 10, pady =(0, 10))
                debug_text.insert("1.0", "\n".join(all_debug))
                debug_text.configure(state = "disabled")

        selected_items_checkboxes = {}

        def update_weight_display():

            selected_weight = 0.0
            for idx, checkbox in selected_items_checkboxes.items():
                if checkbox.get():
                    item = available_items[idx]
                    qty = item.get("quantity", 1)
                    weight = item.get("weight", 0)*qty
                    selected_weight +=weight

            current_encumbrance = self._calculate_encumbrance_status(save_data)

            new_encumbrance = current_encumbrance["encumbrance"]+selected_weight
            new_total_weight = current_encumbrance["total_weight"]+selected_weight

            threshold = current_encumbrance.get("threshold", save_data.get("encumbered_threshold", 50))

            weight_text = f"Selected Weight: {self._format_weight(selected_weight)}\n"
            weight_text +=f"New Total: {self._format_weight(new_total_weight)}\n"
            weight_text +=f"Encumbrance: {self._format_weight(new_encumbrance)} / {self._format_weight(threshold)}"

            if new_encumbrance >threshold:
                weight_text +=" âš ï¸ ENCUMBERED"
                weight_label.configure(text_color = "red")
            else:
                weight_label.configure(text_color = "white")

            weight_label.configure(text = weight_text)

        for i, item in enumerate(available_items):
            item_frame = customtkinter.CTkFrame(scroll_frame)
            item_frame.pack(fill = "x", pady = 10, padx = 10)
            item_frame.grid_columnconfigure(0, weight = 1)

            checkbox = customtkinter.CTkCheckBox(
            item_frame,
            text = "",
            command = update_weight_display
            )
            checkbox.grid(row = 0, column = 0, sticky = "w", padx =(0, 10))
            checkbox.select()
            selected_items_checkboxes[i]= checkbox

            item_info_text = f"{self._format_item_name(item)} - {self._format_weight(item.get('weight', 0))}"
            if item.get("quantity", 1)>1:
                item_info_text +=f" x{item.get('quantity')}"
            if item.get("value"):
                item_info_text +=f"[${item.get('value')}]"

            item_label = customtkinter.CTkLabel(
            item_frame,
            text = item_info_text,
            font = customtkinter.CTkFont(size = 12),
            anchor = "w"
            )
            item_label.grid(row = 0, column = 1, sticky = "ew", padx = 10)

            if item.get("description"):
                desc_label = customtkinter.CTkLabel(
                item_frame,
                text = item.get("description"),
                font = customtkinter.CTkFont(size = 10),
                text_color = "gray",
                wraplength = 600,
                justify = "left",
                anchor = "w"
                )
                desc_label.grid(row = 1, column = 0, columnspan = 2, sticky = "ew", padx = 10, pady =(5, 0))

        weight_frame = customtkinter.CTkFrame(main_frame)
        weight_frame.pack(fill = "x", padx = 20, pady = 10)

        weight_label = customtkinter.CTkLabel(
        weight_frame,
        text = "",
        font = customtkinter.CTkFont(size = 12),
        justify = "left",
        anchor = "w"
        )
        weight_label.pack(fill = "x", padx = 10, pady = 10)

        button_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        button_frame.pack(fill = "x", padx = 20, pady = 20)
        button_frame.grid_columnconfigure((0, 1), weight = 1)

        def take_selected():

            try:

                selected_container_name = container_selector.get()
                selected_container = next((c for c in loot_containers if c["name"]==selected_container_name), None)

                if not selected_container:

                    selected_container = {"name":"Hands", "location":"hands"}

                target_location = selected_container["location"]

                items_to_take =[]
                remaining_items =[]

                for idx, checkbox in selected_items_checkboxes.items():
                    if checkbox.get():
                        items_to_take.append(available_items[idx])
                    else:
                        remaining_items.append(available_items[idx])

                if not items_to_take:
                    self._popup_show_info("Info", "No items selected.", sound = "popup")
                    return

                capacity = get_container_capacity_local(target_location)
                if capacity is not None:
                    current_items = get_container_items_local(target_location)
                    current_weight = sum(
                    it.get("weight", 0)*it.get("quantity", 1)
                    for it in current_items if isinstance(it, dict)
                    )
                    items_weight = sum(
                    it.get("weight", 0)*it.get("quantity", 1)
                    for it in items_to_take if isinstance(it, dict)
                    )
                    if current_weight +items_weight >capacity:
                        self._popup_show_info(
                        "Capacity Exceeded",
                        f"Selected items({self._format_weight(items_weight)}) would exceed container capacity.\n"
                        f"Current: {self._format_weight(current_weight)} / {self._format_weight(capacity)}",
                        sound = "error"
                        )
                        return

                current_items = get_container_items_local(target_location)
                current_items.extend(items_to_take)
                set_container_items_local(target_location, current_items)

                try:
                    self._write_save_to_path(save_path, save_data)
                except Exception as e:
                    logging.error(f"Failed to write updated save: {e}")

                if crate_file_path and os.path.exists(crate_file_path):
                    if remaining_items:

                        updated_crate = crate.copy()
                        updated_crate["generated_items"]= remaining_items
                        updated_crate.pop("loot_table", None)

                        pickled_crate = pickle.dumps(updated_crate)
                        encoded_crate = base64.b85encode(pickled_crate).decode('utf-8')
                        with open(crate_file_path, 'w')as cf:
                            cf.write(encoded_crate)
                        logging.info(f"Updated crate file with {len(remaining_items)} remaining items: {crate_file_path}")
                    else:

                        os.remove(crate_file_path)
                        logging.info(f"Deleted empty loot crate file: {crate_file_path}")

                item_summary = ", ".join([f"{self._format_item_name(item)}"for item in items_to_take])
                logging.info(f"Looted crate '{crate.get('name')}' into {selected_container_name}: {item_summary}")
                self._popup_show_info("Success", f"Took {len(items_to_take)} item(s) into {selected_container_name}:\n{item_summary}", sound = "success")
                self._open_loot_tool()
            except Exception as e:
                logging.error(f"Failed to take items: {e}")
                self._popup_show_info("Error", f"Failed to take items: {e}", sound = "error")

        def take_none():

            self._open_loot_tool()

        take_button = self._create_sound_button(
        button_frame,
        "Take Selected Items",
        take_selected,
        width = 250,
        height = 50,
        font = customtkinter.CTkFont(size = 14)
        )
        take_button.grid(row = 0, column = 0, padx =(0, 10))

        cancel_button = self._create_sound_button(
        button_frame,
        "Leave Crate",
        take_none,
        width = 250,
        height = 50,
        font = customtkinter.CTkFont(size = 14)
        )
        cancel_button.grid(row = 0, column = 1, padx =(10, 0))

        update_weight_display()

    def _open_business_tool(self):
        logging.info("Business tool opened")
        self._clear_window()

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew")

        title_label = customtkinter.CTkLabel(main_frame, text = "Businesses", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title_label.pack(pady = 20)

        try:
            current_tbl = global_variables.get('current_table')
            if current_tbl:
                tbl_path = os.path.join("tables", current_tbl)
            else:
                table_files = sorted(glob.glob(os.path.join("tables", "*.sldtbl")))
                if not table_files:
                    self._popup_show_info("Error", "No table files found.", sound = "error")
                    return
                tbl_path = table_files[0]

            if not os.path.exists(tbl_path):
                self._popup_show_info("Error", "Table file not found.", sound = "error")
                return

            with open(tbl_path, 'r')as f:
                table_data = json.load(f)

            stores = table_data.get("tables", {}).get("stores", [])

            stores =[s for s in stores if s.get("display_in_program", True)]

            if not stores:
                error_label = customtkinter.CTkLabel(main_frame, text = "No businesses available in current table.", font = customtkinter.CTkFont(size = 14), text_color = "orange")
                error_label.pack(pady = 20)
                back_button = self._create_sound_button(main_frame, "Back to Main Menu", lambda:[self._clear_window(), self._build_main_menu()], width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
                back_button.pack(pady = 20)
                return

            scroll_frame = customtkinter.CTkScrollableFrame(main_frame)
            scroll_frame.pack(fill = "both", expand = True, padx = 20, pady = 20)

            armories =[s for s in stores if s.get("type")=="armory"]
            regular_stores =[s for s in stores if s.get("type")=="store"]
            casinos =[s for s in stores if s.get("type")=="casino"]

            if armories:
                armory_section = customtkinter.CTkLabel(scroll_frame, text = "Armories", font = customtkinter.CTkFont(size = 18, weight = "bold"))
                armory_section.pack(pady =(10, 10), anchor = "w", padx = 10)

                for store in armories:
                    store_frame = customtkinter.CTkFrame(scroll_frame)
                    store_frame.pack(fill = "x", pady = 10, padx = 10)

                    name_label = customtkinter.CTkLabel(store_frame, text = store.get("name", "Unknown Armory"), font = customtkinter.CTkFont(size = 14, weight = "bold"))
                    name_label.pack(anchor = "w", padx = 10, pady =(10, 5))

                    shopkeeper = store.get("shopkeeper", "Unknown")
                    shopkeeper_label = customtkinter.CTkLabel(store_frame, text = f"Quartermaster: {shopkeeper}", font = customtkinter.CTkFont(size = 11), text_color = "gray")
                    shopkeeper_label.pack(anchor = "w", padx = 10)

                    points = store.get("armory_points", "disabled")
                    if points !="disabled":
                        points_label = customtkinter.CTkLabel(store_frame, text = f"Points: {points}(resets at 7 PM CST)", font = customtkinter.CTkFont(size = 11), text_color = "orange")
                        points_label.pack(anchor = "w", padx = 10)
                    else:
                        points_label = customtkinter.CTkLabel(store_frame, text = "Unlimited requisitions", font = customtkinter.CTkFont(size = 11), text_color = "green")
                        points_label.pack(anchor = "w", padx = 10)

                    enter_button = self._create_sound_button(store_frame, "Enter Armory", lambda s = store:self._open_armory_interface(s, table_data), width = 200, height = 40, font = customtkinter.CTkFont(size = 12))
                    enter_button.pack(pady = 10, padx = 10)

            if regular_stores:
                store_section = customtkinter.CTkLabel(scroll_frame, text = "Stores", font = customtkinter.CTkFont(size = 18, weight = "bold"))
                store_section.pack(pady =(20, 10), anchor = "w", padx = 10)

                for store in regular_stores:
                    store_frame = customtkinter.CTkFrame(scroll_frame)
                    store_frame.pack(fill = "x", pady = 10, padx = 10)

                    name_label = customtkinter.CTkLabel(store_frame, text = store.get("name", "Unknown Store"), font = customtkinter.CTkFont(size = 14, weight = "bold"))
                    name_label.pack(anchor = "w", padx = 10, pady =(10, 5))

                    shopkeeper = store.get("shopkeeper", "Unknown")
                    shopkeeper_label = customtkinter.CTkLabel(store_frame, text = f"Shopkeeper: {shopkeeper}", font = customtkinter.CTkFont(size = 11), text_color = "gray")
                    shopkeeper_label.pack(anchor = "w", padx = 10)

                    prices = store.get("prices", {})
                    buy_mult = prices.get("buy", 1.0)
                    sell_mult = prices.get("sell", 1.0)
                    prices_label = customtkinter.CTkLabel(store_frame, text = f"Buy: {buy_mult}x value | Sell: {sell_mult}x value", font = customtkinter.CTkFont(size = 11), text_color = "orange")
                    prices_label.pack(anchor = "w", padx = 10)

                    if store.get("accepts_trades"):
                        trades_label = customtkinter.CTkLabel(store_frame, text = "Accepts trades", font = customtkinter.CTkFont(size = 11), text_color = "green")
                        trades_label.pack(anchor = "w", padx = 10)

                    enter_button = self._create_sound_button(store_frame, "Enter Store", lambda s = store:self._open_store_interface(s, table_data), width = 200, height = 40, font = customtkinter.CTkFont(size = 12))
                    enter_button.pack(pady = 10, padx = 10)

            if casinos:
                casino_section = customtkinter.CTkLabel(scroll_frame, text = "Casinos", font = customtkinter.CTkFont(size = 18, weight = "bold"))
                casino_section.pack(pady =(20, 10), anchor = "w", padx = 10)

                for store in casinos:
                    store_frame = customtkinter.CTkFrame(scroll_frame)
                    store_frame.pack(fill = "x", pady = 10, padx = 10)

                    name_label = customtkinter.CTkLabel(store_frame, text = store.get("name", "Unknown Casino"), font = customtkinter.CTkFont(size = 14, weight = "bold"))
                    name_label.pack(anchor = "w", padx = 10, pady =(10, 5))

                    shopkeeper = store.get("shopkeeper", "Unknown")
                    shopkeeper_label = customtkinter.CTkLabel(store_frame, text = f"Proprietor: {shopkeeper}", font = customtkinter.CTkFont(size = 11), text_color = "gray")
                    shopkeeper_label.pack(anchor = "w", padx = 10)

                    min_bet = store.get("min_bet", 10)
                    max_bet = store.get("max_bet", 1000)
                    bet_label = customtkinter.CTkLabel(store_frame, text = f"Bets: ${min_bet} - ${max_bet}", font = customtkinter.CTkFont(size = 11), text_color = "gold")
                    bet_label.pack(anchor = "w", padx = 10)

                    enter_button = self._create_sound_button(store_frame, "Enter Casino", lambda s = store:self._open_casino_interface(s, table_data), width = 200, height = 40, font = customtkinter.CTkFont(size = 12))
                    enter_button.pack(pady = 10, padx = 10)

            back_button = self._create_sound_button(main_frame, "Back to Main Menu", lambda:[self._clear_window(), self._build_main_menu()], width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
            back_button.pack(pady = 20)

        except Exception as e:
            logging.error(f"Failed to open business tool: {e}")
            self._popup_show_info("Error", f"Failed to load businesses: {e}", sound = "error")

    def _get_armory_points_status(self, store_name):

        import pytz
        from datetime import datetime, timedelta

        try:
            cst = pytz.timezone('US/Central')
            now_cst = datetime.now(cst)

            reset_time_today = now_cst.replace(hour = 19, minute = 0, second = 0, microsecond = 0)

            if now_cst >=reset_time_today:
                last_reset = reset_time_today
            else:
                last_reset = reset_time_today -timedelta(days = 1)

            armory_key = f"armory_points_{store_name}"
            last_reset_key = f"armory_reset_{store_name}"

            stored_reset = persistentdata.get(last_reset_key)
            if stored_reset:
                try:
                    stored_reset_dt = datetime.fromisoformat(stored_reset)
                    if stored_reset_dt.tzinfo is None:
                        stored_reset_dt = cst.localize(stored_reset_dt)
                except Exception:
                    stored_reset_dt = None
            else:
                stored_reset_dt = None

            if stored_reset_dt is None or stored_reset_dt <last_reset:
                persistentdata[last_reset_key]= last_reset.isoformat()
                persistentdata[armory_key]= None
                self._save_persistent_data()
                return None

            return persistentdata.get(armory_key)

        except Exception as e:
            logging.warning(f"Failed to check armory points reset: {e}")
            return persistentdata.get(f"armory_points_{store_name}")

    def _set_armory_points_used(self, store_name, points_used):

        armory_key = f"armory_points_{store_name}"
        persistentdata[armory_key]= points_used
        self._save_persistent_data()

    def _start_business_music(self, playlists, first_play:bool = False):

        try:
            if not playlists:
                return None

            all_tracks =[]
            for playlist in playlists:
                music_folder = os.path.join("sounds", "music", playlist)
                if os.path.exists(music_folder):
                    tracks = glob.glob(os.path.join(music_folder, "track*.ogg"))

                    tracks =[t for t in tracks if os.path.getsize(t)>0]
                    all_tracks.extend(tracks)

            failed_tracks = getattr(self, "_failed_music_tracks", set())

            all_tracks =[t for t in all_tracks if t not in failed_tracks]

            if all_tracks:
                prev = getattr(self, "_last_business_music_track", None)

                if len(all_tracks)>1 and prev in all_tracks:
                    choices =[t for t in all_tracks if t !=prev]
                    track = random.choice(choices)if choices else random.choice(all_tracks)
                else:
                    track = random.choice(all_tracks)

                try:
                    pygame.mixer.music.load(track)
                except Exception as load_err:
                    logging.warning(f"Cannot load track {os.path.basename(track)}: {load_err}")
                    failed_tracks.add(track)
                    self._failed_music_tracks = failed_tracks

                    return self._start_business_music(playlists, first_play)

                try:
                    self._last_business_music_track = track
                except Exception:
                    pass

                try:
                    sound = pygame.mixer.Sound(track)
                    track_length = sound.get_length()
                except Exception:
                    track_length = 60.0

                random_start = 0.0
                if first_play:
                    try:
                        random_start = random.uniform(0, max(0, track_length -10))
                    except Exception:
                        random_start = 0.0

                pygame.mixer.music.set_volume(0.3)

                pygame.mixer.music.play(loops = 0, start = random_start)

                logging.info(f"Started business music: {os.path.basename(track)} at {random_start:.1f}s")
                music_info = {"track":track, "playlist":playlists, "start_pos":random_start, "started_at":time.time()}

                try:
                    self._current_business_music = music_info
                except Exception:
                    pass
                try:
                    logging.debug(f"_start_business_music set _current_business_music -> {os.path.basename(track)} start={random_start:.1f}")
                except Exception:
                    pass

                try:
                    existing = getattr(self, "_music_poll_job", None)
                    if existing:
                        try:
                            self.root.after_cancel(existing)
                        except Exception:
                            pass
                        self._music_poll_job = None
                except Exception:
                    pass

                def _poll_music():
                    try:
                        if not pygame.mixer.music.get_busy():

                            try:

                                logging.debug("business music finished, starting next track")
                                self._start_business_music(playlists, first_play = False)
                            except Exception:
                                pass
                        else:

                            self._music_poll_job = self.root.after(1000, _poll_music)
                    except Exception:
                        pass

                try:
                    self._music_poll_job = self.root.after(1000, _poll_music)
                except Exception:
                    self._music_poll_job = None

                return music_info
        except Exception as e:
            logging.warning(f"Failed to start business music: {e}")
        return None

    def _stop_business_music(self, music_info):

        try:

            try:
                job = getattr(self, "_music_poll_job", None)
                if job:
                    try:
                        self.root.after_cancel(job)
                    except Exception:
                        pass
                    self._music_poll_job = None
            except Exception:
                pass

            pygame.mixer.music.stop()
            try:
                pygame.mixer.music.unload()
            except Exception:
                pass
            try:

                if hasattr(self, "_current_business_music"):
                    self._current_business_music = None
            except Exception:
                pass
        except Exception:
            pass

    def _open_armory_interface(self, store, table_data):

        logging.info(f"Opening armory: {store.get('name')}")

        music_channel = None
        if store.get("music")and store.get("playlist"):
            music_channel = self._start_business_music(store.get("playlist"), first_play = True)

        self._clear_window()

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew")
        main_frame.grid_columnconfigure(0, weight = 1)
        main_frame.grid_rowconfigure(1, weight = 1)

        header_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        header_frame.grid(row = 0, column = 0, sticky = "ew", padx = 20, pady = 10)

        title_label = customtkinter.CTkLabel(header_frame, text = store.get("name", "Armory"), font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title_label.pack(pady =(10, 5))

        shopkeeper_label = customtkinter.CTkLabel(header_frame, text = f"Quartermaster: {store.get('shopkeeper', 'Unknown')}", font = customtkinter.CTkFont(size = 14), text_color = "gray")
        shopkeeper_label.pack()

        max_points = store.get("armory_points", "disabled")
        points_used = self._get_armory_points_status(store.get("name", "Unknown"))or 0

        if max_points !="disabled":
            overflow_key = f"armory_overflow_{store.get('name', 'Unknown')}"
            overflow_amt = persistentdata.get(overflow_key, 0)or 0
            remaining_points = max_points +overflow_amt -points_used
            points_label = customtkinter.CTkLabel(header_frame, text = f"Requisition Points: {remaining_points}/{max_points}(+{overflow_amt} overflow)(resets 7 PM CST)", font = customtkinter.CTkFont(size = 14), text_color = "orange")
            points_label.pack(pady = 5)
        else:
            remaining_points = float('inf')
            points_label = customtkinter.CTkLabel(header_frame, text = "Unlimited Requisitions", font = customtkinter.CTkFont(size = 14), text_color = "green")
            points_label.pack(pady = 5)

        try:
            search_frame = customtkinter.CTkFrame(header_frame, fg_color = "transparent")
            search_frame.pack(pady =(6, 2))
            search_entry = customtkinter.CTkEntry(search_frame, placeholder_text = "Search armory items...", width = 360)
            search_entry.pack(side = "left", padx =(0, 6))
            def _perform_armory_search(event = None):
                try:
                    q =(search_entry.get()or "").strip().lower()
                    if not q:

                        try:
                            if selected_category and selected_category[0]:
                                show_category_items(selected_category[0])
                                return
                        except Exception:
                            pass
                        return

                    matches =[]
                    try:
                        for cat, items in list(categories.items()):
                            for it in items:
                                try:
                                    name =(self._format_item_name(it)or "").lower()
                                except Exception:
                                    name =(it.get('name')or '').lower()
                                desc =(it.get('description')or '').lower()
                                if q in name or q in desc:
                                    matches.append(it)

                        categories["Search Results"]= matches
                        show_category_items("Search Results")
                        try:

                            search_entry.configure(text_color = "#7CFC00")
                            self.root.after(800, lambda:search_entry.configure(text_color = "#000000"))
                        except Exception:
                            pass
                    except Exception:
                        pass
                except Exception:
                    pass

            search_btn = self._create_sound_button(search_frame, "Search", _perform_armory_search, width = 80, height = 28, font = customtkinter.CTkFont(size = 11))
            search_btn.pack(side = "left")
            def _clear_search():
                try:
                    search_entry.delete(0, 'end')
                    try:
                        categories.pop("Search Results", None)
                    except Exception:
                        pass
                    try:
                        if selected_category and selected_category[0]:
                            show_category_items(selected_category[0])
                    except Exception:
                        pass
                except Exception:
                    pass
            clear_btn = self._create_sound_button(search_frame, "Clear", _clear_search, width = 60, height = 28, font = customtkinter.CTkFont(size = 11))
            clear_btn.pack(side = "left", padx =(6, 0))
            try:
                search_entry.bind("<Return>", _perform_armory_search)
            except Exception:
                pass
        except Exception:
            pass

        marquee_label = None
        marquee_job:list[object]=[None]

        def _get_track_info(track_path):
            artist = None
            title = None
            length = None
            try:
                logging.debug(f"_get_track_info called for: {os.path.basename(track_path or '')}")
            except Exception:
                pass
            try:

                try:
                    sound = pygame.mixer.Sound(track_path)
                    length = float(sound.get_length())
                except Exception:
                    length = None

                try:
                    from mutagen._file import File as MutagenFile
                    mf = MutagenFile(track_path)
                    if mf is not None:
                        tags = getattr(mf, 'tags', {})or {}

                        def _get_tag(keys):
                            for k in keys:
                                v = tags.get(k)
                                if v:
                                    try:
                                        if isinstance(v, (list, tuple)):
                                            return str(v[0])
                                        return str(v)
                                    except Exception:
                                        return str(v)
                            return None
                        artist = _get_tag(["artist", "ARTIST", "TPE1"])
                        title = _get_tag(["title", "TITLE", "TIT2"])
                except Exception:
                    pass

            except Exception:
                pass

            if not title:
                try:
                    title = os.path.basename(track_path or "")
                except Exception:
                    title = "Unknown"

            return {"artist":artist, "title":title, "length":length}

        def stop_ui_music():
            try:
                if marquee_job[0]:
                    try:
                        self.root.after_cancel(marquee_job[0])# type: ignore[arg-type]
                    except Exception:
                        pass
                    marquee_job[0]= None
            except Exception:
                pass
            try:
                self._stop_business_music(music_channel)
            except Exception:
                pass

        if music_channel and music_channel.get("track"):
            try:

                marquee_frame = customtkinter.CTkFrame(header_frame, fg_color = "black")

                marquee_frame.pack(pady =(6, 0))
                try:
                    marquee_frame.configure(width = 500)

                    try:
                        marquee_frame.pack_propagate(False)
                    except Exception:
                        pass
                except Exception:
                    pass
                try:

                    label_font = None
                    try:
                        import ctypes
                        import tkinter.font as tkfont
                        fp = os.path.join(os.path.dirname(__file__), "fonts", "Tims_8x5_LCD_Matrix.ttf")
                        if os.path.exists(fp)and hasattr(ctypes, 'windll'):
                            try:
                                FR_PRIVATE = 0x10
                                ctypes.windll.gdi32.AddFontResourceExW(fp, FR_PRIVATE, 0)
                            except Exception:
                                pass

                            try:
                                self.root.update_idletasks()
                                fams = list(tkfont.families())
                                for f in fams:
                                    if any(x in f.lower()for x in("tims", "8x5", "lcd")):
                                        label_font = customtkinter.CTkFont(size = 12, family = f)
                                        break
                            except Exception:
                                pass
                    except Exception:
                        pass
                    if not label_font:
                        label_font = customtkinter.CTkFont(size = 12)
                except Exception:
                    label_font = customtkinter.CTkFont(size = 12)
                marquee_label = customtkinter.CTkLabel(marquee_frame, text = "", anchor = "w", font = label_font, width = 480, height = 26, text_color = "#7CFC00")
                marquee_label.pack(anchor = "center", padx = 4)
                try:
                    marquee_debug_label = customtkinter.CTkLabel(marquee_frame, text = "", anchor = "w", font = customtkinter.CTkFont(size = 9, weight = "bold"), text_color = "#FFFF00")
                    marquee_debug_label.pack(anchor = "center", padx = 4, pady =(2, 0))
                except Exception:
                    marquee_debug_label = None
                try:
                    self.root.update_idletasks()
                    lh = marquee_label.winfo_reqheight()or marquee_label.winfo_height()
                    if lh:
                        try:
                            marquee_frame.configure(height = lh)
                        except Exception:
                            pass
                except Exception:
                    pass

                pos =[0]
                prev_track =[music_channel.get('track')if(music_channel and music_channel.get('track'))else None]

                def _fmt_time(s):
                    try:
                        s = max(0, int(s))
                        return f"{s //60}:{s %60:02d}"
                    except Exception:
                        return "0:00"

                def _update_marquee():
                    try:
                        current = getattr(self, "_current_business_music", music_channel)
                        if not current:
                            marquee_label.configure(text = "")
                            return

                        track_path = current.get("track")
                        meta_info = current.get("_meta")
                        if meta_info:
                            base_artist = meta_info.get("artist")or ""
                            base_title = meta_info.get("title")or os.path.basename(track_path or "")
                            total = meta_info.get("length")or 0.0
                        else:
                            base_artist = ""
                            base_title = os.path.basename(track_path or "")
                            total = 0.0

                            try:
                                if not current.get("_meta_loading"):
                                    current["_meta_loading"]= True
                                    def _bg_load():
                                        try:
                                            info = _get_track_info(track_path)
                                            def _apply():
                                                try:
                                                    try:
                                                        logging.debug(f"applying _meta(bg_load): {os.path.basename((current or {}).get('track')or '')} -> title={info.get('title')} artist={info.get('artist')}")
                                                    except Exception:
                                                        pass
                                                    try:
                                                        target = getattr(self, "_current_business_music", None)
                                                        if target is None:

                                                            target = current
                                                        if target is not None:
                                                                target.update({"_meta":info})
                                                                try:
                                                                    logging.debug(f"triggering marquee refresh after applying meta for {os.path.basename((target or {}).get('track')or '')}")
                                                                except Exception:
                                                                    pass
                                                                try:

                                                                    self.root.after(0, _update_marquee)
                                                                except Exception:
                                                                    pass
                                                    except Exception:
                                                        try:
                                                            logging.exception("failed to apply _meta in bg_load for store marquee")
                                                        except Exception:
                                                            pass
                                                except Exception:
                                                    try:
                                                        logging.exception("unexpected error in _apply for bg_load")
                                                    except Exception:
                                                        pass
                                            try:
                                                logging.debug(f"scheduling _apply via root.after for track {os.path.basename((getattr(self, '_current_business_music', current)or {}).get('track')or '')}")
                                            except Exception:
                                                pass
                                            self.root.after(0, _apply)
                                        except Exception:
                                            pass
                                        finally:
                                            try:
                                                current.pop("_meta_loading", None)
                                            except Exception:
                                                pass
                                    import threading
                                    try:
                                        logging.debug("starting background _bg_load thread for store marquee(in _update_marquee)")
                                    except Exception:
                                        pass
                                    threading.Thread(target = _bg_load, daemon = True).start()
                            except Exception:
                                pass

                        started = current.get("started_at")or time.time()
                        start_offset = current.get("start_pos")or 0.0
                        elapsed =(time.time()-started)+float(start_offset)

                        elapsed_display = _fmt_time(elapsed)
                        total_fmt = _fmt_time(total)

                        meta = f"{base_artist} | {base_title} | {elapsed_display}/{total_fmt}"if(base_artist or base_title)else os.path.basename(track_path or "")

                        try:
                            self.root.update_idletasks()
                            label_px = marquee_label.winfo_width()or int(marquee_label.cget("width")or 480)
                        except Exception:
                            label_px = int(marquee_label.cget("width")or 480)

                        avg_char_px = 8
                        visible_chars = max(8, int(label_px /max(1, avg_char_px)))

                        scrollfull = " "+meta +" "
                        if len(scrollfull)<visible_chars:
                            scrollfull = scrollfull +(" "*(visible_chars -len(scrollfull)+2))

                        doubled =(scrollfull *3)
                        display = doubled[pos[0]:pos[0]+visible_chars]
                        marquee_label.configure(text = display)
                        pos[0]=(pos[0]+1)%max(1, len(scrollfull))
                        try:

                            len_scroll = max(1, len(scrollfull))
                            delay_ms = int(min(500, max(60, 80 +(len_scroll *4))))
                        except Exception:
                            delay_ms = 220
                        marquee_job[0]= self.root.after(delay_ms, _update_marquee)
                    except Exception:
                        try:
                            marquee_label.configure(text = os.path.basename((getattr(self, "_current_business_music", music_channel)or {}).get("track")or ""))
                        except Exception:
                            pass

                try:
                    import threading
                    def _load_meta():
                        try:
                            cur = getattr(self, "_current_business_music", music_channel)
                            if not cur:
                                return
                            info = _get_track_info(cur.get("track"))
                            def _apply():
                                try:

                                    cur.update({"_meta":info})
                                except Exception:
                                    pass
                            self.root.after(0, _apply)
                        except Exception:
                            pass
                    try:
                        import threading
                        try:
                            logging.debug("starting initial background _load_meta thread for store marquee")
                        except Exception:
                            pass
                        threading.Thread(target = _load_meta, daemon = True).start()
                    except Exception:
                        pass
                except Exception:
                    pass

                _update_marquee()
            except Exception:
                pass

        save_path = os.path.join(saves_folder or "", (currentsave or "")+".sldsv")
        save_data = self._load_file((currentsave or "")+".sldsv")
        if save_data is None:
            self._popup_show_info("Error", "Failed to load character data.", sound = "error")
            try:
                self._stop_business_music(music_channel)
            except Exception:
                pass
            return

        equipped_weapons = self._get_equipped_weapons(save_data, table_data)
        equipped_calibers = set()
        equipped_magazine_systems = set()

        for wpn in equipped_weapons:
            item = wpn.get("item", {})
            calibers = item.get("caliber", [])
            if isinstance(calibers, str):
                calibers =[calibers]
            for cal in calibers:
                equipped_calibers.add(cal)

            mag_system = item.get("magazinesystem")
            if mag_system:
                equipped_magazine_systems.add(mag_system)

        equipped_attachment_slots = set()
        for wpn in equipped_weapons:
            for acc in(wpn.get('accessories')or[]):
                try:
                    slot = acc.get('slot')
                    if slot:
                        equipped_attachment_slots.add(slot)
                except Exception:
                    pass

        armory_items =[]
        tables = table_data.get("tables", {})
        for table_name, items in tables.items():
            if isinstance(items, list):
                for item in items:
                    if isinstance(item, dict)and item.get("in_armory"):
                        item_copy = item.copy()
                        item_copy["_table_category"]= table_name
                        armory_items.append(item_copy)

        categories = {}
        for item in armory_items:
            cat = item.get("armory_category", "Uncategorized")
            if cat not in categories:
                categories[cat]=[]
            categories[cat].append(item)

        content_frame = customtkinter.CTkFrame(main_frame)
        content_frame.grid(row = 1, column = 0, sticky = "nsew", padx = 20, pady = 10)

        content_frame.grid_columnconfigure(0, weight = 0)
        content_frame.grid_columnconfigure(1, weight = 0)
        content_frame.grid_columnconfigure(2, weight = 1)
        content_frame.grid_rowconfigure(0, weight = 1)

        category_frame = customtkinter.CTkScrollableFrame(content_frame, width = 200)
        category_frame.grid(row = 0, column = 0, sticky = "ns", padx =(0, 10))

        items_frame = customtkinter.CTkFrame(content_frame)
        items_frame.grid(row = 0, column = 2, sticky = "nsew")

        cart =[]
        cart_points =[0]
        lead_free_only =[False]

        subcat_scroll = None

        items_scroll = None
        lead_free_checkbox =[None]

        def update_cart_display():
            if max_points !="disabled":
                overflow_key = f"armory_overflow_{store.get('name', 'Unknown')}"
                overflow_amt = persistentdata.get(overflow_key, 0)or 0
                current_remaining = max_points +overflow_amt -points_used -cart_points[0]
                points_label.configure(text = f"Requisition Points: {current_remaining}/{max_points}(+{overflow_amt} overflow)(Cart: {cart_points[0]} pts)")
            else:
                points_label.configure(text = f"Unlimited Requisitions(Cart: {len(cart)} items)")

        def show_category_items(category_name):
            nonlocal subcat_scroll, items_scroll

            try:
                if subcat_scroll is not None:
                    try:
                        subcat_scroll.grid_forget()
                    except Exception:
                        pass
                    try:
                        subcat_scroll.destroy()
                    except Exception:
                        pass
                    subcat_scroll = None
            except Exception:
                pass
            try:
                if items_scroll is not None:
                    try:
                        items_scroll.pack_forget()
                    except Exception:
                        pass
                    try:
                        items_scroll.destroy()
                    except Exception:
                        pass
                    items_scroll = None
            except Exception:
                pass
            try:

                for widget in items_frame.winfo_children():
                    try:
                        widget.destroy()
                    except Exception:
                        try:
                            widget.grid_forget()
                        except Exception:
                            pass
            except Exception:
                pass

            try:
                selected_category[0]= category_name
                for name, btn in category_buttons.items():
                    try:
                        if name ==category_name:
                            btn.configure(border_color = "white", border_width = 2)
                        else:
                            btn.configure(border_width = 0)
                    except Exception:
                        pass
            except Exception:
                pass

            cat_items = categories.get(category_name, [])

            subcats = {}
            for it in cat_items:
                sub = it.get("armory_subcategory")or it.get("subtype")or "General"
                subcats.setdefault(sub, []).append(it)

            if len(subcats)<=1:
                if subcat_scroll is not None:
                    try:
                        subcat_scroll.grid_forget()
                    except Exception:
                        pass
                    try:
                        subcat_scroll.destroy()
                    except Exception:
                        pass
                    subcat_scroll = None

                try:

                    if items_scroll is not None:
                        try:
                            items_scroll.pack_forget()
                        except Exception:
                            pass
                        try:
                            items_scroll.destroy()
                        except Exception:
                            pass
                        items_scroll = None
                    items_frame.grid(row = 0, column = 1, sticky = "nsew")
                    content_frame.grid_columnconfigure(1, weight = 1)
                    content_frame.grid_columnconfigure(2, weight = 0)
                except Exception:
                    pass

            subcat_buttons_frame = None
            selected_subcat =[None]

            def render_item_list(items_list, parent = None):
                if parent is None:
                    parent = items_scroll if items_scroll is not None else items_frame
                for item in items_list:
                    is_ammo = item.get("_table_category")=="ammunition"
                    variants = item.get("variants", [])if is_ammo else[]

                    if is_ammo and lead_free_only[0]:
                        has_lead_free = any(v.get("lead_free", False)for v in variants)
                        if not has_lead_free:
                            continue

                    item_frame = customtkinter.CTkFrame(parent)
                    item_frame.pack(fill = "x", pady = 5, padx = 10)

                    is_highlighted = False
                    calibers = item.get("caliber", [])
                    if isinstance(calibers, str):
                        calibers =[calibers]

                    if item.get("_table_category")=="ammunition":
                        for cal in calibers:
                            if cal in equipped_calibers:
                                is_highlighted = True
                                break

                    if item.get("_table_category")=="magazines":
                        mag_system = item.get("magazinesystem")
                        if mag_system in equipped_magazine_systems:
                            for cal in calibers:
                                if cal in equipped_calibers:
                                    is_highlighted = True
                                    break

                    if not is_highlighted:
                        try:
                            is_attachment = bool(item.get('attachment')or item.get('accessory')or(item.get('_table_category')in('attachments', 'accessories')))
                            if is_attachment:
                                item_slots = item.get('slot')or item.get('attach_to')or item.get('accessory_slot')or item.get('parent_accessory_slot')or[]
                                if isinstance(item_slots, str):
                                    item_slots =[item_slots]
                                for s in item_slots:
                                    if s and s in equipped_attachment_slots:
                                        is_highlighted = True
                                        break
                        except Exception:
                            pass

                    if is_highlighted:
                        item_frame.configure(fg_color = "#2a4a2a")

                    name_text = self._format_item_name(item)
                    if is_highlighted:
                        name_text = "â­ "+name_text

                    name_label = customtkinter.CTkLabel(item_frame, text = name_text, font = customtkinter.CTkFont(size = 13, weight = "bold"), anchor = "w")
                    name_label.pack(anchor = "w", padx = 10, pady =(8, 2))

                    if item.get("description"):
                        desc_label = customtkinter.CTkLabel(item_frame, text = item.get("description"), font = customtkinter.CTkFont(size = 10), text_color = "gray", wraplength = 500, justify = "left", anchor = "w")
                        desc_label.pack(anchor = "w", padx = 10, pady =(0, 5))

                    info_parts =[]
                    if item.get("weight"):
                        info_parts.append(f"Weight: {self._format_weight(item.get('weight'))}")
                    if item.get("caliber"):
                        cal = item.get("caliber")
                        if isinstance(cal, list):
                            cal = ", ".join(cal)
                        info_parts.append(f"Caliber: {cal}")
                    if item.get("rarity"):
                        info_parts.append(f"Rarity: {item.get('rarity')}")

                    if info_parts:
                        info_label = customtkinter.CTkLabel(item_frame, text = " | ".join(info_parts), font = customtkinter.CTkFont(size = 10), text_color = "orange")
                        info_label.pack(anchor = "w", padx = 10, pady =(0, 5))

                    if is_ammo and variants:
                        variant_info_parts =[]
                        for v in variants:
                            pen = v.get("pen", "?")
                            lf = v.get("lead_free", False)
                            lf_indicator = " ðŸŒ¿"if lf else ""
                            if lead_free_only[0]and not lf:
                                continue
                            variant_info_parts.append(f"{v.get('name', 'Unknown')}(Pen: {pen}{lf_indicator})")
                        if variant_info_parts:
                            variants_text = "Variants: "+", ".join(variant_info_parts)
                            variants_label = customtkinter.CTkLabel(item_frame, text = variants_text, font = customtkinter.CTkFont(size = 9), text_color = "#88aaff", wraplength = 500, justify = "left", anchor = "w")
                            variants_label.pack(anchor = "w", padx = 10, pady =(0, 5))

                    def add_to_cart(it = item):
                        if max_points !="disabled":
                            current_remaining = max_points -points_used -cart_points[0]
                            if current_remaining <1:
                                self._popup_show_info("No Points", "You don't have enough requisition points.", sound = "error")
                                return

                        table_category = it.get("_table_category")or it.get("table_category")

                        if table_category =="magazines":
                            mag_copy = it.copy()
                            mag_copy.pop("_table_category", None)
                            mag_copy.setdefault("rounds", [])

                            try:
                                load_var = customtkinter.BooleanVar(value = True)
                                dlg = customtkinter.CTkToplevel(self.root)
                                dlg.title('Load Magazine?')
                                dlg.transient(self.root)
                                chk = customtkinter.CTkCheckBox(dlg, text = 'Load magazine with ammunition', variable = load_var)
                                chk.pack(padx = 12, pady = 8)
                            except Exception:
                                load_var = None

                            def _open_shop_magazine_editor():
                                try:
                                    ammo_table = tables.get('ammunition', [])
                                    mag_cal = mag_copy.get('caliber')
                                    if isinstance(mag_cal, str):
                                        mag_cal =[mag_cal]

                                    variant_options =[]
                                    variant_map = {}
                                    for ammo_def in ammo_table:
                                        ammo_cal = ammo_def.get('caliber')
                                        if isinstance(ammo_cal, str):
                                            ammo_cal =[ammo_cal]
                                        if mag_cal and ammo_cal and any(c in ammo_cal for c in mag_cal):
                                            for var in ammo_def.get('variants', []):
                                                label = f"{ammo_def.get('name')} | {var.get('name')}"
                                                variant_options.append(label)
                                                variant_map[label]=(ammo_def, var)

                                    if not variant_options:
                                        self._popup_show_info('No Compatible Ammo', 'No compatible ammunition variants found for this magazine.', sound = 'error')
                                        return

                                    editor = customtkinter.CTkToplevel(self.root)
                                    editor.title('Magazine Editor')
                                    editor.transient(self.root)
                                    cap = int(mag_copy.get('capacity', 30)or 30)

                                    scroll_h = max(300, min(1000, cap *24))
                                    slots_frame = customtkinter.CTkScrollableFrame(editor, width = 420, height = scroll_h, fg_color = 'transparent')
                                    slots_frame.pack(side = 'left', fill = 'both', expand = True, padx = 8, pady = 8)

                                    side = customtkinter.CTkFrame(editor, fg_color = 'transparent')
                                    side.pack(side = 'right', fill = 'y', padx = 8, pady = 8)

                                    slot_vars =[]
                                    for i in range(cap):
                                        lbl = customtkinter.CTkLabel(slots_frame, text = f'Slot {i +1}:')
                                        lbl.pack(anchor = 'w')
                                        sv = customtkinter.StringVar(value = variant_options[0])
                                        opt = customtkinter.CTkOptionMenu(slots_frame, values = variant_options, variable = sv, width = 260)
                                        opt.pack(anchor = 'w', pady = 2)
                                        slot_vars.append(sv)

                                    bulk_var = customtkinter.StringVar(value = variant_options[0])
                                    bulk_label = customtkinter.CTkLabel(side, text = 'Bulk set variant:', font = customtkinter.CTkFont(size = 12))
                                    bulk_label.pack(pady =(6, 2))
                                    bulk_menu = customtkinter.CTkOptionMenu(side, values = variant_options, variable = bulk_var, width = 180)
                                    bulk_menu.pack(pady = 4)

                                    def set_all():
                                        v = bulk_var.get()
                                        for sv in slot_vars:
                                            sv.set(v)

                                    set_all_btn = customtkinter.CTkButton(side, text = 'Set All', command = set_all, width = 180)
                                    set_all_btn.pack(pady = 6)

                                    def apply_editor():
                                        try:
                                            rounds =[]
                                            for sv in slot_vars:
                                                v = sv.get()
                                                if not v:
                                                    continue
                                                pair = variant_map.get(v)
                                                if not pair:
                                                    continue
                                                ammo_def, var = pair
                                                rd = {
                                                'name':ammo_def.get('name'),
                                                'caliber':(mag_cal[0]if mag_cal and isinstance(mag_cal, (list, tuple))else(mag_cal[0]if mag_cal else ammo_def.get('caliber'))),
                                                'variant':var.get('name'),
                                                'type':var.get('type'),
                                                'pen':var.get('pen'),
                                                'modifiers':var.get('modifiers'),
                                                'tip':var.get('tip')
                                                }
                                                rounds.append(rd)

                                            mag_copy['rounds']= rounds[:cap]
                                            editor.destroy()

                                            cart.append(mag_copy)
                                            cart_points[0]+=1
                                            update_cart_display()
                                            self._play_ui_sound('click')
                                            logging.info(f"Added magazine to cart: {mag_copy.get('name')}")
                                            dlg.destroy()
                                            return
                                        except Exception:
                                            logging.exception('Failed to apply shop magazine editor')

                                    apply_btn = customtkinter.CTkButton(side, text = 'Apply', command = apply_editor, width = 180)
                                    apply_btn.pack(pady = 10)

                                    cancel_btn = customtkinter.CTkButton(side, text = 'Cancel', command = lambda:editor.destroy(), width = 180, fg_color = '#444444')
                                    cancel_btn.pack()

                                    editor.grab_set()
                                    editor.lift()
                                except Exception:
                                    logging.exception('Failed to open shop magazine editor')

                            btn_frame = customtkinter.CTkFrame(dlg, fg_color = 'transparent')
                            btn_frame.pack(fill = 'x', padx = 8, pady = 8)

                            def _add_plain():
                                cart.append(mag_copy)
                                cart_points[0]+=1
                                update_cart_display()
                                self._play_ui_sound('click')
                                logging.info(f"Added magazine to cart: {mag_copy.get('name')}")
                                dlg.destroy()
                                return

                            open_editor_btn = customtkinter.CTkButton(btn_frame, text = 'Open Editor', command = _open_shop_magazine_editor, width = 140)
                            open_editor_btn.pack(side = 'left', padx = 6)
                            add_plain_btn = customtkinter.CTkButton(btn_frame, text = 'Add(Empty)', command = _add_plain, width = 140)
                            add_plain_btn.pack(side = 'left', padx = 6)
                            cancel_btn = customtkinter.CTkButton(btn_frame, text = 'Cancel', command = dlg.destroy, width = 120, fg_color = '#444444')
                            cancel_btn.pack(side = 'left', padx = 6)

                            dlg.grab_set()
                            dlg.lift()
                            self._safe_focus(dlg)
                            return

                        if table_category =="ammunition":
                            ammo_def = it
                            variants = ammo_def.get("variants", [])
                            sel_var = None
                            if variants:
                                if lead_free_only[0]:
                                    variants =[v for v in variants if v.get("lead_free", False)]
                                if not variants:
                                    self._popup_show_info("No Lead-Free Variants", "No lead-free variants available for this ammunition.", sound = "error")
                                    return
                                opts =[]
                                for v in variants:
                                    pen = v.get("pen", "?")
                                    lf = v.get("lead_free", False)
                                    lf_indicator = " ðŸŒ¿"if lf else ""
                                    opts.append(f"{v.get('name')}(Pen: {pen}{lf_indicator})")
                                sel_var = self._popup_select_option("Ammo Variant", "Choose ammo variant:", opts)
                                if sel_var is None:
                                    return
                                sel_name = sel_var.split("(Pen:")[0]
                                chosen = next((v for v in variants if v.get("name")==sel_name), None)
                            else:
                                chosen = None

                            qty = self._popup_ask_integer("Quantity", "How many rounds to requisition?", initial_value = 10, min_value = 1, max_value = 999)
                            if qty is None:
                                return

                            raw_cal = ammo_def.get("caliber")
                            if isinstance(raw_cal, (list, tuple))and raw_cal:
                                cal_val = raw_cal[0]
                            else:
                                cal_val = raw_cal

                            unit_weight = None
                            if ammo_def.get("weight")is not None:
                                try:
                                    unit_weight = float(ammo_def.get("weight"))
                                except Exception:
                                    unit_weight = None

                            stack_item = {
                            "name":ammo_def.get("name", "Ammunition"),
                            "caliber":cal_val,
                            "variant":chosen.get("name")if chosen else None,
                            "quantity":int(qty)
                            }
                            if unit_weight is not None:
                                stack_item["weight"]= unit_weight

                            for k in["type", "pen", "modifiers", "tip", "rarity"]:
                                if chosen and k in chosen:
                                    stack_item[k]= chosen.get(k)
                                elif k in ammo_def:
                                    stack_item[k]= ammo_def.get(k)

                            cart.append(stack_item)
                            cart_points[0]+=1
                            update_cart_display()
                            self._play_ui_sound("click")
                            logging.info(f"Added ammo to cart: {stack_item.get('name')} x{stack_item.get('quantity')}")
                            return

                        cart.append(it.copy())
                        cart_points[0]+=1
                        update_cart_display()
                        self._play_ui_sound("click")
                        logging.info(f"Added to cart: {it.get('name')}")

                    add_btn = self._create_sound_button(item_frame, "Requisition(+1 pt)", add_to_cart, width = 150, height = 30, font = customtkinter.CTkFont(size = 11))
                    add_btn.pack(anchor = "e", padx = 10, pady = 8)

            if len(subcats)>1:

                try:
                    items_frame.grid_rowconfigure(0, weight = 1)
                    items_frame.grid_columnconfigure(0, weight = 1)
                except Exception:
                    pass

                subcat_scroll = customtkinter.CTkScrollableFrame(content_frame, width = 180)
                subcat_scroll.grid(row = 0, column = 1, sticky = "ns", padx =(10, 6), pady =(0, 6))

                try:
                    items_frame.grid(row = 0, column = 2, sticky = "nsew")
                    content_frame.grid_columnconfigure(1, weight = 0)
                    content_frame.grid_columnconfigure(2, weight = 1)
                except Exception:
                    pass

                content_right = customtkinter.CTkFrame(items_frame)
                content_right.grid(row = 0, column = 0, sticky = "nsew")

                try:
                    items_scroll = customtkinter.CTkScrollableFrame(content_right)
                    items_scroll.pack(fill = "both", expand = True, padx = 0, pady = 0)
                except Exception:
                    items_scroll = None

                subcat_buttons = {}

                def make_subcat_btn(name):
                    def on_click():
                        nonlocal items_scroll

                        for w in content_right.winfo_children():
                            w.destroy()

                        try:
                            items_scroll = customtkinter.CTkScrollableFrame(content_right)
                            items_scroll.pack(fill = "both", expand = True, padx = 0, pady = 0)
                        except Exception:
                            items_scroll = None
                        sub_title = customtkinter.CTkLabel(content_right, text = name, font = customtkinter.CTkFont(size = 16, weight = "bold"))
                        sub_title.pack(pady =(6, 12), anchor = "w", padx = 10)
                        render_item_list(subcats.get(name, []), parent = items_scroll if items_scroll is not None else content_right)
                        selected_subcat[0]= name

                        for nm, b in subcat_buttons.items():
                            try:
                                if nm ==name:
                                    b.configure(border_color = "white", border_width = 2)
                                else:
                                    b.configure(border_width = 0)
                            except Exception:
                                pass
                    return on_click

                for sname in sorted(subcats.keys()):

                    has_highlighted = False
                    for it in subcats.get(sname, []):
                        calibers = it.get("caliber", [])
                        if isinstance(calibers, str):
                            calibers =[calibers]
                        if it.get("_table_category")=="ammunition":
                            for cal in calibers:
                                if cal in equipped_calibers:
                                    has_highlighted = True
                                    break
                        if has_highlighted:
                            break
                        if it.get("_table_category")=="magazines":
                            mag_system = it.get("magazinesystem")
                            if mag_system in equipped_magazine_systems:
                                for cal in calibers:
                                    if cal in equipped_calibers:
                                        has_highlighted = True
                                        break
                        if has_highlighted:
                            break
                    btn_text = sname if not has_highlighted else("â­ "+sname)
                    btn_kwargs = {"width":160, "height":30, "font":customtkinter.CTkFont(size = 10)}
                    if has_highlighted:
                        btn_kwargs["fg_color"]= "#2a8a2a"
                    btn = self._create_sound_button(subcat_scroll, btn_text, make_subcat_btn(sname), **btn_kwargs)
                    btn.pack(fill = "x", pady = 3, padx = 6)
                    subcat_buttons[sname]= btn

                first = sorted(subcats.keys())[0]
                sub_title = customtkinter.CTkLabel(content_right, text = first, font = customtkinter.CTkFont(size = 16, weight = "bold"))
                sub_title.pack(pady =(6, 12), anchor = "w", padx = 10)
                render_item_list(subcats.get(first, []), parent = items_scroll if items_scroll is not None else content_right)
                selected_subcat[0]= first

                for nm, b in subcat_buttons.items():
                    try:
                        if nm ==first:
                            b.configure(border_color = "white", border_width = 2)
                        else:
                            b.configure(border_width = 0)
                    except Exception:
                        pass

                try:
                    if subcat_scroll is not None and len(subcat_scroll.winfo_children())==0:
                        subcat_scroll.destroy()
                        subcat_scroll = None
                        items_frame.grid(row = 0, column = 1, sticky = "nsew")
                        content_frame.grid_columnconfigure(1, weight = 1)
                        content_frame.grid_columnconfigure(2, weight = 0)
                except Exception:
                    pass
            else:

                try:
                    items_scroll = customtkinter.CTkScrollableFrame(items_frame)
                    items_scroll.pack(fill = "both", expand = True, padx = 0, pady = 0)
                except Exception:
                    items_scroll = None

                is_ammo_category = "ammunition"in category_name.lower()or "ammo"in category_name.lower()

                if items_scroll is not None:
                    header_frame_cat = customtkinter.CTkFrame(items_scroll, fg_color = "transparent")
                    header_frame_cat.pack(fill = "x", pady =(10, 6), padx = 10)

                    cat_title = customtkinter.CTkLabel(header_frame_cat, text = category_name, font = customtkinter.CTkFont(size = 18, weight = "bold"))
                    cat_title.pack(side = "left")

                    if is_ammo_category:
                        def toggle_lead_free():
                            lead_free_only[0]= not lead_free_only[0]
                            show_category_items(category_name)

                        lf_check_var = customtkinter.BooleanVar(value = lead_free_only[0])
                        lf_checkbox = customtkinter.CTkCheckBox(
                        header_frame_cat,
                        text = "Lead-Free Only ðŸŒ¿",
                        variable = lf_check_var,
                        command = toggle_lead_free,
                        font = customtkinter.CTkFont(size = 11),
                        text_color = "#7CFC00"
                        )
                        lf_checkbox.pack(side = "right", padx = 10)
                        lead_free_checkbox[0]= lf_checkbox # type: ignore

                    render_item_list(cat_items, parent = items_scroll)
                else:
                    cat_title = customtkinter.CTkLabel(items_frame, text = category_name, font = customtkinter.CTkFont(size = 18, weight = "bold"))
                    cat_title.pack(pady =(10, 6), anchor = "w", padx = 10)
                    render_item_list(cat_items, parent = items_frame)

        sorted_categories = sorted(categories.keys())

        ammo_mags_first =[]
        others =[]
        for cat in sorted_categories:
            if cat.lower()in["ammunition", "magazines", "ammo"]:
                ammo_mags_first.append(cat)
            else:
                others.append(cat)
        sorted_categories = ammo_mags_first +others

        category_buttons = {}
        selected_category =[None]
        for cat_name in sorted_categories:
            has_highlighted = False
            for item in categories.get(cat_name, []):
                calibers = item.get("caliber", [])
                if isinstance(calibers, str):
                    calibers =[calibers]
                for cal in calibers:
                    if cal in equipped_calibers:
                        has_highlighted = True
                        break
                if has_highlighted:
                    break

            btn_text = cat_name
            if has_highlighted:
                btn_text = "â­ "+cat_name

            cat_kwargs = {"width":180, "height":35, "font":customtkinter.CTkFont(size = 11)}
            if has_highlighted:
                cat_kwargs["fg_color"]= "#2a8a2a"
            cat_btn = self._create_sound_button(category_frame, btn_text, lambda c = cat_name:show_category_items(c), **cat_kwargs)
            cat_btn.pack(pady = 3, padx = 5)
            category_buttons[cat_name]= cat_btn

        if sorted_categories:

            selected_category[0]= sorted_categories[0]

            for name, btn in category_buttons.items():
                try:
                    if name ==selected_category[0]:
                        btn.configure(border_color = "white", border_width = 2)
                    else:
                        btn.configure(border_width = 0)
                except Exception:
                    pass
            show_category_items(sorted_categories[0])

        button_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        button_frame.grid(row = 2, column = 0, sticky = "ew", padx = 20, pady = 10)

        def view_cart():
            if not cart:
                self._popup_show_info("Empty Cart", "Your requisition cart is empty.", sound = "popup")
                return

            cart_popup = customtkinter.CTkToplevel(self.root)
            cart_popup.title("Requisition Cart")
            cart_popup.geometry("600x500")
            cart_popup.transient(self.root)

            cart_scroll = customtkinter.CTkScrollableFrame(cart_popup)
            cart_scroll.pack(fill = "both", expand = True, padx = 10, pady = 10)

            for idx, item in enumerate(cart):
                item_frame = customtkinter.CTkFrame(cart_scroll)
                item_frame.pack(fill = "x", pady = 3)

                customtkinter.CTkLabel(item_frame, text = f"{self._format_item_name(item)}(1 pt)", font = customtkinter.CTkFont(size = 12)).pack(side = "left", padx = 10, pady = 5)

                def remove_item(i = idx):
                    cart.pop(i)
                    cart_points[0]-=1
                    update_cart_display()
                    cart_popup.destroy()
                    view_cart()

                remove_btn = customtkinter.CTkButton(item_frame, text = "Remove", command = remove_item, width = 80, height = 25)
                remove_btn.pack(side = "right", padx = 10, pady = 5)

            total_label = customtkinter.CTkLabel(cart_popup, text = f"Total: {cart_points[0]} points", font = customtkinter.CTkFont(size = 14, weight = "bold"))
            total_label.pack(pady = 10)

            def clear_cart():
                cart.clear()
                cart_points[0]= 0
                update_cart_display()
                cart_popup.destroy()

            clear_btn = customtkinter.CTkButton(cart_popup, text = "Clear Cart", command = clear_cart, width = 150)
            clear_btn.pack(pady = 5)

            close_btn = customtkinter.CTkButton(cart_popup, text = "Close", command = cart_popup.destroy, width = 150)
            close_btn.pack(pady = 5)

            try:
                cart_popup.update_idletasks()
                cart_popup.deiconify()
                cart_popup.lift()
                cart_popup.grab_set()
                self._safe_focus(cart_popup)
            except Exception:
                try:
                    cart_popup.grab_set()
                except Exception:
                    pass

        def checkout():
            if not cart:
                self._popup_show_info("Empty Cart", "Your requisition cart is empty.", sound = "popup")
                return

            if max_points !="disabled":
                current_remaining = max_points -points_used -cart_points[0]
                if current_remaining <0:
                    self._popup_show_info("Insufficient Points", "You don't have enough requisition points.", sound = "error")
                    return

            try:
                hands_items = save_data.get("hands", {}).get("items", [])

                for item in cart:
                    item_copy = item.copy()
                    item_copy.pop("_table_category", None)
                    item_copy = add_subslots_to_item(item_copy)

                    try:
                        item_copy["_from_armory"]= store.get("name", "Unknown")
                    except Exception:
                        pass
                    self._add_item_to_container(hands_items, item_copy)

                save_data["hands"]["items"]= hands_items
                self._write_save_to_path(save_path, save_data)

                if max_points !="disabled":
                    new_points_used = points_used +cart_points[0]
                    self._set_armory_points_used(store.get("name", "Unknown"), new_points_used)

                item_names =[it.get("name", "Unknown")for it in cart]
                logging.info(f"Requisitioned items: {item_names}")
                self._popup_show_info("Requisition Complete", f"Requisitioned {len(cart)} item(s):\n"+"\n".join(item_names[:10])+("..."if len(item_names)>10 else ""), sound = "success")

                cart.clear()
                cart_points[0]= 0
                stop_ui_music()
                self._open_business_tool()

            except Exception as e:
                logging.error(f"Failed to checkout: {e}")
                self._popup_show_info("Error", f"Failed to requisition items: {e}", sound = "error")

        def leave_armory():
            def _do_leave(confirmed:bool = True):
                if not confirmed:
                    return
                try:
                    stop_ui_music()
                except Exception:
                    try:
                        self._stop_business_music(music_channel)
                    except Exception:
                        pass
                self._open_business_tool()

            try:
                if cart and len(cart)>0:
                    msg = f"You have {len(cart)} item(s) in your cart.Leaving will discard them.Leave anyway?"
                    self._popup_confirm("Leave Armory", msg, _do_leave)
                    return
            except Exception:
                pass

            _do_leave()

        cart_btn = self._create_sound_button(button_frame, f"View Cart({len(cart)})", view_cart, width = 200, height = 40, font = customtkinter.CTkFont(size = 14))
        cart_btn.pack(side = "left", padx = 10)

        checkout_btn = self._create_sound_button(button_frame, "Confirm Requisition", checkout, width = 200, height = 40, font = customtkinter.CTkFont(size = 14))
        checkout_btn.pack(side = "left", padx = 10)

        def return_armory_items():
            nonlocal points_used
            store_name = store.get("name", "Unknown")
            all_items = get_all_player_items()
            matches =[d for d in all_items if d.get("item", {}).get("_from_armory")==store_name]
            if not matches:
                self._popup_show_info("No Items", "No items from this armory were found on the character.", sound = "popup")
                return

            names =[m.get("item", {}).get("name", "Unknown")for m in matches]
            def do_return():
                try:
                    locations_to_remove = {}
                    for m in matches:
                        loc = m.get("location")
                        idx = m.get("index")
                        locations_to_remove.setdefault(loc, []).append(idx)

                    for loc in locations_to_remove:
                        locations_to_remove[loc]= sorted(locations_to_remove[loc], reverse = True)

                    for loc, indices in locations_to_remove.items():
                        for idx in indices:
                            remove_item_from_location(loc, idx)

                    self._write_save_to_path(save_path, save_data)

                    refund_count = len(matches)
                    if max_points !="disabled":
                        cur_used = self._get_armory_points_status(store_name)or 0
                        new_used = max(cur_used -refund_count, 0)
                        extra = max(refund_count -cur_used, 0)
                        if extra >0:
                            overflow_key = f"armory_overflow_{store_name}"
                            persistentdata[overflow_key]=(persistentdata.get(overflow_key, 0)or 0)+extra
                        self._set_armory_points_used(store_name, new_used)
                        points_used = new_used

                    self._popup_show_info("Return Complete", f"Returned {len(matches)} item(s) to {store_name}.Refunded {refund_count} point(s).", sound = "success")
                    stop_ui_music()
                    self._open_business_tool()
                except Exception as e:
                    logging.error(f"Failed to return armory items: {e}")
                    self._popup_show_info("Error", f"Failed to return items: {e}", sound = "error")

            self._popup_confirm("Return Items", f"Return {len(matches)} item(s) from this armory?\n\n"+"\n".join(names[:10])+("..."if len(names)>10 else ""), do_return)

        return_btn = self._create_sound_button(button_frame, "Return Armory Items", return_armory_items, width = 200, height = 40, font = customtkinter.CTkFont(size = 14))
        return_btn.pack(side = "left", padx = 10)

        back_btn = self._create_sound_button(button_frame, "Leave Armory", leave_armory, width = 200, height = 40, font = customtkinter.CTkFont(size = 14))
        back_btn.pack(side = "right", padx = 10)

    def _open_store_interface(self, store, table_data):

        logging.info(f"Opening store: {store.get('name')}")

        music_channel = None
        if store.get("music")and store.get("playlist"):
            music_channel = self._start_business_music(store.get("playlist"), first_play = True)

        self._clear_window()

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew")
        main_frame.grid_columnconfigure(0, weight = 1)
        main_frame.grid_rowconfigure(1, weight = 1)

        header_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        header_frame.grid(row = 0, column = 0, sticky = "ew", padx = 20, pady = 10)

        title_label = customtkinter.CTkLabel(header_frame, text = store.get("name", "Store"), font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title_label.pack(pady =(10, 5))

        shopkeeper_label = customtkinter.CTkLabel(header_frame, text = f"Shopkeeper: {store.get('shopkeeper', 'Unknown')}", font = customtkinter.CTkFont(size = 14), text_color = "gray")
        shopkeeper_label.pack()

        save_path = os.path.join(saves_folder or "", (currentsave or "")+".sldsv")
        save_data = self._load_file((currentsave or "")+".sldsv")
        if save_data is None:
            self._popup_show_info("Error", "Failed to load character data.", sound = "error")
            try:
                self._stop_business_music(music_channel)
            except Exception:
                pass
            return

        player_money =[save_data.get("money", 0)]

        money_label = customtkinter.CTkLabel(header_frame, text = f"Your Money: ${player_money[0]}", font = customtkinter.CTkFont(size = 16, weight = "bold"), text_color = "green")
        money_label.pack(pady = 5)

        prices = store.get("prices", {"buy":1.0, "sell":1.0})
        buy_mult = prices.get("buy", 1.0)
        sell_mult = prices.get("sell", 1.0)

        prices_label = customtkinter.CTkLabel(header_frame, text = f"Shop buys at {buy_mult}x | Shop sells at {sell_mult}x value", font = customtkinter.CTkFont(size = 12), text_color = "orange")
        prices_label.pack()

        marquee_label = None
        marquee_job:list[object]=[None]

        def _get_track_info(track_path):
            artist = None
            title = None
            length = None
            try:
                try:
                    sound = pygame.mixer.Sound(track_path)
                    length = float(sound.get_length())
                except Exception:
                    length = None
                try:
                    from mutagen._file import File as MutagenFile
                    mf = MutagenFile(track_path)
                    if mf is not None:
                        tags = getattr(mf, 'tags', {})or {}
                        def _get_tag(keys):
                            for k in keys:
                                v = tags.get(k)
                                if v:
                                    try:
                                        if isinstance(v, (list, tuple)):
                                            return str(v[0])
                                        return str(v)
                                    except Exception:
                                        return str(v)
                            return None
                        artist = _get_tag(["artist", "ARTIST", "TPE1"])
                        title = _get_tag(["title", "TITLE", "TIT2"])
                except Exception:
                    pass
            except Exception:
                pass
            if not title:
                try:
                    title = os.path.basename(track_path or "")
                except Exception:
                    title = "Unknown"
            try:
                logging.debug(f"_get_track_info result: title={title} artist={artist} length={length}")
            except Exception:
                pass
            return {"artist":artist, "title":title, "length":length}

        def stop_ui_music():
            try:
                if marquee_job[0]:
                    try:
                        self.root.after_cancel(marquee_job[0])# type: ignore[arg-type]
                    except Exception:
                        pass
                    marquee_job[0]= None
            except Exception:
                pass
            try:
                self._stop_business_music(music_channel)
            except Exception:
                pass

        if music_channel and music_channel.get("track"):
            try:
                track_path = music_channel.get("track")
                info = _get_track_info(track_path)
                base_artist = info.get("artist")or ""
                base_title = info.get("title")or os.path.basename(track_path or "")
                track_len = info.get("length")or 0.0

                marquee_frame = customtkinter.CTkFrame(header_frame, fg_color = "black")

                marquee_frame.pack(pady =(6, 0))
                try:
                    marquee_frame.configure(width = 500)

                    try:
                        marquee_frame.pack_propagate(False)
                    except Exception:
                        pass
                except Exception:
                    pass
                try:

                    label_font = None
                    try:
                        import ctypes
                        import tkinter.font as tkfont
                        fp = os.path.join(os.path.dirname(__file__), "fonts", "Tims_8x5_LCD_Matrix.ttf")
                        if os.path.exists(fp)and hasattr(ctypes, 'windll'):
                            try:
                                FR_PRIVATE = 0x10
                                ctypes.windll.gdi32.AddFontResourceExW(fp, FR_PRIVATE, 0)
                            except Exception:
                                pass

                            try:
                                self.root.update_idletasks()
                                fams = list(tkfont.families())
                                for f in fams:
                                    if any(x in f.lower()for x in("tims", "8x5", "lcd")):
                                        label_font = customtkinter.CTkFont(size = 12, family = f)
                                        break
                            except Exception:
                                pass
                    except Exception:
                        pass
                    if not label_font:
                        label_font = customtkinter.CTkFont(size = 12)
                except Exception:
                    label_font = customtkinter.CTkFont(size = 12)
                marquee_label = customtkinter.CTkLabel(marquee_frame, text = "", anchor = "w", font = label_font, width = 480, height = 26, text_color = "#7CFC00")
                marquee_label.pack(anchor = "center", padx = 4)
                try:
                    marquee_debug_label = customtkinter.CTkLabel(marquee_frame, text = "", anchor = "w", font = customtkinter.CTkFont(size = 9), text_color = "white")
                    marquee_debug_label.pack(anchor = "center", padx = 4, pady =(2, 0))
                except Exception:
                    marquee_debug_label = None
                try:
                    self.root.update_idletasks()
                    lh = marquee_label.winfo_reqheight()or marquee_label.winfo_height()
                    if lh:
                        try:
                            marquee_frame.configure(height = lh)
                        except Exception:
                            pass
                except Exception:
                    pass

                pos =[0]

                def _fmt_time(s):
                    try:
                        s = max(0, int(s))
                        return f"{s //60}:{s %60:02d}"
                    except Exception:
                        return "0:00"

                def _update_marquee():
                    try:

                        current = getattr(self, "_current_business_music", music_channel)
                        meta_info = None
                        if current:
                            meta_info = current.get("_meta")

                        try:
                            track_path =(current or {}).get('track')
                            if track_path !=prev_track[0]:
                                prev_track[0]= track_path
                                pos[0]= 0
                        except Exception:
                            track_path =(current or {}).get('track')
                        try:
                            logging.debug(f"store marquee update: track={os.path.basename((current or {}).get('track')or '')} meta={bool(meta_info)} pos={pos[0]} ids: current={id(current)} music_channel={id(music_channel)} self_cur={id(getattr(self, '_current_business_music', None))}")
                        except Exception:
                            pass
                        try:
                            if marquee_debug_label is not None:
                                dbg = f"meta={bool(meta_info)} id={id(current)}"
                                try:

                                    tt =(meta_info or {}).get('title')if meta_info else((current or {}).get('track')or '')
                                    if tt:
                                        dbg +=f" title={tt[:30]}"
                                except Exception:
                                    pass
                                marquee_debug_label.configure(text = dbg)
                        except Exception:
                            pass

                        if meta_info:
                            base_artist = meta_info.get("artist")or ""
                            base_title = meta_info.get("title")or os.path.basename(track_path or "")
                            total = meta_info.get("length")or 0.0
                        else:

                            base_artist = ""
                            base_title = os.path.basename(track_path or "")
                            total = 0.0
                            try:
                                if current and not current.get("_meta_loading"):
                                    current["_meta_loading"]= True
                                    def _bg_load():
                                        try:
                                            info = _get_track_info((current or {}).get("track"))
                                            def _apply():
                                                try:
                                                    try:
                                                        logging.debug(f"applying _meta(bg_load current): {os.path.basename((current or {}).get('track')or '')} -> title={info.get('title')} artist={info.get('artist')}")
                                                    except Exception:
                                                        pass
                                                    try:
                                                        target = getattr(self, "_current_business_music", None)
                                                        if target is None:
                                                            target = current
                                                        if target is not None:
                                                                target.update({"_meta":info})
                                                                try:
                                                                    logging.debug(f"triggering marquee refresh after applying meta for {os.path.basename((target or {}).get('track')or '')}(current)")
                                                                except Exception:
                                                                    pass
                                                                try:
                                                                    self.root.after(0, _update_marquee)
                                                                except Exception:
                                                                    pass
                                                    except Exception:
                                                        try:
                                                            logging.exception("failed to apply _meta in bg_load(current) for store marquee")
                                                        except Exception:
                                                            pass
                                                except Exception:
                                                    try:
                                                        logging.exception("unexpected error in _apply for bg_load(current)")
                                                    except Exception:
                                                        pass
                                            try:
                                                logging.debug(f"scheduling _apply(current) via root.after for track {os.path.basename((getattr(self, '_current_business_music', current)or {}).get('track')or '')}")
                                            except Exception:
                                                pass
                                            self.root.after(0, _apply)
                                        except Exception:
                                            pass
                                        finally:
                                            try:
                                                current.pop("_meta_loading", None)
                                            except Exception:
                                                pass
                                    import threading
                                    threading.Thread(target = _bg_load, daemon = True).start()
                            except Exception:
                                pass

                        started =(current or {}).get("started_at")or time.time()
                        start_offset =(current or {}).get("start_pos")or 0.0
                        elapsed =(time.time()-started)+float(start_offset)

                        elapsed_display = _fmt_time(elapsed)
                        total_fmt = _fmt_time(total)

                        meta = f"{base_artist} | {base_title} | {elapsed_display}/{total_fmt}"if(base_artist or base_title)else os.path.basename((music_channel or {}).get("track")or "")

                        try:
                            self.root.update_idletasks()
                            label_px = marquee_label.winfo_width()or int(marquee_label.cget("width")or 480)
                        except Exception:
                            label_px = int(marquee_label.cget("width")or 480)

                        avg_char_px = 8
                        visible_chars = max(8, int(label_px /max(1, avg_char_px)))

                        scrollfull = " "+meta +" "
                        if len(scrollfull)<visible_chars:
                            scrollfull = scrollfull +(" "*(visible_chars -len(scrollfull)+2))

                        doubled =(scrollfull *3)
                        display = doubled[pos[0]:pos[0]+visible_chars]
                        marquee_label.configure(text = display)
                        pos[0]=(pos[0]+1)%max(1, len(scrollfull))
                        try:
                            len_scroll = max(1, len(scrollfull))
                            delay_ms = int(min(500, max(60, 70 +(len_scroll *3))))
                        except Exception:
                            delay_ms = 120
                        marquee_job[0]= self.root.after(delay_ms, _update_marquee)
                    except Exception:
                        try:
                            marquee_label.configure(text = os.path.basename((getattr(self, "_current_business_music", music_channel)or {}).get("track")or ""))
                        except Exception:
                            pass

                try:
                    import threading
                    try:
                        logging.debug("starting initial background _load_meta thread for store marquee")
                    except Exception:
                        pass
                    def _load_meta():
                        try:
                            cur = getattr(self, "_current_business_music", music_channel)
                            if not cur:
                                return
                            info = _get_track_info(cur.get("track"))
                            try:
                                logging.debug(f"_load_meta fetched info: title={info.get('title')} artist={info.get('artist')}")
                            except Exception:
                                pass
                            def _apply():
                                try:
                                    try:
                                        logging.debug(f"applying initial _meta(from _load_meta): {os.path.basename((cur or {}).get('track')or '')} -> title={info.get('title')} artist={info.get('artist')}")
                                    except Exception:
                                        pass
                                    try:

                                        target = getattr(self, "_current_business_music", None)
                                        if target is None:
                                            target = cur
                                        if target is not None:
                                            target.update({"_meta":info})
                                            try:
                                                logging.debug(f"triggering marquee refresh after initial apply for {os.path.basename((target or {}).get('track')or '')}")
                                            except Exception:
                                                pass
                                            try:
                                                self.root.after(0, _update_marquee)
                                            except Exception:
                                                pass
                                    except Exception:
                                        try:
                                            logging.exception("failed to apply initial _meta in _load_meta for store marquee")
                                        except Exception:
                                            pass
                                except Exception:
                                    try:
                                        logging.exception("unexpected error in initial _apply for store marquee")
                                    except Exception:
                                        pass
                            try:
                                logging.debug(f"scheduling initial _apply via root.after for store marquee: {os.path.basename((cur or {}).get('track')or '')}")
                            except Exception:
                                pass
                            try:
                                self.root.after(0, _apply)
                            except Exception:
                                pass
                        except Exception:
                            pass
                    threading.Thread(target = _load_meta, daemon = True).start()
                except Exception:
                    pass

                _update_marquee()
            except Exception:
                pass

        def get_all_player_items():

            all_items =[]

            hands_items = save_data.get("hands", {}).get("items", [])
            for idx, item in enumerate(hands_items):
                if isinstance(item, dict):
                    all_items.append({"item":item, "location":"hands", "index":idx})

            equipment = save_data.get("equipment", {})
            for slot_name, slot_item in equipment.items():
                if slot_item and isinstance(slot_item, dict):
                    if "items"in slot_item and "capacity"in slot_item:
                        for idx, item in enumerate(slot_item.get("items", [])):
                            if isinstance(item, dict):
                                all_items.append({"item":item, "location":f"equipment.{slot_name}", "index":idx})

                    if "subslots"in slot_item:
                        for subslot_idx, subslot_data in enumerate(slot_item.get("subslots", [])):
                            subslot_item = subslot_data.get("current")
                            if subslot_item and isinstance(subslot_item, dict)and "items"in subslot_item:
                                for idx, item in enumerate(subslot_item.get("items", [])):
                                    if isinstance(item, dict):
                                        all_items.append({"item":item, "location":f"equipment.{slot_name}.subslot.{subslot_idx}", "index":idx})

                elif isinstance(slot_item, list):
                    for list_idx, list_item in enumerate(slot_item):
                        if list_item and isinstance(list_item, dict):
                            if "items"in list_item and "capacity"in list_item:
                                for idx, item in enumerate(list_item.get("items", [])):
                                    if isinstance(item, dict):
                                        all_items.append({"item":item, "location":f"equipment.{slot_name}.list.{list_idx}", "index":idx})

                            if "subslots"in list_item:
                                for subslot_idx, subslot_data in enumerate(list_item.get("subslots", [])):
                                    subslot_item = subslot_data.get("current")
                                    if subslot_item and isinstance(subslot_item, dict)and "items"in subslot_item:
                                        for idx, item in enumerate(subslot_item.get("items", [])):
                                            if isinstance(item, dict):
                                                all_items.append({"item":item, "location":f"equipment.{slot_name}.list.{list_idx}.subslot.{subslot_idx}", "index":idx})

            return all_items

        def remove_item_from_location(location, index):

            if location =="hands":
                items = save_data.get("hands", {}).get("items", [])
                if 0 <=index <len(items):
                    items.pop(index)
            elif location.startswith("equipment."):
                parts = location.split(".")
                slot = parts[1]
                slot_item = save_data.get("equipment", {}).get(slot)

                if len(parts)==2:
                    if slot_item and isinstance(slot_item, dict)and "items"in slot_item:
                        items = slot_item.get("items", [])
                        if 0 <=index <len(items):
                            items.pop(index)
                elif len(parts)>=4 and parts[2]=="subslot":
                    subslot_idx = int(parts[3])
                    if slot_item and isinstance(slot_item, dict)and "subslots"in slot_item:
                        subslot_item = slot_item["subslots"][subslot_idx].get("current")
                        if subslot_item and "items"in subslot_item:
                            items = subslot_item.get("items", [])
                            if 0 <=index <len(items):
                                items.pop(index)
                elif len(parts)>=4 and parts[2]=="list":
                    list_idx = int(parts[3])
                    if isinstance(slot_item, list)and 0 <=list_idx <len(slot_item):
                        list_item = slot_item[list_idx]
                        if len(parts)==4:
                            if list_item and isinstance(list_item, dict)and "items"in list_item:
                                items = list_item.get("items", [])
                                if 0 <=index <len(items):
                                    items.pop(index)
                        elif len(parts)>=6 and parts[4]=="subslot":
                            subslot_idx = int(parts[5])
                            if list_item and isinstance(list_item, dict)and "subslots"in list_item:
                                subslot_item = list_item["subslots"][subslot_idx].get("current")
                                if subslot_item and "items"in subslot_item:
                                    items = subslot_item.get("items", [])
                                    if 0 <=index <len(items):
                                        items.pop(index)

        store_inventory =[]
        store_inv_config = store.get("inventory", [])
        tables = table_data.get("tables", {})

        for inv_entry in store_inv_config:
            if inv_entry.get("type")=="table":
                table_name = inv_entry.get("table")
                table_items = tables.get(table_name, [])
                for item in table_items:
                    if isinstance(item, dict):
                        item_copy = item.copy()
                        item_copy["_table_category"]= table_name
                        store_inventory.append(item_copy)
            elif inv_entry.get("type")=="id":
                item_id = inv_entry.get("id")
                for table_name, table_items in tables.items():
                    if isinstance(table_items, list):
                        for item in table_items:
                            if isinstance(item, dict)and item.get("id")==item_id:
                                item_copy = item.copy()
                                item_copy["_table_category"]= table_name
                                store_inventory.append(item_copy)
                                break

        inv_qty = store.get("inventory_quantity", "disabled")
        if inv_qty !="disabled"and isinstance(inv_qty, dict):
            min_qty = inv_qty.get("min", 20)
            max_qty = inv_qty.get("max", 40)
            target_qty = random.randint(min_qty, max_qty)
            if len(store_inventory)>target_qty:
                store_inventory = random.sample(store_inventory, target_qty)

        tab_view = customtkinter.CTkTabview(main_frame)
        tab_view.grid(row = 1, column = 0, sticky = "nsew", padx = 20, pady = 10)

        buy_tab = tab_view.add("Buy")
        sell_tab = tab_view.add("Sell")
        if store.get("accepts_trades"):
            trade_tab = tab_view.add("Trade")

        buy_scroll = customtkinter.CTkScrollableFrame(buy_tab)
        buy_scroll.pack(fill = "both", expand = True)

        buy_cart =[]
        buy_total =[0]

        def update_buy_display():
            money_label.configure(text = f"Your Money: ${player_money[0]} | Cart Total: ${buy_total[0]}")

        for item in store_inventory:
            item_frame = customtkinter.CTkFrame(buy_scroll)
            item_frame.pack(fill = "x", pady = 5, padx = 10)

            base_value = item.get("value", 0)
            buy_price = int(base_value *sell_mult)

            name_label = customtkinter.CTkLabel(item_frame, text = f"{self._format_item_name(item)} - ${buy_price}", font = customtkinter.CTkFont(size = 13, weight = "bold"), anchor = "w")
            name_label.pack(anchor = "w", padx = 10, pady =(8, 2))

            if item.get("description"):
                desc_label = customtkinter.CTkLabel(item_frame, text = item.get("description")[:100]+"..."if len(item.get("description", ""))>100 else item.get("description", ""), font = customtkinter.CTkFont(size = 10), text_color = "gray", wraplength = 400, justify = "left", anchor = "w")
                desc_label.pack(anchor = "w", padx = 10, pady =(0, 5))

            def add_to_buy_cart(it = item, price = buy_price):
                if player_money[0]-buy_total[0]<price:
                    self._popup_show_info("Not Enough Money", f"You need ${price} but only have ${player_money[0]-buy_total[0]} remaining.", sound = "error")
                    return
                buy_cart.append({"item":it.copy(), "price":price})
                buy_total[0]+=price
                update_buy_display()
                self._play_ui_sound("click")

            add_btn = self._create_sound_button(item_frame, f"Buy(${buy_price})", add_to_buy_cart, width = 120, height = 30, font = customtkinter.CTkFont(size = 11))
            add_btn.pack(anchor = "e", padx = 10, pady = 8)

        sell_scroll = customtkinter.CTkScrollableFrame(sell_tab)
        sell_scroll.pack(fill = "both", expand = True)

        sell_cart =[]
        sell_total =[0]

        def update_sell_display():
            money_label.configure(text = f"Your Money: ${player_money[0]} | Sell Value: ${sell_total[0]}")

        all_player_items = get_all_player_items()

        for item_data in all_player_items:
            item = item_data["item"]
            location = item_data["location"]
            item_idx = item_data["index"]

            if item.get("_from_armory"):
                continue

            item_frame = customtkinter.CTkFrame(sell_scroll)
            item_frame.pack(fill = "x", pady = 5, padx = 10)

            base_value = item.get("value", 0)
            sell_price = int(base_value *buy_mult)

            location_text = location.replace("equipment.", "").replace(".list.", " #").replace(".subslot.", " sub#")
            name_label = customtkinter.CTkLabel(item_frame, text = f"{self._format_item_name(item)} - ${sell_price}", font = customtkinter.CTkFont(size = 13, weight = "bold"), anchor = "w")
            name_label.pack(anchor = "w", padx = 10, pady =(8, 2))

            loc_label = customtkinter.CTkLabel(item_frame, text = f"Location: {location_text}", font = customtkinter.CTkFont(size = 10), text_color = "gray", anchor = "w")
            loc_label.pack(anchor = "w", padx = 10, pady =(0, 5))

            def add_to_sell_cart(loc = location, i = item_idx, it = item, price = sell_price):
                cart_key = f"{loc}:{i}"
                if cart_key in[f"{s['location']}:{s['index']}"for s in sell_cart]:
                    self._popup_show_info("Already Added", "This item is already in your sell cart.", sound = "popup")
                    return
                sell_cart.append({"location":loc, "index":i, "item":it, "price":price})
                sell_total[0]+=price
                update_sell_display()
                self._play_ui_sound("click")

            add_btn = self._create_sound_button(item_frame, f"Sell(${sell_price})", add_to_sell_cart, width = 120, height = 30, font = customtkinter.CTkFont(size = 11))
            add_btn.pack(anchor = "e", padx = 10, pady = 8)

        if store.get("accepts_trades"):
            trade_main_frame = customtkinter.CTkFrame(trade_tab)
            trade_main_frame.pack(fill = "both", expand = True)

            trade_main_frame.grid_columnconfigure(0, weight = 1)
            trade_main_frame.grid_columnconfigure(1, weight = 1)
            trade_main_frame.grid_rowconfigure(1, weight = 1)

            your_label = customtkinter.CTkLabel(trade_main_frame, text = "Your Items", font = customtkinter.CTkFont(size = 14, weight = "bold"))
            your_label.grid(row = 0, column = 0, pady =(10, 5))

            store_label = customtkinter.CTkLabel(trade_main_frame, text = "Store Items", font = customtkinter.CTkFont(size = 14, weight = "bold"))
            store_label.grid(row = 0, column = 1, pady =(10, 5))

            your_scroll = customtkinter.CTkScrollableFrame(trade_main_frame)
            your_scroll.grid(row = 1, column = 0, sticky = "nsew", padx = 5, pady = 5)

            store_scroll = customtkinter.CTkScrollableFrame(trade_main_frame)
            store_scroll.grid(row = 1, column = 1, sticky = "nsew", padx = 5, pady = 5)

            trade_offer = {"your_items":[], "store_items":[]}
            trade_values = {"your_total":0, "store_total":0}

            trade_status_label = customtkinter.CTkLabel(trade_main_frame, text = "Your offer: $0 | Store offer: $0", font = customtkinter.CTkFont(size = 12))
            trade_status_label.grid(row = 2, column = 0, columnspan = 2, pady = 10)

            def update_trade_display():
                trade_status_label.configure(text = f"Your offer: ${trade_values['your_total']} | Store offer: ${trade_values['store_total']}")

            for item_data in all_player_items:
                item = item_data["item"]
                location = item_data["location"]
                item_idx = item_data["index"]

                if item.get("_from_armory"):
                    continue

                item_frame = customtkinter.CTkFrame(your_scroll)
                item_frame.pack(fill = "x", pady = 3, padx = 5)

                trade_value = int(item.get("value", 0)*buy_mult)
                location_text = location.replace("equipment.", "").replace(".list.", " #").replace(".subslot.", " sub#")

                name_label = customtkinter.CTkLabel(item_frame, text = f"{self._format_item_name(item)}(${trade_value})", font = customtkinter.CTkFont(size = 11), anchor = "w")
                name_label.pack(anchor = "w", padx = 8, pady =(5, 0))

                loc_label = customtkinter.CTkLabel(item_frame, text = f"{location_text}", font = customtkinter.CTkFont(size = 9), text_color = "gray", anchor = "w")
                loc_label.pack(anchor = "w", padx = 8, pady =(0, 3))

                def toggle_your_item(loc = location, i = item_idx, it = item, val = trade_value, frame = item_frame):
                    cart_key = f"{loc}:{i}"
                    existing =[idx for idx, e in enumerate(trade_offer["your_items"])if f"{e['location']}:{e['index']}"==cart_key]
                    if existing:
                        trade_offer["your_items"].pop(existing[0])
                        trade_values["your_total"]-=val
                        frame.configure(fg_color =("gray86", "gray17"))
                    else:
                        trade_offer["your_items"].append({"location":loc, "index":i, "item":it, "value":val})
                        trade_values["your_total"]+=val
                        frame.configure(fg_color =("green", "darkgreen"))
                    update_trade_display()
                    self._play_ui_sound("click")

                item_frame.bind("<Button-1>", lambda e, f = toggle_your_item:f())
                name_label.bind("<Button-1>", lambda e, f = toggle_your_item:f())
                loc_label.bind("<Button-1>", lambda e, f = toggle_your_item:f())

            for item in store_inventory:
                item_frame = customtkinter.CTkFrame(store_scroll)
                item_frame.pack(fill = "x", pady = 3, padx = 5)

                trade_value = int(item.get("value", 0)*sell_mult)

                name_label = customtkinter.CTkLabel(item_frame, text = f"{self._format_item_name(item)}(${trade_value})", font = customtkinter.CTkFont(size = 11), anchor = "w")
                name_label.pack(anchor = "w", padx = 8, pady = 5)

                def toggle_store_item(it = item, val = trade_value, frame = item_frame):
                    item_id = it.get("id", id(it))
                    existing =[idx for idx, e in enumerate(trade_offer["store_items"])if e["item"].get("id", id(e["item"]))==item_id]
                    if existing:
                        trade_offer["store_items"].pop(existing[0])
                        trade_values["store_total"]-=val
                        frame.configure(fg_color =("gray86", "gray17"))
                    else:
                        trade_offer["store_items"].append({"item":it.copy(), "value":val})
                        trade_values["store_total"]+=val
                        frame.configure(fg_color =("green", "darkgreen"))
                    update_trade_display()
                    self._play_ui_sound("click")

                item_frame.bind("<Button-1>", lambda e, f = toggle_store_item:f())
                name_label.bind("<Button-1>", lambda e, f = toggle_store_item:f())

            def complete_trade():
                if not trade_offer["your_items"]and not trade_offer["store_items"]:
                    self._popup_show_info("Empty Trade", "Select items to trade.", sound = "popup")
                    return

                diff = trade_values["store_total"]-trade_values["your_total"]

                if diff >player_money[0]:
                    self._popup_show_info("Not Enough Money", f"This trade requires ${diff} extra but you only have ${player_money[0]}.", sound = "error")
                    return

                try:
                    locations_to_remove = {}
                    for entry in trade_offer["your_items"]:
                        loc = entry["location"]
                        idx = entry["index"]
                        if loc not in locations_to_remove:
                            locations_to_remove[loc]=[]
                        locations_to_remove[loc].append(idx)

                    for loc in locations_to_remove:
                        locations_to_remove[loc]= sorted(locations_to_remove[loc], reverse = True)

                    for loc, indices in locations_to_remove.items():
                        for idx in indices:
                            remove_item_from_location(loc, idx)

                    hands_items = save_data.get("hands", {}).get("items", [])
                    for entry in trade_offer["store_items"]:
                        item_copy = entry["item"].copy()
                        item_copy.pop("_table_category", None)
                        item_copy = add_subslots_to_item(item_copy)
                        self._add_item_to_container(hands_items, item_copy)

                    save_data["hands"]["items"]= hands_items
                    save_data["money"]= player_money[0]-diff
                    self._write_save_to_path(save_path, save_data)

                    your_names =[e["item"].get("name", "Unknown")for e in trade_offer["your_items"]]
                    store_names =[e["item"].get("name", "Unknown")for e in trade_offer["store_items"]]
                    logging.info(f"Trade completed: gave {your_names}, received {store_names}, paid ${diff if diff >0 else 0}")

                    msg = f"Traded {len(trade_offer['your_items'])} of your item(s) for {len(trade_offer['store_items'])} store item(s)."
                    if diff >0:
                        msg +=f" Paid ${diff} extra."
                    elif diff <0:
                        msg +=f" Received ${-diff}."
                    self._popup_show_info("Trade Complete", msg, sound = "success")

                    stop_ui_music()
                    self._open_business_tool()

                except Exception as e:
                    logging.error(f"Failed to complete trade: {e}")
                    self._popup_show_info("Error", f"Failed to complete trade: {e}", sound = "error")

            trade_btn = self._create_sound_button(trade_main_frame, "Complete Trade", complete_trade, width = 200, height = 35, font = customtkinter.CTkFont(size = 13))
            trade_btn.grid(row = 3, column = 0, columnspan = 2, pady = 10)

        button_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        button_frame.grid(row = 2, column = 0, sticky = "ew", padx = 20, pady = 10)

        def complete_purchase():
            if not buy_cart:
                self._popup_show_info("Empty Cart", "Your buy cart is empty.", sound = "popup")
                return

            if buy_total[0]>player_money[0]:
                self._popup_show_info("Not Enough Money", f"You need ${buy_total[0]} but only have ${player_money[0]}.", sound = "error")
                return

            try:
                hands_items = save_data.get("hands", {}).get("items", [])

                for cart_entry in buy_cart:
                    item_copy = cart_entry["item"].copy()
                    item_copy.pop("_table_category", None)
                    item_copy = add_subslots_to_item(item_copy)
                    self._add_item_to_container(hands_items, item_copy)

                save_data["hands"]["items"]= hands_items
                save_data["money"]= player_money[0]-buy_total[0]
                self._write_save_to_path(save_path, save_data)

                item_names =[e["item"].get("name", "Unknown")for e in buy_cart]
                logging.info(f"Purchased items for ${buy_total[0]}: {item_names}")
                self._popup_show_info("Purchase Complete", f"Purchased {len(buy_cart)} item(s) for ${buy_total[0]}.", sound = "success")

                buy_cart.clear()
                buy_total[0]= 0
                player_money[0]= save_data["money"]
                try:
                    stop_ui_music()
                except Exception:
                    try:
                        self._stop_business_music(music_channel)
                    except Exception:
                        pass
                self._open_business_tool()

            except Exception as e:
                logging.error(f"Failed to complete purchase: {e}")
                self._popup_show_info("Error", f"Failed to complete purchase: {e}", sound = "error")

        def complete_sale():
            if not sell_cart:
                self._popup_show_info("Empty Cart", "Your sell cart is empty.", sound = "popup")
                return

            try:
                locations_to_remove = {}
                for entry in sell_cart:
                    loc = entry["location"]
                    idx = entry["index"]
                    if loc not in locations_to_remove:
                        locations_to_remove[loc]=[]
                    locations_to_remove[loc].append(idx)

                for loc in locations_to_remove:
                    locations_to_remove[loc]= sorted(locations_to_remove[loc], reverse = True)

                for loc, indices in locations_to_remove.items():
                    for idx in indices:
                        remove_item_from_location(loc, idx)

                save_data["money"]= player_money[0]+sell_total[0]
                self._write_save_to_path(save_path, save_data)

                logging.info(f"Sold {len(sell_cart)} items for ${sell_total[0]}")
                self._popup_show_info("Sale Complete", f"Sold {len(sell_cart)} item(s) for ${sell_total[0]}.", sound = "success")

                sell_cart.clear()
                sell_total[0]= 0
                player_money[0]= save_data["money"]
                try:
                    stop_ui_music()
                except Exception:
                    try:
                        self._stop_business_music(music_channel)
                    except Exception:
                        pass
                self._open_business_tool()

            except Exception as e:
                logging.error(f"Failed to complete sale: {e}")
                self._popup_show_info("Error", f"Failed to complete sale: {e}", sound = "error")

        def leave_store():
            def _do_leave(confirmed:bool = True):
                if not confirmed:
                    return
                try:
                    stop_ui_music()
                except Exception:
                    try:
                        self._stop_business_music(music_channel)
                    except Exception:
                        pass
                self._open_business_tool()

            try:
                has_buy = bool(buy_cart)
                has_sell = bool(sell_cart)
                if has_buy or has_sell:
                    parts =[]
                    if has_buy:
                        parts.append(f"{len(buy_cart)} item(s) in buy cart")
                    if has_sell:
                        parts.append(f"{len(sell_cart)} item(s) in sell cart")
                    details = " and ".join(parts)
                    msg = f"You have {details}.Leaving will discard these items.Leave anyway?"
                    self._popup_confirm("Leave Store", msg, _do_leave)
                    return
            except Exception:
                pass

            _do_leave()

        buy_btn = self._create_sound_button(button_frame, "Complete Purchase", complete_purchase, width = 200, height = 40, font = customtkinter.CTkFont(size = 14))
        buy_btn.pack(side = "left", padx = 10)

        sell_btn = self._create_sound_button(button_frame, "Complete Sale", complete_sale, width = 200, height = 40, font = customtkinter.CTkFont(size = 14))
        sell_btn.pack(side = "left", padx = 10)

        back_btn = self._create_sound_button(button_frame, "Leave Store", leave_store, width = 200, height = 40, font = customtkinter.CTkFont(size = 14))
        back_btn.pack(side = "right", padx = 10)

    def _play_card_sound(self, sound_name):
        try:
            base_dir = os.path.dirname(__file__)
            sound_path = os.path.join(base_dir, "sounds", "misc", "cards", f"{sound_name}.ogg")
            if os.path.exists(sound_path):
                sound = pygame.mixer.Sound(sound_path)
                sound.play()
        except Exception as e:
            logging.debug(f"Failed to play card sound {sound_name}: {e}")

    def _load_card_image(self, suit, value, size =(80, 112)):
        try:
            if not hasattr(self, '_card_image_cache'):
                self._card_image_cache = {}

            cache_key =(suit, value, size)
            if cache_key in self._card_image_cache:
                return self._card_image_cache[cache_key]

            base_dir = os.path.dirname(__file__)
            if suit is None and value =="back":
                img_path = os.path.join(base_dir, "images", "cards", "back.png")
            else:
                img_path = os.path.join(base_dir, "images", "cards", suit, f"{value}.png")

            if os.path.exists(img_path):
                from PIL import Image
                img = Image.open(img_path)
                img = img.resize(size, Image.Resampling.LANCZOS)
                ctk_img = customtkinter.CTkImage(light_image = img, dark_image = img, size = size)
                self._card_image_cache[cache_key]= ctk_img
                return ctk_img
            else:
                logging.warning(f"Card image not found: {img_path}")
        except Exception as e:
            logging.warning(f"Failed to load card image {suit}/{value}: {e}")
        return None

    def _open_casino_interface(self, store, table_data):
        logging.info(f"Opening casino: {store.get('name')}")

        music_channel = None
        if store.get("music")and store.get("playlist"):
            music_channel = self._start_business_music(store.get("playlist"), first_play = True)

        self._clear_window()

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew")
        main_frame.grid_columnconfigure(0, weight = 1)
        main_frame.grid_rowconfigure(1, weight = 1)

        header_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        header_frame.grid(row = 0, column = 0, sticky = "ew", padx = 20, pady = 10)

        title_label = customtkinter.CTkLabel(header_frame, text = store.get("name", "Casino"), font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title_label.pack(pady =(10, 5))

        shopkeeper_label = customtkinter.CTkLabel(header_frame, text = f"Proprietor: {store.get('shopkeeper', 'Unknown')}", font = customtkinter.CTkFont(size = 14), text_color = "gray")
        shopkeeper_label.pack()

        save_path = os.path.join(saves_folder or "", (currentsave or "")+".sldsv")
        save_data = self._load_file((currentsave or "")+".sldsv")
        if save_data is None:
            self._popup_show_info("Error", "Failed to load character data.", sound = "error")
            try:
                self._stop_business_music(music_channel)
            except Exception:
                pass
            return

        player_money =[save_data.get("money", 0)]
        casino_name = store.get("name", "Unknown Casino")

        if "casino_stats"not in save_data:
            save_data["casino_stats"]= {}
        if casino_name not in save_data["casino_stats"]:
            save_data["casino_stats"][casino_name]= {
            "wins":0,
            "losses":0,
            "games_played":0,
            "net_profit":0
            }
        casino_stats =[save_data["casino_stats"][casino_name]]

        money_label = customtkinter.CTkLabel(header_frame, text = f"Your Money: ${player_money[0]}", font = customtkinter.CTkFont(size = 16, weight = "bold"), text_color = "green")
        money_label.pack(pady = 5)

        stats_frame = customtkinter.CTkFrame(header_frame, fg_color = "transparent")
        stats_frame.pack(pady = 5)

        stats = casino_stats[0]
        net_color = "green"if stats["net_profit"]>=0 else "red"
        net_prefix = "+$"if stats["net_profit"]>=0 else "-$"
        net_display = f"{net_prefix}{abs(stats['net_profit'])}"

        stats_label = customtkinter.CTkLabel(
        stats_frame,
        text = f"Lifetime: {stats['wins']}W / {stats['losses']}L({stats['games_played']} games) | Net: {net_display}",
        font = customtkinter.CTkFont(size = 12),
        text_color = "gray"
        )
        stats_label.pack()

        def update_stats_display():
            try:
                s = casino_stats[0]
                nc = "green"if s["net_profit"]>=0 else "red"
                np = "+$"if s["net_profit"]>=0 else "-$"
                nd = f"{np}{abs(s['net_profit'])}"
                stats_label.configure(text = f"Lifetime: {s['wins']}W / {s['losses']}L({s['games_played']} games) | Net: {nd}")
            except Exception:
                pass

        min_bet = store.get("min_bet", 10)
        max_bet = store.get("max_bet", 1000)

        def update_money_display():
            try:
                money_label.configure(text = f"Your Money: ${player_money[0]}")
            except Exception:
                pass

        def save_money():
            try:
                save_data["money"]= player_money[0]
                save_data["casino_stats"][casino_name]= casino_stats[0]
                self._write_save_to_path(save_path, save_data)
            except Exception as e:
                logging.error(f"Failed to save money: {e}")

        def record_game_result(winnings):
            casino_stats[0]["games_played"]+=1
            casino_stats[0]["net_profit"]+=winnings
            if winnings >0:
                casino_stats[0]["wins"]+=1
            elif winnings <0:
                casino_stats[0]["losses"]+=1
            update_stats_display()

        content_frame = customtkinter.CTkFrame(main_frame)
        content_frame.grid(row = 1, column = 0, sticky = "nsew", padx = 20, pady = 10)
        content_frame.grid_columnconfigure(0, weight = 1)
        content_frame.grid_rowconfigure(0, weight = 1)

        games_frame = customtkinter.CTkFrame(content_frame)
        games_frame.pack(fill = "both", expand = True, padx = 10, pady = 10)

        games_label = customtkinter.CTkLabel(games_frame, text = "Choose a Game", font = customtkinter.CTkFont(size = 18, weight = "bold"))
        games_label.pack(pady = 20)

        available_games = store.get("games", ["Blackjack"])

        def open_blackjack():
            self._open_blackjack_game(store, player_money, update_money_display, save_money, min_bet, max_bet, music_channel, table_data, record_game_result, casino_stats, save_data = save_data, save_path = save_path)

        def open_poker():
            self._open_poker_game(store, player_money, update_money_display, save_money, min_bet, max_bet, music_channel, table_data, record_game_result, casino_stats, save_data = save_data, save_path = save_path)

        def open_highlow():
            self._open_highlow_game(store, player_money, update_money_display, save_money, min_bet, max_bet, music_channel, table_data, record_game_result, casino_stats, save_data = save_data, save_path = save_path)

        def open_roulette():
            self._open_roulette_game(store, player_money, update_money_display, save_money, min_bet, max_bet, music_channel, table_data, record_game_result, casino_stats, save_data = save_data, save_path = save_path)

        def open_poker_lobby():
            self._open_poker_lobby(store, player_money, update_money_display, save_money, min_bet, max_bet, music_channel, table_data, record_game_result, casino_stats, save_data = save_data, save_path = save_path)

        if "Blackjack"in available_games:
            blackjack_btn = self._create_sound_button(games_frame, "Blackjack", open_blackjack, width = 300, height = 50, font = customtkinter.CTkFont(size = 16))
            blackjack_btn.pack(pady = 10)

        if "Poker"in available_games:
            poker_btn = self._create_sound_button(games_frame, "Poker", open_poker_lobby, width = 300, height = 50, font = customtkinter.CTkFont(size = 16))
            poker_btn.pack(pady = 10)

        if "High-Low"in available_games:
            highlow_btn = self._create_sound_button(games_frame, "High-Low", open_highlow, width = 300, height = 50, font = customtkinter.CTkFont(size = 16))
            highlow_btn.pack(pady = 10)

        if "Roulette"in available_games:
            roulette_btn = self._create_sound_button(games_frame, "Roulette", open_roulette, width = 300, height = 50, font = customtkinter.CTkFont(size = 16))
            roulette_btn.pack(pady = 10)

        def leave_casino():
            try:
                self._stop_business_music(music_channel)
            except Exception:
                pass
            save_money()
            self._clear_window()
            self._open_business_tool()

        button_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        button_frame.grid(row = 2, column = 0, sticky = "ew", padx = 20, pady = 10)

        back_btn = self._create_sound_button(button_frame, "Leave Casino", leave_casino, width = 200, height = 40, font = customtkinter.CTkFont(size = 14))
        back_btn.pack(pady = 10)

    def _get_all_player_items_from_save(self, save_data):
        all_items = []
        if not save_data or not isinstance(save_data, dict):
            return all_items

        hands_items = save_data.get("hands", {}).get("items", [])
        for idx, item in enumerate(hands_items):
            if isinstance(item, dict):
                all_items.append({"item": item, "location": "hands", "index": idx})

        equipment = save_data.get("equipment", {})
        for slot_name, slot_item in equipment.items():
            if slot_item and isinstance(slot_item, dict):
                if "items" in slot_item and "capacity" in slot_item:
                    for idx, item in enumerate(slot_item.get("items", [])):
                        if isinstance(item, dict):
                            all_items.append({"item": item, "location": f"equipment.{slot_name}", "index": idx})
                if "subslots" in slot_item:
                    for subslot_idx, subslot_data in enumerate(slot_item.get("subslots", [])):
                        subslot_item = subslot_data.get("current")
                        if subslot_item and isinstance(subslot_item, dict) and "items" in subslot_item:
                            for idx, item in enumerate(subslot_item.get("items", [])):
                                if isinstance(item, dict):
                                    all_items.append({"item": item, "location": f"equipment.{slot_name}.subslot.{subslot_idx}", "index": idx})
            elif isinstance(slot_item, list):
                for list_idx, list_item in enumerate(slot_item):
                    if list_item and isinstance(list_item, dict):
                        if "items" in list_item and "capacity" in list_item:
                            for idx, item in enumerate(list_item.get("items", [])):
                                if isinstance(item, dict):
                                    all_items.append({"item": item, "location": f"equipment.{slot_name}.list.{list_idx}", "index": idx})
                        if "subslots" in list_item:
                            for subslot_idx, subslot_data in enumerate(list_item.get("subslots", [])):
                                subslot_item = subslot_data.get("current")
                                if subslot_item and isinstance(subslot_item, dict) and "items" in subslot_item:
                                    for idx, item in enumerate(subslot_item.get("items", [])):
                                        if isinstance(item, dict):
                                            all_items.append({"item": item, "location": f"equipment.{slot_name}.list.{list_idx}.subslot.{subslot_idx}", "index": idx})
        return all_items

    def _remove_item_from_save_location(self, save_data, location, index):
        if location == "hands":
            items = save_data.get("hands", {}).get("items", [])
            if 0 <= index < len(items):
                items.pop(index)
        elif location.startswith("equipment."):
            parts = location.split(".")
            slot = parts[1]
            slot_item = save_data.get("equipment", {}).get(slot)

            if len(parts) == 2:
                if slot_item and isinstance(slot_item, dict) and "items" in slot_item:
                    items = slot_item.get("items", [])
                    if 0 <= index < len(items):
                        items.pop(index)
            elif len(parts) >= 4 and parts[2] == "subslot":
                subslot_idx = int(parts[3])
                if slot_item and isinstance(slot_item, dict) and "subslots" in slot_item:
                    subslot_item = slot_item["subslots"][subslot_idx].get("current")
                    if subslot_item and "items" in subslot_item:
                        items = subslot_item.get("items", [])
                        if 0 <= index < len(items):
                            items.pop(index)
            elif len(parts) >= 4 and parts[2] == "list":
                list_idx = int(parts[3])
                if isinstance(slot_item, list) and 0 <= list_idx < len(slot_item):
                    list_item = slot_item[list_idx]
                    if len(parts) == 4:
                        if list_item and isinstance(list_item, dict) and "items" in list_item:
                            items = list_item.get("items", [])
                            if 0 <= index < len(items):
                                items.pop(index)
                    elif len(parts) >= 6 and parts[4] == "subslot":
                        subslot_idx = int(parts[5])
                        if list_item and isinstance(list_item, dict) and "subslots" in list_item:
                            subslot_item = list_item["subslots"][subslot_idx].get("current")
                            if subslot_item and "items" in subslot_item:
                                items = subslot_item.get("items", [])
                                if 0 <= index < len(items):
                                    items.pop(index)

    def _open_item_bet_dialog(self, save_data, wagered_items, on_update_cb = None):
        if not save_data:
            self._popup_show_info("Error", "No character data available for item betting.", sound = "error")
            return

        popup = customtkinter.CTkToplevel(self.root)
        popup.title("Wager Items")
        popup.transient(self.root)
        popup.grab_set()
        popup.withdraw()

        all_items = self._get_all_player_items_from_save(save_data)

        wager_total = [sum(int(e["item"].get("value", 0)) for e in wagered_items)]

        status_label = customtkinter.CTkLabel(popup, text = f"Wagered Items Value: ${wager_total[0]}", font = customtkinter.CTkFont(size = 14, weight = "bold"), text_color = "gold")
        status_label.pack(pady = (10, 5))

        hint_label = customtkinter.CTkLabel(popup, text = "Click items to toggle wager (green = wagered)", font = customtkinter.CTkFont(size = 11), text_color = "gray")
        hint_label.pack(pady = (0, 5))

        scroll_frame = customtkinter.CTkScrollableFrame(popup, width = 450, height = 400)
        scroll_frame.pack(fill = "both", expand = True, padx = 10, pady = 5)

        for item_data in all_items:
            item = item_data["item"]
            location = item_data["location"]
            item_idx = item_data["index"]

            if item.get("_from_armory"):
                continue

            item_value = int(item.get("value", 0))
            if item_value <= 0:
                continue

            item_frame = customtkinter.CTkFrame(scroll_frame)
            item_frame.pack(fill = "x", pady = 3, padx = 5)

            cart_key = f"{location}:{item_idx}"
            is_selected = any(f"{e['location']}:{e['index']}" == cart_key for e in wagered_items)
            if is_selected:
                item_frame.configure(fg_color = ("green", "darkgreen"))

            location_text = location.replace("equipment.", "").replace(".list.", " #").replace(".subslot.", " sub#")

            name_label = customtkinter.CTkLabel(item_frame, text = f"{self._format_item_name(item)} (${item_value})", font = customtkinter.CTkFont(size = 11), anchor = "w")
            name_label.pack(anchor = "w", padx = 8, pady = (5, 0))

            loc_label = customtkinter.CTkLabel(item_frame, text = f"{location_text}", font = customtkinter.CTkFont(size = 9), text_color = "gray", anchor = "w")
            loc_label.pack(anchor = "w", padx = 8, pady = (0, 3))

            def toggle_item(loc = location, i = item_idx, it = item, val = item_value, frame = item_frame):
                cart_key = f"{loc}:{i}"
                existing = [idx for idx, e in enumerate(wagered_items) if f"{e['location']}:{e['index']}" == cart_key]
                if existing:
                    wagered_items.pop(existing[0])
                    wager_total[0] -= val
                    frame.configure(fg_color = ("gray86", "gray17"))
                else:
                    wagered_items.append({"location": loc, "index": i, "item": it, "value": val})
                    wager_total[0] += val
                    frame.configure(fg_color = ("green", "darkgreen"))
                status_label.configure(text = f"Wagered Items Value: ${wager_total[0]}")
                self._play_ui_sound("click")

            item_frame.bind("<Button-1>", lambda e, f = toggle_item: f())
            name_label.bind("<Button-1>", lambda e, f = toggle_item: f())
            loc_label.bind("<Button-1>", lambda e, f = toggle_item: f())

        def confirm_wager():
            if on_update_cb:
                on_update_cb()
            popup.destroy()

        def clear_wager():
            wagered_items.clear()
            wager_total[0] = 0
            status_label.configure(text = f"Wagered Items Value: ${wager_total[0]}")
            for widget in scroll_frame.winfo_children():
                try:
                    widget.configure(fg_color = ("gray86", "gray17"))
                except Exception:
                    pass
            if on_update_cb:
                on_update_cb()
            self._play_ui_sound("click")

        btn_frame = customtkinter.CTkFrame(popup, fg_color = "transparent")
        btn_frame.pack(pady = 10)

        clear_btn = self._create_sound_button(btn_frame, "Clear All", clear_wager, width = 120, height = 35, font = customtkinter.CTkFont(size = 12))
        clear_btn.pack(side = "left", padx = 5)

        confirm_btn = self._create_sound_button(btn_frame, "Confirm", confirm_wager, width = 120, height = 35, font = customtkinter.CTkFont(size = 12))
        confirm_btn.pack(side = "left", padx = 5)

        self._play_ui_sound("click")
        popup.update_idletasks()
        w, h = 500, 550
        x = self.root.winfo_x() + (self.root.winfo_width() // 2) - (w // 2)
        y = self.root.winfo_y() + (self.root.winfo_height() // 2) - (h // 2)
        popup.geometry(f"{w}x{h}+{x}+{y}")
        popup.deiconify()

    def _process_item_bet_loss(self, save_data, save_path, wagered_items):
        if not wagered_items or not save_data or not save_path:
            return
        try:
            locations_to_remove = {}
            for entry in wagered_items:
                loc = entry["location"]
                idx = entry["index"]
                if loc not in locations_to_remove:
                    locations_to_remove[loc] = []
                locations_to_remove[loc].append(idx)

            for loc in locations_to_remove:
                locations_to_remove[loc] = sorted(locations_to_remove[loc], reverse = True)

            for loc, indices in locations_to_remove.items():
                for idx in indices:
                    self._remove_item_from_save_location(save_data, loc, idx)

            self._write_save_to_path(save_path, save_data)

            item_names = [e["item"].get("name", "Unknown") for e in wagered_items]
            logging.info(f"Items lost in gambling: {item_names}")
        except Exception as e:
            logging.error(f"Failed to process item bet loss: {e}")

    def _open_blackjack_game(self, store, player_money, update_money_cb, save_money_cb, min_bet, max_bet, music_channel, table_data, record_game_cb = None, casino_stats = None, save_data = None, save_path = None):
        self._clear_window()

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew")
        main_frame.grid_columnconfigure(0, weight = 1)
        main_frame.grid_rowconfigure(1, weight = 1)

        header_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        header_frame.grid(row = 0, column = 0, sticky = "ew", padx = 20, pady = 10)

        title_label = customtkinter.CTkLabel(header_frame, text = "Blackjack", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title_label.pack(pady =(10, 5))

        money_label = customtkinter.CTkLabel(header_frame, text = f"Your Money: ${player_money[0]}", font = customtkinter.CTkFont(size = 16, weight = "bold"), text_color = "green")
        money_label.pack(pady = 5)

        bet_label = customtkinter.CTkLabel(header_frame, text = f"Bet Range: ${min_bet} - ${max_bet}", font = customtkinter.CTkFont(size = 12), text_color = "orange")
        bet_label.pack()

        game_frame = customtkinter.CTkFrame(main_frame)
        game_frame.grid(row = 1, column = 0, sticky = "nsew", padx = 20, pady = 10)
        game_frame.grid_columnconfigure(0, weight = 1)

        suits =["clubs", "diamonds", "hearts", "spades"]
        values =["2", "3", "4", "5", "6", "7", "8", "9", "10", "jack", "queen", "king", "ace"]

        deck =[{"suit":s, "value":v}for s in suits for v in values]
        game_state = {
        "deck":[],
        "player_hand":[],
        "dealer_hand":[],
        "current_bet":0,
        "game_active":False,
        "player_turn":False,
        "result":None,
        "ui_active":True
        }

        wagered_items = []
        item_bet_value = [0]

        dealer_frame = customtkinter.CTkFrame(game_frame, fg_color = "transparent")
        dealer_frame.pack(pady = 10)
        dealer_label = customtkinter.CTkLabel(dealer_frame, text = "Dealer's Hand", font = customtkinter.CTkFont(size = 14, weight = "bold"))
        dealer_label.pack()
        dealer_cards_frame = customtkinter.CTkFrame(dealer_frame, fg_color = "transparent")
        dealer_cards_frame.pack(pady = 5)
        dealer_score_label = customtkinter.CTkLabel(dealer_frame, text = "", font = customtkinter.CTkFont(size = 12))
        dealer_score_label.pack()

        player_frame = customtkinter.CTkFrame(game_frame, fg_color = "transparent")
        player_frame.pack(pady = 10)
        player_label = customtkinter.CTkLabel(player_frame, text = "Your Hand", font = customtkinter.CTkFont(size = 14, weight = "bold"))
        player_label.pack()
        player_cards_frame = customtkinter.CTkFrame(player_frame, fg_color = "transparent")
        player_cards_frame.pack(pady = 5)
        player_score_label = customtkinter.CTkLabel(player_frame, text = "", font = customtkinter.CTkFont(size = 12))
        player_score_label.pack()

        result_label = customtkinter.CTkLabel(game_frame, text = "", font = customtkinter.CTkFont(size = 18, weight = "bold"))
        result_label.pack(pady = 10)

        def get_card_value(card):
            v = card["value"]
            if v in["jack", "queen", "king"]:
                return 10
            elif v =="ace":
                return 11
            else:
                return int(v)

        def calculate_hand(hand):
            total = sum(get_card_value(c)for c in hand)
            aces = sum(1 for c in hand if c["value"]=="ace")
            while total >21 and aces >0:
                total -=10
                aces -=1
            return total

        def shuffle_deck():
            game_state["deck"]= deck.copy()
            random.shuffle(game_state["deck"])
            self._play_card_sound("shuffle")

        def draw_card():
            if not game_state["deck"]:
                shuffle_deck()
            card = game_state["deck"].pop()
            self._play_card_sound("flip")
            return card

        def display_card(frame, card, hidden = False):
            if hidden:
                img = self._load_card_image(None, "back")
            else:
                img = self._load_card_image(card["suit"], card["value"])

            if img:
                card_label = customtkinter.CTkLabel(frame, image = img, text = "")
                card_label.image = img
                card_label.pack(side = "left", padx = 2)
            else:
                text = "??"if hidden else f"{card['value'][0].upper()}{card['suit'][0].upper()}"
                card_label = customtkinter.CTkLabel(frame, text = text, width = 60, height = 84, fg_color = "white", text_color = "black", corner_radius = 5)
                card_label.pack(side = "left", padx = 2)

        def clear_cards(frame):
            for widget in frame.winfo_children():
                widget.destroy()

        def place_card_back(frame):
            img = self._load_card_image(None, "back")
            if img:
                card_label = customtkinter.CTkLabel(frame, image = img, text = "")
                card_label.image = img
                card_label.pack(side = "left", padx = 2)
            else:
                card_label = customtkinter.CTkLabel(frame, text = "??", width = 60, height = 84, fg_color = "white", text_color = "black", corner_radius = 5)
                card_label.pack(side = "left", padx = 2)
            return card_label

        def place_card_face_up(frame, card):
            img = self._load_card_image(card["suit"], card["value"])
            if img:
                card_label = customtkinter.CTkLabel(frame, image = img, text = "")
                card_label.image = img
                card_label.pack(side = "left", padx = 2)
            else:
                text = f"{card['value'][0].upper()}{card['suit'][0].upper()}"
                card_label = customtkinter.CTkLabel(frame, text = text, width = 60, height = 84, fg_color = "white", text_color = "black", corner_radius = 5)
                card_label.pack(side = "left", padx = 2)
            return card_label

        def flip_card_label(card_label, card):
            img = self._load_card_image(card["suit"], card["value"])
            if img:
                card_label.configure(image = img)
                card_label.image = img
            else:
                card_label.configure(text = f"{card['value'][0].upper()}{card['suit'][0].upper()}")

        def update_display(reveal_dealer = False):
            clear_cards(dealer_cards_frame)
            clear_cards(player_cards_frame)

            for i, card in enumerate(game_state["dealer_hand"]):
                if i ==0 and not reveal_dealer and game_state["player_turn"]:
                    display_card(dealer_cards_frame, card, hidden = True)
                else:
                    display_card(dealer_cards_frame, card)

            for card in game_state["player_hand"]:
                display_card(player_cards_frame, card)

            player_total = calculate_hand(game_state["player_hand"])
            player_score_label.configure(text = f"Score: {player_total}")

            if reveal_dealer or not game_state["player_turn"]:
                dealer_total = calculate_hand(game_state["dealer_hand"])
                dealer_score_label.configure(text = f"Score: {dealer_total}")
            else:
                visible_card = game_state["dealer_hand"][1]if len(game_state["dealer_hand"])>1 else None
                if visible_card:
                    dealer_score_label.configure(text = f"Showing: {get_card_value(visible_card)}")
                else:
                    dealer_score_label.configure(text = "")

            money_label.configure(text = f"Your Money: ${player_money[0]}")
            update_money_cb()

        def end_game(result_text, winnings):
            if not game_state.get("ui_active", False):
                return
            game_state["game_active"]= False
            game_state["player_turn"]= False
            game_state["result"]= result_text

            player_money[0]+=winnings
            if record_game_cb:
                record_game_cb(winnings)

            item_lost = False
            if winnings <0 and wagered_items:
                self._process_item_bet_loss(save_data, save_path, wagered_items)
                item_names = [e["item"].get("name", "Unknown") for e in wagered_items]
                item_lost = True
            elif winnings >0 and wagered_items:
                player_money[0] += item_bet_value[0]

            save_money_cb()

            try:
                color = "green"if winnings >0 else("red"if winnings <0 else "orange")
                item_suffix = ""
                if item_lost:
                    item_suffix = f" | Lost {len(wagered_items)} item(s)"
                elif winnings >0 and item_bet_value[0] >0:
                    item_suffix = f" | +${item_bet_value[0]} from items"

                if winnings >0:
                    total_display = winnings + (item_bet_value[0] if wagered_items else 0)
                    result_label.configure(text = f"{result_text}(+${total_display}){item_suffix}", text_color = color)
                elif winnings <0:
                    result_label.configure(text = f"{result_text}(-${abs(winnings)}){item_suffix}", text_color = color)
                else:
                    result_label.configure(text = result_text, text_color = color)

                wagered_items.clear()
                item_bet_value[0] = 0
                try:
                    item_wager_label.configure(text = "Items Wagered: None")
                except Exception:
                    pass

                update_display(reveal_dealer = True)
                update_buttons()
            except Exception:
                pass

        def dealer_turn():
            if not game_state.get("ui_active", False):
                return

            dealer_children = dealer_cards_frame.winfo_children()
            if dealer_children:
                first_label = dealer_children[0]
                self._play_card_sound("flip")
                flip_card_label(first_label, game_state["dealer_hand"][0])

            dealer_total = calculate_hand(game_state["dealer_hand"])
            dealer_score_label.configure(text = f"Score: {dealer_total}")

            def dealer_draw():
                nonlocal dealer_total
                if not game_state.get("ui_active", False):
                    return
                if dealer_total <17:
                    if not game_state["deck"]:
                        shuffle_deck()
                    card = game_state["deck"].pop()
                    game_state["dealer_hand"].append(card)
                    dealer_total = calculate_hand(game_state["dealer_hand"])

                    try:
                        self._play_card_sound("place")
                        place_card_face_up(dealer_cards_frame, card)
                        dealer_score_label.configure(text = f"Score: {dealer_total}")
                    except Exception:
                        return

                    self.root.after(600, dealer_draw)
                else:
                    player_total = calculate_hand(game_state["player_hand"])
                    bet = game_state["current_bet"]

                    if dealer_total >21:
                        end_game("Dealer Busts! You Win!", bet)
                    elif dealer_total >player_total:
                        end_game("Dealer Wins!", -bet)
                    elif player_total >dealer_total:
                        end_game("You Win!", bet)
                    else:
                        end_game("Push! It's a Tie!", 0)

            self.root.after(500, dealer_draw)

        def hit():
            if not game_state["player_turn"]:
                return

            if not game_state["deck"]:
                shuffle_deck()
            card = game_state["deck"].pop()
            game_state["player_hand"].append(card)

            self._play_card_sound("place")
            place_card_face_up(player_cards_frame, card)
            player_total = calculate_hand(game_state["player_hand"])
            player_score_label.configure(text = f"Score: {player_total}")
            if player_total >21:
                end_game("Bust! You Lose!", -game_state["current_bet"])

        def stand():
            if not game_state["player_turn"]:
                return
            game_state["player_turn"]= False
            update_buttons()
            dealer_turn()

        def double_down():
            if not game_state["player_turn"]or len(game_state["player_hand"])!=2:
                return
            if player_money[0]<game_state["current_bet"]:
                self._popup_show_info("Insufficient Funds", "You don't have enough money to double down.", sound = "error")
                return

            game_state["current_bet"]*=2

            if not game_state["deck"]:
                shuffle_deck()
            card = game_state["deck"].pop()
            game_state["player_hand"].append(card)

            self._play_card_sound("place")
            place_card_face_up(player_cards_frame, card)
            player_total = calculate_hand(game_state["player_hand"])
            player_score_label.configure(text = f"Score: {player_total}")
            if player_total >21:
                end_game("Bust! You Lose!", -game_state["current_bet"])
            else:
                game_state["player_turn"]= False
                update_buttons()
                dealer_turn()

        def start_new_game():
            bet_str = bet_entry.get()
            try:
                bet = int(bet_str)
            except ValueError:
                self._popup_show_info("Invalid Bet", "Please enter a valid number.", sound = "error")
                return

            if bet <min_bet or bet >max_bet:
                self._popup_show_info("Invalid Bet", f"Bet must be between ${min_bet} and ${max_bet}.", sound = "error")
                return

            if bet >player_money[0]:
                self._popup_show_info("Insufficient Funds", "You don't have enough money for that bet.", sound = "error")
                return

            game_state["current_bet"]= bet
            result_label.configure(text = "")

            shuffle_deck()
            game_state["player_hand"]=[]
            game_state["dealer_hand"]=[]

            clear_cards(dealer_cards_frame)
            clear_cards(player_cards_frame)
            player_score_label.configure(text = "")
            dealer_score_label.configure(text = "")

            deal_btn.configure(state = "disabled")
            hit_btn.configure(state = "disabled")
            stand_btn.configure(state = "disabled")
            double_btn.configure(state = "disabled")

            drawn_cards =[]
            for _ in range(4):
                if not game_state["deck"]:
                    shuffle_deck()
                drawn_cards.append(game_state["deck"].pop())

            deal_plan =[
                (player_cards_frame, drawn_cards[0], "player", True),
                (dealer_cards_frame, drawn_cards[1], "dealer", False),
                (player_cards_frame, drawn_cards[2], "player", True),
                (dealer_cards_frame, drawn_cards[3], "dealer", True),
            ]

            def animate_deal(step = 0):
                if not game_state.get("ui_active", False):
                    return
                if step >=len(deal_plan):
                    game_state["game_active"]= True
                    game_state["player_turn"]= True
                    game_state["result"]= None

                    player_total = calculate_hand(game_state["player_hand"])
                    player_score_label.configure(text = f"Score: {player_total}")
                    visible_card = game_state["dealer_hand"][1]if len(game_state["dealer_hand"])>1 else None
                    if visible_card:
                        dealer_score_label.configure(text = f"Showing: {get_card_value(visible_card)}")
                    money_label.configure(text = f"Your Money: ${player_money[0]}")
                    update_money_cb()
                    update_buttons()

                    if player_total ==21 and calculate_hand(game_state["dealer_hand"])==21:
                        end_game("Both Blackjack! Push!", 0)
                    elif player_total ==21:
                        end_game("Blackjack! You Win!", int(bet *1.5))
                    elif calculate_hand(game_state["dealer_hand"])==21:
                        end_game("Dealer Blackjack! You Lose!", -bet)
                    return

                frame, card, target, face_up = deal_plan[step]

                if target =="player":
                    game_state["player_hand"].append(card)
                else:
                    game_state["dealer_hand"].append(card)

                self._play_card_sound("place")
                if face_up:
                    place_card_face_up(frame, card)
                else:
                    place_card_back(frame)

                self.root.after(400, lambda:animate_deal(step +1))

            animate_deal(0)

        def update_buttons():
            if game_state["player_turn"]:
                hit_btn.configure(state = "normal")
                stand_btn.configure(state = "normal")
                double_btn.configure(state = "normal"if len(game_state["player_hand"])==2 and player_money[0]>=game_state["current_bet"]else "disabled")
                deal_btn.configure(state = "disabled")
            else:
                hit_btn.configure(state = "disabled")
                stand_btn.configure(state = "disabled")
                double_btn.configure(state = "disabled")
                deal_btn.configure(state = "normal")

        controls_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        controls_frame.grid(row = 2, column = 0, sticky = "ew", padx = 20, pady = 10)

        bet_frame = customtkinter.CTkFrame(controls_frame, fg_color = "transparent")
        bet_frame.pack(pady = 5)

        bet_label_entry = customtkinter.CTkLabel(bet_frame, text = "Bet Amount: $", font = customtkinter.CTkFont(size = 14))
        bet_label_entry.pack(side = "left")

        bet_entry = customtkinter.CTkEntry(bet_frame, width = 100, placeholder_text = str(min_bet))
        bet_entry.pack(side = "left", padx = 5)
        bet_entry.insert(0, str(min_bet))

        if save_data and save_path:
            item_wager_label = customtkinter.CTkLabel(bet_frame, text = "Items Wagered: None", font = customtkinter.CTkFont(size = 11), text_color = "gray")
            item_wager_label.pack(side = "left", padx = 10)

            def update_item_wager_display():
                total = sum(int(e["item"].get("value", 0)) for e in wagered_items)
                item_bet_value[0] = total
                if wagered_items:
                    item_wager_label.configure(text = f"Items Wagered: {len(wagered_items)} (${total})", text_color = "gold")
                else:
                    item_wager_label.configure(text = "Items Wagered: None", text_color = "gray")

            def open_item_wager():
                if game_state["game_active"]:
                    self._popup_show_info("Game Active", "Cannot change item wager during a game.", sound = "popup")
                    return
                self._open_item_bet_dialog(save_data, wagered_items, update_item_wager_display)

            wager_btn = self._create_sound_button(bet_frame, "Wager Items", open_item_wager, width = 110, height = 30, font = customtkinter.CTkFont(size = 11), fg_color = "#8B4513", hover_color = "#654321")
            wager_btn.pack(side = "left", padx = 5)

        action_frame = customtkinter.CTkFrame(controls_frame, fg_color = "transparent")
        action_frame.pack(pady = 10)

        deal_btn = self._create_sound_button(action_frame, "Deal", start_new_game, width = 100, height = 40, font = customtkinter.CTkFont(size = 14))
        deal_btn.pack(side = "left", padx = 5)

        hit_btn = self._create_sound_button(action_frame, "Hit", hit, width = 100, height = 40, font = customtkinter.CTkFont(size = 14))
        hit_btn.pack(side = "left", padx = 5)
        hit_btn.configure(state = "disabled")

        stand_btn = self._create_sound_button(action_frame, "Stand", stand, width = 100, height = 40, font = customtkinter.CTkFont(size = 14))
        stand_btn.pack(side = "left", padx = 5)
        stand_btn.configure(state = "disabled")

        double_btn = self._create_sound_button(action_frame, "Double", double_down, width = 100, height = 40, font = customtkinter.CTkFont(size = 14))
        double_btn.pack(side = "left", padx = 5)
        double_btn.configure(state = "disabled")

        def back_to_casino():
            game_state["ui_active"]= False
            self._open_casino_interface(store, table_data)

        back_btn = self._create_sound_button(controls_frame, "Back to Casino", back_to_casino, width = 200, height = 40, font = customtkinter.CTkFont(size = 14))
        back_btn.pack(pady = 10)

    def _open_poker_game(self, store, player_money, update_money_cb, save_money_cb, min_bet, max_bet, music_channel, table_data, record_game_cb = None, casino_stats = None, variant = "five_card_draw", save_data = None, save_path = None):
        self._clear_window()

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew")
        main_frame.grid_columnconfigure(0, weight = 1)
        main_frame.grid_rowconfigure(1, weight = 1)

        variant_names = {
        "five_card_draw":"5 Card Draw",
        "five_card_stud":"5 Card Stud",
        "seven_card_stud":"7 Card Stud",
        "texas_holdem":"Texas Hold'em"
        }

        header_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        header_frame.grid(row = 0, column = 0, sticky = "ew", padx = 20, pady = 10)

        title_label = customtkinter.CTkLabel(header_frame, text = f"Poker - {variant_names.get(variant, variant)}", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title_label.pack(pady =(10, 5))

        money_label = customtkinter.CTkLabel(header_frame, text = f"Your Money: ${player_money[0]}", font = customtkinter.CTkFont(size = 16, weight = "bold"), text_color = "green")
        money_label.pack(pady = 5)

        bet_label = customtkinter.CTkLabel(header_frame, text = f"Bet Range: ${min_bet} - ${max_bet}", font = customtkinter.CTkFont(size = 12), text_color = "orange")
        bet_label.pack()

        game_frame = customtkinter.CTkFrame(main_frame)
        game_frame.grid(row = 1, column = 0, sticky = "nsew", padx = 20, pady = 10)
        game_frame.grid_columnconfigure(0, weight = 1)

        suits =["clubs", "diamonds", "hearts", "spades"]
        values =["2", "3", "4", "5", "6", "7", "8", "9", "10", "jack", "queen", "king", "ace"]
        deck =[{"suit":s, "value":v}for s in suits for v in values]

        npc_personalities =["aggressive", "passive", "tight", "loose", "erratic"]

        def generate_random_npc_name():
            try:
                tables = table_data.get("tables", {})
                npc_names_data = tables.get("npc_names", {})
                if not npc_names_data:
                    return f"Player {random.randint(1, 999)}"
                nationalities = list(npc_names_data.keys())
                nationality = random.choice(nationalities)
                name_data = npc_names_data[nationality]
                first_names = name_data.get("first", ["Unknown"])
                last_names = name_data.get("last", ["Player"])
                first = random.choice(first_names)
                last = random.choice(last_names)
                return f"{first} {last}"
            except Exception:
                return f"Player {random.randint(1, 999)}"

        player_overrides = store.get("poker_player_override", [])
        generated_names = set()
        npc_names =[]
        npc_personality_map = {}

        for i in range(3):
            override = next((p for p in player_overrides if p.get("slot")==i +1), None)
            if override and override.get("name"):
                name_data = override["name"]
                if isinstance(name_data, dict):
                    name = f"{name_data.get('first', 'Player')} {name_data.get('last', str(i +1))}"
                else:
                    name = str(name_data)
                npc_names.append(name)
                generated_names.add(name)
            else:
                attempts = 0
                while attempts <50:
                    name = generate_random_npc_name()
                    if name not in generated_names:
                        generated_names.add(name)
                        npc_names.append(name)
                        break
                    attempts +=1
                else:
                    fallback = f"Player {i +1}"
                    npc_names.append(fallback)
                    generated_names.add(fallback)

            npc_personality_map[npc_names[-1]]= random.choice(npc_personalities)

        game_state = {
        "deck":[],
        "player_hand":[],
        "npc_hands":{name:[]for name in npc_names},
        "npc_held":{name:[False]*7 for name in npc_names},
        "held":[False]*7,
        "current_bet":0,
        "pot":0,
        "phase":"betting",
        "card_labels":[],
        "folded":{name:False for name in npc_names},
        "player_folded":False,
        "community_cards":[],
        "ui_valid":True
        }

        wagered_items = []
        item_bet_value = [0]

        scroll_frame = customtkinter.CTkScrollableFrame(game_frame)
        scroll_frame.pack(fill = "both", expand = True, padx = 5, pady = 5)

        community_frame = None
        community_cards_frame = None
        if variant =="texas_holdem":
            community_frame = customtkinter.CTkFrame(scroll_frame, fg_color = "transparent")
            community_frame.pack(pady = 10, fill = "x")
            customtkinter.CTkLabel(community_frame, text = "Community Cards", font = customtkinter.CTkFont(size = 14, weight = "bold")).pack()
            community_cards_frame = customtkinter.CTkFrame(community_frame, fg_color = "transparent")
            community_cards_frame.pack(pady = 5)

        npc_frames = {}
        for npc_name in npc_names:
            personality = npc_personality_map.get(npc_name, "normal")
            npc_frame = customtkinter.CTkFrame(scroll_frame, fg_color = "transparent")
            npc_frame.pack(pady = 5, fill = "x")
            personality_emoji = {"aggressive":"ðŸ”¥", "passive":"ðŸ˜Œ", "tight":"ðŸŽ¯", "loose":"ðŸŽ²", "erratic":"ðŸƒ"}.get(personality, "")
            npc_label = customtkinter.CTkLabel(npc_frame, text = f"{npc_name} {personality_emoji}", font = customtkinter.CTkFont(size = 12, weight = "bold"))
            npc_label.pack()
            npc_cards_frame = customtkinter.CTkFrame(npc_frame, fg_color = "transparent")
            npc_cards_frame.pack()
            npc_status_label = customtkinter.CTkLabel(npc_frame, text = "", font = customtkinter.CTkFont(size = 10))
            npc_status_label.pack()
            npc_frames[npc_name]= {"frame":npc_frame, "cards":npc_cards_frame, "status":npc_status_label, "label":npc_label}

        separator = customtkinter.CTkLabel(scroll_frame, text = "â”€"*50, font = customtkinter.CTkFont(size = 10))
        separator.pack(pady = 5)

        player_frame = customtkinter.CTkFrame(scroll_frame, fg_color = "transparent")
        player_frame.pack(pady = 10)
        player_label = customtkinter.CTkLabel(player_frame, text = "Your Hand", font = customtkinter.CTkFont(size = 14, weight = "bold"))
        player_label.pack()
        player_cards_frame = customtkinter.CTkFrame(player_frame, fg_color = "transparent")
        player_cards_frame.pack(pady = 5)
        player_score_label = customtkinter.CTkLabel(player_frame, text = "", font = customtkinter.CTkFont(size = 12))
        player_score_label.pack()

        pot_label = customtkinter.CTkLabel(scroll_frame, text = "Pot: $0", font = customtkinter.CTkFont(size = 16, weight = "bold"), text_color = "gold")
        pot_label.pack(pady = 5)

        result_label = customtkinter.CTkLabel(scroll_frame, text = "", font = customtkinter.CTkFont(size = 18, weight = "bold"))
        result_label.pack(pady = 10)

        def get_card_value_num(card):
            v = card["value"]
            if v =="ace":return 14
            elif v =="king":return 13
            elif v =="queen":return 12
            elif v =="jack":return 11
            else:return int(v)

        def shuffle_deck():
            game_state["deck"]= deck.copy()
            random.shuffle(game_state["deck"])
            self._play_card_sound("shuffle")

        def draw_card():
            if not game_state["deck"]:
                shuffle_deck()
            card = game_state["deck"].pop()
            self._play_card_sound("flip")
            return card

        def evaluate_hand(hand):
            if len(hand)<5:
                return("Nothing", 0, [])

            from itertools import combinations
            best_eval =("Nothing", 0, [])

            for combo in combinations(hand, 5):
                combo_list = list(combo)
                vals = sorted([get_card_value_num(c)for c in combo_list], reverse = True)
                suits_list =[c["suit"]for c in combo_list]

                is_flush = len(set(suits_list))==1
                sorted_vals = sorted(vals)
                is_straight = sorted_vals ==list(range(sorted_vals[0], sorted_vals[0]+5))
                if sorted_vals ==[2, 3, 4, 5, 14]:
                    is_straight = True
                    vals =[5, 4, 3, 2, 1]

                val_counts = {}
                for v in vals:
                    val_counts[v]= val_counts.get(v, 0)+1
                counts = sorted(val_counts.values(), reverse = True)

                if is_straight and is_flush:
                    if sorted(vals)==[10, 11, 12, 13, 14]:
                        eval_result =("Royal Flush", 10, vals)
                    else:
                        eval_result =("Straight Flush", 9, vals)
                elif counts ==[4, 1]:
                    eval_result =("Four of a Kind", 8, vals)
                elif counts ==[3, 2]:
                    eval_result =("Full House", 7, vals)
                elif is_flush:
                    eval_result =("Flush", 6, vals)
                elif is_straight:
                    eval_result =("Straight", 5, vals)
                elif counts ==[3, 1, 1]:
                    eval_result =("Three of a Kind", 4, vals)
                elif counts ==[2, 2, 1]:
                    eval_result =("Two Pair", 3, vals)
                elif counts ==[2, 1, 1, 1]:
                    eval_result =("Pair", 2, vals)
                else:
                    eval_result =("High Card", 1, vals)

                if eval_result[1]>best_eval[1]or(eval_result[1]==best_eval[1]and eval_result[2]>best_eval[2]):
                    best_eval = eval_result

            return best_eval

        def npc_decide_hold(hand, npc_name):
            personality = npc_personality_map.get(npc_name, "normal")
            _, rank, _ = evaluate_hand(hand)
            held =[False]*len(hand)

            mistake_chance = 0.15
            if random.random()<mistake_chance:
                if random.random()<0.5:
                    random_idx = random.randint(0, len(hand)-1)
                    return[i ==random_idx for i in range(len(hand))]
                else:
                    return[True]*len(hand)

            vals =[get_card_value_num(c)for c in hand]
            val_counts = {}
            for i, v in enumerate(vals):
                if v not in val_counts:
                    val_counts[v]=[]
                val_counts[v].append(i)

            if personality =="aggressive":
                if rank >=3:
                    return[True]*len(hand)
            elif personality =="passive":
                if rank >=5:
                    return[True]*len(hand)
            elif personality =="erratic":
                if random.random()<0.3:
                    return[random.random()>0.5 for _ in range(len(hand))]

            if rank >=4:
                return[True]*len(hand)

            for v, indices in val_counts.items():
                if len(indices)>=2:
                    for idx in indices:
                        held[idx]= True

            if rank >=2:
                return held

            if personality =="tight":
                high_cards = sorted(enumerate(vals), key = lambda x:x[1], reverse = True)[:3]
            else:
                high_cards = sorted(enumerate(vals), key = lambda x:x[1], reverse = True)[:2]
            for idx, _ in high_cards:
                if idx <len(held):
                    held[idx]= True

            return held

        def npc_decide_fold(hand, bet, npc_name):
            personality = npc_personality_map.get(npc_name, "normal")
            _, rank, _ = evaluate_hand(hand)

            if random.random()<0.1:
                if rank >=4:
                    return True
                elif rank <=1:
                    return False

            if personality =="aggressive":
                if rank >=2:return False
                return random.random()<0.3
            elif personality =="passive":
                if rank >=4:return False
                if rank >=2:return random.random()<0.4
                return random.random()<0.7
            elif personality =="tight":
                if rank >=3:return False
                if rank >=2:return random.random()<0.5
                return random.random()<0.8
            elif personality =="loose":
                if rank >=1:return False
                return random.random()<0.2
            elif personality =="erratic":
                return random.random()<0.35
            else:
                if rank >=3:return False
                if rank ==2:return random.random()<0.2
                if rank ==1:return random.random()<0.5
                return random.random()<0.3

        def display_community_cards():
            if not community_cards_frame:
                return
            for widget in community_cards_frame.winfo_children():
                widget.destroy()
            for card in game_state["community_cards"]:
                img = self._load_card_image(card["suit"], card["value"], size =(60, 84))
                if img:
                    card_label = customtkinter.CTkLabel(community_cards_frame, image = img, text = "")
                    card_label.image = img
                else:
                    text = f"{card['value'][0].upper()}{card['suit'][0].upper()}"
                    card_label = customtkinter.CTkLabel(community_cards_frame, text = text, width = 50, height = 70, fg_color = "white", text_color = "black", corner_radius = 5)
                card_label.pack(side = "left", padx = 3)

        def display_npc_hand(npc_name, reveal = False, show_indices = None):
            if not game_state["ui_valid"]:
                return
            frame_info = npc_frames[npc_name]
            cards_frame = frame_info["cards"]
            status_label = frame_info["status"]

            for widget in cards_frame.winfo_children():
                widget.destroy()

            if game_state["folded"].get(npc_name, False):
                status_label.configure(text = "FOLDED", text_color = "red")
                return

            hand = game_state["npc_hands"].get(npc_name, [])
            for i, card in enumerate(hand):
                show_card = reveal
                if show_indices is not None and i in show_indices:
                    show_card = True

                if show_card:
                    img = self._load_card_image(card["suit"], card["value"], size =(50, 70))
                else:
                    img = self._load_card_image(None, "back", size =(50, 70))

                if img:
                    card_label = customtkinter.CTkLabel(cards_frame, image = img, text = "")
                    card_label.image = img
                else:
                    text = f"{card['value'][0].upper()}{card['suit'][0].upper()}"if show_card else "??"
                    card_label = customtkinter.CTkLabel(cards_frame, text = text, width = 40, height = 56, fg_color = "white", text_color = "black", corner_radius = 3)
                card_label.pack(side = "left", padx = 1)

            if reveal:
                full_hand = hand +game_state.get("community_cards", [])
                hand_name, _, _ = evaluate_hand(full_hand)
                status_label.configure(text = hand_name, text_color = "cyan")
            else:
                status_label.configure(text = "In Game", text_color = "green")

        def display_player_hand(can_hold = False, show_indices = None):
            if not game_state["ui_valid"]:
                return
            for widget in player_cards_frame.winfo_children():
                widget.destroy()

            game_state["card_labels"]=[]
            hand = game_state["player_hand"]

            for i, card in enumerate(hand):
                card_container = customtkinter.CTkFrame(player_cards_frame, fg_color = "transparent")
                card_container.pack(side = "left", padx = 3)

                show_card = True
                if show_indices is not None and i not in show_indices:
                    show_card = True

                if show_card:
                    img = self._load_card_image(card["suit"], card["value"])
                else:
                    img = self._load_card_image(None, "back")

                if img:
                    card_label = customtkinter.CTkLabel(card_container, image = img, text = "")
                    card_label.image = img
                else:
                    text = f"{card['value'][0].upper()}{card['suit'][0].upper()}"if show_card else "??"
                    card_label = customtkinter.CTkLabel(card_container, text = text, width = 60, height = 84, fg_color = "white", text_color = "black", corner_radius = 5)
                card_label.pack()
                game_state["card_labels"].append(card_label)

                if can_hold and variant =="five_card_draw":
                    held_text = "HELD"if game_state["held"][i]else ""
                    hold_label = customtkinter.CTkLabel(card_container, text = held_text, font = customtkinter.CTkFont(size = 10, weight = "bold"), text_color = "yellow")
                    hold_label.pack()

                    def toggle_hold(idx = i, lbl = hold_label):
                        if game_state["phase"]!="draw":
                            return
                        game_state["held"][idx]= not game_state["held"][idx]
                        lbl.configure(text = "HELD"if game_state["held"][idx]else "")
                        self._play_card_sound("place")

                    card_label.bind("<Button-1>", lambda e, idx = i, lbl = hold_label:toggle_hold(idx, lbl))

            full_hand = hand +game_state.get("community_cards", [])
            hand_name, _, _ = evaluate_hand(full_hand)
            player_score_label.configure(text = f"Current: {hand_name}")

            money_label.configure(text = f"Your Money: ${player_money[0]}")
            pot_label.configure(text = f"Pot: ${game_state['pot']}")
            update_money_cb()

        def deal_new_hand():
            if not game_state["ui_valid"]:
                return
            bet_str = bet_entry.get()
            try:
                bet = int(bet_str)
            except ValueError:
                self._popup_show_info("Invalid Bet", "Please enter a valid number.", sound = "error")
                return

            if bet <min_bet or bet >max_bet:
                self._popup_show_info("Invalid Bet", f"Bet must be between ${min_bet} and ${max_bet}.", sound = "error")
                return

            if bet >player_money[0]:
                self._popup_show_info("Insufficient Funds", "You don't have enough money for that bet.", sound = "error")
                return

            game_state["current_bet"]= bet
            game_state["held"]=[False]*7
            game_state["player_folded"]= False
            game_state["community_cards"]=[]
            for name in npc_names:
                game_state["folded"][name]= False
                game_state["npc_held"][name]=[False]*7
            result_label.configure(text = "")

            shuffle_deck()

            if variant =="five_card_draw":
                game_state["player_hand"]=[draw_card()for _ in range(5)]
                for npc_name in npc_names:
                    game_state["npc_hands"][npc_name]=[draw_card()for _ in range(5)]
            elif variant =="five_card_stud":
                game_state["player_hand"]=[draw_card()for _ in range(5)]
                for npc_name in npc_names:
                    game_state["npc_hands"][npc_name]=[draw_card()for _ in range(5)]
            elif variant =="seven_card_stud":
                game_state["player_hand"]=[draw_card()for _ in range(7)]
                for npc_name in npc_names:
                    game_state["npc_hands"][npc_name]=[draw_card()for _ in range(7)]
            elif variant =="texas_holdem":
                game_state["player_hand"]=[draw_card()for _ in range(2)]
                for npc_name in npc_names:
                    game_state["npc_hands"][npc_name]=[draw_card()for _ in range(2)]
                game_state["community_cards"]=[draw_card()for _ in range(5)]

            active_players = 1 +len(npc_names)
            game_state["pot"]= bet *active_players

            for npc_name in npc_names:
                full_hand = game_state["npc_hands"][npc_name]+game_state.get("community_cards", [])
                if npc_decide_fold(full_hand, bet, npc_name):
                    game_state["folded"][npc_name]= True
                    game_state["pot"]-=bet

            if variant =="five_card_draw":
                game_state["phase"]= "draw"
            else:
                game_state["phase"]= "showdown"

            deal_btn.configure(state = "disabled")
            if variant =="five_card_draw":
                if draw_btn:
                    draw_btn.configure(state = "disabled")
            else:
                if show_btn:
                    show_btn.configure(state = "disabled")
            fold_btn.configure(state = "disabled")

            if variant =="texas_holdem":
                display_community_cards()

            deal_order = list(npc_names)+["__player__"]

            def animate_poker_deal(step = 0):
                if not game_state["ui_valid"]:
                    return
                if step >=len(deal_order):
                    update_buttons()
                    if variant =="five_card_draw":
                        result_label.configure(text = "Click cards to hold, then Draw", text_color = "white")
                    else:
                        result_label.configure(text = "Press 'Show Cards' to reveal hands", text_color = "white")
                    return

                name = deal_order[step]
                self._play_card_sound("place")

                if name =="__player__":
                    can_hold = variant =="five_card_draw"
                    display_player_hand(can_hold = can_hold)
                else:
                    if variant =="five_card_stud":
                        display_npc_hand(name, reveal = False, show_indices =[1, 2, 3, 4])
                    elif variant =="seven_card_stud":
                        display_npc_hand(name, reveal = False, show_indices =[2, 3, 4, 5])
                    else:
                        display_npc_hand(name, reveal = False)

                self.root.after(400, lambda:animate_poker_deal(step +1))

            animate_poker_deal(0)

        def draw_new_cards():
            if not game_state["ui_valid"]:
                return
            if game_state["phase"]!="draw":
                return

            if variant =="five_card_draw":
                for i in range(5):
                    if not game_state["held"][i]:
                        game_state["player_hand"][i]= draw_card()

                for npc_name in npc_names:
                    if not game_state["folded"][npc_name]:
                        npc_held = npc_decide_hold(game_state["npc_hands"][npc_name], npc_name)
                        for i in range(5):
                            if not npc_held[i]:
                                game_state["npc_hands"][npc_name][i]= draw_card()

            game_state["phase"]= "showdown"
            display_player_hand(can_hold = False)

            if draw_btn:
                draw_btn.configure(state = "disabled")
            fold_btn.configure(state = "disabled")

            active_npcs =[n for n in npc_names if not game_state["folded"][n]]

            def reveal_after_draw(step = 0):
                if not game_state["ui_valid"]:
                    return
                if step >=len(active_npcs):
                    determine_winner()
                    update_buttons()
                    return
                self._play_card_sound("flip")
                display_npc_hand(active_npcs[step], reveal = True)
                self.root.after(400, lambda:reveal_after_draw(step +1))

            reveal_after_draw(0)

        def show_cards():
            if not game_state["ui_valid"]:
                return
            game_state["phase"]= "complete"
            display_player_hand(can_hold = False)

            if show_btn:
                show_btn.configure(state = "disabled")
            fold_btn.configure(state = "disabled")

            active_npcs =[n for n in npc_names if not game_state["folded"][n]]

            def reveal_step(step = 0):
                if not game_state["ui_valid"]:
                    return
                if step >=len(active_npcs):
                    determine_winner()
                    update_buttons()
                    return
                self._play_card_sound("flip")
                display_npc_hand(active_npcs[step], reveal = True)
                self.root.after(400, lambda:reveal_step(step +1))

            reveal_step(0)

        def fold_hand():
            if not game_state["ui_valid"]:
                return
            if game_state["phase"]not in["draw", "showdown"]:
                return
            game_state["player_folded"]= True
            game_state["phase"]= "complete"

            loss = -game_state["current_bet"]
            if record_game_cb:
                record_game_cb(loss)

            item_suffix = ""
            if wagered_items:
                self._process_item_bet_loss(save_data, save_path, wagered_items)
                item_suffix = f" | Lost {len(wagered_items)} item(s)"
                wagered_items.clear()
                item_bet_value[0] = 0
                try:
                    item_wager_label.configure(text = "Items Wagered: None", text_color = "gray")
                except Exception:
                    pass

            save_money_cb()

            active_npcs =[n for n in npc_names if not game_state["folded"][n]]
            if active_npcs:
                for npc_name in npc_names:
                    display_npc_hand(npc_name, reveal = True)
                result_label.configure(text = f"You folded. {active_npcs[0]} wins the pot!{item_suffix}", text_color = "red")
            else:
                result_label.configure(text = f"Everyone folded!{item_suffix}", text_color = "orange")

            update_buttons()
            money_label.configure(text = f"Your Money: ${player_money[0]}")
            update_money_cb()

        def determine_winner():
            if not game_state["ui_valid"]:
                return
            player_full_hand = game_state["player_hand"]+game_state.get("community_cards", [])
            player_eval = evaluate_hand(player_full_hand)
            best_hand =("You", player_eval)

            for npc_name in npc_names:
                if not game_state["folded"][npc_name]:
                    npc_full_hand = game_state["npc_hands"][npc_name]+game_state.get("community_cards", [])
                    npc_eval = evaluate_hand(npc_full_hand)
                    if npc_eval[1]>best_hand[1][1]:
                        best_hand =(npc_name, npc_eval)
                    elif npc_eval[1]==best_hand[1][1]:
                        if npc_eval[2]>best_hand[1][2]:
                            best_hand =(npc_name, npc_eval)

            winner_name = best_hand[0]
            winner_hand = best_hand[1][0]
            pot = game_state["pot"]

            if winner_name =="You":
                winnings = pot -game_state["current_bet"]
                player_money[0]+=winnings
                if wagered_items:
                    player_money[0] += item_bet_value[0]
                if record_game_cb:
                    record_game_cb(winnings)
                item_suffix = ""
                if item_bet_value[0] > 0 and wagered_items:
                    item_suffix = f" | +${item_bet_value[0]} from items"
                result_label.configure(text = f"You win with {winner_hand}! +${winnings + (item_bet_value[0] if wagered_items else 0)}{item_suffix}", text_color = "green")
            else:
                loss = -game_state["current_bet"]
                player_money[0]-=game_state["current_bet"]
                if record_game_cb:
                    record_game_cb(loss)
                item_suffix = ""
                if wagered_items:
                    self._process_item_bet_loss(save_data, save_path, wagered_items)
                    item_suffix = f" | Lost {len(wagered_items)} item(s)"
                result_label.configure(text = f"{winner_name} wins with {winner_hand}! -${game_state['current_bet']}{item_suffix}", text_color = "red")

            wagered_items.clear()
            item_bet_value[0] = 0
            try:
                item_wager_label.configure(text = "Items Wagered: None", text_color = "gray")
            except Exception:
                pass

            save_money_cb()
            game_state["phase"]= "complete"
            money_label.configure(text = f"Your Money: ${player_money[0]}")
            update_money_cb()

        def update_buttons():
            if not game_state["ui_valid"]:
                return
            try:
                if game_state["phase"]=="betting":
                    deal_btn.configure(state = "normal")
                    if variant =="five_card_draw":
                        draw_btn.configure(state = "disabled")
                    else:
                        show_btn.configure(state = "disabled")
                    fold_btn.configure(state = "disabled")
                elif game_state["phase"]=="draw":
                    deal_btn.configure(state = "disabled")
                    if variant =="five_card_draw":
                        draw_btn.configure(state = "normal")
                    fold_btn.configure(state = "normal")
                elif game_state["phase"]=="showdown":
                    deal_btn.configure(state = "disabled")
                    if variant !="five_card_draw":
                        show_btn.configure(state = "normal")
                    fold_btn.configure(state = "normal")
                else:
                    deal_btn.configure(state = "normal")
                    if variant =="five_card_draw":
                        draw_btn.configure(state = "disabled")
                    else:
                        show_btn.configure(state = "disabled")
                    fold_btn.configure(state = "disabled")
            except Exception:
                pass

        def show_hand_rankings():
            popup = customtkinter.CTkToplevel(self.root)
            popup.title("Poker Hand Rankings")
            popup.transient(self.root)
            popup.grab_set()
            popup.withdraw()

            scroll_frame = customtkinter.CTkScrollableFrame(popup, width = 500, height = 500)
            scroll_frame.pack(fill = "both", expand = True, padx = 10, pady = 10)

            title_lbl = customtkinter.CTkLabel(scroll_frame, text = "Poker Hand Rankings", font = customtkinter.CTkFont(size = 18, weight = "bold"))
            title_lbl.pack(pady =(5, 15))

            example_hands =[
            ("1.Royal Flush", "A, K, Q, J, 10 all same suit", [("hearts", "ace"), ("hearts", "king"), ("hearts", "queen"), ("hearts", "jack"), ("hearts", "10")]),
            ("2.Straight Flush", "Five sequential cards, same suit", [("spades", "9"), ("spades", "8"), ("spades", "7"), ("spades", "6"), ("spades", "5")]),
            ("3.Four of a Kind", "Four cards of same rank", [("hearts", "king"), ("diamonds", "king"), ("clubs", "king"), ("spades", "king"), ("hearts", "3")]),
            ("4.Full House", "Three of a kind + a pair", [("hearts", "queen"), ("diamonds", "queen"), ("clubs", "queen"), ("spades", "7"), ("hearts", "7")]),
            ("5.Flush", "Five cards of same suit", [("diamonds", "ace"), ("diamonds", "jack"), ("diamonds", "8"), ("diamonds", "5"), ("diamonds", "2")]),
            ("6.Straight", "Five sequential cards, any suit", [("hearts", "10"), ("diamonds", "9"), ("clubs", "8"), ("spades", "7"), ("hearts", "6")]),
            ("7.Three of a Kind", "Three cards of same rank", [("hearts", "8"), ("diamonds", "8"), ("clubs", "8"), ("spades", "king"), ("hearts", "4")]),
            ("8.Two Pair", "Two different pairs", [("hearts", "jack"), ("diamonds", "jack"), ("clubs", "5"), ("spades", "5"), ("hearts", "2")]),
            ("9.Pair", "Two cards of same rank", [("hearts", "ace"), ("diamonds", "ace"), ("clubs", "9"), ("spades", "6"), ("hearts", "3")]),
            ("10.High Card", "Highest card wins", [("hearts", "ace"), ("diamonds", "king"), ("clubs", "9"), ("spades", "5"), ("hearts", "2")]),
            ]

            for hand_name, description, cards in example_hands:
                hand_frame = customtkinter.CTkFrame(scroll_frame, fg_color = "transparent")
                hand_frame.pack(pady = 8, fill = "x")
                name_lbl = customtkinter.CTkLabel(hand_frame, text = hand_name, font = customtkinter.CTkFont(size = 14, weight = "bold"))
                name_lbl.pack(anchor = "w")
                desc_lbl = customtkinter.CTkLabel(hand_frame, text = description, font = customtkinter.CTkFont(size = 11), text_color = "gray")
                desc_lbl.pack(anchor = "w")
                cards_row = customtkinter.CTkFrame(hand_frame, fg_color = "transparent")
                cards_row.pack(anchor = "w", pady = 3)
                for suit, value in cards:
                    img = self._load_card_image(suit, value, size =(45, 63))
                    if img:
                        card_lbl = customtkinter.CTkLabel(cards_row, image = img, text = "")
                        card_lbl.image = img
                    else:
                        card_lbl = customtkinter.CTkLabel(cards_row, text = f"{value[0].upper()}{suit[0].upper()}", width = 35, height = 49, fg_color = "white", text_color = "black", corner_radius = 3)
                    card_lbl.pack(side = "left", padx = 1)

            close_btn = customtkinter.CTkButton(scroll_frame, text = "Close", command = popup.destroy, width = 100)
            close_btn.pack(pady = 15)
            self._play_ui_sound("click")
            popup.update_idletasks()
            w, h = 540, 600
            x = self.root.winfo_x()+(self.root.winfo_width()//2)-(w //2)
            y = self.root.winfo_y()+(self.root.winfo_height()//2)-(h //2)
            popup.geometry(f"{w}x{h}+{x}+{y}")
            popup.deiconify()

        controls_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        controls_frame.grid(row = 2, column = 0, sticky = "ew", padx = 20, pady = 10)

        bet_frame = customtkinter.CTkFrame(controls_frame, fg_color = "transparent")
        bet_frame.pack(pady = 5)

        bet_label_entry = customtkinter.CTkLabel(bet_frame, text = "Bet Amount: $", font = customtkinter.CTkFont(size = 14))
        bet_label_entry.pack(side = "left")

        bet_entry = customtkinter.CTkEntry(bet_frame, width = 100, placeholder_text = str(min_bet))
        bet_entry.pack(side = "left", padx = 5)
        bet_entry.insert(0, str(min_bet))

        if save_data and save_path:
            item_wager_label = customtkinter.CTkLabel(bet_frame, text = "Items Wagered: None", font = customtkinter.CTkFont(size = 11), text_color = "gray")
            item_wager_label.pack(side = "left", padx = 10)

            def update_item_wager_display():
                total = sum(int(e["item"].get("value", 0)) for e in wagered_items)
                item_bet_value[0] = total
                if wagered_items:
                    item_wager_label.configure(text = f"Items Wagered: {len(wagered_items)} (${total})", text_color = "gold")
                else:
                    item_wager_label.configure(text = "Items Wagered: None", text_color = "gray")

            def open_item_wager():
                if game_state["phase"] not in ["betting", "complete"]:
                    self._popup_show_info("Game Active", "Cannot change item wager during a game.", sound = "popup")
                    return
                self._open_item_bet_dialog(save_data, wagered_items, update_item_wager_display)

            wager_btn = self._create_sound_button(bet_frame, "Wager Items", open_item_wager, width = 110, height = 30, font = customtkinter.CTkFont(size = 11), fg_color = "#8B4513", hover_color = "#654321")
            wager_btn.pack(side = "left", padx = 5)

        action_frame = customtkinter.CTkFrame(controls_frame, fg_color = "transparent")
        action_frame.pack(pady = 10)

        deal_btn = self._create_sound_button(action_frame, "Deal", deal_new_hand, width = 100, height = 40, font = customtkinter.CTkFont(size = 14))
        deal_btn.pack(side = "left", padx = 5)

        if variant =="five_card_draw":
            draw_btn = self._create_sound_button(action_frame, "Draw", draw_new_cards, width = 100, height = 40, font = customtkinter.CTkFont(size = 14))
            draw_btn.pack(side = "left", padx = 5)
            draw_btn.configure(state = "disabled")
            show_btn = None
        else:
            show_btn = self._create_sound_button(action_frame, "Show Cards", show_cards, width = 100, height = 40, font = customtkinter.CTkFont(size = 14))
            show_btn.pack(side = "left", padx = 5)
            show_btn.configure(state = "disabled")
            draw_btn = None

        fold_btn = self._create_sound_button(action_frame, "Fold", fold_hand, width = 100, height = 40, font = customtkinter.CTkFont(size = 14))
        fold_btn.pack(side = "left", padx = 5)
        fold_btn.configure(state = "disabled")

        hands_btn = self._create_sound_button(action_frame, "Hand Rankings", show_hand_rankings, width = 120, height = 40, font = customtkinter.CTkFont(size = 12))
        hands_btn.pack(side = "left", padx = 5)

        def back_to_poker_lobby():
            game_state["ui_valid"]= False
            self._open_poker_lobby(store, player_money, update_money_cb, save_money_cb, min_bet, max_bet, music_channel, table_data, record_game_cb, casino_stats, save_data = save_data, save_path = save_path)

        back_btn = self._create_sound_button(controls_frame, "Back to Poker Lobby", back_to_poker_lobby, width = 200, height = 40, font = customtkinter.CTkFont(size = 14))
        back_btn.pack(pady = 10)

    def _open_highlow_game(self, store, player_money, update_money_cb, save_money_cb, min_bet, max_bet, music_channel, table_data, record_game_cb = None, casino_stats = None, save_data = None, save_path = None):
        self._clear_window()

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew")
        main_frame.grid_columnconfigure(0, weight = 1)
        main_frame.grid_rowconfigure(1, weight = 1)

        header_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        header_frame.grid(row = 0, column = 0, sticky = "ew", padx = 20, pady = 10)

        title_label = customtkinter.CTkLabel(header_frame, text = "High-Low", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title_label.pack(pady =(10, 5))

        money_label = customtkinter.CTkLabel(header_frame, text = f"Your Money: ${player_money[0]}", font = customtkinter.CTkFont(size = 16, weight = "bold"), text_color = "green")
        money_label.pack(pady = 5)

        bet_label = customtkinter.CTkLabel(header_frame, text = f"Bet Range: ${min_bet} - ${max_bet}", font = customtkinter.CTkFont(size = 12), text_color = "orange")
        bet_label.pack()

        game_frame = customtkinter.CTkFrame(main_frame)
        game_frame.grid(row = 1, column = 0, sticky = "nsew", padx = 20, pady = 10)
        game_frame.grid_columnconfigure(0, weight = 1)

        suits =["clubs", "diamonds", "hearts", "spades"]
        values =["2", "3", "4", "5", "6", "7", "8", "9", "10", "jack", "queen", "king", "ace"]

        deck =[{"suit":s, "value":v}for s in suits for v in values]
        game_state = {
        "deck":[],
        "current_card":None,
        "next_card":None,
        "current_bet":0,
        "streak":0,
        "winnings":0,
        "game_active":False,
        "ui_valid":True
        }

        wagered_items = []
        item_bet_value = [0]

        instruction_label = customtkinter.CTkLabel(game_frame, text = "Guess if the next card will be Higher or Lower!", font = customtkinter.CTkFont(size = 14), text_color = "gray")
        instruction_label.pack(pady = 10)

        cards_frame = customtkinter.CTkFrame(game_frame, fg_color = "transparent")
        cards_frame.pack(pady = 20)

        current_card_frame = customtkinter.CTkFrame(cards_frame, fg_color = "transparent")
        current_card_frame.pack(side = "left", padx = 20)
        current_label = customtkinter.CTkLabel(current_card_frame, text = "Current Card", font = customtkinter.CTkFont(size = 12, weight = "bold"))
        current_label.pack()
        current_card_display = customtkinter.CTkLabel(current_card_frame, text = "", width = 80, height = 112)
        current_card_display.pack(pady = 5)

        arrow_label = customtkinter.CTkLabel(cards_frame, text = "â†’", font = customtkinter.CTkFont(size = 36, weight = "bold"))
        arrow_label.pack(side = "left", padx = 10)

        next_card_frame = customtkinter.CTkFrame(cards_frame, fg_color = "transparent")
        next_card_frame.pack(side = "left", padx = 20)
        next_label = customtkinter.CTkLabel(next_card_frame, text = "Next Card", font = customtkinter.CTkFont(size = 12, weight = "bold"))
        next_label.pack()
        next_card_display = customtkinter.CTkLabel(next_card_frame, text = "", width = 80, height = 112)
        next_card_display.pack(pady = 5)

        streak_label = customtkinter.CTkLabel(game_frame, text = "Streak: 0", font = customtkinter.CTkFont(size = 16, weight = "bold"), text_color = "cyan")
        streak_label.pack(pady = 5)

        winnings_label = customtkinter.CTkLabel(game_frame, text = "Current Winnings: $0", font = customtkinter.CTkFont(size = 14), text_color = "gold")
        winnings_label.pack(pady = 5)

        result_label = customtkinter.CTkLabel(game_frame, text = "", font = customtkinter.CTkFont(size = 18, weight = "bold"))
        result_label.pack(pady = 10)

        def get_card_rank(card):
            v = card["value"]
            if v =="ace":
                return 14
            elif v =="king":
                return 13
            elif v =="queen":
                return 12
            elif v =="jack":
                return 11
            else:
                return int(v)

        def shuffle_deck():
            game_state["deck"]= deck.copy()
            random.shuffle(game_state["deck"])
            self._play_card_sound("shuffle")

        def draw_card():
            if not game_state["deck"]:
                shuffle_deck()
            card = game_state["deck"].pop()
            self._play_card_sound("flip")
            return card

        def display_card(label, card, hidden = False):
            if not game_state["ui_valid"]:
                return
            if hidden:
                img = self._load_card_image(None, "back")
            elif card:
                img = self._load_card_image(card["suit"], card["value"])
            else:
                img = None

            if img:
                label.configure(image = img, text = "")
                label.image = img
            elif card and not hidden:
                text = f"{card['value'][0].upper()}{card['suit'][0].upper()}"
                label.configure(image = None, text = text, fg_color = "white", text_color = "black")
            else:
                label.configure(image = None, text = "??", fg_color = "gray30", text_color = "white")

        def update_display():
            if not game_state["ui_valid"]:
                return
            try:
                money_label.configure(text = f"Your Money: ${player_money[0]}")
                streak_label.configure(text = f"Streak: {game_state['streak']}")
                winnings_label.configure(text = f"Current Winnings: ${game_state['winnings']}")
                update_money_cb()
            except Exception:
                pass

        def start_game():
            bet_str = bet_entry.get()
            try:
                bet = int(bet_str)
            except ValueError:
                self._popup_show_info("Invalid Bet", "Please enter a valid number.", sound = "error")
                return

            if bet <min_bet or bet >max_bet:
                self._popup_show_info("Invalid Bet", f"Bet must be between ${min_bet} and ${max_bet}.", sound = "error")
                return

            if bet >player_money[0]:
                self._popup_show_info("Insufficient Funds", "You don't have enough money for that bet.", sound = "error")
                return

            game_state["current_bet"]= bet
            game_state["streak"]= 0
            game_state["winnings"]= 0
            game_state["game_active"]= True
            result_label.configure(text = "")

            shuffle_deck()
            game_state["current_card"]= draw_card()
            game_state["next_card"]= None

            display_card(current_card_display, game_state["current_card"])
            display_card(next_card_display, None, hidden = True)

            update_display()
            update_buttons()

        def guess_high():
            if not game_state["game_active"]:
                return
            make_guess("high")

        def guess_low():
            if not game_state["game_active"]:
                return
            make_guess("low")

        def make_guess(guess):
            if not game_state["ui_valid"]:
                return

            game_state["next_card"]= draw_card()
            display_card(next_card_display, game_state["next_card"])

            current_rank = get_card_rank(game_state["current_card"])
            next_rank = get_card_rank(game_state["next_card"])

            if next_rank ==current_rank:
                result_label.configure(text = "It's a Tie! Push - no win or loss.", text_color = "orange")
                game_state["current_card"]= game_state["next_card"]
                self.root.after(1500, continue_or_end)
            elif(guess =="high"and next_rank >current_rank)or(guess =="low"and next_rank <current_rank):
                game_state["streak"]+=1
                multiplier = 1 +(game_state["streak"]-1)*0.5
                round_win = int(game_state["current_bet"]*multiplier)
                game_state["winnings"]+=round_win
                result_label.configure(text = f"Correct! +${round_win}(Streak: {game_state['streak']}x)", text_color = "green")
                game_state["current_card"]= game_state["next_card"]
                update_display()
                self.root.after(1500, continue_or_end)
            else:
                end_game_loss()

        def continue_or_end():
            if not game_state["ui_valid"]:
                return
            display_card(current_card_display, game_state["current_card"])
            display_card(next_card_display, None, hidden = True)
            result_label.configure(text = "Keep going or Cash Out!", text_color = "cyan")
            update_buttons()

        def cash_out():
            if not game_state["game_active"]or game_state["winnings"]<=0:
                return

            winnings = game_state["winnings"]
            player_money[0]+=winnings
            if wagered_items:
                player_money[0] += item_bet_value[0]
            if record_game_cb:
                record_game_cb(winnings)
            save_money_cb()

            game_state["game_active"]= False
            item_suffix = ""
            if item_bet_value[0] > 0 and wagered_items:
                item_suffix = f" | +${item_bet_value[0]} from items"
            result_label.configure(text = f"Cashed Out! +${winnings + (item_bet_value[0] if wagered_items else 0)}{item_suffix}", text_color = "green")
            wagered_items.clear()
            item_bet_value[0] = 0
            try:
                item_wager_label.configure(text = "Items Wagered: None", text_color = "gray")
            except Exception:
                pass
            update_display()
            update_buttons()

        def end_game_loss():
            if not game_state["ui_valid"]:
                return

            loss = -game_state["current_bet"]
            player_money[0]+=loss
            if record_game_cb:
                record_game_cb(loss)

            item_suffix = ""
            if wagered_items:
                self._process_item_bet_loss(save_data, save_path, wagered_items)
                item_suffix = f" | Lost {len(wagered_items)} item(s)"
                wagered_items.clear()
                item_bet_value[0] = 0
                try:
                    item_wager_label.configure(text = "Items Wagered: None", text_color = "gray")
                except Exception:
                    pass

            save_money_cb()

            game_state["game_active"]= False
            result_label.configure(text = f"Wrong! You lose ${game_state['current_bet']}{item_suffix}", text_color = "red")
            game_state["streak"]= 0
            game_state["winnings"]= 0
            update_display()
            update_buttons()

        def update_buttons():
            if not game_state["ui_valid"]:
                return
            try:
                if game_state["game_active"]:
                    start_btn.configure(state = "disabled")
                    high_btn.configure(state = "normal")
                    low_btn.configure(state = "normal")
                    cashout_btn.configure(state = "normal"if game_state["winnings"]>0 else "disabled")
                else:
                    start_btn.configure(state = "normal")
                    high_btn.configure(state = "disabled")
                    low_btn.configure(state = "disabled")
                    cashout_btn.configure(state = "disabled")
            except Exception:
                pass

        controls_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        controls_frame.grid(row = 2, column = 0, sticky = "ew", padx = 20, pady = 10)

        bet_frame = customtkinter.CTkFrame(controls_frame, fg_color = "transparent")
        bet_frame.pack(pady = 5)

        bet_label_entry = customtkinter.CTkLabel(bet_frame, text = "Bet Amount: $", font = customtkinter.CTkFont(size = 14))
        bet_label_entry.pack(side = "left")

        bet_entry = customtkinter.CTkEntry(bet_frame, width = 100, placeholder_text = str(min_bet))
        bet_entry.pack(side = "left", padx = 5)
        bet_entry.insert(0, str(min_bet))

        if save_data and save_path:
            item_wager_label = customtkinter.CTkLabel(bet_frame, text = "Items Wagered: None", font = customtkinter.CTkFont(size = 11), text_color = "gray")
            item_wager_label.pack(side = "left", padx = 10)

            def update_item_wager_display():
                total = sum(int(e["item"].get("value", 0)) for e in wagered_items)
                item_bet_value[0] = total
                if wagered_items:
                    item_wager_label.configure(text = f"Items Wagered: {len(wagered_items)} (${total})", text_color = "gold")
                else:
                    item_wager_label.configure(text = "Items Wagered: None", text_color = "gray")

            def open_item_wager():
                if game_state["game_active"]:
                    self._popup_show_info("Game Active", "Cannot change item wager during a game.", sound = "popup")
                    return
                self._open_item_bet_dialog(save_data, wagered_items, update_item_wager_display)

            wager_btn = self._create_sound_button(bet_frame, "Wager Items", open_item_wager, width = 110, height = 30, font = customtkinter.CTkFont(size = 11), fg_color = "#8B4513", hover_color = "#654321")
            wager_btn.pack(side = "left", padx = 5)

        action_frame = customtkinter.CTkFrame(controls_frame, fg_color = "transparent")
        action_frame.pack(pady = 10)

        start_btn = self._create_sound_button(action_frame, "Start", start_game, width = 100, height = 40, font = customtkinter.CTkFont(size = 14))
        start_btn.pack(side = "left", padx = 5)

        high_btn = self._create_sound_button(action_frame, "Higher", guess_high, width = 100, height = 40, font = customtkinter.CTkFont(size = 14), fg_color = "green", hover_color = "darkgreen")
        high_btn.pack(side = "left", padx = 5)
        high_btn.configure(state = "disabled")

        low_btn = self._create_sound_button(action_frame, "Lower", guess_low, width = 100, height = 40, font = customtkinter.CTkFont(size = 14), fg_color = "red", hover_color = "darkred")
        low_btn.pack(side = "left", padx = 5)
        low_btn.configure(state = "disabled")

        cashout_btn = self._create_sound_button(action_frame, "Cash Out", cash_out, width = 100, height = 40, font = customtkinter.CTkFont(size = 14), fg_color = "gold", hover_color = "darkgoldenrod", text_color = "black")
        cashout_btn.pack(side = "left", padx = 5)
        cashout_btn.configure(state = "disabled")

        def back_to_casino():
            game_state["ui_valid"]= False
            self._open_casino_interface(store, table_data)

        back_btn = self._create_sound_button(controls_frame, "Back to Casino", back_to_casino, width = 200, height = 40, font = customtkinter.CTkFont(size = 14))
        back_btn.pack(pady = 10)

    def _open_roulette_game(self, store, player_money, update_money_cb, save_money_cb, min_bet, max_bet, music_channel, table_data, record_game_cb = None, casino_stats = None, save_data = None, save_path = None):
        self._clear_window()

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew")
        main_frame.grid_columnconfigure(0, weight = 1)
        main_frame.grid_rowconfigure(1, weight = 1)

        header_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        header_frame.grid(row = 0, column = 0, sticky = "ew", padx = 20, pady = 10)

        title_label = customtkinter.CTkLabel(header_frame, text = "Roulette", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title_label.pack(pady =(10, 5))

        money_label = customtkinter.CTkLabel(header_frame, text = f"Your Money: ${player_money[0]}", font = customtkinter.CTkFont(size = 16, weight = "bold"), text_color = "green")
        money_label.pack(pady = 5)

        bet_label = customtkinter.CTkLabel(header_frame, text = f"Bet Range: ${min_bet} - ${max_bet}", font = customtkinter.CTkFont(size = 12), text_color = "orange")
        bet_label.pack()

        game_frame = customtkinter.CTkFrame(main_frame)
        game_frame.grid(row = 1, column = 0, sticky = "nsew", padx = 20, pady = 10)
        game_frame.grid_columnconfigure(0, weight = 1)

        roulette_numbers =[
        (0, "green"), (32, "red"), (15, "black"), (19, "red"), (4, "black"), (21, "red"), (2, "black"),
        (25, "red"), (17, "black"), (34, "red"), (6, "black"), (27, "red"), (13, "black"), (36, "red"),
        (11, "black"), (30, "red"), (8, "black"), (23, "red"), (10, "black"), (5, "red"), (24, "black"),
        (16, "red"), (33, "black"), (1, "red"), (20, "black"), (14, "red"), (31, "black"), (9, "red"),
        (22, "black"), (18, "red"), (29, "black"), (7, "red"), (28, "black"), (12, "red"), (35, "black"),
        (3, "red"), (26, "black")
        ]

        game_state = {
        "current_bet":0,
        "bet_type":None,
        "bet_value":None,
        "spinning":False,
        "ui_valid":True
        }

        wagered_items = []
        item_bet_value = [0]

        wheel_label = customtkinter.CTkLabel(game_frame, text = "Place Your Bet", font = customtkinter.CTkFont(size = 32, weight = "bold"))
        wheel_label.pack(pady = 20)

        result_label = customtkinter.CTkLabel(game_frame, text = "", font = customtkinter.CTkFont(size = 18, weight = "bold"))
        result_label.pack(pady = 10)

        bet_types_frame = customtkinter.CTkFrame(game_frame, fg_color = "transparent")
        bet_types_frame.pack(pady = 10)

        selected_bet =[None, None]

        def select_bet_type(bet_type, bet_value, btn):
            if game_state["spinning"]:
                return
            selected_bet[0]= bet_type
            selected_bet[1]= bet_value
            result_label.configure(text = f"Selected: {bet_type} - {bet_value}", text_color = "cyan")
            self._play_ui_sound("click")

        color_frame = customtkinter.CTkFrame(bet_types_frame, fg_color = "transparent")
        color_frame.pack(pady = 5)
        customtkinter.CTkLabel(color_frame, text = "Color Bets(2x):", font = customtkinter.CTkFont(size = 12)).pack(side = "left", padx = 5)
        red_btn = self._create_sound_button(color_frame, "Red", lambda:select_bet_type("Color", "red", red_btn), width = 80, height = 35, fg_color = "#8B0000", hover_color = "#5C0000")
        red_btn.pack(side = "left", padx = 3)
        black_btn = self._create_sound_button(color_frame, "Black", lambda:select_bet_type("Color", "black", black_btn), width = 80, height = 35, fg_color = "#1a1a1a", hover_color = "#333333")
        black_btn.pack(side = "left", padx = 3)
        green_btn = self._create_sound_button(color_frame, "Green(0)", lambda:select_bet_type("Color", "green", green_btn), width = 80, height = 35, fg_color = "#006400", hover_color = "#004d00")
        green_btn.pack(side = "left", padx = 3)

        parity_frame = customtkinter.CTkFrame(bet_types_frame, fg_color = "transparent")
        parity_frame.pack(pady = 5)
        customtkinter.CTkLabel(parity_frame, text = "Parity Bets(2x):", font = customtkinter.CTkFont(size = 12)).pack(side = "left", padx = 5)
        odd_btn = self._create_sound_button(parity_frame, "Odd", lambda:select_bet_type("Parity", "odd", odd_btn), width = 80, height = 35)
        odd_btn.pack(side = "left", padx = 3)
        even_btn = self._create_sound_button(parity_frame, "Even", lambda:select_bet_type("Parity", "even", even_btn), width = 80, height = 35)
        even_btn.pack(side = "left", padx = 3)

        range_frame = customtkinter.CTkFrame(bet_types_frame, fg_color = "transparent")
        range_frame.pack(pady = 5)
        customtkinter.CTkLabel(range_frame, text = "Range Bets(2x):", font = customtkinter.CTkFont(size = 12)).pack(side = "left", padx = 5)
        low_btn = self._create_sound_button(range_frame, "1-18", lambda:select_bet_type("Range", "low", low_btn), width = 80, height = 35)
        low_btn.pack(side = "left", padx = 3)
        high_btn = self._create_sound_button(range_frame, "19-36", lambda:select_bet_type("Range", "high", high_btn), width = 80, height = 35)
        high_btn.pack(side = "left", padx = 3)

        dozen_frame = customtkinter.CTkFrame(bet_types_frame, fg_color = "transparent")
        dozen_frame.pack(pady = 5)
        customtkinter.CTkLabel(dozen_frame, text = "Dozen Bets(3x):", font = customtkinter.CTkFont(size = 12)).pack(side = "left", padx = 5)
        first_btn = self._create_sound_button(dozen_frame, "1-12", lambda:select_bet_type("Dozen", "first", first_btn), width = 70, height = 35)
        first_btn.pack(side = "left", padx = 3)
        second_btn = self._create_sound_button(dozen_frame, "13-24", lambda:select_bet_type("Dozen", "second", second_btn), width = 70, height = 35)
        second_btn.pack(side = "left", padx = 3)
        third_btn = self._create_sound_button(dozen_frame, "25-36", lambda:select_bet_type("Dozen", "third", third_btn), width = 70, height = 35)
        third_btn.pack(side = "left", padx = 3)

        number_frame = customtkinter.CTkFrame(bet_types_frame, fg_color = "transparent")
        number_frame.pack(pady = 5)
        customtkinter.CTkLabel(number_frame, text = "Straight(36x):", font = customtkinter.CTkFont(size = 12)).pack(side = "left", padx = 5)
        number_entry = customtkinter.CTkEntry(number_frame, width = 60, placeholder_text = "0-36")
        number_entry.pack(side = "left", padx = 3)
        def select_number():
            try:
                num = int(number_entry.get())
                if 0 <=num <=36:
                    select_bet_type("Straight", num, None)
                else:
                    self._popup_show_info("Invalid", "Enter a number 0-36", sound = "error")
            except:
                self._popup_show_info("Invalid", "Enter a number 0-36", sound = "error")
        num_btn = self._create_sound_button(number_frame, "Select", select_number, width = 60, height = 35)
        num_btn.pack(side = "left", padx = 3)

        def play_roulette_tick():
            try:
                tick_path = os.path.join(os.path.dirname(__file__), "sounds", "misc", "roulette", "roulettetick.ogg")
                if os.path.exists(tick_path):
                    sound = pygame.mixer.Sound(tick_path)
                    sound.set_volume(0.5)
                    sound.play()
            except Exception:
                pass

        def spin_wheel():
            if game_state["spinning"]:
                return

            if selected_bet[0]is None:
                self._popup_show_info("No Bet", "Please select a bet type first.", sound = "error")
                return

            bet_str = bet_entry.get()
            try:
                bet = int(bet_str)
            except ValueError:
                self._popup_show_info("Invalid Bet", "Please enter a valid number.", sound = "error")
                return

            if bet <min_bet or bet >max_bet:
                self._popup_show_info("Invalid Bet", f"Bet must be between ${min_bet} and ${max_bet}.", sound = "error")
                return

            if bet >player_money[0]:
                self._popup_show_info("Insufficient Funds", "You don't have enough money for that bet.", sound = "error")
                return

            game_state["current_bet"]= bet
            game_state["bet_type"]= selected_bet[0]
            game_state["bet_value"]= selected_bet[1]
            game_state["spinning"]= True
            spin_btn.configure(state = "disabled")

            winning_idx = random.randint(0, len(roulette_numbers)-1)
            winning_number, winning_color = roulette_numbers[winning_idx]

            spin_duration = random.randint(60, 90)
            current_idx =[0]
            spins_done =[0]

            def animate_spin():
                if not game_state["ui_valid"]:
                    return

                if spins_done[0]>=spin_duration:
                    current_idx[0]= winning_idx
                    num, col = roulette_numbers[current_idx[0]]
                    color_code = "#ff0000"if col =="red"else("#000000"if col =="black"else "#00ff00")
                    wheel_label.configure(text = f"{num}", text_color = color_code)
                    determine_result(winning_number, winning_color)
                    return

                play_roulette_tick()
                current_idx[0]=(current_idx[0]+1)%len(roulette_numbers)
                num, col = roulette_numbers[current_idx[0]]
                color_code = "#ff0000"if col =="red"else("#000000"if col =="black"else "#00ff00")
                wheel_label.configure(text = f"{num}", text_color = color_code)
                spins_done[0]+=1

                delay = 50 +(spins_done[0]*5)
                self.root.after(delay, animate_spin)

            animate_spin()

        def determine_result(number, color):
            bet_type = game_state["bet_type"]
            bet_value = game_state["bet_value"]
            bet = game_state["current_bet"]
            won = False
            multiplier = 0

            if bet_type =="Color":
                if bet_value ==color:
                    won = True
                    multiplier = 2 if color !="green"else 35

            elif bet_type =="Parity":
                if number !=0:
                    is_odd = number %2 ==1
                    if(bet_value =="odd"and is_odd)or(bet_value =="even"and not is_odd):
                        won = True
                        multiplier = 2

            elif bet_type =="Range":
                if number !=0:
                    if(bet_value =="low"and 1 <=number <=18)or(bet_value =="high"and 19 <=number <=36):
                        won = True
                        multiplier = 2

            elif bet_type =="Dozen":
                if bet_value =="first"and 1 <=number <=12:
                    won = True
                    multiplier = 3
                elif bet_value =="second"and 13 <=number <=24:
                    won = True
                    multiplier = 3
                elif bet_value =="third"and 25 <=number <=36:
                    won = True
                    multiplier = 3

            elif bet_type =="Straight":
                if number ==bet_value:
                    won = True
                    multiplier = 36

            if won:
                winnings = bet *(multiplier -1)
                player_money[0]+=winnings
                if wagered_items:
                    player_money[0] += item_bet_value[0]
                if record_game_cb:
                    record_game_cb(winnings)
                item_suffix = ""
                if item_bet_value[0] > 0 and wagered_items:
                    item_suffix = f" | +${item_bet_value[0]} from items"
                result_label.configure(text = f"Winner! {number}({color}) - +${winnings + (item_bet_value[0] if wagered_items else 0)}{item_suffix}", text_color = "green")
            else:
                player_money[0]-=bet
                if record_game_cb:
                    record_game_cb(-bet)
                item_suffix = ""
                if wagered_items:
                    self._process_item_bet_loss(save_data, save_path, wagered_items)
                    item_suffix = f" | Lost {len(wagered_items)} item(s)"
                result_label.configure(text = f"Lost! {number}({color}) - -${bet}{item_suffix}", text_color = "red")

            wagered_items.clear()
            item_bet_value[0] = 0
            try:
                item_wager_label.configure(text = "Items Wagered: None", text_color = "gray")
            except Exception:
                pass

            save_money_cb()
            money_label.configure(text = f"Your Money: ${player_money[0]}")
            update_money_cb()
            game_state["spinning"]= False
            spin_btn.configure(state = "normal")

        controls_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        controls_frame.grid(row = 2, column = 0, sticky = "ew", padx = 20, pady = 10)

        bet_frame = customtkinter.CTkFrame(controls_frame, fg_color = "transparent")
        bet_frame.pack(pady = 5)

        bet_label_entry = customtkinter.CTkLabel(bet_frame, text = "Bet Amount: $", font = customtkinter.CTkFont(size = 14))
        bet_label_entry.pack(side = "left")

        bet_entry = customtkinter.CTkEntry(bet_frame, width = 100, placeholder_text = str(min_bet))
        bet_entry.pack(side = "left", padx = 5)
        bet_entry.insert(0, str(min_bet))

        if save_data and save_path:
            item_wager_label = customtkinter.CTkLabel(bet_frame, text = "Items Wagered: None", font = customtkinter.CTkFont(size = 11), text_color = "gray")
            item_wager_label.pack(side = "left", padx = 10)

            def update_item_wager_display():
                total = sum(int(e["item"].get("value", 0)) for e in wagered_items)
                item_bet_value[0] = total
                if wagered_items:
                    item_wager_label.configure(text = f"Items Wagered: {len(wagered_items)} (${total})", text_color = "gold")
                else:
                    item_wager_label.configure(text = "Items Wagered: None", text_color = "gray")

            def open_item_wager():
                if game_state["spinning"]:
                    self._popup_show_info("Game Active", "Cannot change item wager while spinning.", sound = "popup")
                    return
                self._open_item_bet_dialog(save_data, wagered_items, update_item_wager_display)

            wager_btn = self._create_sound_button(bet_frame, "Wager Items", open_item_wager, width = 110, height = 30, font = customtkinter.CTkFont(size = 11), fg_color = "#8B4513", hover_color = "#654321")
            wager_btn.pack(side = "left", padx = 5)

        action_frame = customtkinter.CTkFrame(controls_frame, fg_color = "transparent")
        action_frame.pack(pady = 10)

        spin_btn = self._create_sound_button(action_frame, "Spin!", spin_wheel, width = 150, height = 50, font = customtkinter.CTkFont(size = 18, weight = "bold"), fg_color = "#8B4513", hover_color = "#654321")
        spin_btn.pack(pady = 5)

        def back_to_casino():
            game_state["ui_valid"]= False
            self._open_casino_interface(store, table_data)

        back_btn = self._create_sound_button(controls_frame, "Back to Casino", back_to_casino, width = 200, height = 40, font = customtkinter.CTkFont(size = 14))
        back_btn.pack(pady = 10)

    def _open_poker_lobby(self, store, player_money, update_money_cb, save_money_cb, min_bet, max_bet, music_channel, table_data, record_game_cb = None, casino_stats = None, save_data = None, save_path = None):
        self._clear_window()

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew")
        main_frame.grid_columnconfigure(0, weight = 1)
        main_frame.grid_rowconfigure(1, weight = 1)

        header_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        header_frame.grid(row = 0, column = 0, sticky = "ew", padx = 20, pady = 10)

        title_label = customtkinter.CTkLabel(header_frame, text = "Poker Room", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title_label.pack(pady =(10, 5))

        money_label = customtkinter.CTkLabel(header_frame, text = f"Your Money: ${player_money[0]}", font = customtkinter.CTkFont(size = 16, weight = "bold"), text_color = "green")
        money_label.pack(pady = 5)

        content_frame = customtkinter.CTkFrame(main_frame)
        content_frame.grid(row = 1, column = 0, sticky = "nsew", padx = 20, pady = 10)
        content_frame.grid_columnconfigure(0, weight = 1)

        games_label = customtkinter.CTkLabel(content_frame, text = "Select Poker Variant", font = customtkinter.CTkFont(size = 18, weight = "bold"))
        games_label.pack(pady = 20)

        def open_five_card_draw():
            self._open_poker_game(store, player_money, update_money_cb, save_money_cb, min_bet, max_bet, music_channel, table_data, record_game_cb, casino_stats, variant = "five_card_draw", save_data = save_data, save_path = save_path)

        def open_five_card_stud():
            self._open_poker_game(store, player_money, update_money_cb, save_money_cb, min_bet, max_bet, music_channel, table_data, record_game_cb, casino_stats, variant = "five_card_stud", save_data = save_data, save_path = save_path)

        def open_seven_card_stud():
            self._open_poker_game(store, player_money, update_money_cb, save_money_cb, min_bet, max_bet, music_channel, table_data, record_game_cb, casino_stats, variant = "seven_card_stud", save_data = save_data, save_path = save_path)

        def open_texas_holdem():
            self._open_poker_game(store, player_money, update_money_cb, save_money_cb, min_bet, max_bet, music_channel, table_data, record_game_cb, casino_stats, variant = "texas_holdem", save_data = save_data, save_path = save_path)

        fcd_btn = self._create_sound_button(content_frame, "5 Card Draw", open_five_card_draw, width = 300, height = 50, font = customtkinter.CTkFont(size = 16))
        fcd_btn.pack(pady = 10)
        customtkinter.CTkLabel(content_frame, text = "Classic draw poker - draw to improve your hand", font = customtkinter.CTkFont(size = 10), text_color = "gray").pack()

        fcs_btn = self._create_sound_button(content_frame, "5 Card Stud", open_five_card_stud, width = 300, height = 50, font = customtkinter.CTkFont(size = 16))
        fcs_btn.pack(pady = 10)
        customtkinter.CTkLabel(content_frame, text = "One hole card, four face-up cards", font = customtkinter.CTkFont(size = 10), text_color = "gray").pack()

        scs_btn = self._create_sound_button(content_frame, "7 Card Stud", open_seven_card_stud, width = 300, height = 50, font = customtkinter.CTkFont(size = 16))
        scs_btn.pack(pady = 10)
        customtkinter.CTkLabel(content_frame, text = "Two hole cards, four face-up, one final hole card", font = customtkinter.CTkFont(size = 10), text_color = "gray").pack()

        th_btn = self._create_sound_button(content_frame, "Texas Hold'em", open_texas_holdem, width = 300, height = 50, font = customtkinter.CTkFont(size = 16))
        th_btn.pack(pady = 10)
        customtkinter.CTkLabel(content_frame, text = "Two hole cards + five community cards", font = customtkinter.CTkFont(size = 10), text_color = "gray").pack()

        button_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        button_frame.grid(row = 2, column = 0, sticky = "ew", padx = 20, pady = 10)

        def back_to_casino():
            self._open_casino_interface(store, table_data)

        back_btn = self._create_sound_button(button_frame, "Back to Casino", back_to_casino, width = 200, height = 40, font = customtkinter.CTkFont(size = 14))
        back_btn.pack(pady = 10)

    def _open_inventory_manager_tool(self):
        logging.info("Inventory Manager definition called")
        self._clear_window()

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew")

        title_label = customtkinter.CTkLabel(main_frame, text = "Inventory Manager", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title_label.pack(pady = 20)

        character_management_button = self._create_sound_button(main_frame, "Character Management", lambda:[self._clear_window(), self._open_character_management()], width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        character_management_button.pack(pady = 20)
        inventory_management_button = self._create_sound_button(main_frame, "Inventory Management", lambda:[self._clear_window(), self._open_inventory_management()], width = 500, height = 50, font = customtkinter.CTkFont(size = 16), state = "disabled"if currentsave is None else "normal")
        inventory_management_button.pack(pady = 20)
        item_equip_button = self._create_sound_button(main_frame, "Item Equipping", lambda:[self._clear_window(), self._open_item_equipping()], width = 500, height = 50, font = customtkinter.CTkFont(size = 16), state = "disabled"if currentsave is None else "normal")
        item_equip_button.pack(pady = 20)
        back_button = self._create_sound_button(main_frame, "Back to Main Menu", lambda:[self._clear_window(), self._build_main_menu()], width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        back_button.pack(pady = 20)

        if currentsave is None:
            warning_label = customtkinter.CTkLabel(main_frame, text = "Load or create a character to access inventory features.", font = customtkinter.CTkFont(size = 14), text_color = "orange")
            warning_label.pack(pady = 10)
    def _open_character_management(self):
        logging.info("Character Management definition called")
        create_new_character_button = self._create_sound_button(self.root, "Create New Character", lambda:[self._clear_window(), self._create_new_character()], width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        create_new_character_button.pack(pady = 20)
        load_existing_character_button = self._create_sound_button(
        self.root,
        "Load Existing Character",
        lambda:[self._clear_window(), self._load_existing_character()],
        width = 500,
        height = 50,
        font = customtkinter.CTkFont(size = 16),
        state = "disabled"if not os.listdir(saves_folder)or all(
        f in["persistent_data.sldsv", "settings.sldsv", "appearance_settings.sldsv", "dm_settings.sldsv"]or f.endswith(".sldsv.sldsv")or f =="backups"
        for f in os.listdir(saves_folder)
        )else "normal"
        )
        load_existing_character_button.pack(pady = 20)

        view_stats_button = self._create_sound_button(
        self.root,
        "View Loaded Character Stats",
        self._view_character_stats,
        width = 500,
        height = 50,
        font = customtkinter.CTkFont(size = 16),
        state = "disabled"if currentsave is None else "normal"
        )
        view_stats_button.pack(pady = 20)

        modify_stats_button = self._create_sound_button(
        self.root,
        "Modify Character Stats",
        lambda:[self._clear_window(), self._modify_character_stats()],
        width = 500,
        height = 50,
        font = customtkinter.CTkFont(size = 16),
        state = "disabled"if currentsave is None else "normal"
        )
        modify_stats_button.pack(pady = 20)

        return_button = self._create_sound_button(self.root, "Return to Inventory Manager", lambda:[self._clear_window(), self._open_inventory_manager_tool()], width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        return_button.pack(pady = 20)

    def _view_character_stats(self):
        logging.info("View Character Stats called")

        if currentsave is None:
            self._popup_show_info("Error", "No character loaded.", sound = "error")
            return

        save_filename =(currentsave or "")+".sldsv"
        save_data = self._load_file(save_filename)

        if save_data is None:
            self._popup_show_info("Error", "Failed to load character data.", sound = "error")
            return

        encumbrance_info = self._calculate_encumbrance_status(save_data)

        self._clear_window()

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew", padx = 20, pady = 20)
        main_frame.grid_rowconfigure(1, weight = 1)
        main_frame.grid_columnconfigure(0, weight = 1)

        title = customtkinter.CTkLabel(main_frame, text = f"Character: {save_data.get('charactername', 'Unknown')}", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title.grid(row = 0, column = 0, pady =(0, 20))

        scroll = customtkinter.CTkScrollableFrame(main_frame, width = 800, height = 500)
        scroll.grid(row = 1, column = 0, sticky = "nsew", padx = 10, pady = 10)
        scroll.grid_columnconfigure(0, weight = 1)

        stats_label = customtkinter.CTkLabel(scroll, text = "Base Stats", font = customtkinter.CTkFont(size = 16, weight = "bold"))
        stats_label.pack(pady =(10, 15), anchor = "w", padx = 20)

        stats = save_data.get("stats", {})
        for stat_name, stat_value in stats.items():

            display_value = stat_value
            agility_penalty_text = ""

            if stat_name =="Agility"and encumbrance_info["encumbrance_level"]>0:
                display_value = stat_value -encumbrance_info["encumbrance_level"]
                agility_penalty_text = f"(Base: {stat_value}, Penalty: -{encumbrance_info['encumbrance_level']})"

            stat_frame = customtkinter.CTkFrame(scroll, fg_color = "transparent")
            stat_frame.pack(fill = "x", pady = 5, padx = 30)

            stat_label = customtkinter.CTkLabel(
            stat_frame,
            text = f"{stat_name}: {display_value:+d}{agility_penalty_text}",
            font = customtkinter.CTkFont(size = 12),
            anchor = "w"
            )
            stat_label.pack(fill = "x")

        enc_label = customtkinter.CTkLabel(scroll, text = "Encumbrance Status", font = customtkinter.CTkFont(size = 16, weight = "bold"))
        enc_label.pack(pady =(20, 15), anchor = "w", padx = 20)

        enc_items =[
        ("Total Weight", self._format_weight(encumbrance_info["total_weight"])),
        ("Encumbrance", self._format_weight(encumbrance_info['encumbrance'])),
        ("Encumbrance Threshold", self._format_weight(encumbrance_info['threshold'])),
        ("Encumbrance Level", f"{encumbrance_info['encumbrance_level']}"),
        ("Status", "Encumbered"if encumbrance_info["is_encumbered"]else "Not Encumbered")
        ]

        for label_text, value_text in enc_items:
            enc_frame = customtkinter.CTkFrame(scroll, fg_color = "transparent")
            enc_frame.pack(fill = "x", pady = 3, padx = 30)

            label = customtkinter.CTkLabel(
            enc_frame,
            text = f"{label_text}: {value_text}",
            font = customtkinter.CTkFont(size = 12),
            anchor = "w"
            )
            label.pack(fill = "x")

        tracked = save_data.get('tracked_stats', {})or {}
        try:
            if isinstance(tracked, dict):
                track_label = customtkinter.CTkLabel(scroll, text = "Tracked Activity", font = customtkinter.CTkFont(size = 16, weight = "bold"))
                track_label.pack(pady =(20, 15), anchor = "w", padx = 20)

                ta_items =[
                ("Rounds Fired(total)", tracked.get('rounds_fired_total', 0)),
                ("Magazines Reloaded(total)", tracked.get('mags_reloaded_total', 0)),
                ("Bullets Loaded(total)", tracked.get('bullets_loaded_total', 0)),
                ("D20 Rolls(total)", tracked.get('d20_rolls_total', 0)),
                ("D20 Ones(1)", tracked.get('d20_ones', 0)),
                ("D20 Twenties(20)", tracked.get('d20_twenties', 0))
                ]

                for label_text, value_text in ta_items:
                    tf = customtkinter.CTkFrame(scroll, fg_color = "transparent")
                    tf.pack(fill = "x", pady = 3, padx = 30)
                    lbl = customtkinter.CTkLabel(tf, text = f"{label_text}: {value_text}", font = customtkinter.CTkFont(size = 12), anchor = "w")
                    lbl.pack(fill = "x")

                bh = tracked.get('bullets_loaded_history', [])or[]
                if isinstance(bh, list)and bh:
                    hist_label = customtkinter.CTkLabel(scroll, text = "Recent Bullets Loaded", font = customtkinter.CTkFont(size = 14, weight = "bold"))
                    hist_label.pack(pady =(12, 6), anchor = "w", padx = 20)
                    for rec in bh[-5:]:
                        try:
                            wid = rec.get('weapon_id')
                            cnt = rec.get('count')
                            t = rec.get('time')
                            txt = f"{wid}: {cnt} @ {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(t))if t else 'unknown'}"
                        except Exception:
                            txt = str(rec)
                        rf = customtkinter.CTkFrame(scroll, fg_color = "transparent")
                        rf.pack(fill = "x", pady = 2, padx = 40)
                        rlbl = customtkinter.CTkLabel(rf, text = txt, font = customtkinter.CTkFont(size = 11), anchor = "w")
                        rlbl.pack(fill = "x")
        except Exception:
            logging.exception('Failed rendering tracked_stats in character view')

        other_label = customtkinter.CTkLabel(scroll, text = "Other Info", font = customtkinter.CTkFont(size = 16, weight = "bold"))
        other_label.pack(pady =(20, 15), anchor = "w", padx = 20)

        other_items =[
        ("Money", f"${save_data.get('money', 0)}"),
        ("Equipment Slots", f"{len([s for s in save_data.get('equipment', {}).values()if s is not None])}/{len(save_data.get('equipment', {}))}"),
        ("Storage Items", f"{len(save_data.get('storage', []))}")
        ]

        for label_text, value_text in other_items:
            other_frame = customtkinter.CTkFrame(scroll, fg_color = "transparent")
            other_frame.pack(fill = "x", pady = 3, padx = 30)

            label = customtkinter.CTkLabel(
            other_frame,
            text = f"{label_text}: {value_text}",
            font = customtkinter.CTkFont(size = 12),
            anchor = "w"
            )
            label.pack(fill = "x")

        button_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        button_frame.grid(row = 2, column = 0, pady = 10)
        button_frame.grid_columnconfigure((0, 1), weight = 1)

        def save_character():
            try:
                self._save_file(save_data)
                self._popup_show_info("Success", "Character saved successfully!", sound = "success")
            except Exception as e:
                logging.error(f"Failed to save character: {e}")
                self._popup_show_info("Error", f"Failed to save: {e}", sound = "error")

        save_button = self._create_sound_button(
        button_frame,
        "Save",
        save_character,
        width = 200,
        height = 40
        )
        save_button.grid(row = 0, column = 0, padx =(0, 10))

        back_button = self._create_sound_button(
        button_frame,
        "Back",
        lambda:[self._clear_window(), self._open_character_management()],
        width = 200,
        height = 40
        )
        back_button.grid(row = 0, column = 1, padx =(10, 0))

    def _modify_character_stats(self):
        logging.info("Modify Character Stats called")

        if currentsave is None:
            self._popup_show_info("Error", "No character loaded.", sound = "error")
            return

        save_filename =(currentsave or "")+".sldsv"
        save_data = self._load_file(save_filename)

        if save_data is None:
            self._popup_show_info("Error", "Failed to load character data.", sound = "error")
            return

        stat_clamp = 20
        slot_disable_points = 6
        try:
            tbl_path = get_current_table_path()
            if tbl_path and os.path.exists(tbl_path):
                with open(tbl_path, 'r')as f:
                    table_data = json.load(f)
                    stat_clamp = table_data.get("additional_settings", {}).get("stat_clamp", 20)
                    slot_disable_points = table_data.get("additional_settings", {}).get("slot_disable_points", 1)
        except Exception:
            pass

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        scrollable_frame = customtkinter.CTkScrollableFrame(self.root, width = 650, height = 700)
        scrollable_frame.grid(row = 0, column = 0, sticky = "nsew", padx = 20, pady = 20)
        scrollable_frame.grid_columnconfigure(0, weight = 1)

        title = customtkinter.CTkLabel(scrollable_frame, text = "Modify Character Stats", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title.grid(row = 0, column = 0, pady =(0, 20))

        stats_frame = customtkinter.CTkFrame(scrollable_frame)
        stats_frame.grid(row = 1, column = 0, sticky = "ew", pady = 10, padx = 10)
        stats_frame.grid_columnconfigure((1, 2, 3), weight = 1)

        stat_names = list(emptysave["stats"].keys())
        stat_sliders = {}
        stat_value_labels = {}
        for i, stat in enumerate(stat_names):
            stat_label = customtkinter.CTkLabel(stats_frame, text = f"{stat}:", font = customtkinter.CTkFont(size = 12), width = 100)
            stat_label.grid(row = i +1, column = 0, sticky = "w", padx =(0, 10), pady = 8)
            value_label = customtkinter.CTkLabel(stats_frame, text = "0", font = customtkinter.CTkFont(size = 12, weight = "bold"), width = 30)
            value_label.grid(row = i +1, column = 1, sticky = "e", padx =(0, 10), pady = 8)
            stat_value_labels[stat]= value_label
            def make_slider_callback(stat_name, value_lbl):
                def on_slider_change(val):
                    value_lbl.configure(text = str(int(float(val))))
                return on_slider_change
            if stat =="Luck":
                stat_min, stat_max = -4, 4
                stat_steps = 8
            else:
                stat_min, stat_max = -20, stat_clamp
                stat_steps = 40 +stat_clamp
            slider = customtkinter.CTkSlider(
            stats_frame,
            from_ = stat_min,
            to = stat_max,
            number_of_steps = stat_steps,
            command = make_slider_callback(stat, value_label)
            )
            slider.set(int(save_data.get('stats', {}).get(stat, 0)))
            slider.grid(row = i +1, column = 2, sticky = "ew", padx = 10, pady = 8)
            stat_sliders[stat]= slider
            range_label = customtkinter.CTkLabel(stats_frame, text = f"[{stat_min}, +{stat_max}]", font = customtkinter.CTkFont(size = 10), text_color = "gray")
            range_label.grid(row = i +1, column = 3, sticky = "w", padx =(10, 0), pady = 8)

        equipment_frame = customtkinter.CTkFrame(scrollable_frame)
        equipment_frame.grid(row = 2, column = 0, sticky = "ew", pady = 10, padx = 10)
        equipment_frame.grid_columnconfigure((0, 1, 2), weight = 1)

        equipment_slots = list(emptysave["equipment"].keys())
        slot_checkboxes = {}
        for i, slot in enumerate(equipment_slots):
            row =(i //3)+1
            col = i %3
            checkbox = customtkinter.CTkCheckBox(
            equipment_frame,
            text = slot.title(),
            font = customtkinter.CTkFont(size = 11)
            )
            if slot in save_data.get('equipment', {}):
                checkbox.select()
            else:
                checkbox.deselect()
            checkbox.grid(row = row, column = col, sticky = "w", padx = 10, pady = 5)
            slot_checkboxes[slot]= checkbox

        sum_frame = customtkinter.CTkFrame(scrollable_frame)
        sum_frame.grid(row = 3, column = 0, sticky = "ew", pady = 15, padx = 10)
        sum_frame.grid_columnconfigure(1, weight = 1)
        sum_label = customtkinter.CTkLabel(sum_frame, text = "Total Points:", font = customtkinter.CTkFont(size = 12, weight = "bold"))
        sum_label.grid(row = 0, column = 0, sticky = "w", padx =(0, 10))
        sum_value_label = customtkinter.CTkLabel(sum_frame, text = "0", font = customtkinter.CTkFont(size = 12, weight = "bold"))
        sum_value_label.grid(row = 0, column = 1, sticky = "w")

        def update_sum(*args):
            stat_total = sum(int(float(stat_sliders[stat].get()))for stat in stat_names)
            disabled_slots = sum(1 for slot, checkbox in slot_checkboxes.items()if not checkbox.get())
            bonus_points = disabled_slots *slot_disable_points *-1
            total = stat_total +bonus_points

            sum_value_label.configure(text = f"{stat_total} + {bonus_points} = {total}")
            if total >0:
                sum_value_label.configure(text_color = "red")
                save_button.configure(state = "disabled")
            else:
                sum_value_label.configure(text_color = "white")
                save_button.configure(state = "normal")

        for stat in stat_names:
            stat_sliders[stat].configure(command = lambda val, s = stat:[
            stat_value_labels[s].configure(text = str(int(float(stat_sliders[s].get())))),
            update_sum()
            ])

        for slot in equipment_slots:
            slot_checkboxes[slot].configure(command = update_sum)

        button_frame = customtkinter.CTkFrame(scrollable_frame, fg_color = "transparent")
        button_frame.grid(row = 4, column = 0, sticky = "ew", pady =(20, 0), padx = 10)
        button_frame.grid_columnconfigure((0, 1), weight = 1)

        def perform_save_modifications():
            try:
                stat_total = sum(int(float(stat_sliders[stat].get()))for stat in stat_names)
                disabled_slots = sum(1 for slot, checkbox in slot_checkboxes.items()if not checkbox.get())
                bonus_points = disabled_slots *slot_disable_points *-1
                total = stat_total +bonus_points

                if total >0:
                    self._popup_show_info('Error', 'Point total must be zero or negative; adjust stats or slots.', sound = 'error')
                    return

                for stat in stat_names:
                    save_data.setdefault('stats', {})[stat]= int(float(stat_sliders[stat].get()))

                for slot, checkbox in slot_checkboxes.items():
                    if not checkbox.get():
                        if slot in save_data.get('equipment', {}):
                            del save_data['equipment'][slot]
                    else:
                        save_data.setdefault('equipment', {}).setdefault(slot, None)

                save_path = os.path.join(saves_folder or 'saves', (currentsave or '')+'.sldsv')
                self._write_save_to_path(save_path, save_data)
                self._popup_show_info('Success', 'Stats saved successfully!', sound = 'success')
                self._clear_window()
                self._open_character_management()
            except Exception as e:
                logging.exception('Failed saving modified stats')
                self._popup_show_info('Error', f'Failed to save: {e}', sound = 'error')

        save_button = self._create_sound_button(button_frame, 'Save', perform_save_modifications, width = 200, height = 50, font = customtkinter.CTkFont(size = 14))
        save_button.grid(row = 0, column = 0, padx =(0, 10))
        cancel_button = self._create_sound_button(button_frame, 'Cancel', lambda:self._popup_confirm(
        'Cancel Modifications',
        'Are you sure you want to cancel? Unsaved changes will be lost.',
        lambda:[self._clear_window(), self._open_character_management()]
        ), width = 200, height = 50, font = customtkinter.CTkFont(size = 14))
        cancel_button.grid(row = 0, column = 1, padx =(10, 0))
    def _create_new_character(self):
        import uuid
        import json
        stat_clamp = 20
        slot_disable_points = 6
        try:
            tbl_path = get_current_table_path()
            if tbl_path and os.path.exists(tbl_path):
                with open(tbl_path, 'r')as f:
                    table_data = json.load(f)
                    stat_clamp = table_data.get("additional_settings", {}).get("stat_clamp", 20)
                    slot_disable_points = table_data.get("additional_settings", {}).get("slot_disable_points", 1)
                    logging.info(f"Loaded stat_clamp from table: {stat_clamp}")
                    logging.info(f"Loaded slot_disable_points from table: {slot_disable_points}")
        except Exception as e:
            logging.warning(f"Failed to load table settings, using default clamp: {e}")
        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        scrollable_frame = customtkinter.CTkScrollableFrame(self.root, width = 650, height = 700)
        scrollable_frame.grid(row = 0, column = 0, sticky = "nsew", padx = 20, pady = 20)
        scrollable_frame.grid_columnconfigure(0, weight = 1)

        title = customtkinter.CTkLabel(scrollable_frame, text = "Create New Character", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title.grid(row = 0, column = 0, pady =(0, 20))
        name_label = customtkinter.CTkLabel(scrollable_frame, text = "Character Name:", font = customtkinter.CTkFont(size = 14))
        name_label.grid(row = 1, column = 0, sticky = "w", pady = 5)
        name_entry = customtkinter.CTkEntry(scrollable_frame, placeholder_text = "Enter character name")
        name_entry.grid(row = 2, column = 0, sticky = "ew", pady =(0, 15), padx = 10)
        stats_frame = customtkinter.CTkFrame(scrollable_frame)
        stats_frame.grid(row = 3, column = 0, sticky = "ew", pady = 10, padx = 10)
        stats_frame.grid_columnconfigure((1, 2, 3), weight = 1)
        stats_label = customtkinter.CTkLabel(stats_frame, text = "Initial Stats(Sum must be â‰¤ 0)", font = customtkinter.CTkFont(size = 14, weight = "bold"))
        stats_label.grid(row = 0, column = 0, columnspan = 4, pady =(0, 15))
        stat_names = list(emptysave["stats"].keys())
        stat_sliders = {}
        stat_value_labels = {}
        for i, stat in enumerate(stat_names):
            stat_label = customtkinter.CTkLabel(stats_frame, text = f"{stat}:", font = customtkinter.CTkFont(size = 12), width = 100)
            stat_label.grid(row = i +1, column = 0, sticky = "w", padx =(0, 10), pady = 8)
            value_label = customtkinter.CTkLabel(stats_frame, text = "0", font = customtkinter.CTkFont(size = 12, weight = "bold"), width = 30)
            value_label.grid(row = i +1, column = 1, sticky = "e", padx =(0, 10), pady = 8)
            stat_value_labels[stat]= value_label
            def make_slider_callback(stat_name, value_lbl):
                def on_slider_change(val):
                    value_lbl.configure(text = str(int(float(val))))
                return on_slider_change
            if stat =="Luck":
                stat_min, stat_max = -4, 4
                stat_steps = 8
            else:
                stat_min, stat_max = -20, stat_clamp
                stat_steps = 40 +stat_clamp
            slider = customtkinter.CTkSlider(
            stats_frame,
            from_ = stat_min,
            to = stat_max,
            number_of_steps = stat_steps,
            command = make_slider_callback(stat, value_label)
            )
            slider.set(0)
            slider.grid(row = i +1, column = 2, sticky = "ew", padx = 10, pady = 8)
            stat_sliders[stat]= slider
            range_label = customtkinter.CTkLabel(stats_frame, text = f"[{stat_min}, +{stat_max}]", font = customtkinter.CTkFont(size = 10), text_color = "gray")
            range_label.grid(row = i +1, column = 3, sticky = "w", padx =(10, 0), pady = 8)

        equipment_frame = customtkinter.CTkFrame(scrollable_frame)
        equipment_frame.grid(row = 4, column = 0, sticky = "ew", pady = 10, padx = 10)
        equipment_frame.grid_columnconfigure((0, 1, 2), weight = 1)

        equipment_label = customtkinter.CTkLabel(equipment_frame, text = f"Equipment Slots(Disable for -{slot_disable_points} point{'s'if slot_disable_points !=1 else ''} each)", font = customtkinter.CTkFont(size = 14, weight = "bold"))
        equipment_label.grid(row = 0, column = 0, columnspan = 3, pady =(0, 15))

        equipment_slots = list(emptysave["equipment"].keys())
        slot_checkboxes = {}

        for i, slot in enumerate(equipment_slots):
            row =(i //3)+1
            col = i %3

            checkbox = customtkinter.CTkCheckBox(
            equipment_frame,
            text = slot.title(),
            font = customtkinter.CTkFont(size = 11)
            )
            checkbox.select()
            checkbox.grid(row = row, column = col, sticky = "w", padx = 10, pady = 5)
            slot_checkboxes[slot]= checkbox

        sum_frame = customtkinter.CTkFrame(scrollable_frame)
        sum_frame.grid(row = 5, column = 0, sticky = "ew", pady = 15, padx = 10)
        sum_frame.grid_columnconfigure(1, weight = 1)
        sum_label = customtkinter.CTkLabel(sum_frame, text = "Total Points:", font = customtkinter.CTkFont(size = 12, weight = "bold"))
        sum_label.grid(row = 0, column = 0, sticky = "w", padx =(0, 10))
        sum_value_label = customtkinter.CTkLabel(sum_frame, text = "0", font = customtkinter.CTkFont(size = 12, weight = "bold"))
        sum_value_label.grid(row = 0, column = 1, sticky = "w")

        def update_sum(*args):
            stat_total = sum(int(float(stat_sliders[stat].get()))for stat in stat_names)
            disabled_slots = sum(1 for slot, checkbox in slot_checkboxes.items()if not checkbox.get())
            bonus_points = disabled_slots *slot_disable_points *-1
            total = stat_total +bonus_points

            sum_value_label.configure(text = f"{stat_total} + {bonus_points} = {total}")
            if total >0:
                sum_value_label.configure(text_color = "red")
                create_button.configure(state = "disabled")
            else:
                sum_value_label.configure(text_color = "white")
                create_button.configure(state = "normal")

        for stat in stat_names:
            stat_sliders[stat].configure(command = lambda val, s = stat:[
            stat_value_labels[s].configure(text = str(int(float(stat_sliders[s].get())))),
            update_sum()
            ])

        for slot in equipment_slots:
            slot_checkboxes[slot].configure(command = update_sum)

        button_frame = customtkinter.CTkFrame(scrollable_frame, fg_color = "transparent")
        button_frame.grid(row = 6, column = 0, sticky = "ew", pady =(20, 0), padx = 10)
        button_frame.grid_columnconfigure((0, 1), weight = 1)

        def perform_character_creation():
            char_name = name_entry.get().strip()
            stat_total = sum(int(float(stat_sliders[stat].get()))for stat in stat_names)
            disabled_slots = sum(1 for slot, checkbox in slot_checkboxes.items()if not checkbox.get())
            bonus_points = disabled_slots *slot_disable_points *-1
            total = stat_total +bonus_points

            try:
                new_save = emptysave.copy()
                new_save["charactername"]= char_name
                for stat in stat_names:
                    new_save["stats"][stat]= int(float(stat_sliders[stat].get()))

                for slot, checkbox in slot_checkboxes.items():
                    if not checkbox.get():
                        del new_save["equipment"][slot]
                char_uuid = str(uuid.uuid4())
                save_basename = f"{char_name}_{char_uuid}"
                save_filename = os.path.join(saves_folder or "saves", save_basename +".sldsv")

                self._write_save_to_path(save_filename, new_save)
                persistentdata["save_uuids"][char_uuid]= char_name
                persistentdata["last_loaded_save"]= char_uuid

                try:
                    global currentsave
                    currentsave = save_basename
                except Exception:
                    pass
                self._save_persistent_data()
                logging.info(f"Character '{char_name}' created successfully with UUID: {char_uuid}")
                self._popup_show_info("Success", f"Character '{char_name}' created successfully!", sound = "success")
                self._clear_window()
                self._open_character_management()
            except Exception as e:
                logging.error(f"Failed to create character: {e}")
                self._popup_show_info("Error", f"Failed to create character: {e}", sound = "error")

        def create_character():
            char_name = name_entry.get().strip()
            if not char_name:
                self._popup_show_info("Error", "Please enter a character name.", sound = "error")
                return

            stat_total = sum(int(float(stat_sliders[stat].get()))for stat in stat_names)
            disabled_slots = sum(1 for slot, checkbox in slot_checkboxes.items()if not checkbox.get())
            bonus_points = disabled_slots *slot_disable_points *-1
            total = stat_total +bonus_points

            if total <0:
                self._popup_confirm(
                "Negative Balance Warning",
                f"Your point balance is {total}(negative).This means you have unspent points.\n\nAre you sure you want to continue?",
                perform_character_creation
                )
            else:
                perform_character_creation()

        def go_back():
            self._clear_window()
            self._open_character_management()

        create_button = self._create_sound_button(button_frame, "Create Character", create_character, width = 200, height = 50, font = customtkinter.CTkFont(size = 14))
        create_button.grid(row = 0, column = 0, padx =(0, 10))
        back_button = self._create_sound_button(
        button_frame,
        "Cancel",
        lambda:self._popup_confirm(
        "Cancel Character Creation",
        "Are you sure you want to cancel? Unsaved changes will be lost.",
        go_back
        ),
        width = 200,
        height = 50,
        font = customtkinter.CTkFont(size = 14)
        )
        back_button.grid(row = 0, column = 1, padx =(10, 0))
    def _load_existing_character(self):
        import json
        import os

        logging.info("Load Existing Character definition called")

        save_files =[]
        current_table = global_variables.get('current_table')
        incompatible_saves =[]
        try:
            for filename in os.listdir(saves_folder):
                if filename.endswith(".sldsv.sldsv"):
                    continue
                if filename.endswith(".sldsv")and filename not in["persistent_data.sldsv", "settings.sldsv", "appearance_settings.sldsv", "dm_settings.sldsv"]:
                    save_path = os.path.join(saves_folder or "saves", filename)
                    try:
                        save_data = self._read_save_from_path(save_path)
                        if save_data is None:
                            char_name = "Unknown"
                        else:
                            char_name = save_data.get("charactername", "Unknown")
                            save_table = save_data.get('_table')or save_data.get('table')

                            if current_table and save_table:
                                current_table_base = os.path.splitext(current_table)[0]
                                save_table_base = os.path.splitext(save_table)[0]
                                if current_table_base !=save_table_base and current_table !=save_table:
                                    incompatible_saves.append({'filename':filename, 'character_name':char_name, 'save_table':save_table})
                                    continue

                            uuid_part = filename.replace(".sldsv", "").split("_")[-1]
                            save_files.append({
                            "filename":filename,
                            "character_name":char_name,
                            "uuid":uuid_part,
                            "data":save_data,
                            "save_table":save_table
                            })
                    except Exception as e:
                        logging.warning(f"Failed to load save file {filename}: {e}")
        except Exception as e:
            logging.error(f"Failed to read saves folder: {e}")
            self._popup_show_info("Error", f"Failed to read saves folder: {e}", sound = "error")
            return

        if not save_files:
            msg = "No character save files found for the current table."
            if incompatible_saves:
                msg +=f"\n\n{len(incompatible_saves)} save(s) found for other tables."
            self._popup_show_info("No Saves Found", msg, sound = "error")
            return

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew", padx = 20, pady = 20)
        main_frame.grid_rowconfigure(1, weight = 1)
        main_frame.grid_columnconfigure(0, weight = 1)

        title = customtkinter.CTkLabel(main_frame, text = "Load Existing Character", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title.grid(row = 0, column = 0, pady =(0, 20))

        scroll_frame = customtkinter.CTkScrollableFrame(main_frame, width = 700, height = 400)
        scroll_frame.grid(row = 1, column = 0, sticky = "nsew", pady =(0, 20))
        scroll_frame.grid_columnconfigure(0, weight = 1)

        def load_character(save_info):
            global currentsave
            try:
                currentsave = save_info["filename"].replace(".sldsv", "")
                persistentdata["save_uuids"].setdefault(save_info["uuid"], save_info["character_name"])
                persistentdata["last_loaded_save"]= save_info["uuid"]
                self._save_persistent_data()
                logging.info(f"Loaded character '{save_info['character_name']}' with UUID: {save_info['uuid']}")
                self._popup_show_info("Success", f"Character '{save_info['character_name']}' loaded successfully!", sound = "success")
                self._clear_window()
                self._build_main_menu()
            except Exception as e:
                logging.error(f"Failed to load character: {e}")
                self._popup_show_info("Error", f"Failed to load character: {e}", sound = "error")

        for i, save_info in enumerate(save_files):
            char_frame = customtkinter.CTkFrame(scroll_frame)
            char_frame.grid(row = i, column = 0, sticky = "ew", pady = 5, padx = 10)
            char_frame.grid_columnconfigure(0, weight = 1)

            name_label = customtkinter.CTkLabel(
            char_frame,
            text = save_info["character_name"],
            font = customtkinter.CTkFont(size = 18, weight = "bold"),
            anchor = "w"
            )
            name_label.grid(row = 0, column = 0, sticky = "w", padx = 15, pady =(10, 5))

            stats = save_info["data"].get("stats", {})
            stats_text = " | ".join([f"{stat}: {value:+d}"for stat, value in stats.items()])
            stats_label = customtkinter.CTkLabel(
            char_frame,
            text = stats_text,
            font = customtkinter.CTkFont(size = 11),
            text_color = "gray",
            anchor = "w"
            )
            stats_label.grid(row = 1, column = 0, sticky = "w", padx = 15, pady =(0, 5))

            equipment_count = len(save_info["data"].get("equipment", {}))
            equipment_label = customtkinter.CTkLabel(
            char_frame,
            text = f"Equipment Slots: {equipment_count}",
            font = customtkinter.CTkFont(size = 11),
            text_color = "gray",
            anchor = "w"
            )
            equipment_label.grid(row = 2, column = 0, sticky = "w", padx = 15, pady =(0, 5))

            save_table_name = save_info.get("save_table")or "Unknown"
            table_label = customtkinter.CTkLabel(
            char_frame,
            text = f"Data Table: {save_table_name}",
            font = customtkinter.CTkFont(size = 11),
            text_color = "gray",
            anchor = "w"
            )
            table_label.grid(row = 3, column = 0, sticky = "w", padx = 15, pady =(0, 5))

            file_name = save_info["filename"]
            file_name_label = customtkinter.CTkLabel(
            char_frame,
            text = f"Filename: {file_name}",
            font = customtkinter.CTkFont(size = 11),
            text_color = "gray",
            anchor = "w"
            )
            file_name_label.grid(row = 4, column = 0, sticky = "w", padx = 15, pady =(0, 10))

            load_button = self._create_sound_button(
            char_frame,
            "Load Character",
            lambda s = save_info:load_character(s),
            width = 150,
            height = 35,
            font = customtkinter.CTkFont(size = 13)
            )
            load_button.grid(row = 0, column = 1, rowspan = 4, padx = 15, pady = 10)

        button_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        button_frame.grid(row = 2, column = 0, pady =(10, 0))

        load_backup_button = self._create_sound_button(
        button_frame,
        "Load from Backup",
        lambda:self._open_load_from_backup(),
        width = 200,
        height = 50,
        font = customtkinter.CTkFont(size = 14),
        fg_color = "#4a5568"
        )
        load_backup_button.pack(side = "left", padx = 10)

        back_button = self._create_sound_button(
        button_frame,
        "Back to Character Management",
        lambda:[self._clear_window(), self._open_character_management()],
        width = 300,
        height = 50,
        font = customtkinter.CTkFont(size = 14)
        )
        back_button.pack(side = "left", padx = 10)

    def _open_load_from_backup(self):

        logging.info("Load from Backup definition called")

        self._clear_window()
        self._play_ui_sound("whoosh1")

        backup_base = os.path.join(saves_folder or "saves", "backups")

        character_folders =[]
        if os.path.exists(backup_base):
            for folder_name in os.listdir(backup_base):
                folder_path = os.path.join(backup_base, folder_name)
                if os.path.isdir(folder_path)and folder_name !="archive":
                    backup_files = glob.glob(os.path.join(folder_path, "*.sldsv"))
                    if backup_files:
                        character_folders.append({
                        "name":folder_name,
                        "path":folder_path,
                        "backup_count":len(backup_files)
                        })

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew", padx = 20, pady = 20)
        main_frame.grid_rowconfigure(1, weight = 1)
        main_frame.grid_columnconfigure(0, weight = 1)

        title = customtkinter.CTkLabel(main_frame, text = "Load from Backup", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title.grid(row = 0, column = 0, pady =(0, 20))

        if not character_folders:
            no_backups = customtkinter.CTkLabel(
            main_frame,
            text = "No backups found.\nBackups are created automatically when saving characters.",
            font = customtkinter.CTkFont(size = 14),
            text_color = "gray"
            )
            no_backups.grid(row = 1, column = 0, pady = 20)
        else:
            scroll_frame = customtkinter.CTkScrollableFrame(main_frame, width = 700, height = 400)
            scroll_frame.grid(row = 1, column = 0, sticky = "nsew", pady =(0, 20))
            scroll_frame.grid_columnconfigure(0, weight = 1)

            for i, char_folder in enumerate(character_folders):
                folder_frame = customtkinter.CTkFrame(scroll_frame)
                folder_frame.grid(row = i, column = 0, sticky = "ew", pady = 5, padx = 10)
                folder_frame.grid_columnconfigure(0, weight = 1)

                name_label = customtkinter.CTkLabel(
                folder_frame,
                text = char_folder["name"],
                font = customtkinter.CTkFont(size = 18, weight = "bold"),
                anchor = "w"
                )
                name_label.grid(row = 0, column = 0, sticky = "w", padx = 15, pady =(10, 5))

                count_label = customtkinter.CTkLabel(
                folder_frame,
                text = f"{char_folder['backup_count']} backup(s) available",
                font = customtkinter.CTkFont(size = 11),
                text_color = "gray",
                anchor = "w"
                )
                count_label.grid(row = 1, column = 0, sticky = "w", padx = 15, pady =(0, 10))

                browse_button = self._create_sound_button(
                folder_frame,
                "Browse Backups",
                lambda cf = char_folder:self._browse_character_backups(cf),
                width = 150,
                height = 35,
                font = customtkinter.CTkFont(size = 13)
                )
                browse_button.grid(row = 0, column = 1, rowspan = 2, padx = 15, pady = 10)

        back_button = self._create_sound_button(
        main_frame,
        "Back to Load Character",
        lambda:[self._clear_window(), self._load_existing_character()],
        width = 300,
        height = 50,
        font = customtkinter.CTkFont(size = 14)
        )
        back_button.grid(row = 2, column = 0, pady =(10, 0))

    def _browse_character_backups(self, char_folder):

        logging.info(f"Browsing backups for: {char_folder['name']}")

        self._clear_window()
        self._play_ui_sound("whoosh1")

        backup_files =[]
        for backup_path in glob.glob(os.path.join(char_folder["path"], "*.sldsv")):
            try:
                filename = os.path.basename(backup_path)
                mtime = os.path.getmtime(backup_path)
                mtime_str = datetime.fromtimestamp(mtime).strftime("%Y-%m-%d %H:%M:%S")

                timestamp_part = filename.replace("backup_", "").replace(".sldsv", "")
                try:
                    if "_"in timestamp_part:
                        parts = timestamp_part.split("_")
                        if len(parts)>=2:
                            date_str = f"{parts[0][:4]}-{parts[0][4:6]}-{parts[0][6:8]}"
                            time_str = f"{parts[1][:2]}:{parts[1][2:4]}:{parts[1][4:6]}"
                            display_time = f"{date_str} {time_str}"
                        else:
                            display_time = mtime_str
                    else:
                        display_time = mtime_str
                except Exception:
                    display_time = mtime_str

                backup_files.append({
                "path":backup_path,
                "filename":filename,
                "mtime":mtime,
                "display_time":display_time
                })
            except Exception as e:
                logging.warning(f"Failed to read backup file info: {e}")

        backup_files.sort(key = lambda x:x["mtime"], reverse = True)

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew", padx = 20, pady = 20)
        main_frame.grid_rowconfigure(1, weight = 1)
        main_frame.grid_columnconfigure(0, weight = 1)

        title = customtkinter.CTkLabel(
        main_frame,
        text = f"Backups: {char_folder['name']}",
        font = customtkinter.CTkFont(size = 24, weight = "bold")
        )
        title.grid(row = 0, column = 0, pady =(0, 20))

        scroll_frame = customtkinter.CTkScrollableFrame(main_frame, width = 700, height = 400)
        scroll_frame.grid(row = 1, column = 0, sticky = "nsew", pady =(0, 20))
        scroll_frame.grid_columnconfigure(0, weight = 1)

        def load_backup(backup_info):
            try:
                backup_data = self._read_save_from_path(backup_info["path"])
                if backup_data is None:
                    self._popup_show_info("Error", "Failed to read backup file.", sound = "error")
                    return

                def confirm_load():
                    global currentsave
                    try:
                        char_name = backup_data.get("charactername", "Unknown")
                        uuid_val = backup_data.get("uuid")
                        if not uuid_val:
                            import uuid
                            uuid_val = str(uuid.uuid4())
                            backup_data["uuid"]= uuid_val

                        save_filename = f"{char_name}_{uuid_val}"
                        save_path = os.path.join(saves_folder or "saves", f"{save_filename}.sldsv")

                        self._write_save_to_path(save_path, backup_data)

                        currentsave = save_filename
                        persistentdata["save_uuids"].setdefault(uuid_val, char_name)
                        persistentdata["last_loaded_save"]= uuid_val
                        self._save_persistent_data()

                        logging.info(f"Restored backup for '{char_name}' from {backup_info['filename']}")
                        self._popup_show_info("Success", f"Backup restored for '{char_name}'!\nBackup time: {backup_info['display_time']}", sound = "success")
                        self._clear_window()
                        self._build_main_menu()
                    except Exception as e:
                        logging.error(f"Failed to restore backup: {e}")
                        self._popup_show_info("Error", f"Failed to restore backup: {e}", sound = "error")

                self._popup_confirm(
                "Restore Backup",
                f"This will restore the backup from:\n{backup_info['display_time']}\n\nThis will overwrite the current save for this character.\nContinue?",
                confirm_load
                )
            except Exception as e:
                logging.error(f"Failed to load backup: {e}")
                self._popup_show_info("Error", f"Failed to load backup: {e}", sound = "error")

        for i, backup_info in enumerate(backup_files):
            is_latest =(i ==0)
            backup_frame = customtkinter.CTkFrame(
            scroll_frame,
            fg_color =("#2d5a2d", "#1a3d1a")if is_latest else None,
            border_width = 2 if is_latest else 0,
            border_color = "#4ade80"if is_latest else None
            )
            backup_frame.grid(row = i, column = 0, sticky = "ew", pady = 3, padx = 10)
            backup_frame.grid_columnconfigure(0, weight = 1)

            time_text = backup_info["display_time"]
            if is_latest:
                time_text = f"â˜† {time_text}(Latest)"

            time_label = customtkinter.CTkLabel(
            backup_frame,
            text = time_text,
            font = customtkinter.CTkFont(size = 14, weight = "bold"),
            text_color = "#4ade80"if is_latest else None,
            anchor = "w"
            )
            time_label.grid(row = 0, column = 0, sticky = "w", padx = 15, pady =(8, 2))

            file_label = customtkinter.CTkLabel(
            backup_frame,
            text = backup_info["filename"],
            font = customtkinter.CTkFont(size = 10),
            text_color = "#86efac"if is_latest else "gray",
            anchor = "w"
            )
            file_label.grid(row = 1, column = 0, sticky = "w", padx = 15, pady =(0, 8))

            load_btn = self._create_sound_button(
            backup_frame,
            "Restore",
            lambda bi = backup_info:load_backup(bi),
            width = 100,
            height = 30,
            font = customtkinter.CTkFont(size = 12)
            )
            load_btn.grid(row = 0, column = 1, rowspan = 2, padx = 15, pady = 5)

        back_button = self._create_sound_button(
        main_frame,
        "Back to Backup List",
        lambda:self._open_load_from_backup(),
        width = 300,
        height = 50,
        font = customtkinter.CTkFont(size = 14)
        )
        back_button.grid(row = 2, column = 0, pady =(10, 0))

    def _open_inventory_management(self):
        logging.info("Inventory Management definition called")

        self._clear_window()

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew", padx = 20, pady = 20)
        main_frame.grid_columnconfigure(0, weight = 1)

        title = customtkinter.CTkLabel(main_frame, text = "Inventory Management", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title.pack(pady =(0, 20))

        container_management_button = self._create_sound_button(
        main_frame,
        "Manage Containers & Transfer Items",
        lambda:[self._clear_window(), self._manage_containers()],
        width = 500,
        height = 50,
        font = customtkinter.CTkFont(size = 16)
        )
        container_management_button.pack(pady = 10)

        player_transfer_button = self._create_sound_button(
        main_frame,
        "Transfer to Another Player(Export/Import)",
        lambda:[self._clear_window(), self._transfer_player()],
        width = 500,
        height = 50,
        font = customtkinter.CTkFont(size = 16)
        )
        player_transfer_button.pack(pady = 10)

        back_button = self._create_sound_button(
        main_frame,
        "Back to Inventory Manager",
        lambda:[self._clear_window(), self._open_inventory_manager_tool()],
        width = 500,
        height = 50,
        font = customtkinter.CTkFont(size = 16)
        )
        back_button.pack(pady = 10)

    def _format_weight(self, weight_kg):

        if appearance_settings["units"]=="imperial":
            weight_lb = weight_kg *2.20462
            return f"{weight_lb:.2f} lb"
        elif appearance_settings["units"]=="cheese":
            cheese_wheels = weight_kg /40.0
            if cheese_wheels ==1.0:
                return "1 cheese wheel"
            elif cheese_wheels ==int(cheese_wheels):
                return f"{int(cheese_wheels)} cheese wheels"
            else:
                return f"{cheese_wheels:.2f} cheese wheels"
        else:
            return f"{weight_kg:.2f} kg"

    def _consume_item(self, item, location, save_data, on_complete = None):

        import threading

        if not item or not isinstance(item, dict):
            self._popup_show_info("Error", "Invalid item.", sound = "error")
            return

        if not item.get("consumable"):
            self._popup_show_info("Error", "This item is not consumable.", sound = "error")
            return

        table_items_map = {}
        try:
            table_files = sorted(glob.glob(os.path.join("tables", f"*{global_variables.get('table_extension', '.sldtbl')}")))
            cur_tbl = global_variables.get("current_table")
            target_file = None
            if cur_tbl:
                for fpath in table_files:
                    if os.path.abspath(fpath).endswith(cur_tbl)or os.path.basename(fpath)==cur_tbl:
                        target_file = fpath
                        break
            if not target_file and table_files:
                target_file = table_files[0]
            if target_file:
                with open(target_file, 'r', encoding = 'utf-8')as f:
                    table_data = json.load(f)
                for table_name, items_list in table_data.get("tables", {}).items():
                    if isinstance(items_list, list):
                        for tbl_item in items_list:
                            if isinstance(tbl_item, dict)and "id"in tbl_item:
                                table_items_map[tbl_item["id"]]= tbl_item
        except Exception as e:
            logging.warning(f"Failed to load table for weight calculation: {e}")

        if item.get("disinfectant_required"):

            disinfectant_found = None
            disinfectant_location = None
            disinfectant_idx = -1

            for idx, inv_item in enumerate(save_data.get("hands", {}).get("items", [])):
                if isinstance(inv_item, dict)and inv_item.get("id")==257:
                    disinfectant_found = inv_item
                    disinfectant_location = "hands"
                    disinfectant_idx = idx
                    break

            if not disinfectant_found:
                for slot_name, eq_item in save_data.get("equipment", {}).items():
                    if isinstance(eq_item, dict)and eq_item.get("items"):
                        for idx, inv_item in enumerate(eq_item.get("items", [])):
                            if isinstance(inv_item, dict)and inv_item.get("id")==257:
                                disinfectant_found = inv_item
                                disinfectant_location = f"equipment.{slot_name}"
                                disinfectant_idx = idx
                                break
                    if disinfectant_found:
                        break

            if not disinfectant_found:
                self._popup_show_info("Disinfectant Required",
                f"You need isopropyl alcohol(disinfectant) to use {item.get('name', 'this item')}.",
                sound = "error")
                return

            disinfectant_sounds = disinfectant_found.get("consumable_sounds", [])

            if disinfectant_found.get("used_up"):
                uses = disinfectant_found.get("uses_left", 1)
                if uses >1:
                    disinfectant_found["uses_left"]= uses -1

                    dis_id = disinfectant_found.get("id")
                    if dis_id is not None and dis_id in table_items_map:
                        dis_table = table_items_map[dis_id]
                        dis_orig_uses = dis_table.get("uses_left", 1)
                        dis_orig_weight = dis_table.get("weight", 0)
                        if dis_orig_uses >0 and dis_orig_weight >0:
                            disinfectant_found["weight"]= dis_orig_weight *(uses -1)/dis_orig_uses
                else:

                    if disinfectant_location =="hands"and isinstance(disinfectant_idx, int):
                        items_list = save_data.get("hands", {}).get("items", [])
                        if disinfectant_idx >=0 and disinfectant_idx <len(items_list):
                            items_list.pop(disinfectant_idx)
                    elif disinfectant_location and disinfectant_location.startswith("equipment.")and isinstance(disinfectant_idx, int):
                        slot = disinfectant_location.split(".")[1]
                        eq_item = save_data.get("equipment", {}).get(slot)
                        if eq_item and isinstance(eq_item, dict):
                            items_list = eq_item.get("items", [])
                            if disinfectant_idx >=0 and disinfectant_idx <len(items_list):
                                items_list.pop(disinfectant_idx)

        def find_item_in_location(loc, target_item):

            if loc =="hands":
                items_list = save_data.get("hands", {}).get("items", [])
                for idx, it in enumerate(items_list):
                    if it is target_item:
                        return items_list, idx
            elif loc.startswith("equipment."):
                parts = loc.split(".")
                slot = parts[1]
                eq = save_data.get("equipment", {}).get(slot)
                if eq and isinstance(eq, dict):

                    if len(parts)>=5 and parts[2]=="subslots":
                        try:
                            subslot_idx = int(parts[3])
                            subslots = eq.get("subslots", [])
                            if subslot_idx <len(subslots):
                                subslot = subslots[subslot_idx]
                                curr = subslot.get("current")if isinstance(subslot, dict)else None
                                if curr and isinstance(curr, dict):

                                    if curr is target_item:

                                        return subslot, "current"

                                    items_list = curr.get("items", [])
                                    for idx, it in enumerate(items_list):
                                        if it is target_item:
                                            return items_list, idx
                        except(ValueError, IndexError):
                            pass
                    else:

                        items_list = eq.get("items", [])
                        for idx, it in enumerate(items_list):
                            if it is target_item:
                                return items_list, idx
            return None, -1

        def play_sounds_and_finish():

            sounds = item.get("consumable_sounds", [])

            if item.get("lighting_device_required"):

                lighting_device = None
                for inv_item in save_data.get("hands", {}).get("items", []):
                    if isinstance(inv_item, dict)and inv_item.get("lighting_device"):
                        lighting_device = inv_item
                        break
                if not lighting_device:
                    for slot_name, eq_item in save_data.get("equipment", {}).items():
                        if isinstance(eq_item, dict)and eq_item.get("items"):
                            for inv_item in eq_item.get("items", []):
                                if isinstance(inv_item, dict)and inv_item.get("lighting_device"):
                                    lighting_device = inv_item
                                    break
                        if lighting_device:
                            break

                if not lighting_device:
                    self._popup_show_info("Lighting Device Required",
                    f"You need a lighter or matches to use {item.get('name', 'this item')}.",
                    sound = "error")
                    return

                new_sounds =[]
                for s in sounds:
                    if s =="lightingdevice":
                        ld_sounds = lighting_device.get("consumable_sounds", [])
                        new_sounds.extend(ld_sounds)
                    else:
                        new_sounds.append(s)
                sounds = new_sounds

                if lighting_device.get("used_up"):
                    uses = lighting_device.get("uses_left", 1)
                    if uses >1:
                        lighting_device["uses_left"]= uses -1

                        ld_id = lighting_device.get("id")
                        if ld_id is not None and ld_id in table_items_map:
                            ld_table = table_items_map[ld_id]
                            ld_orig_uses = ld_table.get("uses_left", 1)
                            ld_orig_weight = ld_table.get("weight", 0)
                            if ld_orig_uses >0 and ld_orig_weight >0:
                                lighting_device["weight"]= ld_orig_weight *(uses -1)/ld_orig_uses
                    else:

                        for idx, inv_item in enumerate(save_data.get("hands", {}).get("items", [])):
                            if inv_item is lighting_device:
                                save_data["hands"]["items"].pop(idx)
                                break
                        else:
                            for slot_name, eq_item in save_data.get("equipment", {}).items():
                                if isinstance(eq_item, dict)and eq_item.get("items"):
                                    for idx, inv_item in enumerate(eq_item.get("items", [])):
                                        if inv_item is lighting_device:
                                            eq_item["items"].pop(idx)
                                            break

            if item.get("disinfectant_required")and disinfectant_found:
                for snd in disinfectant_sounds:
                    self._safe_sound_play("misc/consumable", snd.replace(".ogg", ""), block = True)

            for snd in sounds:
                if snd and snd !="lightingdevice":
                    self._safe_sound_play("misc/consumable", snd.replace(".ogg", ""), block = True)

            if item.get("used_up"):
                uses = item.get("uses_left", 1)
                if uses >1:
                    item["uses_left"]= uses -1

                    item_id = item.get("id")
                    if item_id is not None and item_id in table_items_map:
                        table_item = table_items_map[item_id]
                        original_uses = table_item.get("uses_left", 1)
                        original_weight = table_item.get("weight", 0)
                        if original_uses >0 and original_weight >0:
                            new_weight = original_weight *(uses -1)/original_uses
                            item["weight"]= new_weight
                            logging.info(f"Consumed {item.get('name')}, {uses -1} uses remaining, weight now {new_weight:.4f}")
                        else:
                            logging.info(f"Consumed {item.get('name')}, {uses -1} uses remaining")
                    else:
                        logging.info(f"Consumed {item.get('name')}, {uses -1} uses remaining")
                else:

                    items_list_or_subslot, idx = find_item_in_location(location, item)
                    if items_list_or_subslot is not None:
                        if idx =="current":

                            items_list_or_subslot["current"]= None
                            logging.info(f"Consumed and removed {item.get('name')} from subslot")
                        elif isinstance(idx, int)and idx >=0:
                            items_list_or_subslot.pop(idx)
                            logging.info(f"Consumed and removed {item.get('name')}")
            else:
                logging.info(f"Used {item.get('name')}(reusable)")

            self._save_file(save_data)

            if on_complete:
                self.root.after(0, on_complete)

        thread = threading.Thread(target = play_sounds_and_finish, daemon = True)
        thread.start()

    def _use_stratagem(self, item, location, save_data, on_complete = None):

        import threading

        if not item or not isinstance(item, dict):
            self._popup_show_info("Error", "Invalid item.", sound = "error")
            return

        if not item.get("stratagem"):
            self._popup_show_info("Error", "This item is not a stratagem.", sound = "error")
            return

        num_rounds = item.get("rounds", 1)

        rounds_data =[]
        for r in range(1, num_rounds +1):
            seq = item.get(f"round_{r}", [])
            if seq:
                rounds_data.append(seq)

        if not rounds_data:
            self._popup_show_info("Error", "No stratagem sequences defined.", sound = "error")
            return

        dir_to_arrow = {
        "up":"â†‘",
        "down":"â†“",
        "left":"â†",
        "right":"â†’"
        }

        arrow_to_dir = {
        "Up":"up",
        "Down":"down",
        "Left":"left",
        "Right":"right"
        }

        strat_window = customtkinter.CTkToplevel(self.root)
        strat_window.title(f"Stratagem: {self._format_item_name(item)}")
        strat_window.transient(self.root)
        self._center_popup_on_window(strat_window, 600, 400)
        strat_window.grab_set()
        strat_window.focus_force()

        state = {
        "current_round":0,
        "current_index":0,
        "music_channel":None,
        "is_complete":False
        }

        main_frame = customtkinter.CTkFrame(strat_window)
        main_frame.pack(fill = "both", expand = True, padx = 20, pady = 20)

        title_label = customtkinter.CTkLabel(
        main_frame,
        text = "Starting Stratagem Sequence",
        font = customtkinter.CTkFont(size = 24, weight = "bold")
        )
        title_label.pack(pady = 20)

        round_label = customtkinter.CTkLabel(
        main_frame,
        text = "",
        font = customtkinter.CTkFont(size = 16)
        )
        round_label.pack(pady = 10)

        arrows_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        arrows_frame.pack(pady = 30)

        arrow_labels =[]

        def play_sound_blocking(sound_name):

            sound_path = os.path.join("sounds", "misc", "stratagem", f"{sound_name}.ogg")
            if os.path.exists(sound_path):
                try:
                    sound = pygame.mixer.Sound(sound_path)
                    sound.play()
                    time.sleep(sound.get_length())
                except Exception as e:
                    logging.warning(f"Failed to play stratagem sound {sound_name}: {e}")

        def play_sound(sound_name):

            sound_path = os.path.join("sounds", "misc", "stratagem", f"{sound_name}.ogg")
            if os.path.exists(sound_path):
                try:
                    sound = pygame.mixer.Sound(sound_path)
                    sound.play()
                except Exception as e:
                    logging.warning(f"Failed to play stratagem sound {sound_name}: {e}")

        def start_music():

            sound_path = os.path.join("sounds", "misc", "stratagem", "game_music.ogg")
            if os.path.exists(sound_path):
                try:
                    sound = pygame.mixer.Sound(sound_path)
                    state["music_channel"]= sound.play(loops = -1)
                except Exception as e:
                    logging.warning(f"Failed to start stratagem music: {e}")

        def stop_music():

            if state["music_channel"]:
                try:
                    state["music_channel"].stop()
                except Exception:
                    pass

        def display_round(round_idx):

            nonlocal arrow_labels

            for lbl in arrow_labels:
                lbl.destroy()
            arrow_labels =[]

            if round_idx >=len(rounds_data):
                return

            sequence = rounds_data[round_idx]
            round_label.configure(text = f"Round {round_idx +1} of {len(rounds_data)}")

            for i, direction in enumerate(sequence):
                arrow = dir_to_arrow.get(direction.lower(), "?")
                lbl = customtkinter.CTkLabel(
                arrows_frame,
                text = arrow,
                font = customtkinter.CTkFont(size = 48, weight = "bold"),
                text_color = "gray"
                )
                lbl.pack(side = "left", padx = 10)
                arrow_labels.append(lbl)

            if arrow_labels:
                arrow_labels[0].configure(text_color = "#3B8ED0")

        def update_arrow_colors():

            sequence = rounds_data[state["current_round"]]
            for i, lbl in enumerate(arrow_labels):
                if i <state["current_index"]:
                    lbl.configure(text_color = "gray")
                elif i ==state["current_index"]:
                    lbl.configure(text_color = "#3B8ED0")
                else:
                    lbl.configure(text_color = "white")

        def show_error():

            for lbl in arrow_labels:
                lbl.configure(text_color = "red")
            play_sound("button_press_error")

            def reset_after_error():
                state["current_index"]= 0
                update_arrow_colors()

            strat_window.after(500, reset_after_error)

        def show_success():

            for lbl in arrow_labels:
                lbl.configure(text_color = "green")

        def on_sequence_complete():

            show_success()

            def after_success():
                play_sound_blocking("sequence_success")
                play_sound_blocking("round_over")

                state["current_round"]+=1
                state["current_index"]= 0

                if state["current_round"]>=len(rounds_data):

                    on_game_complete()
                else:

                    strat_window.after(0, lambda:display_round(state["current_round"]))

            threading.Thread(target = after_success, daemon = True).start()

        def on_game_complete():

            state["is_complete"]= True
            stop_music()

            def finish_game():
                play_sound_blocking("game_over")

                def find_and_remove():
                    if location =="hands":
                        items_list = save_data.get("hands", {}).get("items", [])
                        for idx, it in enumerate(items_list):
                            if it is item:
                                items_list.pop(idx)
                                break
                    elif location.startswith("equipment."):
                        parts = location.split(".")
                        slot = parts[1]
                        eq = save_data.get("equipment", {}).get(slot)
                        if eq and isinstance(eq, dict):
                            items_list = eq.get("items", [])
                            for idx, it in enumerate(items_list):
                                if it is item:
                                    items_list.pop(idx)
                                    break

                find_and_remove()
                self._save_file(save_data)
                logging.info(f"Stratagem {item.get('name')} completed and consumed")

                def close_and_callback():
                    strat_window.destroy()
                    if on_complete:
                        on_complete()

                strat_window.after(0, close_and_callback)

            threading.Thread(target = finish_game, daemon = True).start()

        def on_key_press(event):

            if state["is_complete"]:
                return

            if state["current_round"]>=len(rounds_data):
                return

            key_dir = arrow_to_dir.get(event.keysym)
            if not key_dir:
                return

            sequence = rounds_data[state["current_round"]]
            expected = sequence[state["current_index"]].lower()

            if key_dir ==expected:

                play_sound("button_press")
                state["current_index"]+=1

                if state["current_index"]>=len(sequence):

                    on_sequence_complete()
                else:
                    update_arrow_colors()
            else:

                show_error()

        def start_game():

            title_label.configure(text = item.get("name", "Stratagem"))
            start_music()
            display_round(0)
            update_arrow_colors()
            strat_window.bind("<Key>", on_key_press)

        def intro_sequence():

            play_sound_blocking("round_start_coin")
            strat_window.after(0, start_game)

        def on_window_close():

            stop_music()
            strat_window.destroy()

        strat_window.protocol("WM_DELETE_WINDOW", on_window_close)

        threading.Thread(target = intro_sequence, daemon = True).start()

    def _calculate_encumbrance_status(self, save_data):

        def compute_item_weight(itm, include_contained = True):

            if not itm or not isinstance(itm, dict):
                return 0.0
            qty = itm.get("quantity", 1)
            weight = itm.get("weight", 0)*qty

            if include_contained:
                for contained in itm.get("items", []):
                    weight +=compute_item_weight(contained, include_contained = True)

            if "subslots"in itm:
                for ss in itm.get("subslots", []):
                    current = ss.get("current")
                    weight +=compute_item_weight(current, include_contained = True)
            return weight

        def compute_encumbrance_contribution(itm, is_equipped = False):

            if not itm or not isinstance(itm, dict):
                return 0.0

            qty = itm.get("quantity", 1)
            base_weight = itm.get("weight", 0)*qty

            reduction = itm.get("encumbrance_reduction", 1.0)if is_equipped else 1.0
            if reduction <=0:
                reduction = 1.0

            encumbrance = base_weight

            contained_weight = 0.0
            for contained in itm.get("items", []):
                contained_weight +=compute_item_weight(contained, include_contained = True)

            if is_equipped and reduction >0:

                encumbrance +=contained_weight /reduction
            else:

                encumbrance +=contained_weight

            if "subslots"in itm:
                for ss in itm.get("subslots", []):
                    current = ss.get("current")
                    encumbrance +=compute_encumbrance_contribution(current, is_equipped = is_equipped)

            return encumbrance

        total_weight = 0.0
        total_encumbrance = 0.0

        for item in save_data.get("hands", {}).get("items", []):
            item_weight = compute_item_weight(item, include_contained = True)
            total_weight +=item_weight
            total_encumbrance +=item_weight

        for slot, item in save_data.get("equipment", {}).items():
            if item and isinstance(item, dict):
                item_weight = compute_item_weight(item, include_contained = True)
                total_weight +=item_weight

                total_encumbrance +=compute_encumbrance_contribution(item, is_equipped = True)

        encumbrance = max(total_encumbrance, 0.0)

        strength = save_data.get("stats", {}).get("Strength", 0)

        stat_clamp = 4
        try:
            import glob, json, os
            tbl_path = get_current_table_path()
            if tbl_path and os.path.exists(tbl_path):
                with open(tbl_path, 'r')as tf:
                    td = json.load(tf)
                    sc = td.get("additional_settings", {}).get("stat_clamp")
                    if isinstance(sc, (int, float)):
                        stat_clamp = int(sc)
        except Exception:
            pass

        stat_min = -20
        stat_max = stat_clamp

        m_clamped = max(stat_min, min(strength, stat_max))

        span = float(stat_max -stat_min)
        if span <=0:
            span = 24.0

        threshold = 15.0 +85.0 *(m_clamped -stat_min)/span

        threshold = max(15.0, min(100.0, threshold))

        encumbrance_level = 0
        if encumbrance >threshold:
            overflow_percent =(encumbrance -threshold)/threshold
            encumbrance_level = int(overflow_percent *10)

        return {
        "total_weight":total_weight,
        "total_reduction":0.0,
        "encumbrance":encumbrance,
        "threshold":threshold,
        "encumbrance_level":encumbrance_level,
        "is_encumbered":encumbrance_level >0
        }

    def _transfer_player(self):
        import json
        import base64
        import pickle
        from datetime import datetime

        if currentsave is None:
            self._popup_show_info("Error", "No character loaded.", sound = "error")
            return

        self._clear_window()

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.pack(fill = "both", expand = True, padx = 20, pady = 20)

        title = customtkinter.CTkLabel(main_frame, text = "Player Transfer", font = customtkinter.CTkFont(size = 20, weight = "bold"))
        title.pack(pady =(0, 20))

        export_frame = customtkinter.CTkFrame(main_frame)
        export_frame.pack(fill = "x", pady = 10, padx = 10)

        export_label = customtkinter.CTkLabel(export_frame, text = "Export Items/Money", font = customtkinter.CTkFont(size = 16, weight = "bold"))
        export_label.pack(pady = 10)

        money_frame = customtkinter.CTkFrame(export_frame, fg_color = "transparent")
        money_frame.pack(pady = 5)

        money_label = customtkinter.CTkLabel(money_frame, text = "Money Amount:")
        money_label.pack(side = "left", padx = 5)

        money_entry = customtkinter.CTkEntry(money_frame, placeholder_text = "0", width = 150)
        money_entry.pack(side = "left", padx = 5)

        items_label = customtkinter.CTkLabel(export_frame, text = "Select items to export from storage:", font = customtkinter.CTkFont(size = 13))
        items_label.pack(pady =(10, 5))

        items_scroll = customtkinter.CTkScrollableFrame(export_frame, width = 700, height = 200)
        items_scroll.pack(pady = 5, padx = 10)

        selected_items =[]

        def refresh_export_items():
            for widget in items_scroll.winfo_children():
                widget.destroy()
            selected_items.clear()

            save_path = os.path.join(saves_folder or "", (currentsave or "")+".sldsv")
            try:
                save_data = self._load_file((currentsave or "")+".sldsv")
                if save_data is None:
                    raise RuntimeError("Failed to load current save for export")

                storage_items = save_data.get("storage", [])

                if not storage_items:
                    empty_label = customtkinter.CTkLabel(items_scroll, text = "No items in storage", text_color = "gray")
                    empty_label.pack(pady = 20)
                    return

                for idx, item in enumerate(storage_items):
                    item_frame = customtkinter.CTkFrame(items_scroll)
                    item_frame.pack(fill = "x", pady = 2, padx = 5)

                    var = customtkinter.BooleanVar(value = False)

                    def on_check(index = idx, var_ref = var):
                        if var_ref.get():
                            if index not in selected_items:
                                selected_items.append(index)
                        else:
                            if index in selected_items:
                                selected_items.remove(index)

                    checkbox = customtkinter.CTkCheckBox(
                    item_frame,
                    text = f"{self._format_item_name(item)} x{item.get('quantity', 1)}",
                    variable = var,
                    command = on_check
                    )
                    checkbox.pack(side = "left", padx = 10, pady = 5)
            except Exception as e:
                logging.error(f"Failed to load items: {e}")

        refresh_export_items()

        def create_export():
            try:
                save_path = os.path.join(saves_folder or "", (currentsave or "")+".sldsv")
                save_data = self._load_file((currentsave or "")+".sldsv")
                if save_data is None:
                    raise RuntimeError("Failed to load current save for export")

                money_amount = int(money_entry.get()or 0)

                if money_amount >save_data.get("money", 0):
                    self._popup_show_info("Error", "Not enough money!", sound = "error")
                    return

                storage_items = save_data.get("storage", [])
                items_to_export =[storage_items[i]for i in sorted(selected_items)if i <len(storage_items)]

                transfer_data = {
                "money":money_amount,
                "items":items_to_export,
                "timestamp":datetime.now().isoformat(),
                "from_character":save_data.get("charactername", "Unknown")
                }

                save_data["money"]= save_data.get("money", 0)-money_amount

                for idx in sorted(selected_items, reverse = True):
                    if idx <len(storage_items):
                        storage_items.pop(idx)

                save_data["storage"]= storage_items

                self._save_file(save_data)

                pickled_data = pickle.dumps(transfer_data)
                encoded_data = base64.b85encode(pickled_data).decode('utf-8')

                transfer_filename = f"transfers/transfer_{datetime.now().strftime('%Y%m%d_%H%M%S')}.sldtrf"
                with open(transfer_filename, 'w')as f:
                    f.write(encoded_data)

                self._popup_show_info("Success", f"Exported {len(items_to_export)} items and ${money_amount}!", sound = "success")
                logging.info(f"Created transfer file: {transfer_filename}")
                refresh_export_items()
            except Exception as e:
                logging.error(f"Export failed: {e}")
                self._popup_show_info("Error", f"Export failed: {e}", sound = "error")

        export_button = self._create_sound_button(export_frame, "Create Transfer File", create_export, width = 200, height = 40)
        export_button.pack(pady = 10)

        import_frame = customtkinter.CTkFrame(main_frame)
        import_frame.pack(fill = "x", pady = 10, padx = 10)

        import_label = customtkinter.CTkLabel(import_frame, text = "Import Transfer File", font = customtkinter.CTkFont(size = 16, weight = "bold"))
        import_label.pack(pady = 10)

        def list_transfers():
            try:
                transfer_files = glob.glob("transfers/*.sldtrf")
                if not transfer_files:
                    self._popup_show_info("Info", "No transfer files found.", sound = "popup")
                    return

                select_window = customtkinter.CTkToplevel(self.root)
                select_window.title("Select Transfer File")
                select_window.transient(self.root)
                self._center_popup_on_window(select_window, 500, 400)

                scroll_frame = customtkinter.CTkScrollableFrame(select_window, width = 450, height = 300)
                scroll_frame.pack(pady = 10, padx = 10, fill = "both", expand = True)

                def import_transfer(filepath):
                    try:
                        with open(filepath, 'r')as f:
                            encoded_data = f.read()

                        pickled_data = base64.b85decode(encoded_data.encode('utf-8'))
                        transfer_data = pickle.loads(pickled_data)

                        save_data = self._load_file((currentsave or "")+".sldsv")
                        if save_data is None:
                            raise RuntimeError("Failed to load current save for import")
                        save_data["money"]= save_data.get("money", 0)+transfer_data.get("money", 0)
                        for item in transfer_data.get("items", []):
                            save_data["storage"].append(item)
                        self._save_file(save_data)

                        os.remove(filepath)

                        select_window.destroy()
                        self._popup_show_info("Success", f"Received ${transfer_data.get('money', 0)} and {len(transfer_data.get('items', []))} items!", sound = "success")
                    except Exception as e:
                        logging.error(f"Import failed: {e}")
                        self._popup_show_info("Error", f"Import failed: {e}", sound = "error")

                for i, filepath in enumerate(transfer_files):
                    try:
                        with open(filepath, 'r')as f:
                            encoded_data = f.read()
                        pickled_data = base64.b85decode(encoded_data.encode('utf-8'))
                        transfer_data = pickle.loads(pickled_data)

                        file_frame = customtkinter.CTkFrame(scroll_frame)
                        file_frame.pack(fill = "x", pady = 5, padx = 5)

                        info_label = customtkinter.CTkLabel(
                        file_frame,
                        text = f"From: {transfer_data.get('from_character', 'Unknown')}\nMoney: ${transfer_data.get('money', 0)} | Items: {len(transfer_data.get('items', []))}",
                        anchor = "w"
                        )
                        info_label.pack(side = "left", padx = 10, pady = 5)

                        import_btn = self._create_sound_button(
                        file_frame,
                        "Import",
                        lambda f = filepath:import_transfer(f),
                        width = 100,
                        height = 35
                        )
                        import_btn.pack(side = "right", padx = 10, pady = 5)
                    except Exception as e:
                        logging.warning(f"Failed to read transfer file {filepath}: {e}")

                select_window.update_idletasks()
                select_window.deiconify()
                select_window.grab_set()
            except Exception as e:
                logging.error(f"Failed to list transfers: {e}")
                self._popup_show_info("Error", f"Failed to list transfers: {e}", sound = "error")

        import_button = self._create_sound_button(import_frame, "Browse Transfer Files", list_transfers, width = 200, height = 40)
        import_button.pack(pady = 10)

        back_button = self._create_sound_button(main_frame, "Back", lambda:[self._clear_window(), self._open_inventory_management()], width = 200, height = 40)
        back_button.pack(pady = 20)

    def _manage_containers(self):
        logging.info("Container Management definition called")

        if currentsave is None:
            self._popup_show_info("Error", "No character loaded.", sound = "error")
            return

        self._clear_window()

        save_filename =(currentsave or "")+".sldsv"
        save_data = self._load_file(save_filename)

        if save_data is None:
            logging.error(f"Failed to load save file {save_filename}")
            self._popup_show_info("Error", f"Failed to load character data", sound = "error")
            return

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew", padx = 20, pady = 20)
        main_frame.grid_rowconfigure(1, weight = 1)
        main_frame.grid_columnconfigure(0, weight = 1)

        title = customtkinter.CTkLabel(main_frame, text = "Manage Containers & Transfer Items", font = customtkinter.CTkFont(size = 20, weight = "bold"))
        title.grid(row = 0, column = 0, pady =(0, 10))

        tabview = customtkinter.CTkTabview(main_frame, width = 1000, height = 600)
        tabview.grid(row = 1, column = 0, sticky = "nsew", pady = 10)

        tabview.add("View Inventory")
        tabview.add("Transfer Items")

        view_tab = tabview.tab("View Inventory")
        view_tab.grid_rowconfigure(1, weight = 1)
        view_tab.grid_columnconfigure(0, weight = 1)

        enc_info_frame = customtkinter.CTkFrame(view_tab, fg_color =("gray90", "gray20"))
        enc_info_frame.grid(row = 0, column = 0, sticky = "ew", padx = 10, pady = 10)
        enc_info_frame.grid_columnconfigure(0, weight = 1)

        enc_info_label = customtkinter.CTkLabel(enc_info_frame, font = customtkinter.CTkFont(size = 12), anchor = "w")
        enc_info_label.grid(row = 0, column = 0, sticky = "ew", padx = 15, pady = 10)

        def refresh_enc_info():
            encumbrance_info = self._calculate_encumbrance_status(save_data)
            enc_info_label.configure(
            text =(
            f"Total Weight: {self._format_weight(encumbrance_info['total_weight'])} | "
            f"Encumbrance: {self._format_weight(encumbrance_info['encumbrance'])} / {self._format_weight(encumbrance_info['threshold'])} | "
            f"Encumbrance level: {encumbrance_info['encumbrance_level']} | "
            f"Status: {'ENCUMBERED'if encumbrance_info['is_encumbered']else 'OK'}"
            )
            )

        tabview.configure(command = lambda value = None:refresh_enc_info())

        def get_containers():
            containers =[]
            equipment = save_data.get("equipment", {})

            def _slot_blocked_by_subslots(slot_name):
                try:
                    slot_name_l = str(slot_name).lower()if slot_name is not None else ''
                    for other_slot, other_item in equipment.items():
                        if not other_item:
                            continue
                        items_to_check =[]
                        if isinstance(other_item, dict):
                            items_to_check =[other_item]
                        elif isinstance(other_item, list):
                            items_to_check =[it for it in other_item if isinstance(it, dict)]

                        for oi in items_to_check:

                            for subslot_data in oi.get('subslots', [])or[]:
                                try:
                                    conflicts = subslot_data.get('conflicts_with')

                                    if isinstance(conflicts, dict):
                                        if conflicts.get('type')=='main'and str(conflicts.get('slot')).lower()==slot_name_l:
                                            return True
                                    elif isinstance(conflicts, (list, tuple)):
                                        for conflict_slot in conflicts:
                                            if str(conflict_slot).lower()==slot_name_l:
                                                return True
                                except Exception:
                                    pass

                            for acc in oi.get('accessories', [])or[]:
                                try:
                                    curacc = acc.get('current')
                                    if not isinstance(curacc, dict):
                                        continue
                                    for subslot_data in curacc.get('subslots', [])or[]:
                                        try:
                                            conflicts = subslot_data.get('conflicts_with')
                                            cur = subslot_data.get('current')
                                            if not cur:
                                                continue
                                            if isinstance(conflicts, dict):
                                                if conflicts.get('type')=='main'and str(conflicts.get('slot')).lower()==slot_name_l:
                                                    return True
                                            elif isinstance(conflicts, (list, tuple)):
                                                for conflict_slot in conflicts:
                                                    if str(conflict_slot).lower()==slot_name_l:
                                                        return True
                                        except Exception:
                                            pass
                                except Exception:
                                    pass
                    return False
                except Exception:
                    return False

            def _get_conflict_sources(slot_name):
                sources =[]
                try:
                    slot_name_l = str(slot_name).lower()if slot_name is not None else ''
                    for other_slot, other_item in equipment.items():
                        if not other_item:
                            continue
                        items_to_check =[]
                        if isinstance(other_item, dict):
                            items_to_check =[other_item]
                        elif isinstance(other_item, list):
                            items_to_check =[it for it in other_item if isinstance(it, dict)]

                        for oi in items_to_check:
                            for subslot_data in oi.get('subslots', [])or[]:
                                try:
                                    conflicts = subslot_data.get('conflicts_with')
                                    cur = subslot_data.get('current')
                                    if not cur:
                                        continue

                                    targets =[]
                                    if isinstance(conflicts, dict):
                                        if conflicts.get('type')=='main'and conflicts.get('slot'):
                                            targets =[conflicts.get('slot')]
                                    elif isinstance(conflicts, (list, tuple)):
                                        targets =[str(c)for c in conflicts]
                                    elif conflicts:
                                        targets =[str(conflicts)]

                                    targets_l =[str(t).lower()for t in targets]
                                    if slot_name_l in targets_l:
                                        subname = subslot_data.get('name')or subslot_data.get('slot')or 'subslot'
                                        sources.append(f"{other_slot}.{subname}")
                                except Exception:
                                    pass

                            for acc in oi.get('accessories', [])or[]:
                                try:
                                    curacc = acc.get('current')
                                    if not isinstance(curacc, dict):
                                        continue
                                    for subslot_data in curacc.get('subslots', [])or[]:
                                        try:
                                            conflicts = subslot_data.get('conflicts_with')

                                            targets =[]
                                            if isinstance(conflicts, dict):
                                                if conflicts.get('type')=='main'and conflicts.get('slot'):
                                                    targets =[conflicts.get('slot')]
                                            elif isinstance(conflicts, (list, tuple)):
                                                targets =[str(c)for c in conflicts]
                                            elif conflicts:
                                                targets =[str(conflicts)]

                                            targets_l =[str(t).lower()for t in targets]
                                            if slot_name_l in targets_l:
                                                subname = subslot_data.get('name')or subslot_data.get('slot')or 'subslot'
                                                sources.append(f"{other_slot}.{subname}")
                                        except Exception:
                                            pass
                                except Exception:
                                    pass
                except Exception:
                    pass

                seen = set()
                out =[]
                for s in sources:
                    if s not in seen:
                        seen.add(s)
                        out.append(s)
                return out

            def _get_conflicting_item_names(slot_name):
                names =[]
                try:
                    slot_name_l = str(slot_name).lower()if slot_name is not None else ''
                    for other_slot, other_item in equipment.items():
                        if not other_item:
                            continue
                        items_to_check =[]
                        if isinstance(other_item, dict):
                            items_to_check =[other_item]
                        elif isinstance(other_item, list):
                            items_to_check =[it for it in other_item if isinstance(it, dict)]

                        for oi in items_to_check:
                            for subslot_data in oi.get('subslots', [])or[]:
                                try:
                                    conflicts = subslot_data.get('conflicts_with')

                                    targets =[]
                                    if isinstance(conflicts, dict):
                                        if conflicts.get('type')=='main'and conflicts.get('slot'):
                                            targets =[conflicts.get('slot')]
                                    elif isinstance(conflicts, (list, tuple)):
                                        targets =[str(c)for c in conflicts]
                                    elif conflicts:
                                        targets =[str(conflicts)]
                                    targets_l =[t.lower()for t in targets]
                                    if slot_name_l in targets_l:

                                        nm = None
                                        try:
                                            if isinstance(oi, dict):
                                                nm = oi.get('name')or oi.get('id')
                                        except Exception:
                                            nm = None
                                        if not nm:
                                            cur = subslot_data.get('current')
                                            if isinstance(cur, dict):
                                                nm = cur.get('name')or cur.get('id')
                                        if not nm:
                                            nm = other_slot
                                        if nm:
                                            names.append(str(nm))
                                except Exception:
                                    pass

                            for acc in oi.get('accessories', [])or[]:
                                try:

                                    curacc = acc.get('current')if isinstance(acc, dict)else None
                                    acc_subslots =[]
                                    if isinstance(curacc, dict):
                                        acc_subslots.extend(curacc.get('subslots', [])or[])
                                    if isinstance(acc, dict):
                                        acc_subslots.extend(acc.get('subslots', [])or[])

                                    for subslot_data in acc_subslots:
                                        try:
                                            conflicts = subslot_data.get('conflicts_with')
                                            targets =[]
                                            if isinstance(conflicts, dict):
                                                if conflicts.get('type')=='main'and conflicts.get('slot'):
                                                    targets =[conflicts.get('slot')]
                                            elif isinstance(conflicts, (list, tuple)):
                                                targets =[str(c)for c in conflicts]
                                            elif conflicts:
                                                targets =[str(conflicts)]
                                            targets_l =[t.lower()for t in targets]
                                            if slot_name_l in targets_l:

                                                nm = None
                                                try:
                                                    if isinstance(curacc, dict):
                                                        nm = curacc.get('name')or curacc.get('id')
                                                except Exception:
                                                    nm = None
                                                if not nm:
                                                    try:
                                                        if isinstance(acc, dict):
                                                            nm = acc.get('name')or acc.get('id')
                                                    except Exception:
                                                        nm = None
                                                if not nm:
                                                    try:
                                                        if isinstance(oi, dict):
                                                            nm = oi.get('name')or oi.get('id')
                                                    except Exception:
                                                        nm = None
                                                if not nm:
                                                    nm = other_slot
                                                if nm:
                                                    names.append(str(nm))
                                        except Exception:
                                            pass
                                except Exception:
                                    pass
                except Exception:
                    pass

                seen = set();out =[]
                for n in names:
                    if n not in seen:
                        seen.add(n);out.append(n)
                return out

            def _find_any_item_with_conflict(slot_name):

                try:
                    slot_name_l = str(slot_name).lower()if slot_name is not None else ''
                    def check_item(it):
                        if not isinstance(it, dict):
                            return None

                        for ss in it.get('subslots', [])or[]:
                            try:
                                conflicts = ss.get('conflicts_with')
                                targets =[]
                                if isinstance(conflicts, dict):
                                    if conflicts.get('type')=='main'and conflicts.get('slot'):
                                        targets =[conflicts.get('slot')]
                                elif isinstance(conflicts, (list, tuple)):
                                    targets =[str(c)for c in conflicts]
                                elif conflicts:
                                    targets =[str(conflicts)]
                                if any(slot_name_l ==t.lower()for t in targets):
                                    return it.get('name')or it.get('id')
                            except Exception:
                                pass

                        for acc in it.get('accessories', [])or[]:
                            try:

                                for src in(acc, acc.get('current')):
                                    if not isinstance(src, dict):
                                        continue
                                    for ss in src.get('subslots', [])or[]:
                                        try:
                                            conflicts = ss.get('conflicts_with')
                                            targets =[]
                                            if isinstance(conflicts, dict):
                                                if conflicts.get('type')=='main'and conflicts.get('slot'):
                                                    targets =[conflicts.get('slot')]
                                            elif isinstance(conflicts, (list, tuple)):
                                                targets =[str(c)for c in conflicts]
                                            elif conflicts:
                                                targets =[str(conflicts)]
                                            if any(slot_name_l ==t.lower()for t in targets):

                                                return(src.get('name')or src.get('id')or it.get('name')or it.get('id'))
                                        except Exception:
                                            pass
                            except Exception:
                                pass
                        return None

                    for s, it in equipment.items():
                        if isinstance(it, dict):
                            nm = check_item(it)
                            if nm:
                                return str(nm)
                        elif isinstance(it, list):
                            for sub in it:
                                nm = check_item(sub)
                                if nm:
                                    return str(nm)

                    for it in save_data.get('storage', [])or[]:
                        nm = check_item(it)
                        if nm:
                            return str(nm)

                    for it in(save_data.get('hands')or {}).get('items', [])or[]:
                        nm = check_item(it)
                        if nm:
                            return str(nm)

                except Exception:
                    pass
                return None

            containers.append({"name":"Hands", "location":"hands"})
            containers.append({"name":"Storage", "location":"storage"})

            for slot, item in equipment.items():

                if item and isinstance(item, dict):
                    if "capacity"in item and "items"in item:
                        containers.append({
                        "name":f"{item.get('name', 'Container')}({slot})",
                        "location":f"equipment.{slot}"
                        })

                    if "subslots"in item:
                        for subslot_idx, subslot_data in enumerate(item["subslots"]):
                            subslot_item = subslot_data.get("current")
                            if subslot_item and isinstance(subslot_item, dict):
                                if "capacity"in subslot_item and "items"in subslot_item:
                                    subslot_name = subslot_data.get("name", f"Subslot {subslot_idx}")
                                    containers.append({
                                    "name":f"{subslot_item.get('name', 'Container')}({slot} â†’ {subslot_name})",
                                    "location":f"equipment.{slot}.subslot.{subslot_idx}"
                                    })

                elif isinstance(item, list):
                    for idx, subitem in enumerate(item):
                        try:
                            if subitem and isinstance(subitem, dict)and "capacity"in subitem and "items"in subitem:
                                containers.append({
                                "name":f"{subitem.get('name', 'Container')}({slot}#{idx})",
                                "location":f"equipment.{slot}.list.{idx}"
                                })

                            if subitem and isinstance(subitem, dict)and "subslots"in subitem:
                                for subslot_idx, subslot_data in enumerate(subitem.get("subslots", [])):
                                    subslot_item = subslot_data.get("current")
                                    if subslot_item and isinstance(subslot_item, dict):
                                        if "capacity"in subslot_item and "items"in subslot_item:
                                            subslot_name = subslot_data.get("name", f"Subslot {subslot_idx}")
                                            containers.append({
                                            "name":f"{subslot_item.get('name', 'Container')}({slot}#{idx} â†’ {subslot_name})",
                                            "location":f"equipment.{slot}.list.{idx}.subslot.{subslot_idx}"
                                            })
                        except Exception:
                            pass

            return containers

        containers = get_containers()

        def get_container_items(location):

            if location =="storage":
                return save_data.get("storage", [])
            elif location =="hands":
                return save_data["hands"].get("items", [])
            elif location.startswith("equipment."):
                parts = location.split(".")
                slot = parts[1]
                item = save_data["equipment"].get(slot)
                if item is None:
                    return[]

                if len(parts)>2 and parts[2]=="subslot":
                    subslot_idx = int(parts[3])
                    if isinstance(item, dict)and "subslots"in item and subslot_idx <len(item["subslots"]):
                        subslot_item = item["subslots"][subslot_idx].get("current")
                        if subslot_item and isinstance(subslot_item, dict):
                            return subslot_item.get("items", [])

                if len(parts)>2 and parts[2]=="list":
                    list_idx = int(parts[3])
                    if isinstance(item, list)and 0 <=list_idx <len(item):
                        subitem = item[list_idx]
                        if len(parts)>4 and parts[4]=="subslot":
                            subslot_idx = int(parts[5])
                            if "subslots"in subitem and subslot_idx <len(subitem["subslots"]):
                                subslot_item = subitem["subslots"][subslot_idx].get("current")
                                if subslot_item and isinstance(subslot_item, dict):
                                    return subslot_item.get("items", [])
                        return subitem.get("items", [])if isinstance(subitem, dict)else[]

                if isinstance(item, dict):
                    return item.get("items", [])
            return[]

        def set_container_items(location, items):

            if location =="storage":
                save_data["storage"]= items
            elif location =="hands":
                save_data["hands"]["items"]= items
            elif location.startswith("equipment."):
                parts = location.split(".")
                slot = parts[1]
                if slot in save_data["equipment"]and save_data["equipment"][slot]:
                    item = save_data["equipment"][slot]

                    if len(parts)>2 and parts[2]=="subslot":
                        subslot_idx = int(parts[3])
                        if isinstance(item, dict)and "subslots"in item and subslot_idx <len(item["subslots"]):
                            subslot_item = item["subslots"][subslot_idx].get("current")
                            if subslot_item and isinstance(subslot_item, dict):
                                subslot_item["items"]= items

                    elif len(parts)>2 and parts[2]=="list":
                        list_idx = int(parts[3])
                        if isinstance(item, list)and 0 <=list_idx <len(item):
                            subitem = item[list_idx]
                            if len(parts)>4 and parts[4]=="subslot":
                                subslot_idx = int(parts[5])
                                if "subslots"in subitem and subslot_idx <len(subitem["subslots"]):
                                    subslot_item = subitem["subslots"][subslot_idx].get("current")
                                    if subslot_item and isinstance(subslot_item, dict):
                                        subslot_item["items"]= items
                            else:
                                if isinstance(subitem, dict):
                                    subitem["items"]= items
                    else:
                        if isinstance(item, dict):
                            item["items"]= items

        def get_container_weight(location):

            items = get_container_items(location)
            return sum(i.get("weight", 0)*i.get("quantity", 1)for i in items if isinstance(i, dict))

        def get_container_capacity(location):

            if location =="hands":
                base_capacity = save_data.get("hands", {}).get("capacity", 50)
                strength = save_data.get("stats", {}).get("Strength", 0)

                return base_capacity *(1 +strength *0.1)
            if location.startswith("equipment."):
                parts = location.split(".")
                slot = parts[1]
                equip = save_data.get("equipment", {}).get(slot)
                if equip:

                    if len(parts)>2 and parts[2]=="subslot":
                        subslot_idx = int(parts[3])
                        if isinstance(equip, dict)and "subslots"in equip and subslot_idx <len(equip["subslots"]):
                            subslot_item = equip["subslots"][subslot_idx].get("current")
                            if subslot_item and isinstance(subslot_item, dict):
                                return subslot_item.get("capacity")
                            return None

                    if len(parts)>2 and parts[2]=="list":
                        list_idx = int(parts[3])
                        if isinstance(equip, list)and 0 <=list_idx <len(equip):
                            subitem = equip[list_idx]
                            if len(parts)>4 and parts[4]=="subslot":
                                subslot_idx = int(parts[5])
                                if "subslots"in subitem and subslot_idx <len(subitem["subslots"]):
                                    subslot_item = subitem["subslots"][subslot_idx].get("current")
                                    if subslot_item and isinstance(subslot_item, dict):
                                        return subslot_item.get("capacity")
                                return None
                            return subitem.get("capacity")if isinstance(subitem, dict)else None
                    return equip.get("capacity")if isinstance(equip, dict)else None

            return None

        def rebuild_container_labels():

            labels =[]
            for c in containers:

                total_weight = get_container_weight(c["location"])

                try:
                    capacity = get_container_capacity(c.get("location"))
                except Exception:
                    capacity = None
                capacity_text = self._format_weight(capacity)if capacity is not None else "âˆž"
                c["label"]= f"{c['name']}({self._format_weight(total_weight)}/{capacity_text})"
                labels.append(c["label"])
            return labels

        labels = rebuild_container_labels()

        refresh_enc_info()

        view_tab = tabview.tab("View Inventory")
        view_tab.grid_rowconfigure(2, weight = 1)
        view_tab.grid_columnconfigure(0, weight = 1)

        view_frame = customtkinter.CTkFrame(view_tab)
        view_frame.grid(row = 0, column = 0, rowspan = 3, sticky = "nsew", padx = 10, pady = 10)
        view_frame.grid_rowconfigure(2, weight = 1)
        view_frame.grid_columnconfigure(0, weight = 1)

        top_view_frame = customtkinter.CTkFrame(view_frame, fg_color = "transparent")
        top_view_frame.grid(row = 0, column = 0, sticky = "ew", pady =(0, 10))
        top_view_frame.grid_columnconfigure(2, weight = 1)

        container_selector = customtkinter.CTkOptionMenu(
        top_view_frame,
        values = labels,
        width = 300,
        font = customtkinter.CTkFont(size = 14)
        )
        container_selector.grid(row = 0, column = 0, padx =(0, 20))
        container_selector.set(labels[0]if labels else "")

        view_search_label = customtkinter.CTkLabel(top_view_frame, text = "Search:", font = customtkinter.CTkFont(size = 12))
        view_search_label.grid(row = 0, column = 1, padx =(0, 5))

        view_search_entry = customtkinter.CTkEntry(top_view_frame, placeholder_text = "Filter items...", width = 200)
        view_search_entry.grid(row = 0, column = 2, sticky = "w")

        view_info_label = customtkinter.CTkLabel(top_view_frame, text = "", font = customtkinter.CTkFont(size = 11), text_color = "gray")
        view_info_label.grid(row = 0, column = 3, padx = 10)

        view_scroll = customtkinter.CTkScrollableFrame(view_frame, width = 900, height = 380)
        view_scroll.grid(row = 2, column = 0, sticky = "nsew", padx = 10, pady = 10)

        view_pagination_frame = customtkinter.CTkFrame(view_frame, fg_color = "transparent")
        view_pagination_frame.grid(row = 3, column = 0, pady = 5)

        ITEMS_PER_PAGE_VIEW = 20
        view_current_page =[0]
        view_current_filtered =[[]]
        view_search_timer =[None]
        view_all_items =[[]]

        def refresh_view():
            current_label = container_selector.get()
            new_labels = rebuild_container_labels()
            container_selector.configure(values = new_labels)
            if current_label in new_labels:
                container_selector.set(current_label)
            elif new_labels:
                container_selector.set(new_labels[0])
            refresh_enc_info()

            selected_label = container_selector.get()
            selected_container = next((c for c in containers if c.get("label")==selected_label), None)

            if not selected_container:
                view_all_items[0]=[]
                view_current_filtered[0]=[]
                view_current_page[0]= 0
                display_view_page(0)
                return

            location = selected_container["location"]
            items = get_container_items(location)
            view_all_items[0]= items if items else[]
            view_search_entry.delete(0, "end")
            view_current_filtered[0]= view_all_items[0]
            view_current_page[0]= 0
            display_view_page(0)

        def show_item_details(item_data):
            detail_window = customtkinter.CTkToplevel(self.root)
            detail_window.title("Item Details")
            detail_window.transient(self.root)
            self._center_popup_on_window(detail_window, 500, 600)

            scroll = customtkinter.CTkScrollableFrame(detail_window, width = 450, height = 550)
            scroll.pack(pady = 10, padx = 10, fill = "both", expand = True)

            title = customtkinter.CTkLabel(scroll, text = item_data.get("name", "Unknown"), font = customtkinter.CTkFont(size = 18, weight = "bold"))
            title.pack(pady =(10, 20))

            for key, value in item_data.items():
                if key =="name":
                    continue

                prop_frame = customtkinter.CTkFrame(scroll, fg_color = "transparent")
                prop_frame.pack(fill = "x", pady = 2, padx = 10)

                key_label = customtkinter.CTkLabel(
                prop_frame,
                text = f"{key.replace('_', ' ').title()}:",
                font = customtkinter.CTkFont(size = 12, weight = "bold"),
                anchor = "w",
                width = 150
                )
                key_label.pack(side = "left", padx = 5)

                if isinstance(value, (list, dict)):
                    value_text = json.dumps(value, indent = 2)
                else:
                    value_text = str(value)

                value_label = customtkinter.CTkLabel(
                prop_frame,
                text = value_text,
                font = customtkinter.CTkFont(size = 11),
                anchor = "w",
                wraplength = 250
                )
                value_label.pack(side = "left", padx = 5, fill = "x", expand = True)

            close_button = self._create_sound_button(scroll, "Close", detail_window.destroy, width = 120, height = 35)
            close_button.pack(pady = 20)

            detail_window.update_idletasks()
            detail_window.deiconify()
            detail_window.grab_set()

        def create_item_view_widget(item):
            selected_label = container_selector.get()
            selected_container = next((c for c in containers if c.get("label")==selected_label), None)
            location = selected_container["location"]if selected_container else ""

            item_frame = customtkinter.CTkFrame(view_scroll)
            item_frame.pack(fill = "x", pady = 5, padx = 10)
            item_frame.grid_columnconfigure(0, weight = 1)

            item_name = self._format_item_name(item)
            item_qty = item.get("quantity", 1)
            item_weight = item.get("weight", 0)*item_qty
            item_value = item.get("value", 0)

            display_text = f"{item_name} x{item_qty}"
            if item.get("consumable"):
                if item.get("uses_left"):
                    display_text +=f"({item.get('uses_left')} uses left)"
                elif item.get("used_up"):
                    display_text +="(1 use left)"
                else:
                    display_text +="(âˆž uses)"

            name_label = customtkinter.CTkLabel(
            item_frame,
            text = display_text,
            font = customtkinter.CTkFont(size = 14, weight = "bold"),
            anchor = "w"
            )
            name_label.grid(row = 0, column = 0, sticky = "w", padx = 15, pady =(10, 2))

            item_info_label = customtkinter.CTkLabel(
            item_frame,
            text = f"Weight: {self._format_weight(item_weight)} | Value: ${item_value}",
            font = customtkinter.CTkFont(size = 11),
            text_color = "gray",
            anchor = "w"
            )
            item_info_label.grid(row = 1, column = 0, sticky = "w", padx = 15, pady =(0, 10))

            button_col = 1
            details_button = self._create_sound_button(
            item_frame,
            "View Details",
            lambda it = item:show_item_details(it),
            width = 120,
            height = 35,
            font = customtkinter.CTkFont(size = 12)
            )
            details_button.grid(row = 0, column = button_col, rowspan = 2, padx = 15, pady = 10)

            if item.get("consumable"):
                button_col +=1
                consume_button = self._create_sound_button(
                item_frame,
                "Consume",
                lambda it = item, loc = location:self._consume_item(it, loc, save_data, on_complete = refresh_view),
                width = 100,
                height = 35,
                font = customtkinter.CTkFont(size = 12)
                )
                consume_button.grid(row = 0, column = button_col, rowspan = 2, padx =(0, 15), pady = 10)

            if item.get("stratagem"):
                button_col +=1
                stratagem_button = self._create_sound_button(
                item_frame,
                "Use Stratagem",
                lambda it = item, loc = location:self._use_stratagem(it, loc, save_data, on_complete = refresh_view),
                width = 120,
                height = 35,
                font = customtkinter.CTkFont(size = 12)
                )
                stratagem_button.grid(row = 0, column = button_col, rowspan = 2, padx =(0, 15), pady = 10)

        def display_view_page(page_num):
            items = view_current_filtered[0]
            total_pages = max(1, (len(items)+ITEMS_PER_PAGE_VIEW -1)//ITEMS_PER_PAGE_VIEW)
            page_num = max(0, min(page_num, total_pages -1))
            view_current_page[0]= page_num

            for widget in view_scroll.winfo_children():
                widget.destroy()

            if not items:
                empty_label = customtkinter.CTkLabel(view_scroll, text = "Container is empty", font = customtkinter.CTkFont(size = 14), text_color = "gray")
                empty_label.pack(pady = 30)
                view_info_label.configure(text = "No items")
                update_view_pagination(0, 0)
                return

            start_idx = page_num *ITEMS_PER_PAGE_VIEW
            end_idx = min(start_idx +ITEMS_PER_PAGE_VIEW, len(items))

            for i in range(start_idx, end_idx):
                create_item_view_widget(items[i])

            view_info_label.configure(text = f"Page {page_num +1}/{total_pages} | {len(items)} items")
            update_view_pagination(page_num, total_pages)

            try:
                view_scroll._parent_canvas.yview_moveto(0)
            except Exception:
                pass

        def update_view_pagination(current, total):
            for widget in view_pagination_frame.winfo_children():
                widget.destroy()

            if total <=1:
                return

            first_btn = customtkinter.CTkButton(view_pagination_frame, text = "<<", width = 40, height = 30, command = lambda:display_view_page(0), state = "normal"if current >0 else "disabled")
            first_btn.pack(side = "left", padx = 2)

            prev_btn = customtkinter.CTkButton(view_pagination_frame, text = "<", width = 40, height = 30, command = lambda:display_view_page(current -1), state = "normal"if current >0 else "disabled")
            prev_btn.pack(side = "left", padx = 2)

            start_page = max(0, current -3)
            end_page = min(total, start_page +7)
            if end_page -start_page <7:
                start_page = max(0, end_page -7)

            for p in range(start_page, end_page):
                btn = customtkinter.CTkButton(view_pagination_frame, text = str(p +1), width = 35, height = 30, fg_color =("gray75", "gray25")if p ==current else None, command = lambda page = p:display_view_page(page))
                btn.pack(side = "left", padx = 1)

            next_btn = customtkinter.CTkButton(view_pagination_frame, text = ">", width = 40, height = 30, command = lambda:display_view_page(current +1), state = "normal"if current <total -1 else "disabled")
            next_btn.pack(side = "left", padx = 2)

            last_btn = customtkinter.CTkButton(view_pagination_frame, text = ">>", width = 40, height = 30, command = lambda:display_view_page(total -1), state = "normal"if current <total -1 else "disabled")
            last_btn.pack(side = "left", padx = 2)

        def filter_view_items(search_term):
            search_lower = search_term.lower().strip()

            if search_lower:
                filtered =[
                item for item in view_all_items[0]
                if search_lower in item.get("name", "").lower()
                ]
            else:
                filtered = view_all_items[0]

            view_current_filtered[0]= filtered
            view_current_page[0]= 0
            display_view_page(0)

        def on_view_search_change(*args):
            if view_search_timer[0]is not None:
                try:
                    self.root.after_cancel(view_search_timer[0])
                except Exception:
                    pass
            view_search_timer[0]= self.root.after(200, lambda:filter_view_items(view_search_entry.get()))# type: ignore

        view_search_entry.bind("<KeyRelease>", on_view_search_change)
        container_selector.configure(command = lambda _:refresh_view())
        refresh_view()

        transfer_tab = tabview.tab("Transfer Items")
        transfer_tab.grid_rowconfigure(1, weight = 1)
        transfer_tab.grid_columnconfigure((0, 1), weight = 1)

        info_label = customtkinter.CTkLabel(transfer_tab, text = "Select source and destination containers to move items:", font = customtkinter.CTkFont(size = 13))
        info_label.grid(row = 0, column = 0, columnspan = 2, pady = 10)

        container_frame = customtkinter.CTkFrame(transfer_tab)
        container_frame.grid(row = 1, column = 0, columnspan = 2, sticky = "nsew", pady = 10)
        container_frame.grid_rowconfigure(0, weight = 1)
        container_frame.grid_columnconfigure((0, 1), weight = 1)

        source_frame = customtkinter.CTkFrame(container_frame)
        source_frame.grid(row = 0, column = 0, sticky = "nsew", padx =(0, 10))
        source_frame.grid_rowconfigure(3, weight = 1)
        source_frame.grid_columnconfigure(0, weight = 1)

        source_label = customtkinter.CTkLabel(source_frame, text = "Source Container", font = customtkinter.CTkFont(size = 16, weight = "bold"))
        source_label.grid(row = 0, column = 0, pady = 10)

        source_selector = customtkinter.CTkOptionMenu(source_frame, values =[c["name"]for c in containers], width = 300)
        source_selector.grid(row = 1, column = 0, pady = 5)
        source_selector.set(containers[1]["name"]if len(containers)>1 else containers[0]["name"])

        source_search_frame = customtkinter.CTkFrame(source_frame, fg_color = "transparent")
        source_search_frame.grid(row = 2, column = 0, sticky = "ew", padx = 10, pady = 5)
        source_search_frame.grid_columnconfigure(1, weight = 1)

        customtkinter.CTkLabel(source_search_frame, text = "Search:", font = customtkinter.CTkFont(size = 11)).grid(row = 0, column = 0, padx =(0, 5))
        source_search_entry = customtkinter.CTkEntry(source_search_frame, placeholder_text = "Filter...", width = 150)
        source_search_entry.grid(row = 0, column = 1, sticky = "w")
        source_info_label = customtkinter.CTkLabel(source_search_frame, text = "", font = customtkinter.CTkFont(size = 10), text_color = "gray")
        source_info_label.grid(row = 0, column = 2, padx = 10)

        source_scroll = customtkinter.CTkScrollableFrame(source_frame, width = 350, height = 320)
        source_scroll.grid(row = 3, column = 0, sticky = "nsew", padx = 10, pady =(5, 5))

        source_pagination_frame = customtkinter.CTkFrame(source_frame, fg_color = "transparent")
        source_pagination_frame.grid(row = 4, column = 0, pady = 5)

        dest_frame = customtkinter.CTkFrame(container_frame)
        dest_frame.grid(row = 0, column = 1, sticky = "nsew", padx =(10, 0))
        dest_frame.grid_rowconfigure(3, weight = 1)
        dest_frame.grid_columnconfigure(0, weight = 1)

        dest_label = customtkinter.CTkLabel(dest_frame, text = "Destination Container", font = customtkinter.CTkFont(size = 16, weight = "bold"))
        dest_label.grid(row = 0, column = 0, pady = 10)

        dest_selector = customtkinter.CTkOptionMenu(dest_frame, values =[c["name"]for c in containers], width = 300)
        dest_selector.grid(row = 1, column = 0, pady = 5)
        dest_selector.set(containers[0]["name"])

        dest_search_frame = customtkinter.CTkFrame(dest_frame, fg_color = "transparent")
        dest_search_frame.grid(row = 2, column = 0, sticky = "ew", padx = 10, pady = 5)
        dest_search_frame.grid_columnconfigure(1, weight = 1)

        customtkinter.CTkLabel(dest_search_frame, text = "Search:", font = customtkinter.CTkFont(size = 11)).grid(row = 0, column = 0, padx =(0, 5))
        dest_search_entry = customtkinter.CTkEntry(dest_search_frame, placeholder_text = "Filter...", width = 150)
        dest_search_entry.grid(row = 0, column = 1, sticky = "w")
        dest_info_label = customtkinter.CTkLabel(dest_search_frame, text = "", font = customtkinter.CTkFont(size = 10), text_color = "gray")
        dest_info_label.grid(row = 0, column = 2, padx = 10)

        dest_scroll = customtkinter.CTkScrollableFrame(dest_frame, width = 350, height = 320)
        dest_scroll.grid(row = 3, column = 0, sticky = "nsew", padx = 10, pady =(5, 5))

        dest_pagination_frame = customtkinter.CTkFrame(dest_frame, fg_color = "transparent")
        dest_pagination_frame.grid(row = 4, column = 0, pady = 5)

        TRANSFER_ITEMS_PER_PAGE = 15
        source_page =[0]
        source_all_items =[[]]
        source_filtered =[[]]
        source_search_timer =[None]
        dest_page =[0]
        dest_all_items =[[]]
        dest_filtered =[[]]
        dest_search_timer =[None]
        source_location_ref =[""]
        dest_location_ref =[""]

        def update_source_pagination(current, total):
            for widget in source_pagination_frame.winfo_children():
                widget.destroy()
            if total <=1:
                return
            prev_btn = customtkinter.CTkButton(source_pagination_frame, text = "<", width = 30, height = 25, command = lambda:display_source_page(current -1), state = "normal"if current >0 else "disabled")
            prev_btn.pack(side = "left", padx = 2)
            for p in range(max(0, current -2), min(total, current +3)):
                btn = customtkinter.CTkButton(source_pagination_frame, text = str(p +1), width = 28, height = 25, fg_color =("gray75", "gray25")if p ==current else None, command = lambda page = p:display_source_page(page))
                btn.pack(side = "left", padx = 1)
            next_btn = customtkinter.CTkButton(source_pagination_frame, text = ">", width = 30, height = 25, command = lambda:display_source_page(current +1), state = "normal"if current <total -1 else "disabled")
            next_btn.pack(side = "left", padx = 2)

        def update_dest_pagination(current, total):
            for widget in dest_pagination_frame.winfo_children():
                widget.destroy()
            if total <=1:
                return
            prev_btn = customtkinter.CTkButton(dest_pagination_frame, text = "<", width = 30, height = 25, command = lambda:display_dest_page(current -1), state = "normal"if current >0 else "disabled")
            prev_btn.pack(side = "left", padx = 2)
            for p in range(max(0, current -2), min(total, current +3)):
                btn = customtkinter.CTkButton(dest_pagination_frame, text = str(p +1), width = 28, height = 25, fg_color =("gray75", "gray25")if p ==current else None, command = lambda page = p:display_dest_page(page))
                btn.pack(side = "left", padx = 1)
            next_btn = customtkinter.CTkButton(dest_pagination_frame, text = ">", width = 30, height = 25, command = lambda:display_dest_page(current +1), state = "normal"if current <total -1 else "disabled")
            next_btn.pack(side = "left", padx = 2)

        def display_source_page(page_num):
            items = source_filtered[0]
            total_pages = max(1, (len(items)+TRANSFER_ITEMS_PER_PAGE -1)//TRANSFER_ITEMS_PER_PAGE)
            page_num = max(0, min(page_num, total_pages -1))
            source_page[0]= page_num

            for widget in source_scroll.winfo_children():
                widget.destroy()

            if not items:
                empty_label = customtkinter.CTkLabel(source_scroll, text = "Container is empty", text_color = "gray")
                empty_label.pack(pady = 20)
                source_info_label.configure(text = "0 items")
                update_source_pagination(0, 0)
                return

            start_idx = page_num *TRANSFER_ITEMS_PER_PAGE
            end_idx = min(start_idx +TRANSFER_ITEMS_PER_PAGE, len(items))

            for i in range(start_idx, end_idx):
                item_data = items[i]
                original_idx = item_data["_original_idx"]
                item = item_data["item"]

                item_frame = customtkinter.CTkFrame(source_scroll)
                item_frame.pack(fill = "x", pady = 2)

                item_name = self._format_item_name(item)
                item_weight = item.get("weight", 0)*item.get("quantity", 1)

                item_label = customtkinter.CTkLabel(
                item_frame,
                text = f"{item_name} x{item.get('quantity', 1)}({self._format_weight(item_weight)})",
                anchor = "w"
                )
                item_label.pack(side = "left", padx = 10, pady = 5)

                move_button = self._create_sound_button(
                item_frame,
                "Move â†’",
                lambda idx = original_idx:move_item(idx, source_location_ref[0], dest_location_ref[0]),
                width = 80,
                height = 30
                )
                move_button.pack(side = "right", padx = 10, pady = 5)

            source_info_label.configure(text = f"Pg {page_num +1}/{total_pages}({len(items)})")
            update_source_pagination(page_num, total_pages)

        def display_dest_page(page_num):
            items = dest_filtered[0]
            total_pages = max(1, (len(items)+TRANSFER_ITEMS_PER_PAGE -1)//TRANSFER_ITEMS_PER_PAGE)
            page_num = max(0, min(page_num, total_pages -1))
            dest_page[0]= page_num

            for widget in dest_scroll.winfo_children():
                widget.destroy()

            if not items:
                empty_label = customtkinter.CTkLabel(dest_scroll, text = "Container is empty", text_color = "gray")
                empty_label.pack(pady = 20)
                dest_info_label.configure(text = "0 items")
                update_dest_pagination(0, 0)
                return

            start_idx = page_num *TRANSFER_ITEMS_PER_PAGE
            end_idx = min(start_idx +TRANSFER_ITEMS_PER_PAGE, len(items))

            for i in range(start_idx, end_idx):
                item_data = items[i]
                item = item_data["item"]

                item_frame = customtkinter.CTkFrame(dest_scroll)
                item_frame.pack(fill = "x", pady = 2)

                item_name = self._format_item_name(item)
                item_weight = item.get("weight", 0)*item.get("quantity", 1)

                item_label = customtkinter.CTkLabel(
                item_frame,
                text = f"{item_name} x{item.get('quantity', 1)}({self._format_weight(item_weight)})",
                anchor = "w"
                )
                item_label.pack(side = "left", padx = 10, pady = 5)

            dest_info_label.configure(text = f"Pg {page_num +1}/{total_pages}({len(items)})")
            update_dest_pagination(page_num, total_pages)

        def filter_source_items(search_term):
            search_lower = search_term.lower().strip()
            if search_lower:
                filtered =[item for item in source_all_items[0]if search_lower in item["item"].get("name", "").lower()]
            else:
                filtered = source_all_items[0]
            source_filtered[0]= filtered
            source_page[0]= 0
            display_source_page(0)

        def filter_dest_items(search_term):
            search_lower = search_term.lower().strip()
            if search_lower:
                filtered =[item for item in dest_all_items[0]if search_lower in item["item"].get("name", "").lower()]
            else:
                filtered = dest_all_items[0]
            dest_filtered[0]= filtered
            dest_page[0]= 0
            display_dest_page(0)

        def on_source_search_change(*args):
            if source_search_timer[0]is not None:
                try:
                    self.root.after_cancel(source_search_timer[0])
                except Exception:
                    pass
            source_search_timer[0]= self.root.after(200, lambda:filter_source_items(source_search_entry.get()))# type: ignore

        def on_dest_search_change(*args):
            if dest_search_timer[0]is not None:
                try:
                    self.root.after_cancel(dest_search_timer[0])
                except Exception:
                    pass
            dest_search_timer[0]= self.root.after(200, lambda:filter_dest_items(dest_search_entry.get()))# type: ignore

        source_search_entry.bind("<KeyRelease>", on_source_search_change)
        dest_search_entry.bind("<KeyRelease>", on_dest_search_change)

        def refresh_containers():
            source_name = source_selector.get()
            dest_name = dest_selector.get()

            if source_name ==dest_name:
                source_selector.set(dest_name)
                dest_selector.set(source_name)
                source_name = source_selector.get()
                dest_name = dest_selector.get()
                if source_name ==dest_name:
                    for c in containers:
                        if c["name"]!=source_name:
                            dest_selector.set(c["name"])
                            dest_name = c["name"]
                            break

            source_container = next((c for c in containers if c["name"]==source_name), None)
            dest_container = next((c for c in containers if c["name"]==dest_name), None)

            if not source_container or not dest_container:
                return

            source_location_ref[0]= source_container["location"]
            dest_location_ref[0]= dest_container["location"]
            source_items = get_container_items(source_location_ref[0])
            dest_items = get_container_items(dest_location_ref[0])

            source_all_items[0]=[{"item":item, "_original_idx":i}for i, item in enumerate(source_items)if isinstance(item, dict)]
            dest_all_items[0]=[{"item":item, "_original_idx":i}for i, item in enumerate(dest_items)if isinstance(item, dict)]

            source_search_entry.delete(0, "end")
            dest_search_entry.delete(0, "end")
            source_filtered[0]= source_all_items[0]
            dest_filtered[0]= dest_all_items[0]
            source_page[0]= 0
            dest_page[0]= 0
            display_source_page(0)
            display_dest_page(0)

        def move_item(item_idx, source_location, dest_location):
            try:
                source_items = get_container_items(source_location)
                dest_items = get_container_items(dest_location)

                if item_idx >=len(source_items):
                    return

                item = source_items[item_idx]

                if not isinstance(item, dict):
                    item = {"name":str(item), "weight":0, "quantity":1}
                item_weight = item.get("weight", 0)*item.get("quantity", 1)

                dest_capacity = get_container_capacity(dest_location)
                if dest_capacity is not None:
                    current_dest_weight = sum(i.get("weight", 0)*i.get("quantity", 1)for i in dest_items)
                    if current_dest_weight +item_weight >dest_capacity:
                        self._popup_show_info("Error", "Not enough capacity in destination!", sound = "error")
                        return

                source_items.pop(item_idx)
                item = add_subslots_to_item(item)
                dest_items.append(item)

                set_container_items(source_location, source_items)
                set_container_items(dest_location, dest_items)

                encumbrance_info = self._calculate_encumbrance_status(save_data)
                save_data["encumbrance"]= encumbrance_info["total_weight"]

                self._save_file(save_data)

                refresh_containers()
                refresh_enc_info()
                self._play_ui_sound("success")
            except Exception as e:
                logging.error(f"Move failed: {e}")
                self._popup_show_info("Error", f"Move failed: {e}", sound = "error")

        source_selector.configure(command = lambda _:refresh_containers())
        dest_selector.configure(command = lambda _:refresh_containers())

        refresh_containers()

        back_button = self._create_sound_button(
        main_frame,
        "Back",
        lambda:[self._clear_window(), self._open_inventory_management()],
        width = 200,
        height = 40
        )
        back_button.grid(row = 2, column = 0, pady = 10)

    def _open_item_equipping(self):

        logging.info("Item Equipping definition called")

        if currentsave is None:
            self._popup_show_info("Error", "No character loaded.", sound = "error")
            return

        self._clear_window()

        save_filename =(currentsave or "")+".sldsv"
        save_data = self._load_file(save_filename)

        if save_data is None:
            logging.error(f"Failed to load save file {save_filename}")
            self._popup_show_info("Error", f"Failed to load character data", sound = "error")
            return

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.pack(fill = "both", expand = True, padx = 20, pady = 20)

        title = customtkinter.CTkLabel(main_frame, text = "Item Equipping", font = customtkinter.CTkFont(size = 20, weight = "bold"))
        title.pack(pady =(0, 20))

        content_frame = customtkinter.CTkFrame(main_frame)
        content_frame.pack(fill = "both", expand = True)
        content_frame.grid_rowconfigure(0, weight = 1)
        content_frame.grid_columnconfigure((0, 1), weight = 1)

        slots_frame = customtkinter.CTkFrame(content_frame)
        slots_frame.grid(row = 0, column = 0, sticky = "nsew", padx =(0, 10))
        slots_frame.grid_rowconfigure(1, weight = 1)

        slots_frame.grid_columnconfigure(0, weight = 1)

        slots_label = customtkinter.CTkLabel(slots_frame, text = "Equipment Slots", font = customtkinter.CTkFont(size = 16, weight = "bold"))
        slots_label.grid(row = 0, column = 0, pady = 10)

        slots_scroll = customtkinter.CTkScrollableFrame(slots_frame, height = 600)
        slots_scroll.grid(row = 1, column = 0, sticky = "nsew", padx = 10, pady =(0, 10))

        items_frame = customtkinter.CTkFrame(content_frame)
        items_frame.grid(row = 0, column = 1, sticky = "nsew", padx =(10, 0))
        items_frame.grid_rowconfigure(1, weight = 1)

        items_frame.grid_columnconfigure(0, weight = 1)

        items_label = customtkinter.CTkLabel(items_frame, text = "Available Items(Storage & Hands)", font = customtkinter.CTkFont(size = 16, weight = "bold"))
        items_label.grid(row = 0, column = 0, pady = 10)

        items_scroll = customtkinter.CTkScrollableFrame(items_frame, height = 600)
        items_scroll.grid(row = 1, column = 0, sticky = "nsew", padx = 10, pady =(0, 10))

        def refresh_display():

            for widget in slots_scroll.winfo_children():
                widget.destroy()
            for widget in items_scroll.winfo_children():
                widget.destroy()

            equipment = save_data.get("equipment", {})

            def _slot_blocked_by_subslots(slot_name):
                try:
                    slot_name_l = str(slot_name).lower()if slot_name is not None else ''
                    for other_slot, other_item in equipment.items():
                        if not other_item:
                            continue
                        items_to_check =[]
                        if isinstance(other_item, dict):
                            items_to_check =[other_item]
                        elif isinstance(other_item, list):
                            items_to_check =[it for it in other_item if isinstance(it, dict)]

                        for oi in items_to_check:

                            for subslot_data in oi.get('subslots', [])or[]:
                                try:
                                    conflicts = subslot_data.get('conflicts_with')
                                    cur = subslot_data.get('current')
                                    if not cur:
                                        continue
                                    if isinstance(conflicts, dict):
                                        if conflicts.get('type')=='main'and str(conflicts.get('slot')).lower()==slot_name_l:
                                            return True
                                    elif isinstance(conflicts, (list, tuple)):
                                        for conflict_slot in conflicts:
                                            if str(conflict_slot).lower()==slot_name_l:
                                                return True
                                except Exception:
                                    pass

                            for acc in oi.get('accessories', [])or[]:
                                try:
                                    curacc = acc.get('current')
                                    if not isinstance(curacc, dict):
                                        continue
                                    for subslot_data in curacc.get('subslots', [])or[]:
                                        try:
                                            conflicts = subslot_data.get('conflicts_with')
                                            cur = subslot_data.get('current')
                                            if not cur:
                                                continue
                                            if isinstance(conflicts, dict):
                                                if conflicts.get('type')=='main'and str(conflicts.get('slot')).lower()==slot_name_l:
                                                    return True
                                            elif isinstance(conflicts, (list, tuple)):
                                                for conflict_slot in conflicts:
                                                    if str(conflict_slot).lower()==slot_name_l:
                                                        return True
                                        except Exception:
                                            pass
                                except Exception:
                                    pass
                    return False
                except Exception:
                    return False

            for slot, item in equipment.items():
                slot_frame = customtkinter.CTkFrame(slots_scroll)
                slot_frame.pack(fill = "x", pady = 5, padx = 5)

                slot_label = customtkinter.CTkLabel(
                slot_frame,
                text = f"{slot.title()}:",
                font = customtkinter.CTkFont(size = 12, weight = "bold"),
                anchor = "w"
                )
                slot_label.pack(side = "top", anchor = "w", padx = 10, pady =(5, 0))

                if item:

                    if isinstance(item, list):
                        counts = {}
                        for it in item:
                            try:
                                if isinstance(it, dict):
                                    name = it.get('name', 'Unknown')
                                else:
                                    name = str(it)
                            except Exception:
                                name = 'Unknown'
                            counts[name]= counts.get(name, 0)+1

                        if len(counts)==1:
                            name, cnt = next(iter(counts.items()))
                            display_text = f" {name} x{cnt}"
                        else:

                            parts =[f"{n} x{c}"for n, c in counts.items()]
                            display_text = "(MIXED - NOT ALLOWED) "+", ".join(parts)

                            item_label = customtkinter.CTkLabel(
                            slot_frame,
                            text = display_text,
                            anchor = "w",
                            text_color = "#FF4444"
                            )
                            item_label.pack(side = "top", anchor = "w", padx = 10)

                            continue
                    else:
                        item_name = self._format_item_name(item)if isinstance(item, dict)else str(item)
                        display_text = f" {item_name}"

                    item_label = customtkinter.CTkLabel(
                    slot_frame,
                    text = display_text,
                    anchor = "w",
                    text_color = "lightblue"
                    )
                    item_label.pack(side = "top", anchor = "w", padx = 10)

                    unequip_button = self._create_sound_button(
                    slot_frame,
                    "Unequip",
                    lambda s = slot:unequip_item(s),
                    width = 80,
                    height = 30
                    )
                    unequip_button.pack(side = "right", padx = 10, pady = 5)

                    if isinstance(item, dict)and "subslots"in item:
                        for subslot_data in item["subslots"]:
                            subslot_name = subslot_data.get("name", "Unknown Subslot")
                            subslot_type = subslot_data.get("slot", "unknown")
                            current_item = subslot_data.get("current")

                            subslot_frame = customtkinter.CTkFrame(slots_scroll)
                            subslot_frame.pack(fill = "x", pady = 2, padx = 5)

                            subslot_label = customtkinter.CTkLabel(
                            subslot_frame,
                            text = f" â†³ {subslot_name}:",
                            font = customtkinter.CTkFont(size = 11),
                            anchor = "w",
                            text_color = "#FFA500"
                            )
                            subslot_label.pack(side = "top", anchor = "w", padx = 20, pady =(5, 0))

                            if current_item:
                                subitem_name = current_item.get("name", "Unknown")if isinstance(current_item, dict)else str(current_item)

                                is_container = isinstance(current_item, dict)and current_item.get("container", False)
                                if is_container:
                                    total_weight = sum(i.get("weight", 0)*i.get("quantity", 1)for i in current_item.get("items", []))
                                    capacity = current_item.get("capacity", 0)
                                    subitem_text = f" {subitem_name}[{self._format_weight(total_weight)}/{self._format_weight(capacity)}]"
                                else:
                                    subitem_text = f" {subitem_name}"

                                subitem_label = customtkinter.CTkLabel(
                                subslot_frame,
                                text = subitem_text,
                                anchor = "w",
                                text_color = "lightgreen"
                                )
                                subitem_label.pack(side = "top", anchor = "w", padx = 20)

                                button_container = customtkinter.CTkFrame(subslot_frame, fg_color = "transparent")
                                button_container.pack(side = "right", padx = 10, pady = 5)

                                unequip_sub_button = self._create_sound_button(
                                button_container,
                                "Unequip",
                                lambda s = slot, ss = subslot_data:unequip_from_subslot(s, ss),
                                width = 80,
                                height = 25
                                )
                                unequip_sub_button.pack(side = "left", padx = 2)

                                if is_container:
                                    view_button = self._create_sound_button(
                                    button_container,
                                    "View",
                                    lambda ci = current_item:view_container_contents(ci),
                                    width = 60,
                                    height = 25
                                    )
                                    view_button.pack(side = "left", padx = 2)

                                try:
                                    def _render_nested_subslots(parent_item, parent_frame, parent_slot, parent_subslot):
                                        try:
                                            for n_idx, n_sub in enumerate(parent_item.get('subslots', [])or[]):
                                                try:
                                                    n_name = n_sub.get('name', 'Unknown Subslot')
                                                    n_slot = n_sub.get('slot', 'unknown')
                                                    n_current = n_sub.get('current')

                                                    n_frame = customtkinter.CTkFrame(parent_frame)
                                                    n_frame.pack(fill = 'x', pady = 2, padx = 20)

                                                    n_label = customtkinter.CTkLabel(
                                                    n_frame,
                                                    text = f" â†³ {n_name}:",
                                                    font = customtkinter.CTkFont(size = 10),
                                                    anchor = "w",
                                                    text_color = "#FFD700"
                                                    )
                                                    n_label.pack(side = "top", anchor = "w", padx = 10, pady =(4, 0))

                                                    if n_current:
                                                        try:
                                                            nn_name = n_current.get('name', 'Unknown')if isinstance(n_current, dict)else str(n_current)
                                                        except Exception:
                                                            nn_name = 'Unknown'
                                                        nn_label = customtkinter.CTkLabel(n_frame, text = f" {nn_name}", anchor = 'w', text_color = 'lightgreen', font = customtkinter.CTkFont(size = 10))
                                                        nn_label.pack(side = 'top', anchor = 'w', padx = 10)

                                                        btn_cont = customtkinter.CTkFrame(n_frame, fg_color = 'transparent')
                                                        btn_cont.pack(side = 'right', padx = 10, pady = 4)

                                                        unequip_n = self._create_sound_button(btn_cont, 'Unequip', lambda s = parent_slot, ss = parent_subslot, idx = n_idx:unequip_from_subslot(s, ss, subindex = idx)if callable(unequip_from_subslot)else None, width = 70, height = 22)
                                                        unequip_n.pack(side = 'left', padx = 2)

                                                        try:
                                                            if isinstance(n_current, dict):
                                                                _render_nested_subslots(n_current, n_frame, parent_slot, n_sub)
                                                        except Exception:
                                                            pass
                                                    else:
                                                        empty_n = customtkinter.CTkLabel(n_frame, text = f"(empty - accepts: {n_slot})", anchor = 'w', text_color = 'gray', font = customtkinter.CTkFont(size = 9))
                                                        empty_n.pack(side = 'top', anchor = 'w', padx = 10, pady =(0, 4))
                                                except Exception:
                                                    pass
                                        except Exception:
                                            pass

                                    if isinstance(current_item, dict)and current_item.get('subslots'):
                                        _render_nested_subslots(current_item, subslot_frame, slot, subslot_data)
                                except Exception:
                                    pass
                            else:
                                try:
                                    conflicts = subslot_data.get('conflicts_with')
                                except Exception:
                                    conflicts = None

                                if conflicts:
                                    try:
                                        if isinstance(conflicts, dict):
                                            conf_slots =[conflicts.get('slot')]if conflicts.get('slot')else[]
                                        elif isinstance(conflicts, (list, tuple)):
                                            conf_slots =[str(c)for c in conflicts]
                                        else:
                                            conf_slots =[str(conflicts)]
                                        conf_slots =[c for c in conf_slots if c]
                                        conf_text = ', '.join(conf_slots)if conf_slots else 'unknown'
                                    except Exception:
                                        conf_text = 'unknown'
                                    empty_text = f"Conflicts with: {conf_text}"
                                    text_color = "#FF4444"
                                else:
                                    empty_text = f"(empty - accepts: {subslot_type})"
                                    text_color = "gray"

                                empty_sub_label = customtkinter.CTkLabel(
                                subslot_frame,
                                text = empty_text,
                                anchor = "w",
                                text_color = text_color,
                                font = customtkinter.CTkFont(size = 10)
                                )
                                empty_sub_label.pack(side = "top", anchor = "w", padx = 20, pady =(0, 5))

                                try:
                                    nested_list = subslot_data.get('subslots')or[]
                                    if nested_list:
                                        for nsub in nested_list:
                                            try:
                                                n_name = nsub.get('name', 'Unknown Subslot')
                                                n_slot = nsub.get('slot', 'unknown')

                                                n_frame = customtkinter.CTkFrame(subslot_frame)
                                                n_frame.pack(fill = 'x', pady = 2, padx = 20)

                                                n_label = customtkinter.CTkLabel(
                                                n_frame,
                                                text = f" â†³ {n_name}:",
                                                font = customtkinter.CTkFont(size = 10),
                                                anchor = "w",
                                                text_color = "#FFD700"
                                                )
                                                n_label.pack(side = "top", anchor = "w", padx = 10, pady =(4, 0))

                                                empty_n = customtkinter.CTkLabel(n_frame, text = f"(empty - accepts: {n_slot})", anchor = 'w', text_color = 'gray', font = customtkinter.CTkFont(size = 9))
                                                empty_n.pack(side = 'top', anchor = 'w', padx = 10, pady =(0, 4))
                                            except Exception:
                                                pass
                                except Exception:
                                    pass
                else:

                    try:
                        conflict_sources = _get_conflict_sources(slot)
                    except Exception:
                        conflict_sources =[]

                    try:
                        conflict_item = _find_any_item_with_conflict(slot)
                    except Exception:
                        conflict_item = None

                    if conflict_item:
                        empty_text = f"Conflicts with: {conflict_item}"
                        text_color = "#FF4444"
                    elif conflict_sources:

                        parents =[]
                        for s in conflict_sources:
                            try:
                                parent = s.split('.', 1)[0]if '.'in s else s
                            except Exception:
                                parent = s
                            parents.append(parent)

                        seen = set()
                        uniq_parents =[]
                        for p in parents:
                            if p not in seen:
                                seen.add(p)
                                uniq_parents.append(p)
                        conf_text = ', '.join(uniq_parents)
                        empty_text = f"Conflicts with: {conf_text}"
                        text_color = "#FF4444"
                    else:
                        empty_text = "(empty)"
                        text_color = "gray"

                    empty_label = customtkinter.CTkLabel(
                    slot_frame,
                    text = empty_text,
                    anchor = "w",
                    text_color = text_color
                    )
                    empty_label.pack(side = "top", anchor = "w", padx = 10, pady =(0, 5))

                    def open_equip_candidates(target_slot):

                        candidates =[]

                        for hi, hit in enumerate(save_data.get("hands", {}).get("items", [])):
                            if not isinstance(hit, dict):
                                continue
                            if hit.get("equippable"):
                                slot_field = hit.get("slot")
                                slots = slot_field if isinstance(slot_field, list)else[slot_field]
                                if target_slot in slots:
                                    candidates.append(("hands", hi, hit))

                        equipment = save_data.get("equipment", {})
                        for eq_slot, eq_item in equipment.items():
                            if not eq_item or not isinstance(eq_item, dict):
                                continue

                            if "items"in eq_item and isinstance(eq_item.get("items"), list):
                                for ci, citem in enumerate(eq_item["items"]):
                                    if not isinstance(citem, dict):
                                        continue
                                    if citem.get("equippable"):
                                        slot_field = citem.get("slot")
                                        slots = slot_field if isinstance(slot_field, list)else[slot_field]
                                        if target_slot in slots:
                                            candidates.append((f"equipment.{eq_slot}.items", ci, citem))

                            for ss_idx, subslot_data in enumerate(eq_item.get("subslots", [])or[]):
                                subslot_item = subslot_data.get("current")
                                if subslot_item and isinstance(subslot_item, dict)and "items"in subslot_item:
                                    for ci, citem in enumerate(subslot_item["items"]):
                                        if not isinstance(citem, dict):
                                            continue
                                        if citem.get("equippable"):
                                            slot_field = citem.get("slot")
                                            slots = slot_field if isinstance(slot_field, list)else[slot_field]
                                            if target_slot in slots:
                                                candidates.append((f"equipment.{eq_slot}.subslot.{ss_idx}.items", ci, citem))

                        if not candidates:
                            self._popup_show_info("Equip", f"No equippable items for slot: {target_slot}")
                            return

                        popup = customtkinter.CTkToplevel(self.root)
                        popup.title(f"Equip to {target_slot}")
                        popup.transient(self.root)
                        self._center_popup_on_window(popup, 420, 300)
                        list_frame = customtkinter.CTkScrollableFrame(popup, fg_color = "transparent")
                        list_frame.pack(fill = "both", expand = True, padx = 10, pady = 10)

                        sel_var = customtkinter.StringVar(value = "0")
                        for idx, (loc, iidx, itm)in enumerate(candidates):
                            name = itm.get("name", "Unknown")
                            lab = customtkinter.CTkLabel(list_frame, text = f"{name} - {loc}")
                            lab.pack(anchor = "w", pady = 4)
                            rb = customtkinter.CTkRadioButton(list_frame, text = "", variable = sel_var, value = str(idx))
                            rb.pack(anchor = "e")

                        def do_equip():
                            sel = int(sel_var.get())
                            loc, iidx, itm = candidates[sel]
                            popup.destroy()
                            equip_item(loc, iidx, itm)

                        btn_frame = customtkinter.CTkFrame(popup, fg_color = "transparent")
                        btn_frame.pack(fill = "x", padx = 10, pady = 8)
                        customtkinter.CTkButton(btn_frame, text = "Equip Selected", command = do_equip, width = 140).pack(side = "left", padx = 6)
                        customtkinter.CTkButton(btn_frame, text = "Cancel", command = popup.destroy, width = 120).pack(side = "right", padx = 6)

                    equip_slot_btn = self._create_sound_button(
                    slot_frame,
                    "Equip",
                    lambda s = slot:open_equip_candidates(s),
                    width = 80,
                    height = 30,
                    state = "disabled"if _slot_blocked_by_subslots(slot)else "normal"
                    )
                    equip_slot_btn.pack(side = "right", padx = 10, pady = 5)

            all_items =[]

            for i, item in enumerate(save_data["hands"].get("items", [])):
                if isinstance(item, dict):
                    is_equippable = item.get("equippable", False)
                    is_firearm = item.get("firearm", False)
                    is_melee = item.get("melee", False)
                    if is_equippable or is_firearm or is_melee:
                        all_items.append(("hands", i, item))

            equipment = save_data.get("equipment", {})

            def _collect_from_obj(loc_prefix, obj):
                try:
                    if isinstance(obj, dict):

                        if "items"in obj and isinstance(obj.get("items"), list):
                            for ci, citem in enumerate(obj.get("items")or[]):
                                if not isinstance(citem, dict):
                                    continue
                                is_equippable = citem.get("equippable", False)
                                is_firearm = citem.get("firearm", False)
                                is_melee = citem.get("melee", False)
                                if is_equippable or is_firearm or is_melee:
                                    all_items.append((f"{loc_prefix}.items", ci, citem))

                        for ss_idx, subslot_data in enumerate(obj.get("subslots")or[]):
                            try:
                                subcur = subslot_data.get("current")
                                if isinstance(subcur, dict):
                                    _collect_from_obj(f"{loc_prefix}.subslot.{ss_idx}", subcur)
                            except Exception:
                                pass

                        for list_idx, lst_item in enumerate(obj.get("items")or[]):
                            try:
                                if isinstance(lst_item, dict):
                                    _collect_from_obj(f"{loc_prefix}.list.{list_idx}", lst_item)
                            except Exception:
                                pass

                    elif isinstance(obj, list):
                        for idx, sub in enumerate(obj):
                            try:
                                if isinstance(sub, dict):
                                    _collect_from_obj(f"{loc_prefix}.list.{idx}", sub)
                            except Exception:
                                pass
                except Exception:
                    pass

            for eq_slot, eq_item in equipment.items():
                try:
                    if eq_item is None:
                        continue
                    _collect_from_obj(f"equipment.{eq_slot}", eq_item)
                except Exception:
                    pass

            for location, idx, item in all_items:
                item_frame = customtkinter.CTkFrame(items_scroll)
                item_frame.pack(fill = "x", pady = 2, padx = 5)

                item_name = self._format_item_name(item)

                if item.get("equippable"):
                    slots = item.get("slot", [])
                    if not isinstance(slots, list):
                        slots =[slots]
                    slots_text = f"Slots: {', '.join(str(s)for s in slots)}"
                elif item.get("firearm")or item.get("melee"):

                    if item.get("firearm"):
                        weapon_type = item.get("subtype", "unknown")
                    else:
                        weapon_type = item.get("type", "unknown")

                    if weapon_type =="pistol":
                        slots_text = "Slots: holster/sling subslots or waistband"
                    else:
                        slots_text = f"Slots: holster/sling subslots(type: {weapon_type})"
                else:
                    slots_text = "Slots: unknown"

                item_label = customtkinter.CTkLabel(
                item_frame,
                text = f"{item_name}\n {slots_text}",
                anchor = "w",
                font = customtkinter.CTkFont(size = 11)
                )
                item_label.pack(side = "left", padx = 10, pady = 5)

                equip_button = self._create_sound_button(
                item_frame,
                "Equip",
                lambda loc = location, i = idx, itm = item:equip_item(loc, i, itm),
                width = 80,
                height = 30
                )
                equip_button.pack(side = "right", padx = 10, pady = 5)

            if not all_items:
                empty_label = customtkinter.CTkLabel(items_scroll, text = "No equippable items available", text_color = "gray")
                empty_label.pack(pady = 20)

        def equip_item(location, item_idx, item):
            try:
                equipment = save_data.get("equipment", {})

                choices =[]

                def add_choice(label, slot = None, parent_slot = None, subslot = None):
                    choices.append({"label":label, "slot":slot, "parent_slot":parent_slot, "subslot":subslot})

                is_weapon = item.get("firearm", False)or item.get("melee", False)

                if is_weapon:
                    weapon_subtype = item.get("subtype", "unknown")
                    weapon_melee_type = item.get("type")if item.get("melee")else None

                    def _slot_blocked_by_subslots(slot_name):
                        try:
                            slot_name_l = str(slot_name).lower()if slot_name is not None else ''
                            for other_slot, other_item in equipment.items():
                                if not other_item or not isinstance(other_item, dict):
                                    continue

                                for subslot_data in other_item.get('subslots', [])or[]:
                                    try:
                                        conflicts = subslot_data.get('conflicts_with')
                                        cur = subslot_data.get('current')
                                        if not cur:
                                            continue
                                        if isinstance(conflicts, dict):
                                            if conflicts.get('type')=='main'and str(conflicts.get('slot')).lower()==slot_name_l:
                                                return True
                                        elif isinstance(conflicts, (list, tuple)):
                                            for conflict_slot in conflicts:
                                                if str(conflict_slot).lower()==slot_name_l:
                                                    return True
                                    except Exception:
                                        pass

                                for acc in other_item.get('accessories', [])or[]:
                                    try:
                                        curacc = acc.get('current')
                                        if not isinstance(curacc, dict):
                                            continue
                                        for subslot_data in curacc.get('subslots', [])or[]:
                                            try:
                                                conflicts = subslot_data.get('conflicts_with')
                                                cur = subslot_data.get('current')
                                                if not cur:
                                                    continue
                                                if isinstance(conflicts, dict):
                                                    if conflicts.get('type')=='main'and str(conflicts.get('slot')).lower()==slot_name_l:
                                                        return True
                                                elif isinstance(conflicts, (list, tuple)):
                                                    for conflict_slot in conflicts:
                                                        if str(conflict_slot).lower()==slot_name_l:
                                                            return True
                                            except Exception:
                                                pass
                                    except Exception:
                                        pass
                            return False
                        except Exception:
                            return False

                    if weapon_subtype =="pistol"and "waistband"in equipment and equipment["waistband"]is None and not _slot_blocked_by_subslots("waistband"):
                        add_choice("Waistband", slot = "waistband")

                    for parent_slot, equipped_item in equipment.items():
                        if isinstance(equipped_item, dict)and equipped_item.get("holster_sling", False):
                            compatible_types = equipped_item.get("weapon_types", [])
                            if weapon_subtype in compatible_types or weapon_melee_type in compatible_types:
                                for subslot_data in equipped_item.get("subslots", []):
                                    if subslot_data.get("slot")!="weapon_slot"or subslot_data.get("current")is not None:
                                        continue
                                    conflicts = subslot_data.get("conflicts_with")
                                    blocked = False
                                    if conflicts:
                                        if isinstance(conflicts, dict):
                                            conflict_type = conflicts.get("type")
                                            conflict_slot = conflicts.get("slot")
                                            if conflict_type =="main"and conflict_slot in equipment and equipment.get(conflict_slot)is not None:
                                                blocked = True
                                        elif isinstance(conflicts, (list, tuple)):
                                            for conflict_slot in conflicts:
                                                if conflict_slot in equipment and equipment.get(conflict_slot)is not None:
                                                    blocked = True
                                                    break
                                    if blocked:
                                        continue
                                    label = f"{parent_slot.title()} - {subslot_data.get('name', 'Weapon Slot')}"
                                    add_choice(label, parent_slot = parent_slot, subslot = subslot_data)

                    if not choices:
                        if weapon_subtype =="pistol":
                            self._popup_show_info("Error", "No available holster/sling or waistband slot for this pistol.", sound = "error")
                        else:
                            self._popup_show_info("Error", f"No available holster/sling slot for this weapon(type: {weapon_subtype or weapon_melee_type}).", sound = "error")
                        return

                else:

                    valid_slots = item.get("slot", [])
                    if not isinstance(valid_slots, list):
                        valid_slots =[valid_slots]

                    def _slot_blocked_by_subslots(slot_name):
                        try:
                            slot_name_l = str(slot_name).lower()if slot_name is not None else ''
                            for other_slot, other_item in equipment.items():
                                if not other_item or not isinstance(other_item, dict):
                                    continue
                                for subslot_data in other_item.get('subslots', [])or[]:
                                    try:
                                        conflicts = subslot_data.get('conflicts_with')
                                        cur = subslot_data.get('current')
                                        if not cur:
                                            continue
                                        if isinstance(conflicts, dict):
                                            if conflicts.get('type')=='main'and str(conflicts.get('slot')).lower()==slot_name_l:
                                                return True
                                        elif isinstance(conflicts, (list, tuple)):
                                            for conflict_slot in conflicts:
                                                if str(conflict_slot).lower()==slot_name_l:
                                                    return True
                                    except Exception:
                                        pass
                                for acc in other_item.get('accessories', [])or[]:
                                    try:
                                        curacc = acc.get('current')
                                        if not isinstance(curacc, dict):
                                            continue
                                        for subslot_data in curacc.get('subslots', [])or[]:
                                            try:
                                                conflicts = subslot_data.get('conflicts_with')
                                                cur = subslot_data.get('current')
                                                if not cur:
                                                    continue
                                                if isinstance(conflicts, dict):
                                                    if conflicts.get('type')=='main'and str(conflicts.get('slot')).lower()==slot_name_l:
                                                        return True
                                                elif isinstance(conflicts, (list, tuple)):
                                                    for conflict_slot in conflicts:
                                                        if str(conflict_slot).lower()==slot_name_l:
                                                            return True
                                            except Exception:
                                                pass
                                    except Exception:
                                        pass
                            return False
                        except Exception:
                            return False

                    for slot in valid_slots:
                        cur = equipment.get(slot)

                        if slot in equipment and cur is None:

                            if _slot_blocked_by_subslots(slot):
                                continue
                            add_choice(f"{slot.title()}", slot = slot)
                        else:

                            try:
                                if item.get('can_equip_multiple'):
                                    max_e = item.get('max_equip')

                                    count = 0
                                    if isinstance(cur, dict)and cur.get('id')==item.get('id'):
                                        count = 1
                                    elif isinstance(cur, list):

                                        same =[c for c in cur if isinstance(c, dict)and c.get('id')==item.get('id')]
                                        count = len(same)

                                    if max_e is None or(isinstance(max_e, int)and count <int(max_e)):

                                        allow = False
                                        if cur is None:
                                            allow = True
                                        elif isinstance(cur, dict)and cur.get('id')==item.get('id'):
                                            allow = True
                                        elif isinstance(cur, list)and all(isinstance(c, dict)and c.get('id')==item.get('id')for c in cur):
                                            allow = True
                                        if allow:
                                            lbl = f"{slot.title()}"
                                            if count >0:
                                                lbl = f"{lbl}(x{count})"
                                            add_choice(lbl, slot = slot)
                            except Exception:
                                pass

                    def _recurse_find_subslots(root_slot, container, label_prefix = None):
                        try:
                            if not container or not isinstance(container, dict):
                                return
                            for subslot_data in container.get('subslots', [])or[]:
                                try:
                                    subslot_type = subslot_data.get('slot', '')

                                    lbl_suffix = subslot_data.get('name', subslot_type)
                                    label = f"{root_slot.title()} - {lbl_suffix}"if not label_prefix else f"{label_prefix} -> {lbl_suffix}"

                                    if subslot_type in valid_slots and subslot_data.get('current')is None:
                                        conflicts = subslot_data.get('conflicts_with')
                                        blocked = False
                                        if conflicts:
                                            if isinstance(conflicts, dict):
                                                conflict_type = conflicts.get('type')
                                                conflict_slot = conflicts.get('slot')
                                                if conflict_type =='main'and conflict_slot in equipment and equipment.get(conflict_slot)is not None:
                                                    blocked = True
                                            elif isinstance(conflicts, (list, tuple)):
                                                for conflict_slot in conflicts:
                                                    if conflict_slot in equipment and equipment.get(conflict_slot)is not None:
                                                        blocked = True
                                                        break
                                        if not blocked:
                                            add_choice(label, parent_slot = root_slot, subslot = subslot_data)

                                    cur = subslot_data.get('current')
                                    if isinstance(cur, dict):
                                        _recurse_find_subslots(root_slot, cur, label_prefix = label)
                                except Exception:
                                    pass
                        except Exception:
                            pass

                    for parent_slot, equipped_item in equipment.items():
                        if isinstance(equipped_item, dict):
                            _recurse_find_subslots(parent_slot, equipped_item)
                        elif isinstance(equipped_item, list):
                            for idx, subitem in enumerate(equipped_item):
                                _recurse_find_subslots(parent_slot, subitem, label_prefix = f"{parent_slot.title()}#{idx}")

                    def _recurse_accessory_subslots(root_slot, accessory, label_prefix = None):
                        try:
                            cur = accessory.get('current')if isinstance(accessory, dict)else None
                            if not isinstance(cur, dict):
                                return

                            _recurse_find_subslots(root_slot, cur, label_prefix = label_prefix or f"{root_slot.title()} - {accessory.get('name', 'Accessory')}")
                        except Exception:
                            pass

                    for parent_slot, equipped_item in equipment.items():
                        if isinstance(equipped_item, dict)and isinstance(equipped_item.get('accessories'), list):
                            for acc in equipped_item.get('accessories')or[]:
                                try:
                                    _recurse_accessory_subslots(parent_slot, acc)
                                except Exception:
                                    pass

                    if not choices:
                        self._popup_show_info("Error", f"No available slots for this item.Valid slots: {', '.join(valid_slots)}", sound = "error")
                        return

                def apply_choice(choice):
                    def _take_one_from_list(lst, idx):
                        try:
                            if not isinstance(lst, list):
                                return None
                            if idx is None or not(0 <=int(idx)<len(lst)):
                                return None
                            it = lst[int(idx)]
                            if isinstance(it, dict):
                                qty = it.get('quantity')
                                if isinstance(qty, (int, float))and qty >1:

                                    try:
                                        it['quantity']= int(qty)-1
                                    except Exception:
                                        pass
                                    single = it.copy()
                                    single['quantity']= 1
                                    return single

                            try:
                                return lst.pop(int(idx))
                            except Exception:
                                try:

                                    val = lst[int(idx)]
                                    lst[int(idx)]= None
                                    return val
                                except Exception:
                                    return None
                        except Exception:
                            return None

                    if location =="storage":
                        removed_item = _take_one_from_list(save_data["storage"], item_idx)
                    elif location =="hands":
                        removed_item = _take_one_from_list(save_data["hands"]["items"], item_idx)
                        item_weight =(removed_item.get("weight", 0)*removed_item.get("quantity", 1))if isinstance(removed_item, dict)else 0
                        save_data["hands"]["encumbrance"]= max(0, save_data["hands"].get("encumbrance", 0)-item_weight)
                    elif location.startswith("equipment."):

                        parts = location.split('.')
                        removed_item = item
                        try:
                            eq_slot = parts[1]
                            cur = save_data.get('equipment', {}).get(eq_slot)
                            i = 2
                            while i <len(parts):
                                token = parts[i]
                                if token =='items':

                                    if isinstance(cur, dict)and 'items'in cur:
                                        removed_item = _take_one_from_list(cur['items'], item_idx)
                                    elif isinstance(cur, list):
                                        removed_item = _take_one_from_list(cur, item_idx)
                                    else:
                                        removed_item = item
                                    break
                                elif token =='subslot':

                                    idx = int(parts[i +1])if i +1 <len(parts)else None
                                    if idx is None:
                                        removed_item = item
                                        break
                                    if isinstance(cur, dict)and 'subslots'in cur and idx <len(cur['subslots']):
                                        cur = cur['subslots'][idx].get('current')
                                        if cur is None:
                                            removed_item = item
                                            break
                                        i +=2
                                        continue
                                    else:
                                        removed_item = item
                                        break
                                elif token =='list':
                                    idx = int(parts[i +1])if i +1 <len(parts)else None
                                    if idx is None:
                                        removed_item = item
                                        break
                                    if isinstance(cur, list)and 0 <=idx <len(cur):
                                        cur = cur[idx]
                                        i +=2
                                        continue
                                    else:
                                        removed_item = item
                                        break
                                else:

                                    removed_item = item
                                    break
                        except Exception:
                            removed_item = item
                    else:
                        removed_item = item

                    if choice.get("slot"):
                        slot = choice["slot"]
                        cur = save_data["equipment"].get(slot)

                        if cur is None:
                            save_data["equipment"][slot]= removed_item
                        else:

                            try:
                                if item.get('can_equip_multiple')and item.get('id')is not None:
                                    max_e = item.get('max_equip')

                                    if isinstance(cur, dict):
                                        if cur.get('id')==item.get('id'):
                                            lst =[cur, removed_item]
                                            save_data["equipment"][slot]= lst
                                        else:

                                            save_data["equipment"][slot]= removed_item
                                    elif isinstance(cur, list):

                                        same =[c for c in cur if isinstance(c, dict)and c.get('id')==item.get('id')]
                                        if len(same)==len(cur):

                                            if max_e is None or len(cur)<int(max_e):
                                                cur.append(removed_item)
                                                save_data["equipment"][slot]= cur
                                            else:
                                                self._popup_show_info("Equip", f"Cannot equip more than {max_e} of this item into slot '{slot}'.", sound = "error")
                                                return
                                        else:

                                            save_data["equipment"][slot]= removed_item
                                    else:
                                        save_data["equipment"][slot]= removed_item
                                else:

                                    save_data["equipment"][slot]= removed_item
                            except Exception:
                                save_data["equipment"][slot]= removed_item
                    elif choice.get("subslot")is not None:
                        choice["subslot"]["current"]= removed_item

                    self._save_file(save_data)
                    try:
                        globals()['ATTACHMENTS_VERSION']= globals().get('ATTACHMENTS_VERSION', 0)+1
                    except Exception:
                        pass
                    refresh_display()

                    try:
                        played = False

                        if choice.get("slot")=="waistband":
                            logging.debug("Playing slingequip for waistband equip: sounds/firearms/universal/slingequip.ogg")

                            self._safe_sound_play("", "sounds/firearms/universal/slingequip.ogg", block = False)
                            played = True
                        elif choice.get("parent_slot"):
                            parent = save_data.get("equipment", {}).get(choice.get("parent_slot"))
                            if parent and isinstance(parent, dict):
                                pname = parent.get("name", "").lower()
                                ptypes =[pt.lower()for pt in parent.get("weapon_types", [])if isinstance(pt, str)]

                                if "pistol"in ptypes or "holster"in pname:
                                    logging.debug("Playing holsterequip for holster equip: sounds/firearms/universal/holsterequip.ogg")

                                    self._safe_sound_play("", "sounds/firearms/universal/holsterequip.ogg", block = False)
                                    played = True
                                else:
                                    logging.debug("Playing slingequip for sling equip: sounds/firearms/universal/slingequip.ogg")
                                    self._safe_sound_play("", "sounds/firearms/universal/slingequip.ogg", block = False)
                                    played = True
                        if not played:

                            self._play_ui_sound("success")
                    except Exception:
                        try:
                            self._play_ui_sound("success")
                        except Exception:
                            pass

                    try:
                        logging.debug("apply_choice: about to play per-item equip sound for %s", removed_item.get("name"))
                        self._play_firearm_sound(removed_item, "equip")
                    except Exception:
                        logging.exception("Failed to play per-item equip sound")

                if len(choices)==1:
                    apply_choice(choices[0])
                    return

                popup = customtkinter.CTkToplevel(self.root)
                popup.title("Select Slot")
                popup.transient(self.root)
                self._center_popup_on_window(popup, 360, 200)

                prompt_label = customtkinter.CTkLabel(popup, text = "Choose where to equip:", font = customtkinter.CTkFont(size = 14, weight = "bold"))
                prompt_label.pack(pady =(15, 10))

                choice_labels =[c["label"]for c in choices]
                selection = customtkinter.StringVar(value = choice_labels[0])

                choice_menu = customtkinter.CTkOptionMenu(popup, values = choice_labels, variable = selection)
                choice_menu.pack(pady = 10, padx = 20, fill = "x")

                def _on_equip_selection_change(*a):
                    try:
                        label = selection.get()
                        chosen = next((c for c in choices if c["label"]==label), None)
                        if not chosen:
                            return

                        if chosen.get("slot")=="waistband":
                            self._safe_sound_play("", "sounds/firearms/universal/slingequip.ogg")
                        elif chosen.get("parent_slot"):
                            parent = save_data.get("equipment", {}).get(chosen.get("parent_slot"))
                            if parent and isinstance(parent, dict):
                                pname = parent.get("name", "").lower()
                                ptypes =[pt.lower()for pt in parent.get("weapon_types", [])if isinstance(pt, str)]
                                if "pistol"in ptypes or "holster"in pname:
                                    self._safe_sound_play("", "sounds/firearms/universal/holsterequip.ogg")
                                else:
                                    self._safe_sound_play("", "sounds/firearms/universal/slingequip.ogg")
                        else:

                            try:
                                self._play_ui_sound("hover")
                            except Exception:
                                pass
                    except Exception:
                        pass

                try:

                    selection.trace_add("write", _on_equip_selection_change)
                except Exception:
                    try:
                        selection.trace("w", lambda *a:_on_equip_selection_change())
                    except Exception:
                        pass

                button_frame = customtkinter.CTkFrame(popup, fg_color = "transparent")
                button_frame.pack(pady = 15)

                def confirm_choice():
                    label = selection.get()
                    chosen = next((c for c in choices if c["label"]==label), None)
                    if chosen:
                        apply_choice(chosen)
                    popup.destroy()

                def cancel_choice():
                    popup.destroy()

                confirm_btn = self._create_sound_button(button_frame, "Equip", confirm_choice, width = 120, height = 35)
                confirm_btn.pack(side = "left", padx = 10)

                cancel_btn = self._create_sound_button(button_frame, "Cancel", cancel_choice, width = 120, height = 35)
                cancel_btn.pack(side = "left", padx = 10)

                popup.grab_set()
                popup.lift()
                self._safe_focus(popup)
            except Exception as e:
                logging.error(f"Equip failed: {e}")
                self._popup_show_info("Error", f"Equip failed: {e}", sound = "error")

        def unequip_item(slot):
            try:
                item = save_data["equipment"].get(slot)
                if not item:
                    return

                if isinstance(item, dict)and item.get("curse_of_binding"):
                    self._popup_show_info("Curse of Binding", f"{item.get('name', 'This item')} is bound and cannot be unequipped.", sound = "error")
                    return
                if isinstance(item, list):
                    last_item = item[-1]if item else None
                    if isinstance(last_item, dict)and last_item.get("curse_of_binding"):
                        self._popup_show_info("Curse of Binding", f"{last_item.get('name', 'This item')} is bound and cannot be unequipped.", sound = "error")
                        return

                played = False
                try:
                    if slot =="waistband":
                        logging.debug("Playing slingunequip for waistband unequip: sounds/firearms/universal/slingunequip.ogg")

                        self._safe_sound_play("", "sounds/firearms/universal/slingunequip.ogg", block = True)
                        played = True
                    else:
                        parent = save_data.get("equipment", {}).get(slot)
                        if parent and isinstance(parent, dict):
                            pname = parent.get("name", "").lower()
                            ptypes =[pt.lower()for pt in parent.get("weapon_types", [])if isinstance(pt, str)]
                            if "pistol"in ptypes or "holster"in pname:
                                logging.debug("Playing holsterunequip: sounds/firearms/universal/holsterunequip.ogg")
                                self._safe_sound_play("", "sounds/firearms/universal/holsterunequip.ogg", block = True)
                                played = True
                            elif parent.get("holster_sling"):
                                logging.debug("Playing slingunequip: sounds/firearms/universal/slingunequip.ogg")
                                self._safe_sound_play("", "sounds/firearms/universal/slingunequip.ogg", block = True)
                                played = True
                except Exception:
                    played = False

                if isinstance(item, list):
                    rem = item.pop()
                    save_data["hands"]["items"].append(rem)
                    if len(item)==1 and isinstance(item[0], dict):

                        save_data["equipment"][slot]= item[0]
                    elif len(item)==0:
                        save_data["equipment"][slot]= None
                    else:
                        save_data["equipment"][slot]= item
                else:
                    save_data["hands"]["items"].append(item)
                    save_data["equipment"][slot]= None

                self._save_file(save_data)

                refresh_display()
                if not played:
                    self._play_ui_sound("success")
            except Exception as e:
                logging.error(f"Unequip failed: {e}")
                self._popup_show_info("Error", f"Unequip failed: {e}", sound = "error")

        def unequip_from_subslot(parent_slot, subslot_data, subindex = None):
            try:

                if subindex is not None:
                    try:
                        nested = subslot_data.get('subslots')or[]
                        if 0 <=int(subindex)<len(nested):
                            target = nested[int(subindex)]
                            current_item = target.get('current')
                            target_key = target
                        else:
                            current_item = None
                            target_key = None
                    except Exception:
                        current_item = None
                        target_key = None
                else:
                    current_item = subslot_data.get("current")
                    target_key = subslot_data
                if not current_item:
                    return

                if isinstance(current_item, dict)and current_item.get("curse_of_binding"):
                    self._popup_show_info("Curse of Binding", f"{current_item.get('name', 'This item')} is bound and cannot be unequipped.", sound = "error")
                    return

                played = False
                try:
                    parent = save_data.get("equipment", {}).get(parent_slot)
                    if parent and isinstance(parent, dict):
                        pname = parent.get("name", "").lower()
                        ptypes =[pt.lower()for pt in parent.get("weapon_types", [])if isinstance(pt, str)]
                        if parent_slot =="waistband"or(parent.get("holster_sling")and any(pt in("rifle", "smg", "shotgun", "mg")for pt in ptypes)):

                            self._safe_sound_play("", "sounds/firearms/universal/slingunequip.ogg", block = True)
                            played = True
                        else:

                            if "pistol"in ptypes or "holster"in pname:
                                self._safe_sound_play("", "sounds/firearms/universal/holsterunequip.ogg", block = True)
                                played = True
                except Exception:
                    played = False

                try:
                    if not isinstance(current_item, dict)and(isinstance(current_item, int)or(isinstance(current_item, str)and current_item.isdigit())):
                        iid = int(current_item)

                        table_files = sorted(glob.glob(os.path.join("tables", f"*{global_variables.get('table_extension', '.sldtbl')}")))
                        for tf in table_files:
                            try:
                                with open(tf, 'r', encoding = 'utf-8')as f:
                                    td = json.load(f)
                            except Exception:
                                continue
                            for arr in td.get('tables', {}).values():
                                if isinstance(arr, list):
                                    for cand in arr:
                                        if isinstance(cand, dict)and cand.get('id')==iid:
                                            current_item = cand.copy()
                                            break
                                    if isinstance(current_item, dict):
                                        break
                            if isinstance(current_item, dict):
                                break
                except Exception:
                    pass

                save_data["hands"]["items"].append(current_item)
                try:
                    if subindex is not None and target_key is not None:
                        target_key['current']= None
                    else:
                        subslot_data["current"]= None
                except Exception:
                    try:
                        subslot_data["current"]= None
                    except Exception:
                        pass

                self._save_file(save_data)

                refresh_display()
                if not played:
                    self._play_ui_sound("success")
            except Exception as e:
                logging.error(f"Unequip from subslot failed: {e}")
                self._popup_show_info("Error", f"Unequip failed: {e}", sound = "error")

        def view_container_contents(container_item):
            try:
                self._play_ui_sound("click")

                popup = customtkinter.CTkToplevel(self.root)
                popup.title(f"Container: {self._format_item_name(container_item)}")
                popup.transient(self.root)
                self._center_popup_on_window(popup, 500, 600)

                main_container = customtkinter.CTkFrame(popup)
                main_container.pack(fill = "both", expand = True, padx = 20, pady = 20)

                title = customtkinter.CTkLabel(
                main_container,
                text = container_item.get('name', 'Unknown Container'),
                font = customtkinter.CTkFont(size = 18, weight = "bold")
                )
                title.pack(pady =(0, 10))

                total_weight = sum(i.get("weight", 0)*i.get("quantity", 1)for i in container_item.get("items", []))
                capacity = container_item.get("capacity", 0)
                capacity_label = customtkinter.CTkLabel(
                main_container,
                text = f"Capacity: {self._format_weight(total_weight)} / {self._format_weight(capacity)}",
                font = customtkinter.CTkFont(size = 14)
                )
                capacity_label.pack(pady =(0, 15))

                items_frame = customtkinter.CTkScrollableFrame(main_container, height = 400)
                items_frame.pack(fill = "both", expand = True, pady =(0, 10))

                items = container_item.get("items", [])
                if items:
                    for i, item in enumerate(items):
                        item_frame = customtkinter.CTkFrame(items_frame)
                        item_frame.pack(fill = "x", pady = 3, padx = 5)

                        item_name = self._format_item_name(item)
                        quantity = item.get("quantity", 1)
                        weight = item.get("weight", 0)

                        info_text = f"{item_name}"
                        if quantity >1:
                            info_text +=f"(x{quantity})"
                        info_text +=f" - {self._format_weight(weight *quantity)}"

                        item_label = customtkinter.CTkLabel(
                        item_frame,
                        text = info_text,
                        anchor = "w"
                        )
                        item_label.pack(side = "left", padx = 10, pady = 5, fill = "x", expand = True)
                else:
                    empty_label = customtkinter.CTkLabel(
                    items_frame,
                    text = "Container is empty",
                    text_color = "gray"
                    )
                    empty_label.pack(pady = 20)

                close_button = self._create_sound_button(
                main_container,
                "Close",
                popup.destroy,
                width = 120,
                height = 35
                )
                close_button.pack(pady =(10, 0))

                popup.update_idletasks()
                popup.grab_set()
                popup.lift()
                self._safe_focus(popup)
            except Exception as e:
                logging.error(f"View container failed: {e}")
                self._popup_show_info("Error", f"Failed to view container: {e}", sound = "error")

        refresh_display()

        back_button = self._create_sound_button(
        main_frame,
        "Back",
        lambda:[self._clear_window(), self._open_inventory_manager_tool()],
        width = 200,
        height = 40
        )
        back_button.pack(pady = 10)

    # â”€â”€ Combat Report System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    def _init_combat_session_stats(self, save_data):
        """Initialize per-session combat tracking.  Called when combat mode opens."""
        try:
            ts = save_data.setdefault('tracked_stats', {})
            ts['_session_rounds_fired'] = 0
            ts['_session_d20_rolls'] = []
            ts['_session_lead_rounds'] = 0
            ts['_session_leadfree_rounds'] = 0
            ts['_session_mags_loaded'] = 0
            ts['_session_rounds_loaded'] = 0
            ts['_session_start_time'] = time.time()
            ts['_session_weapons_used'] = []
        except Exception:
            logging.exception('Failed to init combat session stats')

    def _update_session_fire_stats(self, save_data, rounds_fired, rolls, fired_round=None):
        """Called after each fire event to update per-session counters."""
        try:
            ts = save_data.setdefault('tracked_stats', {})
            ts['_session_rounds_fired'] = int(ts.get('_session_rounds_fired', 0)) + int(rounds_fired)

            session_rolls = ts.setdefault('_session_d20_rolls', [])
            if isinstance(rolls, (list, tuple)):
                session_rolls.extend(rolls)

            # Determine if the fired round contains lead
            is_lead_free = False
            if isinstance(fired_round, dict):
                is_lead_free = bool(fired_round.get('lead_free', False))
                # Also check variant-level lead_free
                if not is_lead_free:
                    variant_data = fired_round.get('variant')
                    if isinstance(variant_data, dict):
                        is_lead_free = bool(variant_data.get('lead_free', False))
                # Check by looking up the variant name against the table
                if not is_lead_free:
                    try:
                        variant_name = None
                        if isinstance(fired_round.get('variant'), str):
                            variant_name = fired_round.get('variant')
                        elif isinstance(fired_round.get('variant'), dict):
                            variant_name = fired_round['variant'].get('name')
                        if variant_name:
                            tbl_path = get_current_table_path()
                            if tbl_path and os.path.exists(tbl_path):
                                with open(tbl_path, 'r', encoding='utf-8') as tf:
                                    tdata = json.load(tf)
                                    ammo_arr = tdata.get('tables', {}).get('ammunition', [])
                                    for a in ammo_arr:
                                        for v in (a.get('variants') or []):
                                            if isinstance(v, dict) and v.get('name') == variant_name:
                                                is_lead_free = bool(v.get('lead_free', False))
                                                break
                                        if is_lead_free:
                                            break
                    except Exception:
                        pass

            if is_lead_free:
                ts['_session_leadfree_rounds'] = int(ts.get('_session_leadfree_rounds', 0)) + int(rounds_fired)
            else:
                ts['_session_lead_rounds'] = int(ts.get('_session_lead_rounds', 0)) + int(rounds_fired)
        except Exception:
            logging.exception('Failed to update session fire stats')

    def _update_session_reload_stats(self, save_data, rounds_loaded):
        """Called after each reload to update per-session counters."""
        try:
            ts = save_data.setdefault('tracked_stats', {})
            ts['_session_mags_loaded'] = int(ts.get('_session_mags_loaded', 0)) + 1
            ts['_session_rounds_loaded'] = int(ts.get('_session_rounds_loaded', 0)) + int(rounds_loaded)
        except Exception:
            logging.exception('Failed to update session reload stats')

    def _generate_combat_report_data(self, save_data):
        """Collect all session data into a report dict."""
        try:
            ts = save_data.get('tracked_stats', {}) or {}
            character_name = save_data.get('charactername', 'Unknown')

            session_rolls = ts.get('_session_d20_rolls', []) or []
            total_rolls = len(session_rolls)
            avg_roll = (sum(session_rolls) / total_rolls) if total_rolls > 0 else 0.0
            nat20s = sum(1 for r in session_rolls if r == 20)
            nat1s = sum(1 for r in session_rolls if r == 1)

            lead_rounds = int(ts.get('_session_lead_rounds', 0))
            leadfree_rounds = int(ts.get('_session_leadfree_rounds', 0))
            total_fired = int(ts.get('_session_rounds_fired', 0))
            used_lead = lead_rounds > 0

            mags_loaded = int(ts.get('_session_mags_loaded', 0))
            rounds_loaded = int(ts.get('_session_rounds_loaded', 0))

            # Load lfinfo â€” try pulling latest from GitHub first, fall back to local
            lf_info = {}
            try:
                lf_path = os.path.join('remotedata', 'lfinfo.json')
                try:
                    remote_url = 'https://raw.githubusercontent.com/soli-dstate/DOOM-Tools/master/remotedata/lfinfo.json'
                    resp = requests.get(remote_url, timeout=5)
                    if resp.status_code == 200:
                        lf_info = resp.json()
                        os.makedirs('remotedata', exist_ok=True)
                        with open(lf_path, 'w', encoding='utf-8') as f:
                            json.dump(lf_info, f, indent=4)
                        logging.info('Pulled latest lfinfo.json from GitHub')
                except Exception:
                    logging.debug('Could not fetch lfinfo.json from GitHub, using local copy')
                if not lf_info and os.path.exists(lf_path):
                    with open(lf_path, 'r', encoding='utf-8') as f:
                        lf_info = json.load(f)
            except Exception:
                logging.exception('Failed to load lfinfo.json')

            lead_free_required = lf_info.get('lead_free_required', False)
            lead_fine = lf_info.get('fine_for_lead', 0)

            now = datetime.now()
            report = {
                'character': character_name,
                'date': now.strftime('%Y-%m-%d'),
                'time': now.strftime('%H:%M:%S'),
                'timestamp': now.strftime('%Y%m%d_%H%M%S'),
                'rounds_fired': total_fired,
                'lead_rounds_fired': lead_rounds,
                'leadfree_rounds_fired': leadfree_rounds,
                'used_lead': used_lead,
                'lead_free_required': lead_free_required,
                'lead_fine': lead_fine,
                'nat20s': nat20s,
                'nat1s': nat1s,
                'total_rolls': total_rolls,
                'average_roll': round(avg_roll, 2),
                'magazines_loaded': mags_loaded,
                'rounds_loaded': rounds_loaded,
            }
            # If lead rounds were used while lead-free is required, apply fine to character money
            try:
                if used_lead and lead_free_required and lead_fine:
                    # allow negative balances (debt)
                    try:
                        cur_money = save_data.get('money', 0) or 0
                        new_money = int(cur_money) - int(lead_fine)
                        save_data['money'] = new_money
                        # persist the save
                        try:
                            self._save_file(save_data)
                        except Exception:
                            logging.exception('Failed to persist save after applying lead fine')
                        report['fine_applied'] = True
                        report['money_after'] = save_data['money']
                        logging.info('Applied lead fine of %s to %s; new balance: %s', lead_fine, character_name, save_data['money'])
                    except Exception:
                        logging.exception('Failed to apply lead fine')
                else:
                    report['fine_applied'] = False
                    report['money_after'] = save_data.get('money', 0) or 0
            except Exception:
                logging.exception('Error while checking/applying lead fine')
            return report
        except Exception:
            logging.exception('Failed to generate combat report data')
            return None

    def _format_combat_report_lines(self, report):
        """Turn report dict into a list of printable lines for the dot-matrix effect."""
        if not report:
            return ['COMBAT REPORT', '', 'No data available.']

        lines = []
        lines.append('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
        lines.append('        COMBAT   REPORT')
        lines.append('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
        lines.append(f"  Operative: {report['character']}")
        lines.append(f"  Date: {report['date']}  Time: {report['time']}")
        lines.append('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€')
        lines.append(f"  Rounds Fired: {report['rounds_fired']}")

        if report.get('used_lead'):
            lines.append(f"  âš  LEAD ROUNDS USED: {report['lead_rounds_fired']}")
            if report.get('lead_free_required'):
                lines.append(f"  âš  LEAD-FREE REQUIRED â€” FINE: ${report['lead_fine']:,}")
        else:
            lines.append('  âœ“ All rounds lead-free')

        lines.append(f"  Lead-Free Rounds: {report['leadfree_rounds_fired']}")
        lines.append('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€')
        lines.append(f"  D20 Rolls: {report['total_rolls']}")
        lines.append(f"  Natural 20s: {report['nat20s']}")
        lines.append(f"  Natural 1s: {report['nat1s']}")
        lines.append(f"  Average Roll: {report['average_roll']}")
        lines.append('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€')
        lines.append(f"  Magazines Loaded: {report['magazines_loaded']}")
        lines.append(f"  Rounds Loaded: {report['rounds_loaded']}")
        lines.append('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•')
        return lines

    def _save_combat_report_to_file(self, report):
        """Save the combat report as a .txt under combatreports/."""
        try:
            os.makedirs('combatreports', exist_ok=True)
            safe_name = "".join(c if c.isalnum() or c in (' ', '-', '_') else '_' for c in report.get('character', 'Unknown'))
            filename = f"{safe_name} _ {report['date']} _ {report['time'].replace(':', '-')}.txt"
            filepath = os.path.join('combatreports', filename)

            lines = self._format_combat_report_lines(report)
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write('\n'.join(lines))
                f.write('\n')

            logging.info(f"Combat report saved to {filepath}")
            return filepath
        except Exception:
            logging.exception('Failed to save combat report')
            return None

    def _show_combat_report_animation(self, report, on_dismiss=None):
        """Show the animated dot-matrix combat report on a paper overlay."""
        try:
            lines = self._format_combat_report_lines(report)

            # Save the report to file
            saved_path = self._save_combat_report_to_file(report)

            overlay = customtkinter.CTkFrame(
                self.root,
                fg_color='#1a1a1a',
                corner_radius=0
            )
            overlay.place(relx=0, rely=0, relwidth=1, relheight=1)

            root_w = self.root.winfo_width() or 1920
            root_h = self.root.winfo_height() or 1080

            paper_w = min(520, root_w - 80)
            paper_h = min(680, root_h - 80)

            paper = customtkinter.CTkFrame(
                overlay,
                fg_color='#f5f0e1',
                corner_radius=4,
                border_width=2,
                border_color='#c8c0a8',
                width=paper_w,
                height=paper_h
            )

            # Start paper off-screen at the TOP (print head above window)
            paper_x = (root_w - paper_w) // 2
            paper_start_y = -(paper_h + 20)
            paper_mid_y = (root_h - paper_h) // 2

            paper.place(x=paper_x, y=paper_start_y)

            # Inner content area with padding for the "paper" feel
            content_frame = customtkinter.CTkFrame(paper, fg_color='#f5f0e1', corner_radius=0)
            content_frame.pack(fill='both', expand=True, padx=20, pady=20)

            # Dot matrix font - monospace
            dot_font = customtkinter.CTkFont(family='Courier New', size=13, weight='bold')

            # Pre-split each line into words for word-at-a-time printing
            line_labels = []
            for i, line_text in enumerate(lines):
                lbl = customtkinter.CTkLabel(
                    content_frame,
                    text='',
                    font=dot_font,
                    text_color='#1a1a1a',
                    anchor='w',
                    justify='left'
                )
                lbl.pack(anchor='w', pady=1)
                # Build word boundaries: list of end-indices for each word chunk
                words = []
                pos = 0
                in_space = True
                for ci, ch in enumerate(line_text):
                    if ch == ' ':
                        if not in_space:
                            words.append(ci)
                        in_space = True
                    else:
                        in_space = False
                if line_text and (not words or words[-1] != len(line_text)):
                    words.append(len(line_text))
                line_labels.append((lbl, line_text, words))

            # Dismiss button (hidden until animation completes)
            dismiss_btn = self._create_sound_button(
                paper,
                text='Dismiss',
                command=lambda: None,
                width=120,
                height=32,
                fg_color='#444444',
                hover_color='#666666',
                font=customtkinter.CTkFont(size=12)
            )

            # Saved path label
            saved_label = customtkinter.CTkLabel(
                paper,
                text=f'Saved: {os.path.basename(saved_path)}' if saved_path else '',
                font=customtkinter.CTkFont(size=10),
                text_color='#888888'
            )

            # Pre-load printer sounds and cache durations
            printer_sounds = {}
            sound_durations = {}
            try:
                for snd_name in ('start', 'character', 'characterloop', 'nextline', 'paperprint'):
                    snd_path = os.path.join('sounds', 'misc', 'printer', f'{snd_name}.ogg')
                    if os.path.exists(snd_path):
                        snd = pygame.mixer.Sound(snd_path)
                        printer_sounds[snd_name] = snd
                        sound_durations[snd_name] = max(10, int(snd.get_length() * 1000))
            except Exception:
                logging.debug('Failed to pre-load printer sounds')

            def _play_printer_sound(name):
                """Play a printer sound effect by name."""
                try:
                    snd = printer_sounds.get(name)
                    if snd:
                        channel = pygame.mixer.find_channel()
                        if channel:
                            channel.play(snd)
                except Exception:
                    logging.debug('Failed to play printer sound: %s', name)

            def _stop_all_printer_sounds():
                """Stop all playing printer sounds."""
                try:
                    for snd in printer_sounds.values():
                        snd.stop()
                except Exception:
                    pass

            def _sound_ms(name, fallback=50):
                """Return cached duration in ms for a sound, or fallback."""
                return sound_durations.get(name, fallback)

            # Calculate per-line step for paper feed
            num_lines = max(len(line_labels), 1)
            line_step = (paper_h - 40) / num_lines  # content area minus padding

            # Animation state
            # Start with paper positioned so the first line sits near the bottom of the screen
            initial_print_y = root_h - 80  # first text line visible near bottom
            anim_state = {
                'phase': 'slide_in',
                'current_y': float(paper_start_y),
                'print_target_y': float(initial_print_y),
                'line_index': 0,
                'word_index': 0,
                'skipped': False,
            }

            def _dismiss():
                try:
                    overlay.destroy()
                except Exception:
                    pass
                if on_dismiss:
                    try:
                        on_dismiss()
                    except Exception:
                        pass

            def _skip():
                """Skip to the finished state."""
                anim_state['skipped'] = True
                _stop_all_printer_sounds()
                try:
                    for lbl, txt, _w in line_labels:
                        lbl.configure(text=txt)
                    paper.place(x=paper_x, y=int(paper_mid_y))
                    skip_btn.place_forget()
                    dismiss_btn.pack(side='bottom', pady=(0, 8))
                    saved_label.pack(side='bottom', pady=(0, 2))
                except Exception:
                    pass

            dismiss_btn.configure(command=_dismiss)

            # Skip button (visible during animation)
            skip_btn = self._create_sound_button(
                overlay,
                text='Skip',
                command=_skip,
                width=80,
                height=28,
                fg_color='#555555',
                hover_color='#777777',
                font=customtkinter.CTkFont(size=11)
            )
            skip_btn.place(relx=1.0, rely=1.0, anchor='se', x=-20, y=-20)

            def _animate():
                try:
                    if anim_state['skipped']:
                        return

                    phase = anim_state['phase']

                    if phase == 'slide_in':
                        # Slide paper DOWN from top
                        cur = anim_state['current_y']
                        target = anim_state['print_target_y']
                        speed = max(12, abs(target - cur) * 0.14)
                        new_y = cur + speed
                        if new_y >= target:
                            new_y = target
                            anim_state['phase'] = 'start_sound'
                            anim_state['current_y'] = new_y
                            paper.place(x=paper_x, y=int(new_y))
                            self.root.after(200, _animate)
                            return
                        anim_state['current_y'] = new_y
                        paper.place(x=paper_x, y=int(new_y))
                        self.root.after(10, _animate)

                    elif phase == 'start_sound':
                        _play_printer_sound('start')
                        anim_state['phase'] = 'printing'
                        self.root.after(_sound_ms('start', 200), _animate)

                    elif phase == 'printing':
                        idx = anim_state['line_index']
                        if idx >= len(line_labels):
                            anim_state['phase'] = 'pre_final'
                            self.root.after(300, _animate)
                            return

                        lbl, full_text, words = line_labels[idx]
                        word_idx = anim_state['word_index']

                        # Trivial / empty lines
                        if len(full_text) <= 1:
                            lbl.configure(text=full_text)
                            anim_state['line_index'] = idx + 1
                            anim_state['word_index'] = 0
                            anim_state['phase'] = 'feed_paper'
                            self.root.after(10, _animate)
                            return

                        if word_idx >= len(words):
                            # Line complete â€” feed paper up
                            anim_state['line_index'] = idx + 1
                            anim_state['word_index'] = 0
                            anim_state['phase'] = 'feed_paper'
                            self.root.after(10, _animate)
                            return

                        # Ensure per-line char state is initialized
                        if anim_state.get('current_line') != idx:
                            anim_state['current_line'] = idx
                            anim_state['char_pos'] = 0
                            # ensure no lingering loop channel
                            try:
                                lc = anim_state.pop('loop_channel', None)
                                if lc:
                                    lc.stop()
                            except Exception:
                                pass

                        # Print characters up to the end of the current word
                        end_pos = words[word_idx]
                        char_pos = anim_state['char_pos']

                        if char_pos < end_pos:
                            # If starting a new word, begin looping the word sound
                            if not anim_state.get('loop_channel'):
                                try:
                                    loop_snd = printer_sounds.get('characterloop')
                                    if loop_snd:
                                        ch = pygame.mixer.find_channel()
                                        if ch:
                                            ch.play(loop_snd, loops=-1)
                                            anim_state['loop_channel'] = ch
                                except Exception:
                                    pass

                            # Print next character
                            next_pos = char_pos + 1
                            lbl.configure(text=full_text[:next_pos])
                            anim_state['char_pos'] = next_pos
                            self.root.after(18, _animate)
                        else:
                            # Word finished: stop loop, play end-character sound
                            try:
                                lc = anim_state.pop('loop_channel', None)
                                if lc:
                                    lc.stop()
                            except Exception:
                                pass
                            _play_printer_sound('character')
                            anim_state['word_index'] = word_idx + 1
                            # keep char_pos at end_pos so next word continues from here
                            self.root.after(_sound_ms('character', 30) + 40, _animate)

                    elif phase == 'feed_paper':
                        # Play nextline sound and slide paper up by one line
                        _play_printer_sound('nextline')
                        feed_target = anim_state['current_y'] - line_step
                        anim_state['feed_target'] = feed_target
                        anim_state['phase'] = 'feeding'
                        self.root.after(10, _animate)

                    elif phase == 'feeding':
                        # Smoothly move paper up to feed_target
                        cur = anim_state['current_y']
                        feed_target = anim_state['feed_target']
                        speed = max(4, abs(cur - feed_target) * 0.35)
                        new_y = cur - speed
                        if new_y <= feed_target:
                            new_y = feed_target
                            anim_state['current_y'] = new_y
                            paper.place(x=paper_x, y=int(new_y))
                            anim_state['phase'] = 'printing'
                            self.root.after(30, _animate)
                            return
                        anim_state['current_y'] = new_y
                        paper.place(x=paper_x, y=int(new_y))
                        self.root.after(8, _animate)

                    elif phase == 'pre_final':
                        # Play paperprint sound while sliding paper to center
                        _play_printer_sound('paperprint')
                        anim_state['phase'] = 'final_slide'
                        self.root.after(10, _animate)

                    elif phase == 'final_slide':
                        # Slide paper to center over the duration of the paperprint sound
                        cur = anim_state['current_y']
                        target = float(paper_mid_y)
                        # initialize timing state
                        if 'final_start' not in anim_state:
                            anim_state['final_start'] = time.time()
                            anim_state['final_start_y'] = cur
                            anim_state['final_target_y'] = target
                            anim_state['final_duration_ms'] = 1360
                        elapsed = (time.time() - anim_state['final_start']) * 1000.0
                        dur = anim_state.get('final_duration_ms', 400)
                        t = min(1.0, elapsed / float(dur))
                        new_y = anim_state['final_start_y'] + (anim_state['final_target_y'] - anim_state['final_start_y']) * t
                        anim_state['current_y'] = new_y
                        paper.place(x=paper_x, y=int(new_y))
                        if t >= 1.0:
                            anim_state['phase'] = 'done'
                            skip_btn.place_forget()
                            try:
                                dismiss_btn.pack(side='bottom', pady=(0, 8))
                                saved_label.pack(side='bottom', pady=(0, 2))
                            except Exception:
                                pass
                            return
                        self.root.after(10, _animate)

                except Exception:
                    logging.exception('Combat report animation error')
                    # Fallback: just show everything
                    try:
                        for lbl, txt, _w in line_labels:
                            lbl.configure(text=txt)
                        paper.place(x=paper_x, y=int(paper_mid_y))
                        skip_btn.place_forget()
                        dismiss_btn.pack(side='bottom', pady=(0, 8))
                        saved_label.pack(side='bottom', pady=(0, 2))
                    except Exception:
                        pass

            # Kick off animation
            self.root.after(100, _animate)

        except Exception:
            logging.exception('Failed to show combat report animation')
            if on_dismiss:
                try:
                    on_dismiss()
                except Exception:
                    pass

    def _reprint_combat_report(self, filepath):
        """Re-print a saved combat report with the dot-matrix animation."""
        try:
            if not os.path.exists(filepath):
                self._popup_show_info('Error', 'Combat report file not found.', sound='error')
                return

            with open(filepath, 'r', encoding='utf-8') as f:
                content = f.read()

            lines = content.strip().split('\n')

            # Build a minimal report dict for the animation by parsing the file
            report = {
                'character': 'Unknown',
                'date': '',
                'time': '',
                'rounds_fired': 0,
                'lead_rounds_fired': 0,
                'leadfree_rounds_fired': 0,
                'used_lead': False,
                'lead_free_required': False,
                'lead_fine': 0,
                'nat20s': 0,
                'nat1s': 0,
                'total_rolls': 0,
                'average_roll': 0,
                'magazines_loaded': 0,
                'rounds_loaded': 0,
            }

            # For re-print we use the raw lines directly
            self._show_combat_report_reprint(lines)

        except Exception:
            logging.exception('Failed to reprint combat report')
            self._popup_show_info('Error', 'Failed to open combat report.', sound='error')

    def _show_combat_report_reprint(self, lines, on_dismiss=None):
        """Show a previously saved report with the same paper animation."""
        try:
            overlay = customtkinter.CTkFrame(
                self.root,
                fg_color='#1a1a1a',
                corner_radius=0
            )
            overlay.place(relx=0, rely=0, relwidth=1, relheight=1)

            root_w = self.root.winfo_width() or 1920
            root_h = self.root.winfo_height() or 1080

            paper_w = min(520, root_w - 80)
            paper_h = min(680, root_h - 80)

            paper = customtkinter.CTkFrame(
                overlay,
                fg_color='#f5f0e1',
                corner_radius=4,
                border_width=2,
                border_color='#c8c0a8',
                width=paper_w,
                height=paper_h
            )

            # Start paper off-screen at the TOP (print head above window)
            paper_x = (root_w - paper_w) // 2
            paper_start_y = -(paper_h + 20)
            paper_mid_y = (root_h - paper_h) // 2

            paper.place(x=paper_x, y=paper_start_y)

            content_frame = customtkinter.CTkFrame(paper, fg_color='#f5f0e1', corner_radius=0)
            content_frame.pack(fill='both', expand=True, padx=20, pady=20)

            dot_font = customtkinter.CTkFont(family='Courier New', size=13, weight='bold')

            # Pre-split each line into words for word-at-a-time printing
            line_labels = []
            for line_text in lines:
                lbl = customtkinter.CTkLabel(
                    content_frame,
                    text='',
                    font=dot_font,
                    text_color='#1a1a1a',
                    anchor='w',
                    justify='left'
                )
                lbl.pack(anchor='w', pady=1)
                words = []
                pos = 0
                in_space = True
                for ci, ch in enumerate(line_text):
                    if ch == ' ':
                        if not in_space:
                            words.append(ci)
                        in_space = True
                    else:
                        in_space = False
                if line_text and (not words or words[-1] != len(line_text)):
                    words.append(len(line_text))
                line_labels.append((lbl, line_text, words))

            dismiss_btn = self._create_sound_button(
                paper,
                text='Dismiss',
                command=lambda: None,
                width=120,
                height=32,
                fg_color='#444444',
                hover_color='#666666',
                font=customtkinter.CTkFont(size=12)
            )

            # Pre-load printer sounds and cache durations
            printer_sounds = {}
            sound_durations = {}
            try:
                for snd_name in ('start', 'character', 'characterloop', 'nextline', 'paperprint'):
                    snd_path = os.path.join('sounds', 'misc', 'printer', f'{snd_name}.ogg')
                    if os.path.exists(snd_path):
                        snd = pygame.mixer.Sound(snd_path)
                        printer_sounds[snd_name] = snd
                        sound_durations[snd_name] = max(10, int(snd.get_length() * 1000))
            except Exception:
                logging.debug('Failed to pre-load printer sounds')

            def _play_printer_sound(name):
                """Play a printer sound effect by name."""
                try:
                    snd = printer_sounds.get(name)
                    if snd:
                        channel = pygame.mixer.find_channel()
                        if channel:
                            channel.play(snd)
                except Exception:
                    logging.debug('Failed to play printer sound: %s', name)

            def _stop_all_printer_sounds():
                """Stop all playing printer sounds."""
                try:
                    for snd in printer_sounds.values():
                        snd.stop()
                except Exception:
                    pass

            def _sound_ms(name, fallback=50):
                """Return cached duration in ms for a sound, or fallback."""
                return sound_durations.get(name, fallback)

            # Calculate per-line step for paper feed
            num_lines = max(len(line_labels), 1)
            line_step = (paper_h - 40) / num_lines

            initial_print_y = root_h - 80
            anim_state = {
                'phase': 'slide_in',
                'current_y': float(paper_start_y),
                'print_target_y': float(initial_print_y),
                'line_index': 0,
                'word_index': 0,
                'skipped': False,
            }

            def _dismiss():
                try:
                    overlay.destroy()
                except Exception:
                    pass
                if on_dismiss:
                    try:
                        on_dismiss()
                    except Exception:
                        pass

            def _skip():
                """Skip to the finished state."""
                anim_state['skipped'] = True
                _stop_all_printer_sounds()
                try:
                    for lbl, txt, _w in line_labels:
                        lbl.configure(text=txt)
                    paper.place(x=paper_x, y=int(paper_mid_y))
                    skip_btn.place_forget()
                    dismiss_btn.pack(side='bottom', pady=(0, 8))
                except Exception:
                    pass

            dismiss_btn.configure(command=_dismiss)

            # Skip button (visible during animation)
            skip_btn = self._create_sound_button(
                overlay,
                text='Skip',
                command=_skip,
                width=80,
                height=28,
                fg_color='#555555',
                hover_color='#777777',
                font=customtkinter.CTkFont(size=11)
            )
            skip_btn.place(relx=1.0, rely=1.0, anchor='se', x=-20, y=-20)

            def _animate():
                try:
                    if anim_state['skipped']:
                        return

                    phase = anim_state['phase']

                    if phase == 'slide_in':
                        # Slide paper DOWN from top
                        cur = anim_state['current_y']
                        target = anim_state['print_target_y']
                        speed = max(12, abs(target - cur) * 0.14)
                        new_y = cur + speed
                        if new_y >= target:
                            new_y = target
                            anim_state['phase'] = 'start_sound'
                            anim_state['current_y'] = new_y
                            paper.place(x=paper_x, y=int(new_y))
                            self.root.after(200, _animate)
                            return
                        anim_state['current_y'] = new_y
                        paper.place(x=paper_x, y=int(new_y))
                        self.root.after(10, _animate)

                    elif phase == 'start_sound':
                        _play_printer_sound('start')
                        anim_state['phase'] = 'printing'
                        self.root.after(_sound_ms('start', 200), _animate)

                    elif phase == 'printing':
                        idx = anim_state['line_index']
                        if idx >= len(line_labels):
                            anim_state['phase'] = 'pre_final'
                            self.root.after(300, _animate)
                            return

                        lbl, full_text, words = line_labels[idx]
                        word_idx = anim_state['word_index']

                        # Trivial / empty lines
                        if len(full_text) <= 1:
                            lbl.configure(text=full_text)
                            anim_state['line_index'] = idx + 1
                            anim_state['word_index'] = 0
                            anim_state['phase'] = 'feed_paper'
                            self.root.after(10, _animate)
                            return

                        if word_idx >= len(words):
                            # Line complete â€” feed paper up
                            anim_state['line_index'] = idx + 1
                            anim_state['word_index'] = 0
                            anim_state['phase'] = 'feed_paper'
                            self.root.after(10, _animate)
                            return

                        # Ensure per-line char state is initialized
                        if anim_state.get('current_line') != idx:
                            anim_state['current_line'] = idx
                            anim_state['char_pos'] = 0
                            try:
                                lc = anim_state.pop('loop_channel', None)
                                if lc:
                                    lc.stop()
                            except Exception:
                                pass

                        # Print characters up to the end of the current word
                        end_pos = words[word_idx]
                        char_pos = anim_state['char_pos']

                        if char_pos < end_pos:
                            if not anim_state.get('loop_channel'):
                                try:
                                    loop_snd = printer_sounds.get('characterloop')
                                    if loop_snd:
                                        ch = pygame.mixer.find_channel()
                                        if ch:
                                            ch.play(loop_snd, loops=-1)
                                            anim_state['loop_channel'] = ch
                                except Exception:
                                    pass

                            next_pos = char_pos + 1
                            lbl.configure(text=full_text[:next_pos])
                            anim_state['char_pos'] = next_pos
                            self.root.after(18, _animate)
                        else:
                            try:
                                lc = anim_state.pop('loop_channel', None)
                                if lc:
                                    lc.stop()
                            except Exception:
                                pass
                            _play_printer_sound('character')
                            anim_state['word_index'] = word_idx + 1
                            self.root.after(_sound_ms('character', 30) + 40, _animate)

                    elif phase == 'feed_paper':
                        _play_printer_sound('nextline')
                        feed_target = anim_state['current_y'] - line_step
                        anim_state['feed_target'] = feed_target
                        anim_state['phase'] = 'feeding'
                        self.root.after(10, _animate)

                    elif phase == 'feeding':
                        cur = anim_state['current_y']
                        feed_target = anim_state['feed_target']
                        speed = max(4, abs(cur - feed_target) * 0.35)
                        new_y = cur - speed
                        if new_y <= feed_target:
                            new_y = feed_target
                            anim_state['current_y'] = new_y
                            paper.place(x=paper_x, y=int(new_y))
                            anim_state['phase'] = 'printing'
                            self.root.after(30, _animate)
                            return
                        anim_state['current_y'] = new_y
                        paper.place(x=paper_x, y=int(new_y))
                        self.root.after(8, _animate)

                    elif phase == 'pre_final':
                        _play_printer_sound('paperprint')
                        anim_state['phase'] = 'final_slide'
                        self.root.after(10, _animate)

                    elif phase == 'final_slide':
                        # Slide paper to center over the duration of the paperprint sound
                        cur = anim_state['current_y']
                        target = float(paper_mid_y)
                        # initialize timing state
                        if 'final_start' not in anim_state:
                            anim_state['final_start'] = time.time()
                            anim_state['final_start_y'] = cur
                            anim_state['final_target_y'] = target
                            anim_state['final_duration_ms'] = 1360
                        elapsed = (time.time() - anim_state['final_start']) * 1000.0
                        dur = anim_state.get('final_duration_ms', 400)
                        t = min(1.0, elapsed / float(dur))
                        new_y = anim_state['final_start_y'] + (anim_state['final_target_y'] - anim_state['final_start_y']) * t
                        anim_state['current_y'] = new_y
                        paper.place(x=paper_x, y=int(new_y))
                        if t >= 1.0:
                            anim_state['phase'] = 'done'
                            skip_btn.place_forget()
                            try:
                                dismiss_btn.pack(side='bottom', pady=(0, 8))
                            except Exception:
                                pass
                            return
                        self.root.after(10, _animate)

                except Exception:
                    logging.exception('Combat report reprint animation error')
                    try:
                        for lbl, txt, _w in line_labels:
                            lbl.configure(text=txt)
                        paper.place(x=paper_x, y=int(paper_mid_y))
                        skip_btn.place_forget()
                        dismiss_btn.pack(side='bottom', pady=(0, 8))
                    except Exception:
                        pass

            self.root.after(100, _animate)

        except Exception:
            logging.exception('Failed to show combat report reprint animation')

    def _open_combat_reports_menu(self):
        """Browse and re-print past combat reports."""
        logging.info('Combat Reports menu opened')

        self._clear_window()
        self._play_ui_sound('whoosh1')

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.pack(fill='both', expand=True, padx=20, pady=20)

        title_label = customtkinter.CTkLabel(
            main_frame,
            text='Combat Reports',
            font=customtkinter.CTkFont(size=24, weight='bold')
        )
        title_label.pack(pady=(0, 20))

        reports_dir = 'combatreports'
        os.makedirs(reports_dir, exist_ok=True)

        report_files = sorted(
            [f for f in os.listdir(reports_dir) if f.endswith('.txt')],
            reverse=True
        )

        if not report_files:
            empty_label = customtkinter.CTkLabel(
                main_frame,
                text='No combat reports found.',
                font=customtkinter.CTkFont(size=14),
                text_color='gray'
            )
            empty_label.pack(pady=40)
        else:
            scroll = customtkinter.CTkScrollableFrame(main_frame, fg_color='transparent')
            scroll.pack(fill='both', expand=True, padx=10, pady=10)

            for report_file in report_files:
                report_path = os.path.join(reports_dir, report_file)
                display_name = report_file.replace('.txt', '').replace('_', ' ')

                row_frame = customtkinter.CTkFrame(scroll, fg_color='transparent')
                row_frame.pack(fill='x', pady=3, padx=5)

                name_label = customtkinter.CTkLabel(
                    row_frame,
                    text=display_name,
                    font=customtkinter.CTkFont(size=12),
                    anchor='w'
                )
                name_label.pack(side='left', fill='x', expand=True)

                reprint_btn = self._create_sound_button(
                    row_frame,
                    text='Re-Print',
                    command=lambda p=report_path: self._reprint_combat_report(p),
                    width=100,
                    height=28,
                    font=customtkinter.CTkFont(size=11)
                )
                reprint_btn.pack(side='right', padx=5)

                delete_btn = self._create_sound_button(
                    row_frame,
                    text='Delete',
                    command=lambda p=report_path: self._delete_combat_report(p),
                    width=80,
                    height=28,
                    fg_color='#8B0000',
                    hover_color='#A52A2A',
                    font=customtkinter.CTkFont(size=11)
                )
                delete_btn.pack(side='right', padx=2)

        back_button = self._create_sound_button(
            main_frame,
            'Back',
            lambda: [self._clear_window(), self._build_main_menu()],
            width=200,
            height=40
        )
        back_button.pack(pady=10)

    def _delete_combat_report(self, filepath):
        """Delete a combat report file and refresh the menu."""
        try:
            if os.path.exists(filepath):
                os.remove(filepath)
                logging.info(f'Deleted combat report: {filepath}')
            self._open_combat_reports_menu()
        except Exception:
            logging.exception('Failed to delete combat report')
            self._popup_show_info('Error', 'Failed to delete report.', sound='error')

    def _open_combat_mode_tool(self):

        logging.info("Combat Mode opened")
        logging.debug("currentsave=%s debugmode=%s", currentsave, global_variables.get("debugmode", {}).get("value"))

        if currentsave is None:
            self._popup_show_info("Error", "No character loaded.Please load a character first.", sound = "error")
            return

        try:
            save_path = os.path.join(saves_folder or "saves", currentsave or "")
            if not save_path.endswith('.sldsv'):
                save_path +='.sldsv'
            save_data = self._load_file((currentsave or "")+".sldsv")
            if save_data is None:
                logging.error("Failed to load save for combat mode")
                self._popup_show_info("Error", "Failed to load save.", sound = "error")
                return
        except Exception as e:
            logging.error(f"Failed to load save: {e}")
            self._popup_show_info("Error", f"Failed to load save: {e}", sound = "error")
            return

        try:
            tbl_path = get_current_table_path()
            if not tbl_path or not os.path.exists(tbl_path):
                self._popup_show_info("Error", "No table file found.", sound = "error")
                return
            with open(tbl_path, 'r')as f:
                table_data = json.load(f)
        except Exception as e:
            logging.error(f"Failed to load table: {e}")
            self._popup_show_info("Error", f"Failed to load table: {e}", sound = "error")
            return

        if "combat_state"not in save_data:
            save_data["combat_state"]= {
            "current_weapon_index":0,
            "barrel_temperatures":{},
            "barrel_cleanliness":{},
            "ambient_temperature":70,
            "weapon_last_used":{}
            }

        combat_state = save_data["combat_state"]

        equipped_weapons = self._get_equipped_weapons(save_data, table_data)

        if not equipped_weapons:
            self._popup_show_info("Error", "No weapons equipped.Please equip a weapon first.", sound = "error")
            return

        if combat_state["current_weapon_index"]>=len(equipped_weapons):
            combat_state["current_weapon_index"]= 0

        now_ts = time.time()
        ambient = combat_state.get("ambient_temperature", 70)

        for wpn in equipped_weapons:
            weapon_id = str(wpn["item"].get("id"))
            temp_map = combat_state.setdefault("barrel_temperatures", {})
            last_used_map = combat_state.setdefault("weapon_last_used", {})

            current_temp = temp_map.get(weapon_id, ambient)
            last_used = last_used_map.get(weapon_id)

            if last_used is None and weapon_id in temp_map:
                assumed_interval = combat_state.get("temp_poll_interval", 15)
                last_used = now_ts -float(assumed_interval)

            elapsed = max(0.0, now_ts -last_used)if last_used is not None else 0.0

            if elapsed >0 and current_temp !=ambient:

                default_k = math.log(2.0)/300.0
                magic_k = math.log(2.0)/600.0
                magicsys_local = str(wpn.get("magicsoundsystem")or "").lower()
                is_magic_local =(str(wpn.get("type")or "").lower()=="magic")or(magicsys_local in("hg", "at", "mg", "rf"))
                k = magic_k if is_magic_local else default_k
                new_temp = ambient +(current_temp -ambient)*math.exp(-k *elapsed)

                low = min(ambient, current_temp)
                high = max(ambient, current_temp)
                new_temp = min(max(new_temp, low), high)
                temp_map[weapon_id]= new_temp

                last_used_map[weapon_id]= now_ts
                logging.debug(
                "Weapon %s cooling: was %.1fÂ°F, now %.1fÂ°F after %.1f seconds",
                weapon_id,
                current_temp,
                new_temp,
                elapsed,
                )

        logging.info(
        "Combat UI init: %s weapons, current index=%s(%s)",
        len(equipped_weapons),
        combat_state["current_weapon_index"],
        equipped_weapons[combat_state["current_weapon_index"]]["item"].get("name", "Unknown")if equipped_weapons else "n/a"
        )

        # Initialize per-session combat tracking
        self._init_combat_session_stats(save_data)

        self._clear_window()
        self._play_ui_sound("whoosh1")

        main_frame = customtkinter.CTkScrollableFrame(self.root, fg_color = "transparent")
        main_frame.pack(fill = "both", expand = True, padx = 20, pady = 20)

        title_label = customtkinter.CTkLabel(
        main_frame,
        text = "Combat Mode",
        font = customtkinter.CTkFont(size = 24, weight = "bold")
        )
        title_label.pack(pady =(0, 20))

        temp_frame = customtkinter.CTkFrame(main_frame)
        temp_frame.pack(fill = "x", pady =(0, 10))

        ambient_temp = combat_state['ambient_temperature']
        if appearance_settings["units"]=="metric":
            ambient_temp = round((ambient_temp -32)*5 /9, 1)
            temp_unit = "Â°C"
        else:
            temp_unit = "Â°F"

        ambient_label = customtkinter.CTkLabel(
        temp_frame,
        text = f"Ambient Temperature: {ambient_temp}{temp_unit}",
        font = customtkinter.CTkFont(size = 14)
        )
        ambient_label.pack(side = "left", padx = 10, pady = 10)

        def _show_combat_stats():

            try:
                parts =[]

                sd_stats = save_data.get("stats", {})or {}
                parts.append("Player base stats:")
                if isinstance(sd_stats, dict)and sd_stats:
                    for k, v in sd_stats.items():
                        parts.append(f" {k}: {v}")
                else:
                    parts.append("(no base stats)")

                agg = {}
                parts.append("")
                parts.append("Weapon modifiers(per-weapon):")
                for idx, entry in enumerate(equipped_weapons):
                    w = entry.get("item")if isinstance(entry, dict)else None
                    name = w.get("name", f"weapon_{idx}")if isinstance(w, dict)else str(entry)
                    mods = {}
                    if isinstance(w, dict):
                        mods = w.get("_active_modifiers", {})or {}
                    parts.append(f" {name}:")
                    stats_mods = mods.get("stats", {})if isinstance(mods, dict)else {}
                    if stats_mods:
                        for sk, sv in stats_mods.items():
                            parts.append(f" {sk}: {sv}")
                            try:
                                agg[sk]= agg.get(sk, 0)+(int(sv)if isinstance(sv, (int, float))else 0)
                            except Exception:
                                pass
                    else:
                        parts.append("(no modifiers)")

                parts.append("")
                parts.append("Aggregated weapon modifiers:")

                try:
                    stat_clamp = 20
                    try:
                        tbl_path = get_current_table_path()
                        if tbl_path and os.path.exists(tbl_path):
                            with open(tbl_path, 'r')as tf:
                                td = json.load(tf)
                                stat_clamp = td.get("additional_settings", {}).get("stat_clamp", stat_clamp)
                    except Exception:
                        pass
                except Exception:
                    stat_clamp = 20

                if agg:
                    for k, v in agg.items():
                        try:
                            num = int(v)if isinstance(v, (int, float))else int(float(v))
                        except Exception:
                            try:
                                num = int(v)
                            except Exception:
                                num = 0

                        num = max(num, -20)
                        num = min(num, int(stat_clamp or 20))
                        parts.append(f" {k}: {num}")
                else:
                    parts.append("(none)")

                try:
                    equip_agg = {}
                    active_sets =[]
                    applied_set_keys = set()
                    equipment = save_data.get("equipment", {})if isinstance(save_data, dict)else {}
                    if isinstance(equipment, dict):

                        for slot_name, equipped_item in equipment.items():
                            if not equipped_item or not isinstance(equipped_item, dict):
                                continue
                            mods = equipped_item.get("modifiers")or {}
                            if isinstance(mods, dict):
                                stats = mods.get("stats")or {}
                                if isinstance(stats, dict):
                                    for sk, sv in stats.items():
                                        try:
                                            equip_agg[sk]= equip_agg.get(sk, 0)+(int(sv)if isinstance(sv, (int, float))else 0)
                                        except Exception:
                                            pass
                            istats = equipped_item.get("stats")or {}
                            if isinstance(istats, dict):
                                for sk, sv in istats.items():
                                    try:
                                        equip_agg[sk]= equip_agg.get(sk, 0)+(int(sv)if isinstance(sv, (int, float))else 0)
                                    except Exception:
                                        pass

                        for slot_name, equipped_item in equipment.items():
                            try:
                                if not equipped_item or not isinstance(equipped_item, dict):
                                    continue
                                sb = equipped_item.get("set_bonus")or {}
                                if not sb or not isinstance(sb, dict):
                                    continue
                                requires = sb.get("requires")or[]
                                if not isinstance(requires, list)or not requires:
                                    continue

                                try:
                                    req_pairs =[]
                                    for req in requires:
                                        rslot = req.get("slot")
                                        rid = req.get("id")
                                        req_pairs.append((str(rslot), int(rid)if rid is not None and isinstance(rid, (int, float, str))and str(rid).isdigit()else rid))
                                    req_key = tuple(sorted(req_pairs))
                                except Exception:
                                    req_key = None
                                if req_key is None:
                                    continue
                                if req_key in applied_set_keys:
                                    continue

                                ok = True
                                member_names =[]
                                for req in requires:
                                    try:
                                        rslot = req.get("slot")
                                        rid = req.get("id")
                                        cur = equipment.get(rslot)
                                        if not cur or not isinstance(cur, dict)or cur.get("id")!=rid:
                                            ok = False
                                            break
                                        member_names.append(cur.get("name", f"{rslot}"))
                                    except Exception:
                                        ok = False
                                        break
                                if not ok:
                                    continue

                                sstats = sb.get("stats")or {}
                                if isinstance(sstats, dict):
                                    for sk, sv in sstats.items():
                                        try:
                                            equip_agg[sk]= equip_agg.get(sk, 0)+(int(sv)if isinstance(sv, (int, float))else 0)
                                        except Exception:
                                            pass
                                applied_set_keys.add(req_key)
                                set_name = sb.get("name")or equipped_item.get("name")or "Set Bonus"
                                active_sets.append({"name":set_name, "members":member_names, "stats":sstats})
                            except Exception:
                                pass

                    parts.append("")
                    parts.append("Equipment modifiers / Set bonuses:")
                    try:
                        clamp_val = None
                        tbl_path = get_current_table_path()
                        if tbl_path and os.path.exists(tbl_path):
                            with open(tbl_path, 'r')as tf:
                                td = json.load(tf)
                                clamp_val = td.get('additional_settings', {}).get('bonus_clamp')
                    except Exception:
                        clamp_val = None

                    if equip_agg:
                        for k, v in equip_agg.items():
                            try:
                                num = int(v)if isinstance(v, (int, float))else int(float(v))
                            except Exception:
                                try:
                                    num = int(v)
                                except Exception:
                                    num = 0
                            if k.lower()=='aim'and clamp_val is not None:
                                try:
                                    cnum = int(float(clamp_val))
                                    num = min(num, cnum)
                                except Exception:
                                    pass
                            parts.append(f" {k}: {num}")
                    else:
                        parts.append("(none)")

                    if active_sets:
                        parts.append("")
                        parts.append("Active set bonuses:")
                        for s in active_sets:
                            try:
                                stats_text =[]
                                if isinstance(s.get('stats'), dict):
                                    for sk, sv in s.get('stats', {}).items():
                                        stats_text.append(f"+{sv} {sk}")
                                members_text = ", ".join(s.get('members', [])or[])
                                parts.append(f" {s.get('name')}: {'; '.join(stats_text)}({members_text})")
                            except Exception:
                                pass
                except Exception as e:
                    logging.debug("Failed aggregating equipment modifiers for combat stats: %s", e)

                popup_text = "\n".join(parts)
            except Exception as e:
                logging.exception("Failed to build combat stats: %s", e)
                popup_text = f"Error building stats: {e}"
            try:
                self._popup_show_info("Combat Stats", popup_text)
            except Exception:
                try:

                    from tkinter import messagebox as _mb
                    _mb.showinfo("Combat Stats", popup_text)
                except Exception:
                    logging.error("Unable to display combat stats popup")

        stats_btn = self._create_sound_button(temp_frame, "Show Stats", _show_combat_stats, width = 160, height = 36)
        stats_btn.pack(side = "right", padx = 8, pady = 10)

        weapon_switch_outer = customtkinter.CTkFrame(main_frame)
        weapon_switch_outer.pack(fill = "x", pady =(0, 20))

        weapon_switch_frame = customtkinter.CTkScrollableFrame(weapon_switch_outer, orientation = "horizontal", height = 60, fg_color = "transparent")
        weapon_switch_frame.pack(fill = "x", expand = True)

        def refresh_weapon_display():

            self._save_combat_state(save_data)
            try:
                _update_nvg_button()
            except Exception:
                pass
            self._open_combat_mode_tool()

        def select_previous():
            logging.debug(
            "Switching weapon: prev from %s/%s",
            combat_state["current_weapon_index"],
            len(equipped_weapons)
            )

            try:

                try:
                    combat_state.pop("active_underbarrel", None)
                except Exception:
                    pass
                cur_idx = combat_state.get("current_weapon_index", 0)

                new_idx =(combat_state["current_weapon_index"]-1)%len(equipped_weapons)

                def _parent_slot_from_entry(entry):
                    slot = entry.get("slot", "")
                    if slot =="Hands":
                        return None
                    if "->"in slot:
                        return slot.split("->")[0].strip()
                    return slot

                def _container_type(parent_slot):

                    if parent_slot is None:
                        return "hands"
                    if parent_slot =="waistband":
                        return "waistband"
                    parent = save_data.get("equipment", {}).get(parent_slot)
                    if parent and isinstance(parent, dict):
                        pname = parent.get("name", "").lower()
                        ptypes =[pt.lower()for pt in parent.get("weapon_types", [])if isinstance(pt, str)]
                        if "pistol"in ptypes or "holster"in pname:
                            return "holster"
                        if parent.get("holster_sling"):
                            return "sling"
                    return "unknown"

                try:
                    combat_state.pop("active_underbarrel", None)
                except Exception:
                    pass

                old_entry = equipped_weapons[cur_idx]if 0 <=cur_idx <len(equipped_weapons)else None
                new_entry = equipped_weapons[new_idx]

                old_parent = _parent_slot_from_entry(old_entry)if old_entry else None
                new_parent = _parent_slot_from_entry(new_entry)

                old_type = _container_type(old_parent)
                new_type = _container_type(new_parent)

                if old_type in("sling", "waistband"):
                    self._safe_sound_play("", "sounds/firearms/universal/slingunequip.ogg", block = True)
                elif old_type =="holster":
                    self._safe_sound_play("", "sounds/firearms/universal/holsterunequip.ogg", block = True)

                combat_state["current_weapon_index"]= new_idx

                if new_type in("sling", "waistband"):
                    self._safe_sound_play("", "sounds/firearms/universal/slingequip.ogg", block = False)
                elif new_type =="holster":
                    self._safe_sound_play("", "sounds/firearms/universal/holsterequip.ogg", block = False)

                try:
                    self._play_firearm_sound(new_entry["item"], "equip")
                except Exception:
                    pass
            except Exception:
                pass
            refresh_weapon_display()

        def select_next():
            logging.debug(
            "Switching weapon: next from %s/%s",
            combat_state["current_weapon_index"],
            len(equipped_weapons)
            )

            try:
                cur_idx = combat_state.get("current_weapon_index", 0)

                new_idx =(combat_state["current_weapon_index"]+1)%len(equipped_weapons)

                def _parent_slot_from_entry(entry):
                    slot = entry.get("slot", "")
                    if slot =="Hands":
                        return None
                    if "->"in slot:
                        return slot.split("->")[0].strip()
                    return slot

                def _container_type(parent_slot):
                    if parent_slot is None:
                        return "hands"
                    if parent_slot =="waistband":
                        return "waistband"
                    parent = save_data.get("equipment", {}).get(parent_slot)
                    if parent and isinstance(parent, dict):
                        pname = parent.get("name", "").lower()
                        ptypes =[pt.lower()for pt in parent.get("weapon_types", [])if isinstance(pt, str)]
                        if "pistol"in ptypes or "holster"in pname:
                            return "holster"
                        if parent.get("holster_sling"):
                            return "sling"
                    return "unknown"

                old_entry = equipped_weapons[cur_idx]if 0 <=cur_idx <len(equipped_weapons)else None
                new_entry = equipped_weapons[new_idx]

                old_parent = _parent_slot_from_entry(old_entry)if old_entry else None
                new_parent = _parent_slot_from_entry(new_entry)

                old_type = _container_type(old_parent)
                new_type = _container_type(new_parent)

                if old_type in("sling", "waistband"):
                    self._safe_sound_play("", "sounds/firearms/universal/slingunequip.ogg", block = True)
                elif old_type =="holster":
                    self._safe_sound_play("", "sounds/firearms/universal/holsterunequip.ogg", block = True)

                combat_state["current_weapon_index"]= new_idx

                if new_type in("sling", "waistband"):
                    self._safe_sound_play("", "sounds/firearms/universal/slingequip.ogg", block = False)
                elif new_type =="holster":
                    self._safe_sound_play("", "sounds/firearms/universal/holsterequip.ogg", block = False)

                try:
                    new_weapon = new_entry["item"]
                    self._play_firearm_sound(new_weapon, "equip")
                except Exception:
                    pass
            except Exception:
                pass
            refresh_weapon_display()

        def _barrel_swap_current():

            try:

                wpn = None
                try:
                    wpn = current_weapon_state.get('weapon')if isinstance(current_weapon_state, dict)else None
                except Exception:
                    wpn = None
                if not wpn:
                    wpn = current_weapon

                if not wpn or not isinstance(wpn, dict):
                    try:
                        self._popup_show_info('Barrel Swap', 'No weapon selected.', sound = 'error')
                    except Exception:
                        pass
                    return

                if not bool(wpn.get('barrel_swap', False)):
                    try:
                        self._popup_show_info('Barrel Swap', 'Selected weapon does not support barrel swapping.')
                    except Exception:
                        pass
                    return

                wid = str(wpn.get('id'))
                temp_map = combat_state.setdefault('barrel_temperatures', {})
                last_used_map = combat_state.setdefault('weapon_last_used', {})
                ambient_local = combat_state.get('ambient_temperature', 70)
                now_local = time.time()
                temp_map[wid]= ambient_local
                last_used_map[wid]= now_local
                try:
                    self._save_combat_state(save_data)
                except Exception:
                    pass
                try:
                    self._popup_show_info('Barrel Swap', f"Swapped barrel on {wpn.get('name', 'weapon')}.Temperature reset to {ambient_local}{temp_unit}")
                except Exception:
                    pass
            except Exception as e:
                logging.exception('Barrel swap failed: %s', e)
                try:
                    self._popup_show_info('Error', f'Barrel swap failed: {e}', sound = 'error')
                except Exception:
                    pass

        def on_left_arrow(event):
            logging.debug("Left arrow pressed - switching weapon")
            select_previous()

        def on_right_arrow(event):
            logging.debug("Right arrow pressed - switching weapon")
            select_next()

        self.root.bind("<Left>", on_left_arrow)
        self.root.bind("<Right>", on_right_arrow)

        def on_b_key(event):
            try:
                logging.debug("'b' pressed - barrel swap requested")
                _barrel_swap_current()
            except Exception:
                pass

        def on_n_key(event):
            try:
                logging.debug("'n' pressed - NVG toggle requested")
                _toggle_nvg()
            except Exception:
                pass

        try:
            self.root.bind("b", on_b_key)
            self.root.bind("B", on_b_key)
            self.root.bind("n", on_n_key)
            self.root.bind("N", on_n_key)
        except Exception:
            pass

        self._create_sound_button(
        weapon_switch_frame,
        text = "â† Previous Weapon",
        command = select_previous,
        width = 150,
        height = 40
        ).pack(side = "left", padx = 10, pady = 10)

        active_ub = combat_state.get("active_underbarrel")
        def _resolve_active_underbarrel_obj(active_entry):
            try:
                if not active_entry or not isinstance(active_entry, dict):
                    return None
                parent_index = active_entry.get("parent_index")
                aid = active_entry.get("accessory_id")
                aname = active_entry.get("accessory_name")
                try:
                    logging.info("Resolving active underbarrel: parent_index=%s accessory_id=%s accessory_name=%s current_weapon_index=%s equipped_count=%s",
                    parent_index, aid, aname, combat_state.get("current_weapon_index"), len(equipped_weapons))
                except Exception:
                    pass
                if parent_index is None:
                    return None
                if parent_index <0 or parent_index >=len(equipped_weapons):
                    return None
                parent_slot = equipped_weapons[parent_index].get("slot", "")
                try:
                    logging.info("Resolved parent_slot from equipped_weapons[%s]-> %s", parent_index, parent_slot)
                except Exception:
                    pass

                if "->"in parent_slot:
                    parent_slot = parent_slot.split("->")[0].strip()
                parent_item = save_data.get("equipment", {}).get(parent_slot)
                try:
                    logging.info("Parent item found: %s", bool(parent_item))
                except Exception:
                    pass
                if not parent_item or not isinstance(parent_item, dict):
                    try:
                        logging.info("No parent_item present for slot '%s'", parent_slot)
                    except Exception:
                        pass
                    return None

                for acc in parent_item.get("accessories", [])or[]:
                    cur = acc.get("current")
                    try:
                        logging.info("Checking parent accessory entry current=%s", repr(cur))
                    except Exception:
                        pass
                    if isinstance(cur, dict):
                        if aid is not None and cur.get("id")==aid:
                            try:
                                logging.info("Resolver matched accessory by id: %s", cur.get("id"))
                            except Exception:
                                pass
                            return cur
                        if aname and cur.get("name")==aname:
                            try:
                                logging.info("Resolver matched accessory by name: %s", cur.get("name"))
                            except Exception:
                                pass
                            return cur
                    else:

                        try:
                            if aid is not None and(isinstance(cur, int)or(isinstance(cur, str)and cur.isdigit()))and int(cur)==int(aid):

                                tables = table_data.get("tables", {})if isinstance(table_data, dict)else {}
                                for arr in tables.values():
                                    if isinstance(arr, list):
                                        for it in arr:
                                            if isinstance(it, dict)and it.get("id")==int(cur):
                                                return it
                        except Exception:
                            pass

                for sub in parent_item.get("subslots", [])or[]:
                    try:
                        logging.info("Checking parent subslot '%s' for accessories", sub.get("name"))
                    except Exception:
                        pass
                    sub_cur = sub.get("current")if isinstance(sub, dict)else None
                    if not sub_cur or not isinstance(sub_cur, dict):
                        continue
                    for acc in sub_cur.get("accessories", [])or[]:
                        cur = acc.get("current")
                        try:
                            logging.info("Checking subslot accessory entry current=%s", repr(cur))
                        except Exception:
                            pass
                        if isinstance(cur, dict):
                            if aid is not None and cur.get("id")==aid:
                                try:
                                    logging.info("Resolver matched accessory in subslot by id: %s", cur.get("id"))
                                except Exception:
                                    pass
                                return cur
                            if aname and cur.get("name")==aname:
                                try:
                                    logging.info("Resolver matched accessory in subslot by name: %s", cur.get("name"))
                                except Exception:
                                    pass
                                return cur
                        else:
                            try:
                                if aid is not None and(isinstance(cur, int)or(isinstance(cur, str)and cur.isdigit()))and int(cur)==int(aid):
                                    tables = table_data.get("tables", {})if isinstance(table_data, dict)else {}
                                    for arr in tables.values():
                                        if isinstance(arr, list):
                                            for it in arr:
                                                if isinstance(it, dict)and it.get("id")==int(cur):
                                                    return it
                            except Exception:
                                pass
                return None
            except Exception:
                return None

        try:
            logging.info("Active underbarrel raw state: %s", repr(active_ub))
        except Exception:
            pass
        resolved_active_acc = _resolve_active_underbarrel_obj(active_ub)
        try:
            if resolved_active_acc is not None and hasattr(resolved_active_acc, 'get')and callable(getattr(resolved_active_acc, 'get')):
                name = resolved_active_acc.get('name', resolved_active_acc)
            else:
                name = resolved_active_acc
            logging.info("Resolved active accessory from resolver: %s", name)
        except Exception:
            try:
                logging.info("Resolved active accessory: %s", str(resolved_active_acc))
            except Exception:
                pass
        if active_ub and isinstance(active_ub, dict)and active_ub.get("parent_index")==combat_state.get("current_weapon_index")and resolved_active_acc:

            current_weapon = resolved_active_acc
            current_weapon_data = {"item":current_weapon, "slot":f"{equipped_weapons[combat_state['current_weapon_index']]['slot']} -> underbarrel"}
        else:
            current_weapon_data = equipped_weapons[combat_state["current_weapon_index"]]
            current_weapon = current_weapon_data["item"]
        current_weapon_state = {
        "weapon":current_weapon,
        "ammo_label_ref":None,
        "original_ammo_text":"",
        "clean_label_ref":None,
        "mag_checked":False
        }
        weapon_name_label = customtkinter.CTkLabel(
        weapon_switch_frame,
        text = f"Selected: {current_weapon.get('name', 'Unknown')}",
        font = customtkinter.CTkFont(size = 14, weight = "bold")
        )
        weapon_name_label.pack(side = "left", padx = 20, pady = 10, expand = True)

        self._create_sound_button(
        weapon_switch_frame,
        text = "Next Weapon â†’",
        command = select_next,
        width = 150,
        height = 40
        ).pack(side = "right", padx = 10, pady = 10)

        details_frame = customtkinter.CTkFrame(main_frame)
        details_frame.pack(fill = "both", expand = True, pady =(0, 20))

        try:
            self._apply_item_overrides(current_weapon)
        except Exception:
            pass
        self._display_weapon_details(details_frame, current_weapon, combat_state, save_data, table_data, current_weapon_state)

        def update_weapon_view():

            wpn = current_weapon_state["weapon"]
            weapon_name_label.configure(text = f"Selected: {wpn.get('name', 'Unknown')}")
            for child in details_frame.winfo_children():
                child.destroy()

            sd = globals().get('save_data')if 'save_data'in globals()else save_data
            try:
                self._apply_item_overrides(wpn)
            except Exception:
                pass
            self._display_weapon_details(details_frame, wpn, combat_state, sd, table_data, current_weapon_state)

            try:

                try:
                    new_max = _compute_rounds_max_for_weapon(wpn, current_weapon_state)
                    _apply_rounds_max(new_max)
                except Exception:
                    pass
            except Exception:
                pass

            try:
                dev_menu = current_weapon_state.get("dev_variant_menu_ref")
                dev_var = current_weapon_state.get("dev_variant_var")
                dev_cal_menu = current_weapon_state.get("dev_caliber_menu_ref")
                dev_cal_var = current_weapon_state.get("dev_caliber_var")
                if dev_menu and dev_var is not None:

                    try:

                        new_choices =[]
                        caliber_list = wpn.get("caliber", [])or[]

                        try:
                            if dev_cal_var and hasattr(dev_cal_var, 'get'):
                                sel_cal = dev_cal_var.get()
                                if sel_cal:
                                    cal = sel_cal
                                else:
                                    cal = caliber_list[0]if caliber_list else None
                            else:
                                cal = caliber_list[0]if caliber_list else None
                        except Exception:
                            cal = caliber_list[0]if caliber_list else None
                        ammo_tables = table_data.get("tables", {}).get("ammunition", [])if table_data else[]
                        for ammo in ammo_tables:
                            try:
                                if cal and ammo.get("caliber")==cal:
                                    for var in ammo.get("variants", [])or[]:
                                        new_choices.append(var.get("name", "Unknown"))
                                else:
                                    w_sounds = wpn.get("sounds")or wpn.get("sound_folder")or wpn.get("ammo_type")
                                    if w_sounds and(ammo.get("sounds")==w_sounds or ammo.get("ammo_type")==w_sounds):
                                        for var in ammo.get("variants", [])or[]:
                                            new_choices.append(var.get("name", "Unknown"))
                            except Exception:
                                pass
                        if not new_choices:
                            new_choices =["Ball"]

                        try:
                            dev_menu.configure(values = new_choices)
                            if dev_var.get()not in new_choices:
                                dev_var.set(new_choices[0])
                        except Exception:

                            try:
                                dev_menu.set_values(new_choices)
                                if dev_var.get()not in new_choices:
                                    dev_var.set(new_choices[0])
                            except Exception:
                                pass

                        try:
                            if dev_cal_menu is not None and dev_cal_var is not None:
                                calib_vals =[]
                                if isinstance(caliber_list, (list, tuple)):
                                    calib_vals =[str(x)for x in caliber_list if x is not None]
                                elif isinstance(caliber_list, str):
                                    calib_vals =[caliber_list]
                                if not calib_vals:
                                    calib_vals =[""]
                                try:
                                    dev_cal_menu.configure(values = calib_vals)
                                    if dev_cal_var.get()not in calib_vals:
                                        try:
                                            dev_cal_var.set(calib_vals[0])
                                        except Exception:
                                            pass

                                    if len(calib_vals)<=1:
                                        try:
                                            dev_cal_menu.configure(state = "disabled")
                                        except Exception:
                                            pass
                                    else:
                                        try:
                                            dev_cal_menu.configure(state = "normal")
                                        except Exception:
                                            pass
                                except Exception:
                                    try:
                                        dev_cal_menu.set_values(calib_vals)
                                    except Exception:
                                        pass
                        except Exception:
                            pass
                    except Exception:
                        pass
            except Exception:
                pass
            sd2 = globals().get('save_data')if 'save_data'in globals()else save_data
            self._save_combat_state(sd2)

            try:
                rb = current_weapon_state.get('reload_mag_btn_ref')
                if rb:
                    def _hands_have_compatible_rounds(wpn):
                        try:

                            if wpn and isinstance(wpn, dict)and wpn.get('has_ammo_in_pool')is False:
                                return False
                            cal_list = wpn.get('caliber')if isinstance(wpn, dict)else None
                            cal = None
                            if isinstance(cal_list, (list, tuple)):
                                cal = str(cal_list[0])if cal_list else None
                            elif isinstance(cal_list, str):
                                cal = cal_list

                            for itm in save_data.get('hands', {}).get('items', []):
                                if not itm or not isinstance(itm, dict):
                                    continue

                                if itm.get('magazinesystem')or itm.get('capacity'):
                                    continue

                                rds = itm.get('rounds')
                                if isinstance(rds, list)and rds:
                                    first = rds[0]
                                    if isinstance(first, dict)and cal and str(first.get('caliber'))==str(cal):
                                        return True
                                    if isinstance(first, str)and cal and str(cal)in first:
                                        return True

                                    return True

                                qty = int(itm.get('quantity')or 0)if isinstance(itm.get('quantity'), (int, float))else 0
                                if qty >0:
                                    ical = itm.get('caliber')or itm.get('name')
                                    if not cal or(ical and str(ical)==str(cal)):
                                        return True

                                if itm.get('caliber')and(not cal or str(itm.get('caliber'))==str(cal)):
                                    return True
                            return False
                        except Exception:
                            return False

                    def _inventory_has_nonfull_magazine():
                        try:
                            def check_item(itm):
                                if not itm or not isinstance(itm, dict):
                                    return False
                                cap = itm.get('capacity')
                                if cap is None:
                                    return False
                                try:
                                    cap_i = int(cap)
                                except Exception:
                                    return False
                                rounds = itm.get('rounds')
                                cur = 0
                                if isinstance(rounds, list):
                                    cur = len(rounds)
                                else:
                                    try:
                                        cur = int(rounds or 0)
                                    except Exception:
                                        cur = 0
                                return cur <cap_i

                            for itm in save_data.get('hands', {}).get('items', []):
                                try:
                                    if check_item(itm):
                                        return True
                                except Exception:
                                    pass
                            for slot_name, eq_item in save_data.get('equipment', {}).items():
                                try:
                                    if not eq_item or not isinstance(eq_item, dict):
                                        continue
                                    for itm in eq_item.get('items', [])or[]:
                                        try:
                                            if check_item(itm):
                                                return True
                                        except Exception:
                                            pass
                                    for sub in eq_item.get('subslots', [])or[]:
                                        try:
                                            curr = sub.get('current')
                                            if curr and isinstance(curr, dict):
                                                for itm in curr.get('items', [])or[]:
                                                    try:
                                                        if check_item(itm):
                                                            return True
                                                    except Exception:
                                                        pass
                                        except Exception:
                                            pass
                                except Exception:
                                    pass
                            return False
                        except Exception:
                            return False

                    def _inventory_has_nonempty_magazine():

                        try:
                            def check_mag(itm):
                                if not itm or not isinstance(itm, dict):
                                    return False
                                if itm.get('capacity')is None:
                                    return False
                                rounds = itm.get('rounds', [])
                                return isinstance(rounds, list)and len(rounds)>0

                            for itm in save_data.get('hands', {}).get('items', []):
                                if check_mag(itm):
                                    return True
                            for slot_name, eq_item in save_data.get('equipment', {}).items():
                                try:
                                    if not eq_item or not isinstance(eq_item, dict):
                                        continue
                                    for itm in eq_item.get('items', [])or[]:
                                        if check_mag(itm):
                                            return True
                                    for sub in eq_item.get('subslots', [])or[]:
                                        try:
                                            curr = sub.get('current')
                                            if curr and isinstance(curr, dict):
                                                for itm in curr.get('items', [])or[]:
                                                    if check_mag(itm):
                                                        return True
                                        except Exception:
                                            pass
                                except Exception:
                                    pass

                            wpn = current_weapon_state.get('weapon')or {}
                            loaded_mag = wpn.get('loaded')
                            if check_mag(loaded_mag):
                                return True
                            return False
                        except Exception:
                            return False

                    has_nonfull = _inventory_has_nonfull_magazine()
                    has_nonempty = _inventory_has_nonempty_magazine()
                    enabled = has_nonfull or has_nonempty
                    try:
                        rb.configure(state = 'normal'if enabled else 'disabled')
                    except Exception:
                        try:
                            if not enabled:
                                rb.configure(state = 'disabled')
                            else:
                                rb.configure(state = 'normal')
                        except Exception:
                            pass
            except Exception:
                pass

        nvg_btn = None

        def _find_nvg_item():

            def _is_nvg(itm):
                try:
                    if not itm or not isinstance(itm, dict):
                        return False
                    iid = itm.get("id")
                    if iid is not None and str(iid)=="98":
                        return True
                    if itm.get("night_vision"):
                        return True
                    name = itm.get("name")or ""
                    if isinstance(name, str)and "night"in name.lower()and "vision"in name.lower():
                        return True
                except Exception:
                    pass
                return False

            try:

                for itm in save_data.get("hands", {}).get("items", []):
                    try:
                        if _is_nvg(itm):
                            return itm
                    except Exception:
                        pass

                for slot_name, eq in save_data.get("equipment", {}).items():
                    try:
                        if not eq:
                            continue
                        if "items"in eq and isinstance(eq["items"], list):
                            for itm in eq["items"]:
                                try:
                                    if _is_nvg(itm):
                                        return itm
                                except Exception:
                                    pass

                        if "subslots"in eq:
                            for sub in eq.get("subslots", []):
                                try:
                                    curr = sub.get("current")if isinstance(sub, dict)else None

                                    try:
                                        if _is_nvg(curr):
                                            return curr
                                    except Exception:
                                        pass

                                    if curr and "items"in curr and isinstance(curr["items"], list):
                                        for itm in curr["items"]:
                                            try:
                                                if _is_nvg(itm):
                                                    return itm
                                            except Exception:
                                                pass

                                    try:
                                        nested = curr
                                        depth = 0
                                        while isinstance(nested, dict)and depth <4:
                                            nested = nested.get("current")
                                            if _is_nvg(nested):
                                                return nested
                                            depth +=1
                                    except Exception:
                                        pass
                                except Exception:
                                    pass
                    except Exception:
                        pass

                try:
                    for acc in current_weapon.get("accessories", [])or[]:
                        try:
                            cur = acc.get("current")
                            if _is_nvg(cur):
                                return cur

                            if isinstance(cur, dict)and "items"in cur and isinstance(cur["items"], list):
                                for itm in cur["items"]:
                                    try:
                                        if _is_nvg(itm):
                                            return itm
                                    except Exception:
                                        pass
                        except Exception:
                            pass
                except Exception:
                    pass
            except Exception:
                pass
            return None

        def _update_nvg_button():

            try:
                has = _find_nvg_item()is not None
                active = bool(combat_state.get("nvg_active"))
                if nvg_btn is None:
                    return
                if not has:
                    try:
                        nvg_btn.configure(state = "disabled", fg_color = None)
                    except Exception:
                        nvg_btn.configure(state = "disabled")
                    return

                try:
                    nvg_btn.configure(state = "normal")
                    if active:
                        nvg_btn.configure(fg_color = "#228B22", hover_color = "#2E8B57")
                    else:
                        nvg_btn.configure(fg_color = "#444444", hover_color = "#666666")
                except Exception:
                    pass
            except Exception:
                pass

        actions_outer_frame = customtkinter.CTkFrame(main_frame)
        actions_outer_frame.pack(fill = "x", pady =(0, 20))

        actions_frame = customtkinter.CTkScrollableFrame(actions_outer_frame, orientation = "horizontal", height = 280, fg_color = "transparent")
        actions_frame.pack(fill = "x", expand = True)

        rounds_label_frame = customtkinter.CTkFrame(actions_frame)
        rounds_label_frame.pack(fill = "x", padx = 10, pady = 5)

        customtkinter.CTkLabel(
        rounds_label_frame,
        text = "Rounds to Fire:",
        font = customtkinter.CTkFont(size = 12)
        ).pack(side = "left", padx = 10)

        rounds_var = customtkinter.IntVar(value = 3)
        rounds_value_label = customtkinter.CTkLabel(
        rounds_label_frame,
        text = "3",
        font = customtkinter.CTkFont(size = 12, weight = "bold")
        )
        rounds_value_label.pack(side = "left", padx = 5)

        def update_rounds_label(val):

            try:
                iv = int(round(float(val)))
            except Exception:
                try:
                    iv = int(float(val))
                except Exception:
                    iv = 1
            rounds_value_label.configure(text = str(iv))
            try:

                rounds_slider.set(iv)
                rounds_var.set(iv)
            except Exception:
                pass

        def _compute_rounds_max_for_weapon(wpn, wpn_state = None):
            max_val = 10
            try:
                if not isinstance(wpn, dict):
                    return max_val
                try:
                    subtype = str(wpn.get("subtype", "")or "").lower()
                except Exception:
                    subtype = ""
                if subtype !="machine_gun":
                    return max_val
                total = 0
                try:
                    if wpn.get("chambered"):
                        total +=1
                except Exception:
                    pass
                try:
                    internal_rounds = wpn.get("rounds")or[]
                    if isinstance(internal_rounds, list):
                        total +=len(internal_rounds)
                except Exception:
                    pass
                try:
                    loaded = wpn.get("loaded")
                    if isinstance(loaded, dict):
                        lr = loaded.get("rounds")
                        if isinstance(lr, list):
                            total +=len(lr)
                        else:
                            cap = loaded.get("capacity")
                            if cap:
                                try:
                                    total +=int(cap)
                                except Exception:
                                    pass
                except Exception:
                    pass
                if total >0:
                    max_val = max(max_val, total)
            except Exception:
                pass
            return max_val

        def _apply_rounds_max(max_slider_local):
            try:
                rounds_slider.configure(to = max_slider_local)
            except Exception:
                try:
                    rounds_slider.config(to = max_slider_local)
                except Exception:
                    pass
            try:
                cur = int(rounds_var.get()or 1)
                if cur >max_slider_local:
                    rounds_var.set(max_slider_local)
                    rounds_slider.set(max_slider_local)
                    rounds_value_label.configure(text = str(max_slider_local))
            except Exception:
                pass

        max_slider = _compute_rounds_max_for_weapon(current_weapon, current_weapon_state)

        rounds_slider = customtkinter.CTkSlider(
        rounds_label_frame,
        from_ = 1,
        to = max_slider,
        variable = rounds_var,
        command = update_rounds_label,
        width = 200
        )
        rounds_slider.pack(side = "left", padx = 10, expand = True, fill = "x")

        firemode_label_frame = customtkinter.CTkFrame(actions_frame)
        firemode_label_frame.pack(side = "left", padx = 10, pady = 10)

        customtkinter.CTkLabel(
        firemode_label_frame,
        text = "Fire Mode:",
        font = customtkinter.CTkFont(size = 12)
        ).pack(side = "top", padx = 5, pady = 2)

        raw_modes = current_weapon.get("action", ["Semi"])or["Semi"]
        supported_modes =[]
        for m in raw_modes:
            try:
                if isinstance(m, str):
                    supported_modes.append(m.title())
                else:
                    supported_modes.append(str(m))
            except Exception:
                pass
        if not supported_modes:
            supported_modes =["Semi"]

        selected_modes = combat_state.setdefault("selected_firemode", {})
        weapon_id = str(current_weapon.get("id"))
        initial_mode = selected_modes.get(weapon_id, supported_modes[0])
        if initial_mode not in supported_modes:
            initial_mode = supported_modes[0]

        mode_angles = {
        "Safe":0,
        "Semi":90,
        "Auto":180,
        "Burst":270,
        "Bolt":315,
        "Single":135,
        "Double":225,
        "Pump":45
        }

        firemode_var = customtkinter.StringVar(value = initial_mode)

        def play_fireselector_sound():
            self._safe_sound_play("firearms/universal", "fireselector")

        def on_firemode_change(new_mode):
            selected_modes[weapon_id]= new_mode
            play_fireselector_sound()

        dial_canvas = customtkinter.CTkCanvas(
        firemode_label_frame,
        width = 140,
        height = 140,
        bg = "#212121",
        highlightthickness = 0
        )
        dial_canvas.pack(side = "top", padx = 5, pady = 5)

        dial_state = {"current_angle":mode_angles.get(initial_mode, 90), "dragging":False}

        def draw_dial():
            dial_canvas.delete("all")
            center_x, center_y = 70, 70
            radius = 35

            dial_canvas.create_oval(
            center_x -radius, center_y -radius,
            center_x +radius, center_y +radius,
            fill = "#333333", outline = "#555555", width = 2
            )

            labels = {
            0:"SAFE",
            45:"PUMP",
            90:"SEMI",
            135:"SINGLE",
            180:"AUTO",
            225:"DOUBLE",
            270:"BURST",
            315:"BOLT"
            }

            for mode, angle in mode_angles.items():
                if mode not in supported_modes:
                    continue
                rad = math.radians(angle)

                x1 = center_x +(radius -8)*math.cos(rad)
                y1 = center_y +(radius -8)*math.sin(rad)
                x2 = center_x +radius *math.cos(rad)
                y2 = center_y +radius *math.sin(rad)
                dial_canvas.create_line(x1, y1, x2, y2, fill = "#888888", width = 3)

                label_dist = radius +14
                label_x = center_x +label_dist *math.cos(rad)
                label_y = center_y +label_dist *math.sin(rad)
                dial_canvas.create_text(
                label_x, label_y,
                text = labels.get(angle, mode),
                fill = "#AAAAAA",
                font =("Arial", 9, "bold")
                )

            current_angle = dial_state["current_angle"]
            rad = math.radians(current_angle)
            pointer_x = center_x +28 *math.cos(rad)
            pointer_y = center_y +28 *math.sin(rad)
            dial_canvas.create_line(center_x, center_y, pointer_x, pointer_y, fill = "#FF4444", width = 4)

            knob_radius = 6
            dial_canvas.create_oval(
            center_x -knob_radius, center_y -knob_radius,
            center_x +knob_radius, center_y +knob_radius,
            fill = "#FF4444", outline = "#FFFFFF", width = 2
            )

            dial_canvas.create_text(
            center_x, 10,
            text = firemode_var.get(),
            fill = "#00FF00",
            font =("Arial", 11, "bold")
            )

        def get_angle_from_point(x, y):

            center_x, center_y = 70, 70
            dx = x -center_x
            dy = y -center_y
            angle = math.degrees(math.atan2(dy, dx))%360
            return angle

        def snap_to_nearest_mode(angle):

            best_mode = None
            best_diff = 360

            for mode, mode_angle in mode_angles.items():
                if mode not in supported_modes:
                    continue
                diff = min(abs(angle -mode_angle), 360 -abs(angle -mode_angle))
                if diff <best_diff:
                    best_diff = diff
                    best_mode = mode

            return best_mode, mode_angles.get(best_mode or "", angle)

        def on_mouse_down(event):
            center_x, center_y = 70, 70
            dx = event.x -center_x
            dy = event.y -center_y
            distance = math.sqrt(dx **2 +dy **2)

            if distance <40:
                dial_state["dragging"]= True

        def on_mouse_move(event):
            if not dial_state["dragging"]:
                return

            angle = get_angle_from_point(event.x, event.y)
            dial_state["current_angle"]= angle
            draw_dial()

        def on_mouse_up(event):
            if not dial_state["dragging"]:
                return

            dial_state["dragging"]= False

            best_mode, snapped_angle = snap_to_nearest_mode(dial_state["current_angle"])
            if best_mode:
                dial_state["current_angle"]= snapped_angle
                firemode_var.set(best_mode)
                on_firemode_change(best_mode)
                draw_dial()

        dial_canvas.bind("<Button-1>", on_mouse_down)
        dial_canvas.bind("<B1-Motion>", on_mouse_move)
        dial_canvas.bind("<ButtonRelease-1>", on_mouse_up)

        if len(supported_modes)==1:
            dial_canvas.configure(state = "disabled")

        draw_dial()

        attach_mode_frame = customtkinter.CTkFrame(actions_frame)
        attach_mode_frame.pack(side = "left", padx = 10, pady = 10)

        customtkinter.CTkLabel(
        attach_mode_frame,
        text = "Attachment Mode:",
        font = customtkinter.CTkFont(size = 12)
        ).pack(side = "top", padx = 5, pady = 2)

        attach_canvas = customtkinter.CTkCanvas(
        attach_mode_frame,
        width = 140,
        height = 140,
        bg = "#212121",
        highlightthickness = 0
        )
        attach_canvas.pack(side = "top", padx = 5, pady = 5)

        acc_with_modes = None
        acc_modes =[]
        acc_slot_ref = None
        attachments_with_modes =[]
        for ai, acc in enumerate(current_weapon.get("accessories", [])or[]):
            cur = acc.get("current")
            if cur and isinstance(cur, dict)and isinstance(cur.get("modes"), list)and cur.get("modes"):

                display = str(cur.get('name', 'Attachment'))
                attachments_with_modes.append((ai, acc, display))

        attach_select_var = customtkinter.StringVar(value = "")
        def _update_attachment_selection(choice):
            nonlocal acc_with_modes, acc_modes, acc_slot_ref, attachments_with_modes

            attachments_with_modes =[]
            for ai, acc in enumerate(current_weapon.get("accessories", [])or[]):
                cur = acc.get("current")
                if cur and isinstance(cur, dict)and isinstance(cur.get("modes"), list)and cur.get("modes"):
                    display = str(cur.get('name', 'Attachment'))
                    attachments_with_modes.append((ai, acc, display))

            try:
                new_names =[disp for(_ai, _acc, disp)in attachments_with_modes]
                if hasattr(attach_mode_frame, 'mode_option')and attach_mode_frame.mode_option:
                    try:
                        attach_mode_frame.mode_option.configure(values = new_names)
                    except Exception:
                        pass
                if 'attach_select'in locals()or 'attach_select'in globals():
                    try:
                        attach_select.configure(values = new_names)
                    except Exception:
                        pass
            except Exception:
                logging.exception("Failed to refresh attachment option menu values")

            sel = None
            for ai, acc, disp in attachments_with_modes:
                if disp ==choice:
                    sel =(ai, acc)
                    break
            if sel is None:
                acc_with_modes = None
                acc_modes =[]
                acc_slot_ref = None
            else:
                acc_with_modes = sel[1]
                cur =(acc_with_modes.get("current")if isinstance(acc_with_modes, dict)else None)or {}
                orig_modes = cur.get("modes")or[]

                try:
                    cleaned =[m for m in orig_modes if not(isinstance(m, dict)and m.get("mode_method")is not None and not m.get("name"))]
                except Exception:
                    cleaned = orig_modes

                try:
                    if acc_with_modes.get("_mode_index")is None:
                        acc_with_modes["_mode_index"]= 0
                    else:
                        old_idx = int(acc_with_modes.get("_mode_index")or 0)
                        if 0 <=old_idx <len(orig_modes):
                            try:
                                elem = orig_modes[old_idx]
                                if elem in cleaned:
                                    acc_with_modes["_mode_index"]= int(cleaned.index(elem))
                                else:
                                    acc_with_modes["_mode_index"]= 0
                            except Exception:
                                acc_with_modes["_mode_index"]= 0
                except Exception:
                    try:
                        acc_with_modes["_mode_index"]= int(acc_with_modes.get("_mode_index")or 0)
                    except Exception:
                        acc_with_modes["_mode_index"]= 0

                acc_modes = cleaned
                acc_slot_ref = acc_with_modes

                try:
                    if acc_modes:
                        idx = int(acc_with_modes.get("_mode_index")or 0)
                        idx = max(0, min(idx, len(acc_modes)-1))
                        mode_obj = acc_modes[idx]
                        pos_deg = mode_obj.get("position")if isinstance(mode_obj, dict)else None
                        if pos_deg is None:
                            pos_deg =(idx *(360.0 /max(1, len(acc_modes))))
                        try:
                            attach_state["current_angle"]= float(pos_deg)
                        except Exception:
                            pass
                except Exception:
                    pass

                _refresh_mode_controls()
            draw_attach_dial()

        attach_names =[disp for(_ai, _acc, disp)in attachments_with_modes]
        if attach_names:
            attach_select = customtkinter.CTkOptionMenu(attach_mode_frame, values = attach_names, variable = attach_select_var, command = _update_attachment_selection)
            attach_select.pack(side = "top", padx = 5, pady =(2, 4))

            attach_select_var.set(attach_names[0])
        else:

            customtkinter.CTkLabel(attach_mode_frame, text = "No attachment selected", font = customtkinter.CTkFont(size = 10), text_color = "#888888").pack(side = "top", padx = 5, pady =(2, 4))

        attach_mode_var = customtkinter.StringVar(value = "")
        attach_mode_slider = None

        def _refresh_mode_controls():
            nonlocal attach_mode_slider

            visible_modes =[]
            mode_index_map =[]
            for mi, mode in enumerate(acc_modes):
                if isinstance(mode, dict)and mode.get("mode_method")is not None and not mode.get("name"):

                    continue

                visible_modes.append(mode)
                mode_index_map.append(mi)
            mode_names =[]
            for vmi, mode in enumerate(visible_modes):
                if isinstance(mode, dict):
                    mode_names.append(mode.get("name", f"Mode {vmi}"))
                else:
                    mode_names.append(str(mode))

            mode_method = None
            try:

                cur =(acc_with_modes.get("current")if acc_with_modes else None)or {}
                mode_method = cur.get("mode_method")
                if not mode_method and acc_with_modes and isinstance(acc_with_modes, dict):
                    mode_method = acc_with_modes.get("mode_method")
                if not mode_method and acc_slot_ref and isinstance(acc_slot_ref, dict):
                    mode_method = acc_slot_ref.get("mode_method")

                if not mode_method:
                    for m in acc_modes:
                        if isinstance(m, dict)and m.get("mode_method"):
                            mode_method = m.get("mode_method")
                            break
            except Exception:
                mode_method = None

            if not mode_method:
                has_position = any(isinstance(m, dict)and m.get("position")is not None for m in acc_modes)
                mode_method = "dial"if has_position else "option"

            try:

                if mode_method =="option":
                    if hasattr(attach_mode_frame, 'mode_option'):
                        try:
                            attach_mode_frame.mode_option.configure(values = mode_names)
                            attach_mode_frame.mode_option.pack(side = "top", padx = 5, pady =(2, 4))
                        except Exception:
                            pass
                    else:
                        attach_mode_frame.mode_option = customtkinter.CTkOptionMenu(attach_mode_frame, values = mode_names, variable = attach_mode_var, command = lambda v:_set_mode_by_name(v))
                        attach_mode_frame.mode_option.pack(side = "top", padx = 5, pady =(2, 4))
                else:

                    if hasattr(attach_mode_frame, 'mode_option'):
                        try:
                            attach_mode_frame.mode_option.pack_forget()
                        except Exception:
                            pass
            except Exception:
                logging.exception("Failed to refresh mode option menu")

            try:

                if mode_method =="slider":

                    if hasattr(attach_mode_frame, 'mode_slider')and attach_mode_frame.mode_slider:
                        try:
                            attach_mode_frame.mode_slider.configure(from_ = 0, to = max(0, len(visible_modes)-1), number_of_steps = max(1, len(visible_modes)-1))
                            attach_mode_frame.mode_slider.pack(side = "top", padx = 5, pady =(2, 6), fill = "x")
                        except Exception:
                            pass
                    else:
                        attach_mode_frame.mode_slider = customtkinter.CTkSlider(attach_mode_frame, from_ = 0, to = max(0, len(visible_modes)-1), number_of_steps = max(1, len(visible_modes)-1), command = lambda v:_set_mode_by_index(round(float(v))))
                        attach_mode_frame.mode_slider.pack(side = "top", padx = 5, pady =(2, 6), fill = "x")
                else:

                    if hasattr(attach_mode_frame, 'mode_slider')and attach_mode_frame.mode_slider:
                        try:
                            attach_mode_frame.mode_slider.pack_forget()
                        except Exception:
                            pass
            except Exception:
                logging.exception("Failed to refresh mode slider")

            if acc_with_modes and acc_modes:
                actual_mi = int(acc_with_modes.get("_mode_index")or 0)

                try:
                    vis_index = mode_index_map.index(actual_mi)if actual_mi in mode_index_map else 0
                except Exception:
                    vis_index = 0
                try:
                    attach_mode_var.set(mode_names[vis_index]if mode_names else "")
                except Exception:
                    attach_mode_var.set(mode_names[0]if mode_names else "")
                try:
                    attach_mode_frame.mode_slider.set(vis_index)
                except Exception:
                    pass

            attach_mode_frame._visible_modes = visible_modes
            attach_mode_frame._mode_index_map = mode_index_map

            try:
                if not hasattr(attach_mode_frame, 'mode_label')or attach_mode_frame.mode_label is None:
                    attach_mode_frame.mode_label = customtkinter.CTkLabel(attach_mode_frame, text = "", font = customtkinter.CTkFont(size = 12, weight = "bold"), text_color = "#44AAFF")
            except Exception:
                attach_mode_frame.mode_label = None

            try:
                ml = getattr(attach_mode_frame, 'mode_label', None)
                current_mode_name = ""
                try:
                    if acc_with_modes and acc_modes:
                        actual_mi = int(acc_with_modes.get("_mode_index")or 0)
                        actual_mi = max(0, min(actual_mi, len(acc_modes)-1))
                        mode_obj = acc_modes[actual_mi]
                        current_mode_name = mode_obj.get("name")if isinstance(mode_obj, dict)else str(mode_obj)
                except Exception:
                    current_mode_name = ""
                if ml:
                    try:
                        ml.configure(text = current_mode_name)
                    except Exception:
                        pass
                    try:
                        if mode_method in("slider", "option"):
                            ml.pack(side = "top", padx = 5, pady =(0, 6))
                        else:
                            ml.pack_forget()
                    except Exception:
                        pass
            except Exception:
                pass

            try:
                if mode_method =="dial":
                    try:
                        attach_canvas.pack(side = "top", padx = 5, pady = 5)
                    except Exception:
                        pass

                    attach_canvas.configure(state = "normal")
                else:
                    try:
                        attach_canvas.pack_forget()
                    except Exception:
                        pass
            except Exception:
                logging.exception("Failed to adjust attach canvas visibility")

        def _set_mode_by_name(name):
            if not acc_with_modes or not acc_modes:
                return

            vis = getattr(attach_mode_frame, '_visible_modes', None)
            map_ = getattr(attach_mode_frame, '_mode_index_map', None)
            if vis is not None and map_ is not None:
                for vmi, mode in enumerate(vis):
                    mode_name = mode.get("name")if isinstance(mode, dict)else str(mode)
                    if mode_name ==name:

                        actual = map_[vmi]
                        _set_mode_by_index(actual)
                        return

            for mi, mode in enumerate(acc_modes):
                mode_name = mode.get("name")if isinstance(mode, dict)else str(mode)
                if mode_name ==name:
                    _set_mode_by_index(mi)
                    return

        def _set_mode_by_index(idx):
            if not acc_with_modes or not acc_modes:
                return

            try:
                map_ = getattr(attach_mode_frame, '_mode_index_map', None)
                if map_ is not None and 0 <=int(idx)<len(map_):
                    actual_idx = int(map_[int(idx)])
                else:
                    actual_idx = int(idx)
            except Exception:
                actual_idx = 0
            try:
                old_index = acc_with_modes.get("_mode_index")
            except Exception:
                old_index = None
            try:
                acc_with_modes["_mode_index"]= int(actual_idx)
            except Exception:
                acc_with_modes["_mode_index"]= 0

            try:
                new_index = acc_with_modes.get("_mode_index")
                if new_index !=old_index:
                    self._safe_sound_play("firearms/universal", "fireselector")
            except Exception:
                pass
            try:
                self._apply_item_overrides(current_weapon)
            except Exception:
                logging.exception("Failed to apply overrides after attachment mode change")

            _refresh_mode_controls()

            try:
                mi = int(acc_with_modes.get("_mode_index")or 0)
                pos_deg = acc_modes[mi].get("position")if isinstance(acc_modes[mi], dict)and acc_modes[mi].get("position")is not None else(mi *(360.0 /max(1, len(acc_modes))))
                attach_state["current_angle"]= float(pos_deg)# type: ignore
            except Exception:
                pass

            try:
                ml = getattr(attach_mode_frame, 'mode_label', None)
                if ml:
                    try:
                        mode_obj = acc_modes[int(acc_with_modes.get("_mode_index")or 0)]
                        mname = mode_obj.get("name")if isinstance(mode_obj, dict)else str(mode_obj)
                    except Exception:
                        mname = ""
                    try:
                        ml.configure(text = mname)
                    except Exception:
                        pass
            except Exception:
                pass
            draw_attach_dial()

        attach_state = {"current_angle":90, "dragging":False}

        def draw_attach_dial():
            attach_canvas.delete("all")
            center_x, center_y = 70, 70
            radius = 35
            attach_canvas.create_oval(
            center_x -radius, center_y -radius,
            center_x +radius, center_y +radius,
            fill = "#333333", outline = "#555555", width = 2
            )

            if not acc_modes:
                attach_canvas.create_text(center_x, center_y, text = "No Modes", fill = "#AAAAAA", font =("Arial", 10))
                return

            for mi, mode in enumerate(acc_modes):
                try:
                    pos_deg = None
                    if isinstance(mode, dict):
                        pos_deg = mode.get("position")
                    if pos_deg is None:
                        pos_deg =(mi *(360.0 /max(1, len(acc_modes))))
                    rad = math.radians(float(pos_deg))
                    x1 = center_x +(radius -8)*math.cos(rad)
                    y1 = center_y +(radius -8)*math.sin(rad)
                    x2 = center_x +radius *math.cos(rad)
                    y2 = center_y +radius *math.sin(rad)
                    attach_canvas.create_line(x1, y1, x2, y2, fill = "#888888", width = 3)

                    label_dist = radius +12
                    label_x = center_x +label_dist *math.cos(rad)
                    label_y = center_y +label_dist *math.sin(rad)
                    label_text = mode.get("name", f"Mode {mi}")if isinstance(mode, dict)else str(mode)
                    attach_canvas.create_text(label_x, label_y, text = label_text.upper(), fill = "#AAAAAA", font =("Arial", 9, "bold"))
                except Exception:
                    logging.exception("draw_attach_dial tick failed")

            current_angle = attach_state["current_angle"]
            rad = math.radians(current_angle)
            pointer_x = center_x +28 *math.cos(rad)
            pointer_y = center_y +28 *math.sin(rad)
            attach_canvas.create_line(center_x, center_y, pointer_x, pointer_y, fill = "#44AAFF", width = 4)
            knob_radius = 6
            attach_canvas.create_oval(
            center_x -knob_radius, center_y -knob_radius,
            center_x +knob_radius, center_y +knob_radius,
            fill = "#44AAFF", outline = "#FFFFFF", width = 2
            )

            if acc_with_modes and isinstance(acc_with_modes.get("current"), dict):
                mode_idx = acc_with_modes.get("_mode_index")
                try:
                    mode_idx = int(mode_idx)if mode_idx is not None else 0
                except Exception:
                    mode_idx = 0
                mode_idx = max(0, min(mode_idx, len(acc_modes)-1))
                mode_name = acc_modes[mode_idx].get("name", "Mode")if isinstance(acc_modes[mode_idx], dict)else str(acc_modes[mode_idx])
            else:
                mode_name = "None"

            attach_canvas.create_text(70, 10, text = mode_name, fill = "#00FF00", font =("Arial", 11, "bold"))

        def get_attach_angle_from_point(x, y):
            center_x, center_y = 70, 70
            dx = x -center_x
            dy = y -center_y
            angle = math.degrees(math.atan2(dy, dx))%360
            return angle

        def snap_attach_to_nearest(angle):
            if not acc_modes:
                return None, angle
            best_idx = 0
            best_diff = 360
            for mi, mode in enumerate(acc_modes):
                try:
                    pos_deg = mode.get("position")if isinstance(mode, dict)else None
                    if pos_deg is None:
                        pos_deg =(mi *(360.0 /max(1, len(acc_modes))))
                    md = float(pos_deg)
                    diff = min(abs(angle -md), 360 -abs(angle -md))
                    if diff <best_diff:
                        best_diff = diff
                        best_idx = mi
                except Exception:
                    pass
            chosen_angle = acc_modes[best_idx].get("position")if isinstance(acc_modes[best_idx], dict)and acc_modes[best_idx].get("position")is not None else(best_idx *(360.0 /max(1, len(acc_modes))))
            return best_idx, float(chosen_angle)# type: ignore

        def attach_on_mouse_down(event):
            center_x, center_y = 70, 70
            dx = event.x -center_x
            dy = event.y -center_y
            distance = math.sqrt(dx **2 +dy **2)
            if distance <40:
                attach_state["dragging"]= True

        def attach_on_mouse_move(event):
            if not attach_state["dragging"]:
                return
            angle = get_attach_angle_from_point(event.x, event.y)
            attach_state["current_angle"]= angle
            draw_attach_dial()

        def attach_on_mouse_up(event):
            if not attach_state["dragging"]:
                return
            attach_state["dragging"]= False
            if not acc_modes:
                return
            idx, snapped = snap_attach_to_nearest(attach_state["current_angle"])
            if idx is None:
                return
            attach_state["current_angle"]= snapped

            try:
                old_index = acc_with_modes.get("_mode_index")
            except Exception:
                old_index = None
            try:
                acc_with_modes["_mode_index"]= int(idx)
            except Exception:
                acc_with_modes["_mode_index"]= 0

            try:
                new_index = acc_with_modes.get("_mode_index")
                if new_index !=old_index:
                    self._safe_sound_play("firearms/universal", "fireselector")
            except Exception:
                pass
            try:
                self._apply_item_overrides(current_weapon)
            except Exception:
                logging.exception("Failed to apply overrides after attachment mode change")

            try:
                ml = getattr(attach_mode_frame, 'mode_label', None)
                if ml:
                    try:
                        mode_obj = acc_modes[int(acc_with_modes.get("_mode_index")or 0)]
                        mname = mode_obj.get("name")if isinstance(mode_obj, dict)else str(mode_obj)
                    except Exception:
                        mname = ""
                    try:
                        ml.configure(text = mname)
                    except Exception:
                        pass
            except Exception:
                pass
            draw_attach_dial()

        attach_canvas.bind("<Button-1>", attach_on_mouse_down)
        attach_canvas.bind("<B1-Motion>", attach_on_mouse_move)
        attach_canvas.bind("<ButtonRelease-1>", attach_on_mouse_up)

        if not acc_modes:
            attach_canvas.configure(state = "disabled")

        try:
            if attach_names:
                _update_attachment_selection(attach_names[0])
        except Exception:
            logging.exception("Initial attachment selection failed")

        draw_attach_dial()

        def fire_weapon():
            wpn = current_weapon_state["weapon"]

            try:
                magicsys_local = str(wpn.get("magicsoundsystem")or "").lower()
                is_magic_local =(str(wpn.get("type")or "").lower()=="magic")or(magicsys_local in("hg", "at", "mg", "rf"))
                if is_magic_local:
                    weapon_id_local = str(wpn.get("id"))
                    temp_local = combat_state.get("barrel_temperatures", {}).get(weapon_id_local, combat_state.get("ambient_temperature", 70))
                    overheat_thresh = float(wpn.get("overheat_temp", wpn.get("shutdown_temp", 600)or 600))
                    if temp_local >=overheat_thresh:
                        try:
                            self._popup_show_info("Overheated", "Weapon is overheated and cannot fire.Wait for cooling.")
                        except Exception:
                            pass
                        return
            except Exception:
                pass
            rounds_to_fire = rounds_var.get()
            logging.info(
            "Fire button pressed: weapon=%s, rounds=%s, mode=%s",
            wpn.get("name", "Unknown"),
            rounds_to_fire,
            firemode_var.get()
            )

            def _do_fire():
                try:
                    res = self._fire_weapon(wpn, combat_state, rounds_to_fire, firemode_var.get(), save_data)
                    logging.info("Fire result(background): %s", res)
                    try:

                        self.root.after(0, lambda:self._popup_show_info("Fire Result", res))
                        self.root.after(0, update_weapon_view)
                    except Exception:
                        pass
                except Exception as e:
                    logging.exception("Fire action failed(background): %s", e)
                    try:
                        self.root.after(0, lambda:self._popup_show_info("Fire Error", str(e)))
                    except Exception:
                        pass
                finally:
                    try:
                        fb = current_weapon_state.get('fire_button_ref')
                        if fb:
                            try:
                                self.root.after(0, lambda:(fb.configure(state = 'normal')))
                                self.root.after(0, lambda:fb.configure(text =(current_weapon_state.get('fire_button_orig_text')or "Fire")))
                            except Exception:
                                pass
                    except Exception:
                        pass

            try:
                fb = current_weapon_state.get('fire_button_ref')
                if fb:
                    try:
                        fb.configure(state = 'disabled')
                        fb.configure(text = "Firing...")
                    except Exception:
                        pass
            except Exception:
                pass

            try:
                t = threading.Thread(target = _do_fire, name = "CombatFireThread", daemon = True)
                t.start()
            except Exception:

                try:
                    result = self._fire_weapon(wpn, combat_state, rounds_to_fire, firemode_var.get(), save_data)
                    logging.info("Fire result(sync fallback): %s", result)
                    self._popup_show_info("Fire Result", result)
                except Exception as e:
                    logging.exception("Fire action failed: %s", e)
                    self._popup_show_info("Fire Error", str(e))
                update_weapon_view()

        def reload_weapon():
            wpn = current_weapon_state["weapon"]
            logging.info("Reload requested for %s", wpn.get("name", "Unknown"))
            magazine_system = wpn.get("magazinesystem")
            magazine_type = wpn.get("magazinetype", "").lower()

            pf = None
            try:
                pf = wpn.get("platform")or wpn.get("underbarrel_platform")
            except Exception:
                pf = None
            if wpn.get("underbarrel_weapon")or(pf and pf in getattr(self, "PLATFORM_DEFAULTS", {})):
                result = self._reload_weapon(wpn, save_data)
                self._popup_show_info("Reload Result", result)
                update_weapon_view()
                return

            if wpn.get("infinite_ammo"):
                result = self._reload_weapon(wpn, save_data)
                self._popup_show_info("Reload Result", result)
                update_weapon_view()
                return

            if "internal"in magazine_type or "revolver"in wpn.get("platform", "").lower()or "cylinder"in magazine_type:
                result = self._reload_weapon(wpn, save_data)
                self._popup_show_info("Reload Result", result)
                update_weapon_view()
                return

            if not magazine_system:
                inferred_ms = None
                if wpn.get("magazinetype"):
                    inferred_ms = wpn.get("magazinetype")
                else:
                    loaded_mag = wpn.get("loaded")
                    if isinstance(loaded_mag, dict)and loaded_mag.get("magazinesystem"):
                        inferred_ms = loaded_mag.get("magazinesystem")
                    else:

                        for item in save_data.get("hands", {}).get("items", []):
                            if item and isinstance(item, dict)and("rounds"in item or "capacity"in item):
                                inferred_ms = item.get("magazinesystem")or item.get("magazinetype")
                                if inferred_ms:
                                    break
                        if not inferred_ms:
                            for slot_name, eq_item in save_data.get("equipment", {}).items():
                                if eq_item and isinstance(eq_item, dict):
                                    if "items"in eq_item and isinstance(eq_item["items"], list):
                                        for mag in eq_item["items"]:
                                            if mag and isinstance(mag, dict)and("rounds"in mag or "capacity"in mag):
                                                inferred_ms = mag.get("magazinesystem")or mag.get("magazinetype")
                                                break
                                    if inferred_ms:
                                        break
                if inferred_ms:

                    wpn["magazinesystem"]= inferred_ms

            self._show_magazine_selection_menu(wpn, save_data, table_data, current_weapon_state, update_weapon_view)

        def clean_weapon():
            wpn = current_weapon_state["weapon"]
            logging.info("Clean requested for %s", wpn.get("name", "Unknown"))
            result = self._clean_weapon(wpn, combat_state)
            self._popup_show_info("Clean Result", result)
            update_weapon_view()

        def on_spacebar(event):
            logging.debug("Spacebar pressed - firing")
            fire_weapon()

        self.root.bind("<space>", on_spacebar)

        reload_last_press_time =[0.0]
        reload_pending_id =[None]

        def on_r_press(event):

            current_time = time.time()
            time_since_last = current_time -reload_last_press_time[0]
            reload_last_press_time[0]= current_time

            if reload_pending_id[0]:
                self.root.after_cancel(reload_pending_id[0])
                reload_pending_id[0]= None

            if time_since_last <0.4:
                logging.debug("R double-tapped - auto-reload with drop")
                reload_auto_drop()
            else:

                try:
                    _rid = self.root.after(400, lambda:reload_weapon())
                    reload_pending_id[0]= _rid # type: ignore
                except Exception:
                    reload_pending_id[0]= None

        self.root.bind("r", on_r_press)
        self.root.bind("R", on_r_press)

        def reload_auto_drop():

            wpn = current_weapon_state["weapon"]

            if wpn.get("infinite_ammo"):
                result = self._reload_weapon(wpn, save_data)
                self._popup_show_info("Auto-Reload", result)
                update_weapon_view()
                return

            magazine_system = wpn.get("magazinesystem")
            if not magazine_system:
                self._popup_show_info("Auto-Reload", "Weapon doesn't use detachable magazines")
                return

            all_magazines =[]

            for item in save_data.get("hands", {}).get("items", []):
                if item and isinstance(item, dict)and item.get("magazinesystem")==magazine_system:
                    all_magazines.append(("hands", item))

            for slot_name, eq_item in save_data.get("equipment", {}).items():
                if eq_item and isinstance(eq_item, dict):
                    if "items"in eq_item and isinstance(eq_item["items"], list):
                        for item in eq_item["items"]:
                            if item and isinstance(item, dict)and item.get("magazinesystem")==magazine_system:
                                all_magazines.append(("equipment", item))
                    if "subslots"in eq_item:
                        for subslot in eq_item["subslots"]:
                            if subslot.get("current"):
                                curr = subslot["current"]
                                if "items"in curr and isinstance(curr["items"], list):
                                    for item in curr["items"]:
                                        if item and isinstance(item, dict)and item.get("magazinesystem")==magazine_system:
                                            all_magazines.append(("equipment", item))

            if not all_magazines:
                self._popup_show_info("Auto-Reload", "No compatible magazines in inventory!")
                return

            best_mag_idx = 0
            best_round_count = len(all_magazines[0][1].get("rounds", []))

            for idx, (location, mag_item)in enumerate(all_magazines):
                round_count = len(mag_item.get("rounds", []))
                if round_count >best_round_count:
                    best_round_count = round_count
                    best_mag_idx = idx

            location, mag_item = all_magazines[best_mag_idx]

            current_mag = wpn.get("loaded")
            chambered = wpn.get("chambered")
            is_gun_empty = not chambered and(not current_mag or not current_mag.get("rounds", []))

            try:

                mag_type_current =((current_mag.get("magazinetype")if current_mag else None)or wpn.get("magazinetype")or "").lower()
                platform =(wpn.get("platform")or "").lower()
                is_belt =("belt"in mag_type_current)or("belt"in platform)or("m249"in platform)

                try:
                    logging.debug("reload_auto_drop: weapon=%s platform=%s magazinetype=%s current_mag_present=%s dualfeed=%s submagazinetype=%s submagazinesystem=%s is_belt=%s",
                    wpn.get("name", wpn.get("id", "unknown")),
                    platform,
                    mag_type_current,
                    bool(current_mag),
                    bool(wpn.get("dualfeed")),
                    wpn.get("submagazinetype"),
                    wpn.get("submagazinesystem"),
                    is_belt)
                except Exception:
                    pass

                handled_belt = False

                if current_mag and not("belt"in mag_type_current):

                    try:
                        self._play_weapon_action_sound(wpn, "magout")
                    except Exception:
                        pass

                    time.sleep(random.uniform(0.5, 1.0))

                    try:
                        magdrop_sound = f"magdrop{random.randint(0, 1)}"
                        self._safe_sound_play("", f"sounds/firearms/universal/{magdrop_sound}.ogg")
                    except Exception:
                        pass
                    time.sleep(random.uniform(0.5, 1.0))

                    try:
                        self._safe_sound_play("", "sounds/firearms/universal/pouchout.ogg")
                    except Exception:
                        pass
                    time.sleep(random.uniform(0.25, 0.5))

                    mag_type = wpn.get("magazinetype", "").lower()
                    platform_check = wpn.get("platform", "").lower()
                    if not any(k in mag_type for k in("internal", "tube", "cylinder"))and "revolver"not in platform_check:
                        try:
                            self._play_weapon_action_sound(wpn, "magin")
                        except Exception:
                            pass
                    time.sleep(random.uniform(0.25, 0.5))

                elif is_belt:

                    if wpn.get("dualfeed")and(wpn.get("submagazinesystem")or wpn.get("submagazinetype")):
                        try:
                            self._perform_dualfeed_belt_reload_sequence(wpn)
                        except Exception:
                            pass
                    else:
                        try:
                            self._perform_belt_reload_sequence(wpn)
                        except Exception:
                            pass
                    handled_belt = True

                else:

                    try:
                        self._safe_sound_play("", "sounds/firearms/universal/pouchout.ogg")
                    except Exception:
                        pass
                    time.sleep(0.8)

                if not handled_belt and is_gun_empty:
                    rt_mag_type = str(wpn.get("magazinetype", "")or "").lower()
                    rt_platform_raw = wpn.get("platform", "")or ""
                    if isinstance(rt_platform_raw, (list, tuple)):
                        rt_platform_raw = rt_platform_raw[0]if rt_platform_raw else ""
                    rt_platform = str(rt_platform_raw).lower()
                    rt_action_raw = wpn.get("action", "")or ""
                    if isinstance(rt_action_raw, (list, tuple)):
                        rt_action_raw = rt_action_raw[0]if rt_action_raw else ""
                    rt_action = str(rt_action_raw).lower()
                    is_pump_reload =("pump"in rt_platform or rt_action =="pump"or "pump"in rt_mag_type)

                    if is_pump_reload:
                        try:
                            self._play_weapon_action_sound(wpn, "pumpback", block = True)
                        except Exception:
                            pass
                        try:
                            self._play_weapon_action_sound(wpn, "pumpforward")
                        except Exception:
                            pass
                    elif not wpn.get("bolt_catch"):
                        try:
                            self._play_weapon_action_sound(wpn, "boltback", block = True)
                        except Exception:
                            pass

                        try:
                            self._play_weapon_action_sound(wpn, "boltforward")
                        except Exception:
                            pass
                    else:
                        try:
                            self._play_weapon_action_sound(wpn, "boltforward")
                        except Exception:
                            pass

                try:
                    mag_type =(wpn.get("magazinetype")or "").lower()
                    platform_check =(wpn.get("platform")or "").lower()
                    is_detachable_box =(not any(k in mag_type for k in("internal", "tube", "cylinder"))
                    and "revolver"not in platform_check
                    and "belt"not in mag_type and "belt"not in platform_check
                    and "m249"not in platform_check)
                except Exception:
                    is_detachable_box = True

                if is_detachable_box:

                    time.sleep(0.01)
                else:
                    time.sleep(0.75)
            except Exception as e:
                logging.error(f"reload_auto_drop sound sequence error: {e}")

            if current_mag:
                pass

            previous_chambered = wpn.get("chambered")
            wpn["loaded"]= mag_item

            if is_gun_empty and mag_item.get("rounds", []):

                try:
                    wpn["chambered"]= mag_item["rounds"].pop(0)
                except Exception:
                    wpn["chambered"]= None
            else:

                wpn["chambered"]= previous_chambered

            if location =="hands":
                if mag_item in save_data.get("hands", {}).get("items", []):
                    save_data["hands"]["items"].remove(mag_item)
            elif location =="equipment":

                try:
                    self._play_weapon_action_sound(wpn, "pouchout")
                except Exception:
                    pass
                for slot_name, eq_item in save_data.get("equipment", {}).items():
                    if eq_item:
                        if "items"in eq_item and isinstance(eq_item["items"], list):
                            if mag_item in eq_item["items"]:
                                eq_item["items"].remove(mag_item)
                        if "subslots"in eq_item:
                            for subslot in eq_item["subslots"]:
                                if subslot.get("current"):
                                    curr = subslot["current"]
                                    if "items"in curr and isinstance(curr["items"], list):
                                        if mag_item in curr["items"]:
                                            curr["items"].remove(mag_item)

            mag_name = mag_item.get("name", "magazine")
            rounds = len(mag_item.get("rounds", []))
            chambered_info = " +1 in chamber"if is_gun_empty and wpn.get("chambered")else ""
            self._popup_show_info("Auto-Reload", f"Loaded {mag_name}({rounds}{chambered_info} rounds)!")
            update_weapon_view()

        fire_btn = self._create_sound_button(
        actions_frame,
        text = "Fire(Press SPACE)",
        command = fire_weapon,
        width = 150,
        height = 50,
        font = customtkinter.CTkFont(size = 14)
        )
        fire_btn.pack(side = "left", padx = 10, pady = 10)

        try:
            current_weapon_state['fire_button_ref']= fire_btn
            current_weapon_state['fire_button_orig_text']= "Fire(Press SPACE)"
        except Exception:
            pass

        self._create_sound_button(
        actions_frame,
        text = "Reload(Press R)",
        command = reload_weapon,
        width = 150,
        height = 50,
        font = customtkinter.CTkFont(size = 14)
        ).pack(side = "left", padx = 10, pady = 10)

        self._create_sound_button(
        actions_frame,
        text = "Clean",
        command = clean_weapon,
        width = 150,
        height = 50,
        font = customtkinter.CTkFont(size = 14),
        fg_color = "#006400",
        hover_color = "#228B22"
        ).pack(side = "left", padx = 10, pady = 10)

        def cycle_bolt():
            wpn = current_weapon_state["weapon"]
            logging.info("Cycle bolt requested for %s", wpn.get("name", "Unknown"))
            result = self._cycle_bolt(wpn)
            self._popup_show_info("Cycle Action", result)
            update_weapon_view()

        # Cycle Action is exposed via the More Actions popup; toolbar button removed

        def _toggle_nvg():
            try:
                nvg_item = _find_nvg_item()
                if not nvg_item:
                    self._popup_show_info("NVG", "No night-vision goggles found in inventory.")
                    try:
                        nvg_btn.configure(state = "disabled")
                    except Exception:
                        pass
                    return
                active = bool(combat_state.get("nvg_active"))

                combat_state["nvg_active"]= not active

                try:
                    combat_state["nvg_item_id"]= int(nvg_item.get("id"))
                except Exception:
                    combat_state["nvg_item_id"]= nvg_item.get("id")

                try:
                    if combat_state["nvg_active"]:
                        self._safe_sound_play("misc/nvg", "on")
                    else:
                        self._safe_sound_play("misc/nvg", "off")
                except Exception:
                    pass

                try:
                    _update_nvg_button()
                except Exception:
                    pass
            except Exception:
                logging.exception("NVG toggle failed")

        try:
            nvg_btn = self._create_sound_button(actions_frame, "NVG", _toggle_nvg, width = 150, height = 50, font = customtkinter.CTkFont(size = 14))
            nvg_btn.pack(side = "left", padx = 10, pady = 10)
        except Exception:
            logging.exception("Failed to create NVG button")
        try:
            _update_nvg_button()
        except Exception:
            pass

        def cooling_tick():
            try:
                ambient_temp = combat_state.get("ambient_temperature", 70)
                temps = combat_state.setdefault("barrel_temperatures", {})
                magic_ids = list(combat_state.get("magic_weapon_ids", {}).keys())

                for mid in magic_ids:
                    try:
                        t = float(temps.get(mid, ambient_temp))
                        if t >ambient_temp:

                            drop = max(1.0, (t -ambient_temp)*0.18)
                            t = max(ambient_temp, t -drop)
                            temps[mid]= t
                    except Exception:
                        pass

                try:
                    w = current_weapon_state.get("weapon")
                    fb = current_weapon_state.get("fire_button_ref")
                    if fb and isinstance(fb, (customtkinter.CTkButton, )):
                        is_magic_w = False
                        try:
                            ms = str(w.get("magicsoundsystem")or "").lower()
                            is_magic_w =(str(w.get("type")or "").lower()=="magic")or(ms in("hg", "at", "mg", "rf"))
                        except Exception:
                            is_magic_w = False

                        if is_magic_w:
                            wid = str(w.get("id"))
                            tnow = temps.get(wid, ambient_temp)
                            overheat_thresh = float(w.get("overheat_temp", w.get("shutdown_temp", 600)or 600))
                            if tnow >=overheat_thresh:
                                try:
                                    fb.configure(state = "disabled")
                                    fb.configure(text =(current_weapon_state.get('fire_button_orig_text')or "Fire")+"(Overheated)")
                                except Exception:
                                    pass
                            else:
                                try:
                                    fb.configure(state = "normal")
                                    fb.configure(text = current_weapon_state.get('fire_button_orig_text')or "Fire")
                                except Exception:
                                    pass
                except Exception:
                    pass
            except Exception:
                logging.exception("cooling_tick failed")
            finally:
                try:
                    self.root.after(1000, cooling_tick)
                except Exception:
                    pass

        try:
            self.root.after(1000, cooling_tick)
        except Exception:
            pass

        def manage_attachments():
            wpn = current_weapon_state["weapon"]
            accessories = wpn.get("accessories", [])or[]
            if not accessories:
                self._popup_show_info("Attachments", "This weapon has no attachment slots.")
                return

            popup = customtkinter.CTkToplevel(self.root)
            popup.title("Attachments")
            popup.transient(self.root)
            self._center_popup_on_window(popup, 420, 400)

            rows =[]

            def candidates_for_slot(slot_req):
                matches =[]

                for itm in save_data.get("hands", {}).get("items", []):
                    if itm and isinstance(itm, dict)and itm.get("attachment"):
                        slot_field = itm.get("slot")
                        if slot_field ==slot_req or(isinstance(slot_field, list)and slot_req in slot_field):
                            matches.append(itm)

                for slot_name, eq_item in save_data.get("equipment", {}).items():
                    if eq_item and "items"in eq_item:
                        for itm in eq_item["items"]:
                            if itm and isinstance(itm, dict)and itm.get("attachment"):
                                slot_field = itm.get("slot")
                                if slot_field ==slot_req or(isinstance(slot_field, list)and slot_req in slot_field):
                                    matches.append(itm)
                return matches

            for acc in accessories:
                frame = customtkinter.CTkFrame(popup)
                frame.pack(fill = "x", padx = 10, pady = 6)
                customtkinter.CTkLabel(frame, text = acc.get("name", "Slot"), font = customtkinter.CTkFont(size = 12, weight = "bold")).pack(anchor = "w")
                opts =[(None, "None")]
                for itm in candidates_for_slot(acc.get("slot")):
                    label = itm.get("name", "Attachment")
                    opts.append((itm, label))

                cur = acc.get("current")
                current_label = "None"
                try:
                    if cur and isinstance(cur, dict):

                        found = False
                        cur_id = cur.get("id")
                        for itm, lbl in opts:
                            try:
                                if itm is cur:
                                    current_label = lbl
                                    found = True
                                    break
                                if isinstance(itm, dict)and cur_id is not None and itm.get("id")==cur_id:
                                    current_label = lbl
                                    found = True
                                    break
                            except Exception:
                                pass
                        if not found:

                            try:
                                installed_label = cur.get("name", "Installed")
                            except Exception:
                                installed_label = "Installed"
                            opts.append((cur, installed_label))# type: ignore
                            current_label = installed_label
                except Exception:
                    current_label = "None"

                current_choice = customtkinter.StringVar(value = current_label)
                option = customtkinter.CTkOptionMenu(frame, values =[o[1]for o in opts], variable = current_choice, width = 220)
                option.pack(anchor = "w", pady = 4)

                def _open_mode_dial_for(acc_ref):
                    try:

                        cur = acc_ref.get("current")
                        if not cur or not isinstance(cur, dict):
                            self._popup_show_info("Attachment Modes", "No attachment installed in this slot.")
                            return
                        modes = cur.get("modes")or[]
                        if not modes or not isinstance(modes, list):
                            self._popup_show_info("Attachment Modes", "This attachment has no selectable modes.")
                            return

                        import tkinter as tk

                        dial = customtkinter.CTkToplevel(self.root)
                        dial.title("Select Mode")
                        size = 320
                        dial.transient(self.root)
                        self._center_popup_on_window(dial, size, size)

                        canvas = tk.Canvas(dial, width = size, height = size, highlightthickness = 0)
                        canvas.pack(fill = "both", expand = True)

                        cx = size //2
                        cy = size //2
                        r = int(size *0.35)

                        canvas.create_oval(cx -r, cy -r, cx +r, cy +r, outline = "#888", width = 2)

                        for mi, mode in enumerate(modes):
                            try:
                                pos_deg = mode.get("position")if isinstance(mode, dict)else None
                                if pos_deg is None:
                                    pos_deg =(mi *(360.0 /max(1, len(modes))))
                                theta = math.radians(float(pos_deg))
                                mx = cx +int(r *math.cos(theta))
                                my = cy +int(r *math.sin(theta))
                                label = mode.get("name", f"Mode {mi}")if isinstance(mode, dict)else str(mode)

                                btn = customtkinter.CTkButton(dial, text = label, width = 110, command =(lambda idx = mi, a = acc_ref, d = dial:_set_mode_and_close(a, idx, d)))

                                canvas.create_window(mx, my, window = btn)
                            except Exception:
                                logging.exception("Failed to render mode button")

                        cur_index = acc_ref.get("_mode_index")
                        if cur_index is None:
                            cur_index = acc_ref.get("mode_index")or 0
                        try:
                            cur_index = int(cur_index)
                        except Exception:
                            cur_index = 0

                        def _set_mode_and_close(acc_set, idx_set, dial_win):
                            try:
                                acc_set["_mode_index"]= int(idx_set)
                            except Exception:
                                acc_set["_mode_index"]= 0
                            try:

                                self._apply_item_overrides(wpn)
                            except Exception:
                                logging.exception("Failed to apply overrides after mode change")
                            try:
                                dial_win.destroy()
                            except Exception:
                                pass

                    except Exception:
                        logging.exception("open_mode_dial failed")

                def _find_table_candidates(slot_req):
                    candidates =[]
                    try:
                        table_files = sorted(glob.glob(os.path.join('tables', f"*{global_variables.get('table_extension', '.sldtbl')}")))
                        for tf in table_files:
                            try:
                                with open(tf, 'r', encoding = 'utf-8')as tfh:
                                    td = json.load(tfh)
                                tables = td.get('tables', {})
                                for subname, items in tables.items():
                                    if not isinstance(items, list):
                                        continue
                                    for it in items:
                                        if not isinstance(it, dict):
                                            continue
                                        matched = False
                                        try:
                                            slot_field = it.get('slot')
                                            if slot_field ==slot_req or(isinstance(slot_field, (list, tuple))and slot_req in slot_field):
                                                matched = True
                                        except Exception:
                                            pass
                                        try:
                                            accs = it.get('accessories')or[]
                                            if isinstance(accs, list):
                                                for a in accs:
                                                    if isinstance(a, dict)and a.get('slot'):
                                                        if a.get('slot')==slot_req:
                                                            matched = True
                                                            break
                                        except Exception:
                                            pass

                                        if matched:

                                            try:
                                                if it.get('firearm'):
                                                    continue
                                            except Exception:
                                                pass
                                            candidates.append((it, tf, subname))
                            except Exception:
                                continue
                    except Exception:
                        pass
                    return candidates

                def _open_add_from_table(acc_ref):
                    try:
                        slot_req = acc_ref.get("slot")
                        if not slot_req:
                            self._popup_show_info("Add From Table", "This slot has no slot name defined.")
                            return

                        candidates =[]
                        table_files = sorted(glob.glob(os.path.join('tables', f"*{global_variables.get('table_extension', '.sldtbl')}")))
                        for tf in table_files:
                            try:
                                with open(tf, 'r', encoding = 'utf-8')as tfh:
                                    td = json.load(tfh)
                                tables = td.get('tables', {})
                                for subname, items in tables.items():
                                    if not isinstance(items, list):
                                        continue
                                    for it in items:
                                        if not isinstance(it, dict):
                                            continue

                                        matched = False
                                        try:
                                            slot_field = it.get('slot')
                                            if slot_field ==slot_req or(isinstance(slot_field, (list, tuple))and slot_req in slot_field):
                                                matched = True
                                        except Exception:
                                            pass
                                        try:
                                            accs = it.get('accessories')or[]
                                            if isinstance(accs, list):
                                                for a in accs:
                                                    if isinstance(a, dict)and a.get('slot'):
                                                        if a.get('slot')==slot_req:
                                                            matched = True
                                                            break
                                        except Exception:
                                            pass
                                        try:
                                            subs = it.get('subslots')or[]
                                            if isinstance(subs, list):
                                                for s in subs:
                                                    if isinstance(s, dict)and s.get('slot'):
                                                        if s.get('slot')==slot_req:
                                                            matched = True
                                                            break
                                        except Exception:
                                            pass

                                        if matched:

                                            try:
                                                if it.get('firearm'):
                                                    continue
                                            except Exception:
                                                pass
                                            candidates.append((it, tf, subname))
                            except Exception:
                                continue

                        if not candidates:
                            self._popup_show_info("Add From Table", f"No table items found for slot '{slot_req}'.")
                            return

                        popup = customtkinter.CTkToplevel(self.root)
                        popup.title("Add From Table")
                        popup.transient(self.root)
                        self._center_popup_on_window(popup, 520, 360)

                        label = customtkinter.CTkLabel(popup, text = f"Select an item to add into slot '{slot_req}':", font = customtkinter.CTkFont(size = 13))
                        label.pack(pady = 8, padx = 12)

                        sel_var = customtkinter.StringVar(value = "")
                        names =[]
                        for it, tf, sub in candidates:
                            names.append(f"{it.get('name', '<unnamed>')}({os.path.basename(tf)}:{sub})")

                        opt = customtkinter.CTkOptionMenu(popup, values = names, variable = sel_var)
                        opt.pack(fill = "x", padx = 12, pady = 8)

                        def _do_add():
                            choice = sel_var.get()
                            if not choice:
                                self._popup_show_info("Add From Table", "Please select an item to add.")
                                return
                            idx = 0
                            try:
                                idx = names.index(choice)
                            except Exception:
                                idx = 0
                            item = candidates[idx][0]
                            try:
                                import copy as _copy
                                new_item = _copy.deepcopy(item)
                                save_data.setdefault('hands', {})
                                save_data['hands'].setdefault('items', [])
                                save_data['hands']['items'].append(new_item)
                                self._popup_show_info("Add From Table", f"Added '{new_item.get('name', 'item')}' to hands.")
                                try:
                                    popup.destroy()
                                except Exception:
                                    pass
                            except Exception as e:
                                logging.exception("Failed to add item from table: %s", e)

                        add_btn = customtkinter.CTkButton(popup, text = "Add Selected", command = _do_add, width = 140)
                        add_btn.pack(pady = 10)

                        cancel_btn = customtkinter.CTkButton(popup, text = "Cancel", command = popup.destroy, width = 120, fg_color = "#444444", hover_color = "#555555")
                        cancel_btn.pack(pady = 6)

                    except Exception as e:
                        logging.exception("_open_add_from_table failed: %s", e)

                dev_ok = False
                try:
                    dev_ok = bool(global_variables.get('devmode', {}).get('value'))
                except Exception:
                    dev_ok = False

                try:
                    slot_req = acc.get('slot')
                    candidates_here = _find_table_candidates(slot_req)if slot_req else[]
                except Exception:
                    candidates_here =[]

                add_table_btn = customtkinter.CTkButton(frame, text = "Add From Table...", width = 140, command =(lambda a = acc:_open_add_from_table(a)))
                if(not dev_ok)or(not candidates_here):
                    try:
                        add_table_btn.configure(state = "disabled")
                    except Exception:
                        pass
                add_table_btn.pack(anchor = "w", pady = 2)

                rows.append((acc, opts, current_choice, None))

            def apply_changes():
                def _sync_attachment_subslot(weapon, flattened_acc, new_value):

                    try:
                        parent_slot = flattened_acc.get('_parent_accessory_slot')
                        subslot_slot = flattened_acc.get('_subslot_slot')
                        if not parent_slot or not subslot_slot:
                            return

                        for parent_acc in weapon.get('accessories', [])or[]:
                            try:
                                if parent_acc.get('slot')!=parent_slot:
                                    continue
                                cur = parent_acc.get('current')
                                if not cur or not isinstance(cur, dict):
                                    continue
                                for sub in cur.get('subslots', [])or[]:
                                    if sub.get('slot')==subslot_slot:
                                        try:
                                            import copy as _c
                                            sub['current']= _c.deepcopy(new_value)if isinstance(new_value, dict)else new_value
                                        except Exception:
                                            sub['current']= new_value
                                        return
                            except Exception:
                                pass
                    except Exception:
                        pass

                for acc, opts, var, subslot_ref in rows:
                    chosen_label = var.get()
                    chosen_item = None
                    for itm, lbl in opts:
                        if lbl ==chosen_label:
                            chosen_item = itm
                            break

                    def _remove_all_references(item):
                        try:
                            if not item or not isinstance(item, dict):
                                return
                            item_id = item.get("id")
                        except Exception:
                            item_id = None

                        def _scan(obj):
                            if isinstance(obj, dict):
                                for k, v in list(obj.items()):
                                    _scan(v)
                            elif isinstance(obj, list):

                                to_remove =[]
                                for el in obj:
                                    try:
                                        if el is item:
                                            to_remove.append(el)
                                        elif isinstance(el, dict)and item_id is not None and el.get("id")==item_id:
                                            to_remove.append(el)
                                    except Exception:
                                        pass
                                for r in to_remove:
                                    try:
                                        while r in obj:
                                            obj.remove(r)
                                    except Exception:
                                        pass
                                for el in obj:
                                    _scan(el)

                        try:
                            _scan(save_data)
                        except Exception:
                            pass

                    if subslot_ref is not None:

                        if subslot_ref.get("current"):
                            try:
                                _remove_all_references(subslot_ref.get("current"))
                            except Exception:
                                pass
                            save_data.get("hands", {}).get("items", []).append(subslot_ref.get("current"))

                        if chosen_item is None:
                            subslot_ref["current"]= None
                        else:
                            try:
                                _remove_all_references(chosen_item)
                            except Exception:
                                pass
                            hands_items = save_data.get("hands", {}).get("items", [])
                            try:
                                if chosen_item in hands_items:
                                    hands_items.remove(chosen_item)
                            except Exception:
                                pass
                            try:
                                for slot_name, eq_item in save_data.get("equipment", {}).items():
                                    if eq_item and "items"in eq_item and isinstance(eq_item["items"], list):
                                        try:
                                            while chosen_item in eq_item["items"]:
                                                eq_item["items"].remove(chosen_item)
                                        except Exception:
                                            pass

                                    if eq_item and "subslots"in eq_item:
                                        for sub in eq_item.get("subslots", []):
                                            if sub and sub.get("current")and "items"in sub.get("current", {}):
                                                try:
                                                    while chosen_item in sub["current"]["items"]:
                                                        sub["current"]["items"].remove(chosen_item)
                                                except Exception:
                                                    pass
                            except Exception:
                                pass

                            try:
                                import copy as _copy
                                new_installed = _copy.deepcopy(chosen_item)if isinstance(chosen_item, dict)else chosen_item
                            except Exception:
                                new_installed = chosen_item

                            subslot_ref["current"]= new_installed

                            try:
                                def _sync_subslot_to_save(accessory_obj, subslot_obj, installed_obj):
                                    try:

                                        aid = accessory_obj.get('id')if isinstance(accessory_obj, dict)else None
                                        aname = accessory_obj.get('name')if isinstance(accessory_obj, dict)else None
                                        aslot = accessory_obj.get('slot')if isinstance(accessory_obj, dict)else None
                                        for slot_name, eq_item in save_data.get('equipment', {}).items():
                                            if not eq_item or not isinstance(eq_item, dict):
                                                continue

                                            for acc in eq_item.get('accessories', [])or[]:
                                                try:
                                                    if not isinstance(acc, dict):
                                                        continue
                                                    match = False
                                                    if aid is not None and acc.get('id')==aid:
                                                        match = True
                                                    elif aname and acc.get('name')==aname:
                                                        match = True
                                                    elif aslot and acc.get('slot')==aslot:
                                                        match = True
                                                    if match:

                                                        for sub in acc.get('current', {}).get('subslots', [])if acc.get('current')else[]:
                                                            try:
                                                                if(sub.get('slot')and sub.get('slot')==subslot_obj.get('slot'))or(sub.get('name')and sub.get('name')==subslot_obj.get('name')):

                                                                    try:
                                                                        import copy as _c
                                                                        sub['current']= _c.deepcopy(installed_obj)if isinstance(installed_obj, dict)else installed_obj
                                                                    except Exception:
                                                                        sub['current']= installed_obj
                                                                    return True
                                                            except Exception:
                                                                pass
                                                except Exception:
                                                    pass
                                        return False
                                    except Exception:
                                        return False

                                try:
                                    _sync_subslot_to_save(acc, subslot_ref, new_installed)
                                except Exception:
                                    pass
                            except Exception:
                                pass

                    else:

                        if acc.get("current"):
                            try:
                                _remove_all_references(acc["current"])
                            except Exception:
                                pass
                            save_data.get("hands", {}).get("items", []).append(acc["current"])

                        if chosen_item is None:
                            acc["current"]= None
                            if acc.get("_is_attachment_subslot"):
                                try:
                                    _sync_attachment_subslot(wpn, acc, None)
                                except Exception:
                                    pass
                        else:
                            try:
                                _remove_all_references(chosen_item)
                            except Exception:
                                pass

                            hands_items = save_data.get("hands", {}).get("items", [])
                            try:
                                if chosen_item in hands_items:
                                    hands_items.remove(chosen_item)
                            except Exception:
                                pass

                            try:
                                for slot_name, eq_item in save_data.get("equipment", {}).items():
                                    if eq_item and "items"in eq_item and isinstance(eq_item["items"], list):
                                        try:
                                            while chosen_item in eq_item["items"]:
                                                eq_item["items"].remove(chosen_item)
                                        except Exception:
                                            pass

                                    if eq_item and "subslots"in eq_item:
                                        for sub in eq_item.get("subslots", []):
                                            if sub and sub.get("current")and "items"in sub.get("current", {}):
                                                try:
                                                    while chosen_item in sub["current"]["items"]:
                                                        sub["current"]["items"].remove(chosen_item)
                                                except Exception:
                                                    pass
                            except Exception:
                                pass

                            try:
                                import copy as _copy
                                new_installed = _copy.deepcopy(chosen_item)if isinstance(chosen_item, dict)else chosen_item
                            except Exception:
                                new_installed = chosen_item

                            acc["current"]= new_installed

                            if acc.get("_is_attachment_subslot"):
                                try:
                                    _sync_attachment_subslot(wpn, acc, new_installed)
                                except Exception:
                                    pass

                            try:
                                if isinstance(acc.get("current"), dict):
                                    add_subslots_to_item(acc.get("current"))
                            except Exception:
                                pass

                            try:
                                modes = acc.get("current", {}).get("modes")or[]
                                if isinstance(modes, list)and modes:
                                    if acc.get("_mode_index")is None and acc.get("mode_index")is None:
                                        acc["_mode_index"]= 0
                            except Exception:
                                pass

                for acc, opts, var, subslot_ref in rows:
                    if acc.get('_is_attachment_subslot'):
                        continue
                    try:
                        acc_slot = acc.get('slot')
                        to_remove =[]
                        for i, other_acc in enumerate(wpn.get('accessories', [])or[]):
                            if other_acc.get('_is_attachment_subslot')and other_acc.get('_parent_accessory_slot')==acc_slot:
                                to_remove.append(other_acc)
                        for r in to_remove:
                            try:
                                wpn['accessories'].remove(r)
                            except Exception:
                                pass

                        if acc.get('current')and isinstance(acc.get('current'), dict):
                            try:
                                _add_attachment_subslots_to_weapon(wpn, acc, acc.get('current'))
                            except Exception:
                                pass
                    except Exception:
                        pass

                try:
                    self._apply_item_overrides(wpn)
                except Exception:
                    logging.exception("Failed to apply attachment overrides")

                try:
                    self._save_file(save_data)
                except Exception:
                    logging.exception("Failed to save save_data after applying attachments")

                popup.destroy()
                update_weapon_view()

            apply_btn = customtkinter.CTkButton(popup, text = "Apply", command = apply_changes, width = 120)
            apply_btn.pack(pady = 10)

            try:
                popup.update_idletasks()
                req_w = popup.winfo_reqwidth()
                req_h = popup.winfo_reqheight()
                screen_w = popup.winfo_screenwidth()
                screen_h = popup.winfo_screenheight()

                max_w = max(200, screen_w -100)
                max_h = max(150, screen_h -100)
                final_w = min(req_w, max_w)
                final_h = min(req_h, max_h)
                self._center_popup_on_window(popup, final_w, final_h)
            except Exception:

                try:
                    self._center_popup_on_window(popup, 420, 400)
                except Exception:
                    pass

        def check_magazine():
            import time
            wpn = current_weapon_state["weapon"]
            loaded_mag = wpn.get("loaded")

            if not loaded_mag:
                ammo_label_ref = current_weapon_state.get("ammo_label_ref")
                if ammo_label_ref:
                    ammo_label_ref.configure(text = "Ammo: No magazine loaded", text_color =("gray10", "gray90"))
                    self.root.update()
                return

            rounds = loaded_mag.get("rounds", [])
            round_count = len(rounds)
            capacity = loaded_mag.get("capacity", "Unknown")

            tip_color = None
            if rounds:
                first_round = rounds[0]
                if isinstance(first_round, dict):
                    tip_color = first_round.get("tip")
                elif isinstance(first_round, str)and "|"in first_round:
                    variant_name = first_round.split("|")[-1].strip()
                    caliber_part = first_round.split("|")[0].strip()
                    try:
                        tbl_path = get_current_table_path()
                        if tbl_path and os.path.exists(tbl_path):
                            with open(tbl_path, 'r')as f:
                                table_data = json.load(f)
                            for ammo in table_data.get("tables", {}).get("ammunition", []):
                                if ammo.get("caliber")==caliber_part or ammo.get("name")==caliber_part:
                                    for var in ammo.get("variants", []):
                                        if var.get("name")==variant_name:
                                            tip_color = var.get("tip")
                                            break
                                    break
                    except Exception:
                        pass

            is_belt =("belt"in(wpn.get("magazinetype", "")or ""))or("belt"in(wpn.get("platform", "")or ""))or("m249"in(wpn.get("platform", "")or ""))
            try:
                if is_belt:
                    logging.debug("check_magazine: skipping magout for belt-fed weapon(platform=%s)", wpn.get("platform"))
                else:
                    self._play_weapon_action_sound(wpn, "magout")
            except Exception:

                if not is_belt:
                    try:
                        self._play_weapon_action_sound(wpn, "magout")
                    except Exception:
                        pass

            ammo_label_ref = current_weapon_state.get("ammo_label_ref")

            if ammo_label_ref:
                ammo_label_ref.configure(text = "Checking magazine...", text_color =("gray10", "gray90"))
                self.root.update()

            time.sleep(2.5)

            if capacity !="Unknown"and capacity >0:
                fill_ratio = round_count /capacity
                if fill_ratio ==0:
                    estimation = "Ammo: Empty"
                elif fill_ratio <0.5:
                    estimation = "Ammo: Less than halfway full"
                elif fill_ratio ==0.5:
                    estimation = "Ammo: Halfway full"
                elif fill_ratio <1.0:
                    estimation = "Ammo: More than halfway full"
                else:
                    estimation = "Ammo: Full"
            else:
                estimation = "Ammo: Unknown capacity"

            self._play_weapon_action_sound(wpn, "magin")

            current_weapon_state["mag_checked"]= True

            next_variant_name = None
            try:
                if rounds:
                    first_r = rounds[0]
                    if isinstance(first_r, dict):
                        next_variant_name = first_r.get("variant")or first_r.get("name")
            except Exception:
                next_variant_name = None
            variant_suffix = f" [{next_variant_name}]"if next_variant_name and round_count >0 else ""

            if ammo_label_ref:
                if tip_color and round_count >0:
                    ammo_label_ref.configure(text = f"{estimation}{variant_suffix}", text_color = tip_color)
                else:
                    ammo_label_ref.configure(text = f"{estimation}{variant_suffix}", text_color =("gray10", "gray90"))
                self.root.update()

        def reload_magazine():

            try:
                wpn_check = current_weapon_state.get("weapon")or {}

                wpn_sounds = wpn_check.get("sounds")or wpn_check.get("sound_folder")or wpn_check.get("ammo_type")
                if wpn_check.get("underbarrel_weapon")or(isinstance(wpn_sounds, str)and "40mm"in wpn_sounds):

                    try:
                        result = self._reload_underbarrel(wpn_check, save_data, combat_reload = False)
                        if result:
                            update_weapon_view()
                        return
                    except Exception:
                        logging.exception("Underbarrel reload failed")
            except Exception:
                pass

            wpn = current_weapon_state["weapon"]

            wpn_mag_system = wpn.get("magazinesystem")or wpn.get("magazinetype")
            wpn_caliber_raw = wpn.get("caliber")
            wpn_calibers = set()
            if isinstance(wpn_caliber_raw, (list, tuple)):
                for c in wpn_caliber_raw:
                    if c:
                        wpn_calibers.add(str(c).lower().strip())
            elif isinstance(wpn_caliber_raw, str)and wpn_caliber_raw:
                wpn_calibers.add(wpn_caliber_raw.lower().strip())

            def _mag_is_compatible(mag_item):

                if not mag_item or not isinstance(mag_item, dict):
                    return False

                mag_system = mag_item.get("magazinesystem")
                if wpn_mag_system and mag_system:
                    if str(mag_system).lower().strip()!=str(wpn_mag_system).lower().strip():
                        return False

                mag_caliber_raw = mag_item.get("caliber")
                mag_calibers = set()
                if isinstance(mag_caliber_raw, (list, tuple)):
                    for c in mag_caliber_raw:
                        if c:
                            mag_calibers.add(str(c).lower().strip())
                elif isinstance(mag_caliber_raw, str)and mag_caliber_raw:
                    mag_calibers.add(mag_caliber_raw.lower().strip())
                if wpn_calibers and mag_calibers:
                    if not wpn_calibers.intersection(mag_calibers):
                        return False

                capacity = mag_item.get("capacity", 0)
                try:
                    capacity = int(capacity)
                except(ValueError, TypeError):
                    capacity = 0
                current_rounds = len(mag_item.get("rounds", []))
                if current_rounds >=capacity:
                    return False
                return True

            all_magazines =[]

            for item in save_data.get("hands", {}).get("items", []):
                if item and "magazinesystem"in item and "capacity"in item:
                    if _mag_is_compatible(item):
                        all_magazines.append(("hands", item))

            for slot_name, eq_item in save_data.get("equipment", {}).items():
                if eq_item:
                    if "items"in eq_item and isinstance(eq_item["items"], list):
                        for item in eq_item["items"]:
                            if item and "magazinesystem"in item and "capacity"in item:
                                if _mag_is_compatible(item):
                                    all_magazines.append(("equipment", item))

                    if "subslots"in eq_item:
                        for subslot in eq_item["subslots"]:
                            if subslot.get("current"):
                                curr = subslot["current"]
                                if "items"in curr and isinstance(curr["items"], list):
                                    for item in curr["items"]:
                                        if item and "magazinesystem"in item and "capacity"in item:
                                            if _mag_is_compatible(item):
                                                all_magazines.append(("equipment", item))

            loaded_mag = wpn.get("loaded")
            if loaded_mag and "magazinesystem"in loaded_mag and "capacity"in loaded_mag:
                if _mag_is_compatible(loaded_mag):
                    all_magazines.append(("loaded", loaded_mag))

            if not all_magazines:
                msg = "No compatible magazines found!\n\nMake sure you have magazines that:\nâ€¢ Match the weapon's magazine system"
                if wpn_mag_system:
                    msg +=f"({wpn_mag_system})"
                msg +="\nâ€¢ Match the weapon's caliber"
                if wpn_calibers:
                    msg +=f"({', '.join(wpn_calibers)})"
                msg +="\nâ€¢ Are not already full"
                self._popup_show_info("Reload Magazine", msg)
                return

            popup = customtkinter.CTkToplevel(self.root)
            popup.title("Select Magazine to Reload")
            popup.transient(self.root)
            self._center_popup_on_window(popup, 550, 500)

            label = customtkinter.CTkLabel(
            popup,
            text = "Select a magazine to reload with rounds:",
            font = customtkinter.CTkFont(size = 13),
            wraplength = 500
            )
            label.pack(pady = 10, padx = 20)

            scroll_frame = customtkinter.CTkScrollableFrame(popup, fg_color = "transparent")
            scroll_frame.pack(fill = "both", expand = True, padx = 10, pady = 10)

            selected_mag = customtkinter.StringVar(value = "0")

            for idx, (location, mag_item)in enumerate(all_magazines):
                mag_name = mag_item.get("name", "Unknown Magazine")
                capacity = mag_item.get("capacity", "?")
                mag_rounds_list = mag_item.get("rounds", [])
                rounds = len(mag_rounds_list)
                mag_system = mag_item.get("magazinesystem", "Unknown")
                _next_var = ""
                if mag_rounds_list and isinstance(mag_rounds_list, list)and len(mag_rounds_list)>0:
                    _nr = mag_rounds_list[0]
                    if isinstance(_nr, dict):
                        _nv = _nr.get("variant")or _nr.get("name")
                        if _nv:
                            _next_var = f" [next: {_nv}]"

                radio_frame = customtkinter.CTkFrame(scroll_frame, fg_color = "transparent")
                radio_frame.pack(fill = "x", pady = 5, padx = 5)

                radio_text = f"{mag_name}({rounds}/{capacity}) - {mag_system} - {location}{_next_var}"
                radio = customtkinter.CTkRadioButton(
                radio_frame,
                text = radio_text,
                variable = selected_mag,
                value = str(idx),
                font = customtkinter.CTkFont(size = 11)
                )
                radio.pack(anchor = "w")

            def reload_selected():
                if not selected_mag.get():
                    self._popup_show_info("Reload Magazine", "Please select a magazine!")
                    return

                idx = int(selected_mag.get())
                location, mag_item = all_magazines[idx]

                capacity = mag_item.get("capacity", 0)
                current_rounds = len(mag_item.get("rounds", []))

                if current_rounds >=capacity:
                    self._popup_show_info("Reload Magazine", f"Magazine is already full({current_rounds}/{capacity})")
                    return

                mcal = mag_item.get('caliber')
                mag_cals = set()
                if isinstance(mcal, (list, tuple)):
                    for c in mcal:
                        if c:
                            mag_cals.add(str(c).lower().strip())
                elif isinstance(mcal, str)and mcal:
                    mag_cals.add(mcal.lower().strip())

                filter_calibers = wpn_calibers if wpn_calibers else mag_cals

                def _get_available_rounds_by_variant():

                    variants = {}

                    def _caliber_matches(item_cal):

                        if not filter_calibers:
                            return True
                        if not item_cal:
                            return False
                        item_cal_str = str(item_cal).lower().strip()
                        return item_cal_str in filter_calibers

                    def _get_variant_name(itm):

                        variant = itm.get('variant')
                        if variant:
                            return str(variant)

                        name = itm.get('name')
                        if name:
                            return str(name)
                        return 'Unknown'

                    def _process_item(itm):

                        if not itm or not isinstance(itm, dict):
                            return
                        if itm.get('magazinesystem')or itm.get('capacity'):
                            return

                        itm_cal = itm.get('caliber')
                        if not _caliber_matches(itm_cal):
                            return

                        rds = itm.get('rounds')
                        if isinstance(rds, list)and rds:
                            for r in rds:
                                if isinstance(r, dict):
                                    r_cal = r.get('caliber')
                                    if not _caliber_matches(r_cal):
                                        continue
                                    variant = _get_variant_name(r)
                                    variants[variant]= variants.get(variant, 0)+1
                            return

                        qty = int(itm.get('quantity')or 0)if isinstance(itm.get('quantity'), (int, float))else 0
                        if qty >0:
                            variant = _get_variant_name(itm)
                            variants[variant]= variants.get(variant, 0)+qty
                            return

                        if itm.get('caliber'):
                            variant = _get_variant_name(itm)
                            variants[variant]= variants.get(variant, 0)+1

                    for itm in save_data.get('hands', {}).get('items', []):
                        _process_item(itm)

                    for slot_name, eq_item in save_data.get('equipment', {}).items():
                        if not eq_item or not isinstance(eq_item, dict):
                            continue

                        for itm in eq_item.get('items', [])or[]:
                            _process_item(itm)

                        for sub in eq_item.get('subslots', [])or[]:
                            curr = sub.get('current')
                            if curr and isinstance(curr, dict):
                                for itm in curr.get('items', [])or[]:
                                    _process_item(itm)

                    return variants

                try:
                    available_by_variant = _get_available_rounds_by_variant()
                except Exception:
                    available_by_variant = {}

                total_available = sum(available_by_variant.values())

                if total_available <=0:
                    cal_str = ", ".join(sorted(filter_calibers))if filter_calibers else "compatible caliber"
                    self._popup_show_info("Reload Magazine", f"No loose rounds in hands matching {cal_str}")
                    return

                try:
                    popup.destroy()
                except Exception:
                    pass

                def _open_magazine_editor():
                    try:
                        editor = customtkinter.CTkToplevel(self.root)
                        editor.title('Magazine Editor')
                        editor.transient(self.root)
                        cap = int(mag_item.get('capacity', 0)or 0)
                        existing = list(mag_item.get('rounds', [])or[])

                        main_area = customtkinter.CTkFrame(editor)
                        main_area.grid(row = 0, column = 0, sticky = 'nsew', padx = 8, pady = 8)

                        scroll_h = max(300, min(1000, cap *24))
                        slots_frame = customtkinter.CTkScrollableFrame(main_area, width = 420, height = scroll_h, fg_color = 'transparent')
                        slots_frame.pack(side = 'left', fill = 'both', expand = True)

                        variants =['Empty']+sorted(available_by_variant.keys())

                        slot_vars =[]
                        for i in range(cap):
                            if i <len(existing):

                                rv = customtkinter.StringVar(value =(existing[i].get('variant')if isinstance(existing[i], dict)else(str(existing[i])if existing[i]else 'Empty')))
                                lbl = customtkinter.CTkLabel(slots_frame, text = f'Slot {i +1}: ')
                                lbl.pack(anchor = 'w')
                                vlabel = customtkinter.CTkLabel(slots_frame, textvariable = rv)
                                vlabel.pack(anchor = 'w', padx = 12)
                                slot_vars.append(None)
                            else:
                                sv = customtkinter.StringVar(value = 'Empty')
                                opt = customtkinter.CTkOptionMenu(slots_frame, values = variants, variable = sv, width = 220)
                                opt.pack(anchor = 'w', pady = 2)
                                slot_vars.append(sv)

                        side = customtkinter.CTkFrame(editor, fg_color = 'transparent')
                        side.grid(row = 0, column = 1, sticky = 'ns', padx = 8, pady = 8)
                        side.pack_propagate(False)

                        bulk_label = customtkinter.CTkLabel(side, text = 'Bulk Actions', font = customtkinter.CTkFont(size = 12, weight = 'bold'))
                        bulk_label.pack(pady = 6)

                        bulk_var = customtkinter.StringVar(value = variants[0])
                        bulk_menu = customtkinter.CTkOptionMenu(side, values = variants, variable = bulk_var, width = 180)
                        bulk_menu.pack(pady = 6)

                        def set_all():
                            val = bulk_var.get()
                            for sv in slot_vars:
                                if sv is not None:
                                    sv.set(val)

                        set_all_btn = customtkinter.CTkButton(side, text = 'Set All', command = set_all, width = 160)
                        set_all_btn.pack(pady = 6)

                        def apply_changes():

                            desired =[]
                            for sv in slot_vars:
                                if sv is None:
                                    continue
                                v = sv.get()
                                if v and v !='Empty':
                                    desired.append(v)
                            if not desired:
                                editor.destroy()
                                return

                            collected =[]

                            def _take_round_from_container(variant_name):

                                for hi in range(len(save_data.get('hands', {}).get('items', []))-1, -1, -1):
                                    itm = save_data['hands']['items'][hi]
                                    try:
                                        if not itm or not isinstance(itm, dict):
                                            continue

                                        rds = itm.get('rounds')
                                        if isinstance(rds, list)and rds:
                                            for ri, r in enumerate(rds):
                                                rv =(r.get('variant')if isinstance(r, dict)else(str(r)if r else None))
                                                if rv ==variant_name:
                                                    return rds.pop(ri)
                                        qty = int(itm.get('quantity')or 0)if isinstance(itm.get('quantity'), (int, float))else 0
                                        if qty >0:
                                            name = itm.get('variant')or itm.get('name')or itm.get('caliber')
                                            if name and str(name)==variant_name:

                                                itm['quantity']= qty -1
                                                r = {k:v for k, v in itm.items()if k !='quantity'}
                                                return r
                                        if itm.get('caliber')and(itm.get('variant')or itm.get('name'))and(itm.get('variant')==variant_name or itm.get('name')==variant_name):
                                            try:
                                                save_data['hands']['items'].pop(hi)
                                            except Exception:
                                                pass
                                    except Exception:
                                        continue

                                for slot_name, eq_item in list(save_data.get('equipment', {}).items()):
                                    if not eq_item or not isinstance(eq_item, dict):
                                        continue
                                    for cidx in range(len(eq_item.get('items', []))-1, -1, -1):
                                        try:
                                            itm = eq_item['items'][cidx]
                                            if not itm or not isinstance(itm, dict):
                                                continue
                                            rds = itm.get('rounds')
                                            if isinstance(rds, list)and rds:
                                                for ri, r in enumerate(rds):
                                                    rv =(r.get('variant')if isinstance(r, dict)else(str(r)if r else None))
                                                    if rv ==variant_name:
                                                        return rds.pop(ri)
                                            qty = int(itm.get('quantity')or 0)if isinstance(itm.get('quantity'), (int, float))else 0
                                            if qty >0:
                                                name = itm.get('variant')or itm.get('name')or itm.get('caliber')
                                                if name and str(name)==variant_name:
                                                    itm['quantity']= qty -1
                                                    r = {k:v for k, v in itm.items()if k !='quantity'}
                                                    return r
                                        except Exception:
                                            pass
                                return None

                            for vname in desired:
                                r = _take_round_from_container(vname)
                                if r is not None:
                                    collected.append(r)
                                else:
                                    logging.debug('Magazine editor: could not find round for variant %s', vname)

                            space = cap -len(mag_item.get('rounds', [])or[])
                            to_add = collected[:space]
                            if to_add:
                                mag_item.setdefault('rounds', []).extend(to_add)
                            editor.destroy()
                            update_weapon_view()
                            if load_into_weapon_var is None or load_into_weapon_var.get():
                                try:
                                    update_weapon_view()
                                except Exception:
                                    pass
                            self._popup_show_info('Magazine', f'Added {len(to_add)} rounds to {mag_item.get("name", "magazine")}')
                    except Exception:
                        logging.exception('Failed to apply magazine editor changes')

                    apply_btn = customtkinter.CTkButton(side, text = 'Apply', command = apply_changes, width = 160)
                    apply_btn.pack(pady = 6)

                    editor.update_idletasks()
                    ew = editor.winfo_reqwidth()
                    eh = editor.winfo_reqheight()
                    sw = editor.winfo_screenwidth()
                    sh = editor.winfo_screenheight()
                    x =(sw //2)-(ew //2)
                    y =(sh //2)-(eh //2)
                    editor.geometry(f'+{x}+{y}')
                    editor.grab_set()
                    editor.lift()
                    self._safe_focus(editor)

                _open_magazine_editor()

            button_frame = customtkinter.CTkFrame(popup, fg_color = "transparent")
            button_frame.pack(fill = "x", padx = 10, pady = 10)

            reload_btn = customtkinter.CTkButton(
            button_frame,
            text = "Reload Selected",
            command = reload_selected,
            width = 150,
            height = 40
            )
            reload_btn.pack(side = "left", padx = 5)

            cancel_btn = customtkinter.CTkButton(
            button_frame,
            text = "Cancel",
            command = popup.destroy,
            width = 150,
            height = 40,
            fg_color = "#444444",
            hover_color = "#555555"
            )
            cancel_btn.pack(side = "left", padx = 5)

            popup.update_idletasks()
            popup_width = popup.winfo_reqwidth()
            popup_height = popup.winfo_reqheight()
            screen_width = popup.winfo_screenwidth()
            screen_height = popup.winfo_screenheight()
            x =(screen_width //2)-(popup_width //2)
            y =(screen_height //2)-(popup_height //2)
            popup.geometry(f"+{x}+{y}")
            popup.deiconify()
            popup.grab_set()
            popup.lift()
            self._safe_focus(popup)

        def check_cleanliness():
            import time
            wpn = current_weapon_state["weapon"]
            wpn_id = str(wpn.get("id"))
            cleanliness = combat_state.get("barrel_cleanliness", {}).get(wpn_id, 100.0)

            self._play_weapon_action_sound(wpn, "boltback", block = True)
            time.sleep(0.3)

            clean_label_ref = current_weapon_state.get("clean_label_ref")

            if clean_label_ref:
                clean_label_ref.configure(text = "Inspecting barrel...")
                self.root.update()

            time.sleep(2.5)

            if cleanliness >=90:
                estimation = "Cleanliness: Pristine"
            elif cleanliness >=70:
                estimation = "Cleanliness: Clean"
            elif cleanliness >=50:
                estimation = "Cleanliness: Dirty"
            elif cleanliness >=30:
                estimation = "Cleanliness: Very dirty"
            else:
                estimation = "Cleanliness: Fouled"

            self._play_weapon_action_sound(wpn, "boltforward")
            time.sleep(0.2)

            loaded_mag = wpn.get("loaded")
            if loaded_mag and loaded_mag.get("rounds"):
                removed_round = loaded_mag["rounds"].pop(0)
                logging.info(f"Removed round during inspection: {removed_round}")

            if clean_label_ref:
                clean_label_ref.configure(text = estimation)
                self.root.update()

        try:
            check_clean_btn = self._create_sound_button(
            actions_frame,
            text = "Check Cleanliness",
            command = check_cleanliness,
            width = 150,
            height = 50,
            font = customtkinter.CTkFont(size = 14)
            )
        except Exception:
            check_clean_btn = None
        try:
            check_mag_btn = self._create_sound_button(
            actions_frame,
            text = "Check Magazine",
            command = check_magazine,
            width = 150,
            height = 50,
            font = customtkinter.CTkFont(size = 14)
            )
        except Exception:
            check_mag_btn = None

        reload_mag_btn = self._create_sound_button(
        actions_frame,
        text = "Magazine Management",

        command = lambda:_show_magazine_popup(),
        width = 150,
        height = 50,
        font = customtkinter.CTkFont(size = 14),
        fg_color = "#1a4d1a",
        hover_color = "#2d7a2d"
        )
        reload_mag_btn.pack(side = "left", padx = 10, pady = 10)
        try:
            current_weapon_state['reload_mag_btn_ref']= reload_mag_btn
        except Exception:
            pass

        def unload_magazine():
            try:
                wpn = current_weapon_state.get('weapon')or {}
                loaded = wpn.get('loaded')
                if not loaded:
                    self._popup_show_info('Unload', 'No magazine loaded to unload')
                    return

                save_data.get('hands', {}).get('items', []).append(loaded)
                wpn['loaded']= None

                self._popup_show_info('Unload', f"Unloaded {loaded.get('name', 'magazine')} to hands")
                update_weapon_view()
            except Exception as e:
                logging.exception('Failed to unload magazine: %s', e)

        unload_btn = self._create_sound_button(actions_frame, text = 'Unload Magazine', command = unload_magazine, width = 150, height = 50, font = customtkinter.CTkFont(size = 14), fg_color = '#444444', hover_color = '#555555')
        try:
            current_weapon_state['unload_mag_btn_ref']= unload_btn
        except Exception:
            pass

        def remove_magazine():
            try:
                import random as _rand
                wpn = current_weapon_state.get('weapon')or {}
                loaded = wpn.get('loaded')
                if not loaded:
                    self._popup_show_info('Remove Magazine', 'No magazine loaded to remove')
                    return

                try:
                    is_belt =("belt"in(wpn.get('magazinetype', '')or ''))or("belt"in(wpn.get('platform', '')or ''))or("m249"in(wpn.get('platform', '')or ''))
                except Exception:
                    is_belt = False

                try:
                    if not is_belt:
                        self._play_weapon_action_sound(wpn, 'magout')
                except Exception:
                    pass
                try:
                    time.sleep(_rand.uniform(1, 1.25))
                except Exception:
                    pass
                try:
                    self._safe_sound_play("", "sounds/firearms/universal/pouchin.wav")
                except Exception:
                    pass

                try:
                    save_data.setdefault('hands', {}).setdefault('items', []).append(loaded)
                except Exception:
                    pass

                try:
                    wpn['loaded']= None
                except Exception:
                    pass

                mag_name = loaded.get('name', 'magazine')if isinstance(loaded, dict)else str(loaded)
                self._popup_show_info('Remove Magazine', f'Removed {mag_name} to hands')
                update_weapon_view()
            except Exception as e:
                logging.exception('Failed to remove magazine: %s', e)

        try:
            remove_btn = self._create_sound_button(actions_frame, text = 'Remove Magazine', command = remove_magazine, width = 150, height = 50, font = customtkinter.CTkFont(size = 14), fg_color = '#8B0000', hover_color = '#A00000')
            remove_btn.pack(side = 'left', padx = 10, pady = 10)
            try:
                current_weapon_state['remove_mag_btn_ref']= remove_btn
            except Exception:
                pass
        except Exception:
            pass

        def _show_magazine_popup():
            try:
                popup = customtkinter.CTkToplevel(self.root)
                popup.title('Magazine')
                popup.geometry('420x220')
                popup.transient(self.root)

                lab = customtkinter.CTkLabel(popup, text = 'Magazine Actions', font = customtkinter.CTkFont(size = 14, weight = 'bold'))
                lab.pack(pady = 8)

                try:
                    wpn_mag_info = current_weapon_state.get('weapon') or {}
                    _loaded_mag_info = wpn_mag_info.get('loaded')
                    _mag_next_variant = None
                    if isinstance(_loaded_mag_info, dict):
                        _mag_rds = _loaded_mag_info.get('rounds', [])
                        if _mag_rds and isinstance(_mag_rds, list) and len(_mag_rds) > 0:
                            _mnr = _mag_rds[0]
                            if isinstance(_mnr, dict):
                                _mag_next_variant = _mnr.get('variant') or _mnr.get('name')
                    if _mag_next_variant:
                        customtkinter.CTkLabel(popup, text = f'Next round: {_mag_next_variant}', font = customtkinter.CTkFont(size = 12)).pack(pady = 2)
                except Exception:
                    pass

                try:
                    load_into_weapon_var = customtkinter.BooleanVar(value = True)
                    load_checkbox = customtkinter.CTkCheckBox(popup, text = 'Load magazine into weapon', variable = load_into_weapon_var)
                    load_checkbox.pack(pady = 4)
                except Exception:
                    load_into_weapon_var = None

                try:
                    wpn_local = current_weapon_state.get('weapon')or {}

                    wpn_mag_system = wpn_local.get("magazinesystem")or wpn_local.get("magazinetype")
                    wpn_caliber_raw = wpn_local.get("caliber")
                    wpn_calibers = set()
                    if isinstance(wpn_caliber_raw, (list, tuple)):
                        for c in wpn_caliber_raw:
                            if c:
                                wpn_calibers.add(str(c).lower().strip())
                    elif isinstance(wpn_caliber_raw, str)and wpn_caliber_raw:
                        wpn_calibers.add(wpn_caliber_raw.lower().strip())

                    def _mag_is_compatible_local(mag_item):

                        if not mag_item or not isinstance(mag_item, dict):
                            return False

                        mag_system = mag_item.get("magazinesystem")
                        if wpn_mag_system and mag_system:
                            if str(mag_system).lower().strip()!=str(wpn_mag_system).lower().strip():
                                return False

                        mag_caliber_raw = mag_item.get("caliber")
                        mag_calibers = set()
                        if isinstance(mag_caliber_raw, (list, tuple)):
                            for c in mag_caliber_raw:
                                if c:
                                    mag_calibers.add(str(c).lower().strip())
                        elif isinstance(mag_caliber_raw, str)and mag_caliber_raw:
                            mag_calibers.add(mag_caliber_raw.lower().strip())
                        if wpn_calibers and mag_calibers:
                            if not wpn_calibers.intersection(mag_calibers):
                                return False

                        capacity = mag_item.get("capacity", 0)
                        try:
                            capacity = int(capacity)
                        except(ValueError, TypeError):
                            capacity = 0
                        current_rounds = len(mag_item.get("rounds", []))
                        if current_rounds >=capacity:
                            return False
                        return True

                    def _hands_have_compatible_rounds_local(wpn):
                        try:
                            def check_container_items(item_iterable):
                                for itm in item_iterable:
                                    try:
                                        if not itm or not isinstance(itm, dict):
                                            continue

                                        if itm.get('magazinesystem')or itm.get('capacity'):
                                            continue
                                        rds = itm.get('rounds')
                                        if isinstance(rds, list)and rds:
                                            return True
                                        qty = int(itm.get('quantity')or 0)if isinstance(itm.get('quantity'), (int, float))else 0
                                        if qty >0:
                                            return True
                                        if itm.get('caliber'):
                                            return True
                                    except Exception:
                                        continue
                                return False

                            if check_container_items(save_data.get('hands', {}).get('items', [])):
                                return True

                            for slot_name, eq_item in save_data.get('equipment', {}).items():
                                try:
                                    if not eq_item or not isinstance(eq_item, dict):
                                        continue
                                    for itm in eq_item.get('items', [])or[]:
                                        if check_container_items([itm]):
                                            return True
                                    for sub in eq_item.get('subslots', [])or[]:
                                        try:
                                            curr = sub.get('current')
                                            if curr and isinstance(curr, dict):
                                                for itm in curr.get('items', [])or[]:
                                                    if check_container_items([itm]):
                                                        return True
                                        except Exception:
                                            pass
                                except Exception:
                                    pass

                            return False
                        except Exception:
                            return False

                    def _inventory_has_compatible_nonfull_mag():

                        try:
                            def check_nonfull_mag(itm):
                                if not itm or not isinstance(itm, dict):
                                    return False
                                cap = itm.get('capacity')
                                if cap is None:
                                    return False
                                try:
                                    cap_i = int(cap)
                                except Exception:
                                    return False
                                rounds = itm.get('rounds', [])
                                cur = len(rounds)if isinstance(rounds, list)else 0
                                return cur <cap_i

                            for itm in save_data.get('hands', {}).get('items', []):
                                try:
                                    if check_nonfull_mag(itm):
                                        return True
                                except Exception:
                                    pass

                            for slot_name, eq_item in save_data.get('equipment', {}).items():
                                try:
                                    if not eq_item or not isinstance(eq_item, dict):
                                        continue
                                    for itm in eq_item.get('items', [])or[]:
                                        try:
                                            if check_nonfull_mag(itm):
                                                return True
                                        except Exception:
                                            pass
                                    for sub in eq_item.get('subslots', [])or[]:
                                        try:
                                            curr = sub.get('current')
                                            if curr and isinstance(curr, dict):
                                                for itm in curr.get('items', [])or[]:
                                                    try:
                                                        if check_nonfull_mag(itm):
                                                            return True
                                                    except Exception:
                                                        pass
                                        except Exception:
                                            pass
                                except Exception:
                                    pass

                            loaded_mag = wpn_local.get('loaded')
                            if check_nonfull_mag(loaded_mag):
                                return True

                            return False
                        except Exception:
                            return False

                    can_reload = _hands_have_compatible_rounds_local(wpn_local)and _inventory_has_compatible_nonfull_mag()

                    def _inventory_has_mag_with_rounds():

                        try:
                            def check_mag(itm):
                                if not itm or not isinstance(itm, dict):
                                    return False
                                if 'magazinesystem'not in itm and 'capacity'not in itm:
                                    return False
                                rounds = itm.get('rounds', [])
                                return isinstance(rounds, list)and len(rounds)>0

                            for itm in save_data.get('hands', {}).get('items', []):
                                if check_mag(itm):
                                    return True

                            for slot_name, eq_item in save_data.get('equipment', {}).items():
                                try:
                                    if not eq_item or not isinstance(eq_item, dict):
                                        continue
                                    for itm in eq_item.get('items', [])or[]:
                                        if check_mag(itm):
                                            return True
                                    for sub in eq_item.get('subslots', [])or[]:
                                        try:
                                            curr = sub.get('current')
                                            if curr and isinstance(curr, dict):
                                                for itm in curr.get('items', [])or[]:
                                                    if check_mag(itm):
                                                        return True
                                        except Exception:
                                            pass
                                except Exception:
                                    pass

                            loaded_mag_local = wpn_local.get('loaded')
                            if check_mag(loaded_mag_local):
                                return True

                            return False
                        except Exception:
                            return False

                    can_unload = _inventory_has_mag_with_rounds()
                except Exception:
                    can_reload = False
                    can_unload = False

                def unload_magazine_rounds():

                    try:
                        popup.destroy()
                    except Exception:
                        pass

                    wpn = current_weapon_state.get('weapon')or {}

                    all_magazines =[]

                    def check_mag_has_rounds(itm):
                        if not itm or not isinstance(itm, dict):
                            return False
                        if 'magazinesystem'not in itm and 'capacity'not in itm:
                            return False
                        rounds = itm.get('rounds', [])
                        return isinstance(rounds, list)and len(rounds)>0

                    for item in save_data.get("hands", {}).get("items", []):
                        if check_mag_has_rounds(item):
                            all_magazines.append(("hands", item))

                    for slot_name, eq_item in save_data.get("equipment", {}).items():
                        if eq_item:
                            if "items"in eq_item and isinstance(eq_item["items"], list):
                                for item in eq_item["items"]:
                                    if check_mag_has_rounds(item):
                                        all_magazines.append(("equipment", item))
                            if "subslots"in eq_item:
                                for subslot in eq_item["subslots"]:
                                    if subslot.get("current"):
                                        curr = subslot["current"]
                                        if "items"in curr and isinstance(curr["items"], list):
                                            for item in curr["items"]:
                                                if check_mag_has_rounds(item):
                                                    all_magazines.append(("equipment", item))

                    loaded_mag = wpn.get("loaded")
                    if check_mag_has_rounds(loaded_mag):
                        all_magazines.append(("loaded", loaded_mag))

                    if not all_magazines:
                        self._popup_show_info("Unload Magazine", "No magazines with rounds found!")
                        return

                    unload_popup = customtkinter.CTkToplevel(self.root)
                    unload_popup.title("Select Magazine to Unload")
                    unload_popup.transient(self.root)
                    self._center_popup_on_window(unload_popup, 550, 500)

                    label = customtkinter.CTkLabel(
                    unload_popup,
                    text = "Select a magazine to unload rounds from:",
                    font = customtkinter.CTkFont(size = 13),
                    wraplength = 500
                    )
                    label.pack(pady = 10, padx = 20)

                    scroll_frame = customtkinter.CTkScrollableFrame(unload_popup, fg_color = "transparent")
                    scroll_frame.pack(fill = "both", expand = True, padx = 10, pady = 10)

                    selected_mag = customtkinter.StringVar(value = "0")

                    for idx, (location, mag_item)in enumerate(all_magazines):
                        mag_name = mag_item.get("name", "Unknown Magazine")
                        capacity = mag_item.get("capacity", "?")
                        mag_rounds_list = mag_item.get("rounds", [])
                        rounds = len(mag_rounds_list)
                        mag_system = mag_item.get("magazinesystem", "Unknown")
                        _next_var = ""
                        if mag_rounds_list and isinstance(mag_rounds_list, list)and len(mag_rounds_list)>0:
                            _nr = mag_rounds_list[0]
                            if isinstance(_nr, dict):
                                _nv = _nr.get("variant")or _nr.get("name")
                                if _nv:
                                    _next_var = f" [next: {_nv}]"

                        radio_frame = customtkinter.CTkFrame(scroll_frame, fg_color = "transparent")
                        radio_frame.pack(fill = "x", pady = 5, padx = 5)

                        radio_text = f"{mag_name}({rounds}/{capacity}) - {mag_system} - {location}{_next_var}"
                        radio = customtkinter.CTkRadioButton(
                        radio_frame,
                        text = radio_text,
                        variable = selected_mag,
                        value = str(idx),
                        font = customtkinter.CTkFont(size = 11)
                        )
                        radio.pack(anchor = "w")

                    def unload_selected():
                        if not selected_mag.get():
                            self._popup_show_info("Unload Magazine", "Please select a magazine!")
                            return

                        idx = int(selected_mag.get())
                        location, mag_item = all_magazines[idx]

                        mag_rounds = mag_item.get("rounds", [])
                        current_round_count = len(mag_rounds)
                        if current_round_count <=0:
                            self._popup_show_info("Unload Magazine", "Magazine is already empty")
                            return

                        variants_in_mag = {}
                        for r in mag_rounds:
                            if isinstance(r, dict):
                                variant = r.get('variant', 'Unknown')
                                variants_in_mag[variant]= variants_in_mag.get(variant, 0)+1

                        def proceed_with_unload(selected_variant):

                            if selected_variant and selected_variant !="All Variants":
                                variant_count = variants_in_mag.get(selected_variant, 0)
                            else:
                                variant_count = current_round_count
                                selected_variant = None

                            if variant_count <=0:
                                self._popup_show_info("Unload Magazine", "No rounds to unload")
                                return

                            def on_amount_selected(to_unload):
                                        if to_unload is None or to_unload <=0:
                                            return

                                        def on_unload_complete(result_msg):
                                            self._popup_show_info("Unload Magazine", result_msg)
                                            update_weapon_view()

                                        is_loaded =(location =="loaded")
                                        self._unload_magazine_rounds(mag_item, save_data, max_rounds = to_unload, on_complete = on_unload_complete, is_loaded_in_weapon = is_loaded, weapon = wpn if is_loaded else None, variant_filter = selected_variant)

                            self._popup_ask_integer("Unload Rounds", f"Enter rounds to unload(1-{variant_count}):", initial_value = variant_count, min_value = 1, max_value = variant_count, on_result = on_amount_selected)

                        if len(variants_in_mag)>1:

                            try:
                                unload_popup.destroy()
                            except Exception:
                                pass
                            variant_popup = customtkinter.CTkToplevel(self.root)
                            variant_popup.title("Select Ammo Variant")
                            variant_popup.transient(self.root)
                            self._center_popup_on_window(variant_popup, 400, 350)

                            label = customtkinter.CTkLabel(
                            variant_popup,
                            text = "Multiple ammo variants in magazine.\nSelect which to unload:",
                            font = customtkinter.CTkFont(size = 13),
                            wraplength = 380
                            )
                            label.pack(pady = 10, padx = 10)

                            scroll_frame = customtkinter.CTkScrollableFrame(variant_popup, fg_color = "transparent")
                            scroll_frame.pack(fill = "both", expand = True, padx = 10, pady = 5)

                            selected_variant_var = customtkinter.StringVar(value = "All Variants")

                            radio = customtkinter.CTkRadioButton(
                            scroll_frame,
                            text = f"All Variants({current_round_count} rounds)",
                            variable = selected_variant_var,
                            value = "All Variants",
                            font = customtkinter.CTkFont(size = 11)
                            )
                            radio.pack(anchor = "w", pady = 3)

                            for variant, count in sorted(variants_in_mag.items()):
                                radio = customtkinter.CTkRadioButton(
                                scroll_frame,
                                text = f"{variant}({count} rounds)",
                                variable = selected_variant_var,
                                value = variant,
                                font = customtkinter.CTkFont(size = 11)
                                )
                                radio.pack(anchor = "w", pady = 3)

                            def on_variant_selected():
                                variant_popup.destroy()
                                proceed_with_unload(selected_variant_var.get())

                            btn_frame = customtkinter.CTkFrame(variant_popup, fg_color = "transparent")
                            btn_frame.pack(fill = "x", padx = 10, pady = 10)

                            ok_btn = customtkinter.CTkButton(btn_frame, text = "Continue", command = on_variant_selected, width = 120)
                            ok_btn.pack(side = "left", padx = 5)

                            cancel_btn = customtkinter.CTkButton(btn_frame, text = "Cancel", command = variant_popup.destroy, width = 120, fg_color = "#444444")
                            cancel_btn.pack(side = "left", padx = 5)

                            variant_popup.update_idletasks()
                            screen_width = variant_popup.winfo_screenwidth()
                            screen_height = variant_popup.winfo_screenheight()
                            x =(screen_width //2)-(200)
                            y =(screen_height //2)-(175)
                            variant_popup.geometry(f"+{x}+{y}")
                            variant_popup.grab_set()
                            variant_popup.lift()
                            self._safe_focus(variant_popup)
                        else:

                            try:
                                unload_popup.destroy()
                            except Exception:
                                pass
                            variant = list(variants_in_mag.keys())[0]if variants_in_mag else None
                            proceed_with_unload(variant)

                    button_frame = customtkinter.CTkFrame(unload_popup, fg_color = "transparent")
                    button_frame.pack(fill = "x", padx = 10, pady = 10)

                    unload_btn = customtkinter.CTkButton(
                    button_frame,
                    text = "Unload Selected",
                    command = unload_selected,
                    width = 150,
                    height = 40
                    )
                    unload_btn.pack(side = "left", padx = 5)

                    cancel_btn = customtkinter.CTkButton(
                    button_frame,
                    text = "Cancel",
                    command = unload_popup.destroy,
                    width = 150,
                    height = 40,
                    fg_color = "#444444",
                    hover_color = "#555555"
                    )
                    cancel_btn.pack(side = "left", padx = 5)

                    unload_popup.update_idletasks()
                    popup_width = unload_popup.winfo_reqwidth()
                    popup_height = unload_popup.winfo_reqheight()
                    screen_width = unload_popup.winfo_screenwidth()
                    screen_height = unload_popup.winfo_screenheight()
                    x =(screen_width //2)-(popup_width //2)
                    y =(screen_height //2)-(popup_height //2)
                    unload_popup.geometry(f"+{x}+{y}")
                    unload_popup.deiconify()
                    unload_popup.grab_set()
                    unload_popup.lift()
                    self._safe_focus(unload_popup)

                try:
                    def reload_and_close():
                        try:
                            popup.destroy()
                        except Exception:
                            pass
                        reload_magazine()

                    reload_btn = self._create_sound_button(popup, text = 'Reload Magazine', command = reload_and_close, width = 240, height = 40, font = customtkinter.CTkFont(size = 12), fg_color = '#1a4d1a')
                    reload_btn.pack(pady = 6)
                    try:
                        reload_btn.configure(state = 'normal'if can_reload else 'disabled')
                    except Exception:
                        pass
                except Exception:
                    pass

                try:
                    unload_btn_popup = self._create_sound_button(popup, text = 'Unload Magazine', command = unload_magazine_rounds, width = 240, height = 40, font = customtkinter.CTkFont(size = 12), fg_color = '#444444')
                    unload_btn_popup.pack(pady = 6)
                    try:
                        unload_btn_popup.configure(state = 'normal'if can_unload else 'disabled')
                    except Exception:
                        pass
                except Exception:
                    pass

                try:
                    customtkinter.CTkButton(popup, text = 'Close', command = popup.destroy, width = 140).pack(pady = 8)
                except Exception:
                    pass

                try:
                    popup.grab_set()
                    popup.lift()
                    self._safe_focus(popup)
                except Exception:
                    pass
            except Exception:
                pass

        def _find_throwables_in_inventory():
            items =[]

            for itm in save_data.get('hands', {}).get('items', []):
                try:
                    if itm and isinstance(itm, dict)and str(itm.get('type', '')).lower()in('fragmentation', 'smoke', 'stun', '9-bang', '9bang', '9_bang'):
                        items.append(('hands', itm))
                except Exception:
                    pass

            for slot_name, eq_item in save_data.get('equipment', {}).items():
                try:
                    if not eq_item or not isinstance(eq_item, dict):
                        continue
                    if 'items'in eq_item and isinstance(eq_item['items'], list):
                        for itm in eq_item['items']:
                            try:
                                if itm and isinstance(itm, dict)and str(itm.get('type', '')).lower()in('fragmentation', 'smoke', 'stun', '9-bang', '9bang', '9_bang'):
                                    items.append(('equipment', itm))
                            except Exception:
                                pass
                    if 'subslots'in eq_item:
                        for sub in eq_item.get('subslots', []):
                            try:
                                curr = sub.get('current')if isinstance(sub, dict)else None
                                if curr and isinstance(curr, dict)and 'items'in curr and isinstance(curr['items'], list):
                                    for itm in curr['items']:
                                        try:
                                            if itm and isinstance(itm, dict)and str(itm.get('type', '')).lower()in('fragmentation', 'smoke', 'stun', '9-bang', '9bang', '9_bang'):
                                                items.append(('equipment', itm))
                                        except Exception:
                                            pass
                            except Exception:
                                pass
                except Exception:
                    pass
            return items

        def _find_consumables_in_inventory():

            items =[]

            for itm in save_data.get('hands', {}).get('items', []):
                try:
                    if itm and isinstance(itm, dict)and itm.get('consumable'):
                        items.append(('hands', itm))
                except Exception:
                    pass

            for slot_name, eq_item in save_data.get('equipment', {}).items():
                try:
                    if not eq_item or not isinstance(eq_item, dict):
                        continue

                    if 'items'in eq_item and isinstance(eq_item['items'], list):
                        for itm in eq_item['items']:
                            try:
                                if itm and isinstance(itm, dict)and itm.get('consumable'):
                                    items.append((f'equipment.{slot_name}', itm))
                            except Exception:
                                pass

                    if 'subslots'in eq_item:
                        for sub_idx, sub in enumerate(eq_item.get('subslots', [])):
                            try:
                                curr = sub.get('current')if isinstance(sub, dict)else None
                                if curr and isinstance(curr, dict):

                                    if curr.get('consumable'):
                                        items.append((f'equipment.{slot_name}.subslots.{sub_idx}.current', curr))

                                    if 'items'in curr and isinstance(curr['items'], list):
                                        for itm in curr['items']:
                                            try:
                                                if itm and isinstance(itm, dict)and itm.get('consumable'):
                                                    items.append((f'equipment.{slot_name}.subslots.{sub_idx}.current', itm))
                                            except Exception:
                                                pass
                            except Exception:
                                pass
                except Exception:
                    pass
            return items

        def _has_ear_protection():
            try:
                for slot, eq in save_data.get('equipment', {}).items():
                    if not eq or not isinstance(eq, dict):
                        continue

                    if eq.get('ear_protection'):
                        return True

                    for itm in eq.get('items', [])or[]:
                        try:
                            if itm and isinstance(itm, dict)and itm.get('ear_protection'):
                                return True
                        except Exception:
                            pass
                    for sub in eq.get('subslots', [])or[]:
                        try:
                            curr = sub.get('current')
                            if curr and isinstance(curr, dict):
                                if curr.get('ear_protection'):
                                    return True
                                for itm in curr.get('items', [])or[]:
                                    try:
                                        if itm and isinstance(itm, dict)and itm.get('ear_protection'):
                                            return True
                                    except Exception:
                                        pass
                        except Exception:
                            pass
                return False
            except Exception:
                return False

        def _has_flash_goggles():
            try:
                for slot, eq in save_data.get('equipment', {}).items():
                    if not eq or not isinstance(eq, dict):
                        continue
                    if eq.get('flashbang_goggle'):
                        return True
                    for itm in eq.get('items', [])or[]:
                        try:
                            if itm and isinstance(itm, dict)and itm.get('flashbang_goggle'):
                                return True
                        except Exception:
                            pass
                    for sub in eq.get('subslots', [])or[]:
                        try:
                            curr = sub.get('current')
                            if curr and isinstance(curr, dict):
                                if curr.get('flashbang_goggle'):
                                    return True
                                for itm in curr.get('items', [])or[]:
                                    try:
                                        if itm and isinstance(itm, dict)and itm.get('flashbang_goggle'):
                                            return True
                                    except Exception:
                                        pass
                        except Exception:
                            pass
                return False
            except Exception:
                return False

        def _handle_flashbang_effects(bang_count = 1):

            try:
                has_ears = _has_ear_protection()
                has_gog = _has_flash_goggles()

                if not has_ears:
                    try:
                        self._flashbang_mute = True
                        self._flashbang_volume = 0.0
                    except Exception:
                        pass

                    try:
                        def _play_ring():
                            try:
                                logging.debug("Flashbang: spawning ring playback thread")
                                self._safe_sound_play('', 'sounds/misc/throwable/ring.ogg')
                                logging.debug("Flashbang: ring playback attempted")
                            except Exception:
                                logging.exception('Flashbang ring playback failed')
                        threading.Thread(target = _play_ring, daemon = True).start()
                    except Exception:
                        logging.exception('Failed to start ring playback thread')

                    try:

                        try:
                            if hasattr(self, '_flashbang_fade_cancel')and self._flashbang_fade_cancel is not None:
                                try:
                                    self._flashbang_fade_cancel.set()
                                except Exception:
                                    pass
                        except Exception:
                            pass

                        fade_cancel = threading.Event()
                        self._flashbang_fade_cancel = fade_cancel

                        def _fade_in_after_delay(cancel_evt = fade_cancel):
                            try:
                                wait = random.uniform(7.0, 8.0)

                                waited = 0.0
                                step_wait = 0.1
                                while waited <wait:
                                    if cancel_evt.is_set():
                                        return
                                    time.sleep(step_wait)
                                    waited +=step_wait

                                steps = 20
                                dur = 3.0
                                step_sleep = dur /steps
                                for i in range(1, steps +1):
                                    if cancel_evt.is_set():
                                        return
                                    try:
                                        self._flashbang_volume = float(i)/float(steps)
                                    except Exception:
                                        self._flashbang_volume = 1.0
                                    time.sleep(step_sleep)

                                try:
                                    self._flashbang_mute = False
                                    self._flashbang_volume = 1.0

                                    try:
                                        cache = getattr(self, '_sound_cache', {})or {}
                                        for spath, ssound in cache.items():
                                            try:
                                                ssound.set_volume(1.0)
                                            except Exception:
                                                pass
                                    except Exception:
                                        pass
                                except Exception:
                                    pass
                            except Exception:
                                try:
                                    self._flashbang_mute = False
                                    self._flashbang_volume = 1.0
                                except Exception:
                                    pass

                        t = threading.Thread(target = _fade_in_after_delay, daemon = True)
                        t.start()
                        self._flashbang_fade_thread = t
                    except Exception:
                        pass
                else:

                    try:
                        self._bang_muffle = True

                        self._bang_muffle_volume = getattr(self, '_bang_muffle_volume', 0.45)

                        try:
                            prev = getattr(self, '_bang_muffle_timer', None)
                            if prev:
                                try:
                                    prev.cancel()
                                except Exception:
                                    pass
                        except Exception:
                            pass

                        try:
                            mt = threading.Timer(5.0, lambda:setattr(self, '_bang_muffle', False))
                            mt.daemon = True
                            mt.start()
                            self._bang_muffle_timer = mt
                        except Exception:
                            pass
                    except Exception:
                        pass

                if not has_gog:
                    def _create_overlay():
                        try:
                            ov = customtkinter.CTkToplevel(self.root)
                            ov.overrideredirect(True)
                            sw = self.root.winfo_screenwidth()
                            sh = self.root.winfo_screenheight()
                            ov.geometry(f"{sw}x{sh}+0+0")
                            try:
                                ov.attributes('-topmost', True)
                            except Exception:
                                pass
                            try:
                                ov.attributes('-alpha', 1.0)
                            except Exception:
                                pass
                            try:
                                ov.configure(fg_color = 'white')
                            except Exception:
                                try:
                                    ov.configure(bg = 'white')
                                except Exception:
                                    pass
                            return ov
                        except Exception:
                            return None

                    try:
                        def _make_and_fade():
                            try:

                                existing = getattr(self, '_flashbang_overlay', None)
                                existing_after = getattr(self, '_flashbang_overlay_after_id', None)
                                overlay = existing
                                if overlay is None or not getattr(overlay, 'winfo_exists', lambda:False)():
                                    overlay = _create_overlay()
                                    try:
                                        self._flashbang_overlay = overlay
                                    except Exception:
                                        pass
                                else:
                                    try:

                                        if existing_after:
                                            try:
                                                overlay.after_cancel(existing_after)
                                            except Exception:
                                                pass
                                    except Exception:
                                        pass
                                    try:
                                        overlay.attributes('-alpha', 1.0)
                                    except Exception:
                                        pass

                                delay = int(random.uniform(7000, 8000))
                                def _fade_step(count = 0, steps = None):
                                    try:
                                        if not getattr(overlay, 'winfo_exists', lambda:False)():
                                            try:
                                                if getattr(self, '_flashbang_overlay', None)is overlay:
                                                    self._flashbang_overlay = None
                                                    self._flashbang_overlay_after_id = None
                                            except Exception:
                                                pass
                                            return

                                        dur = 3.0

                                        target_fps = 165

                                        if not steps:
                                            try:
                                                steps = max(1, int(dur *target_fps))
                                            except Exception:
                                                steps = 60

                                        try:
                                            interval_ms = max(1, int((dur *1000.0)/float(steps)))
                                        except Exception:
                                            interval_ms = max(1, int((dur *1000.0)/60))

                                        t = float(count)/float(steps)if steps else 1.0

                                        smooth = t *t *(3.0 -2.0 *t)
                                        alpha = 1.0 -smooth
                                        alpha = max(0.0, min(1.0, alpha))
                                        try:
                                            overlay.attributes('-alpha', alpha)
                                        except Exception:
                                            pass

                                        if count <steps:
                                            aid = overlay.after(int(interval_ms), lambda:_fade_step(count +1, steps))
                                            try:
                                                self._flashbang_overlay_after_id = aid
                                            except Exception:
                                                pass
                                        else:
                                            try:
                                                overlay.destroy()
                                            except Exception:
                                                pass
                                            try:
                                                if getattr(self, '_flashbang_overlay', None)is overlay:
                                                    self._flashbang_overlay = None
                                                    self._flashbang_overlay_after_id = None
                                            except Exception:
                                                pass
                                    except Exception:
                                        try:
                                            if overlay:
                                                overlay.destroy()
                                        except Exception:
                                            pass

                                try:
                                    aid = overlay.after(delay, lambda:_fade_step(0))
                                    try:
                                        self._flashbang_overlay_after_id = aid
                                    except Exception:
                                        pass
                                except Exception:
                                    try:

                                        _fade_step(0)
                                    except Exception:
                                        pass
                            except Exception:
                                pass

                        self.root.after(0, _make_and_fade)
                    except Exception:
                        pass

                return True
            except Exception:
                return False

        def _handle_fragmentation_flash_effects():

            try:
                has_gog = _has_flash_goggles()
                if has_gog:
                    return True

                def _create_quick_flash():
                    try:
                        ov = customtkinter.CTkToplevel(self.root)
                        ov.overrideredirect(True)
                        sw = self.root.winfo_screenwidth()
                        sh = self.root.winfo_screenheight()
                        ov.geometry(f"{sw}x{sh}+0+0")
                        try:
                            ov.attributes('-topmost', True)
                        except Exception:
                            pass
                        try:
                            ov.attributes('-alpha', 1.0)
                        except Exception:
                            pass
                        try:
                            ov.configure(fg_color = 'white')
                        except Exception:
                            try:
                                ov.configure(bg = 'white')
                            except Exception:
                                pass

                        def _quick_fade(step = 0, steps = None):
                            try:
                                if not getattr(ov, 'winfo_exists', lambda:False)():
                                    return

                                dur = random.uniform(0.2, 0.35)
                                target_fps = 165
                                if not steps:
                                    try:
                                        steps = max(1, int(dur *target_fps))
                                    except Exception:
                                        steps = 60

                                try:
                                    interval_ms = max(1, int((dur *1000.0)/float(steps)))
                                except Exception:
                                    interval_ms = max(1, int((dur *1000.0)/60))

                                t = float(step)/float(steps)if steps else 1.0
                                smooth = t *t *(3.0 -2.0 *t)
                                alpha = 1.0 -smooth
                                alpha = max(0.0, min(1.0, alpha))
                                try:
                                    ov.attributes('-alpha', alpha)
                                except Exception:
                                    pass

                                if step <steps:
                                    ov.after(int(interval_ms), lambda:_quick_fade(step +1, steps))
                                else:
                                    try:
                                        ov.destroy()
                                    except Exception:
                                        pass
                            except Exception:
                                try:
                                    ov.destroy()
                                except Exception:
                                    pass

                        ov.after(int(random.uniform(10, 30)), lambda:_quick_fade(1, None))
                        return ov
                    except Exception:
                        return None

                try:

                    try:
                        if _has_ear_protection():
                            try:
                                self._bang_muffle = True
                                self._bang_muffle_volume = getattr(self, '_bang_muffle_volume', 0.45)
                                prev = getattr(self, '_bang_muffle_timer', None)
                                if prev:
                                    try:
                                        prev.cancel()
                                    except Exception:
                                        pass
                                mt = threading.Timer(3.0, lambda:setattr(self, '_bang_muffle', False))
                                mt.daemon = True
                                mt.start()
                                self._bang_muffle_timer = mt
                            except Exception:
                                pass
                    except Exception:
                        pass

                    self.root.after(0, _create_quick_flash)
                except Exception:
                    pass
                return True
            except Exception:
                return False

        def _handle_goggle_dark_flash_effects():

            try:

                if not _has_flash_goggles():
                    return False

                def _create_quick_dark():
                    try:
                        ov = customtkinter.CTkToplevel(self.root)
                        ov.overrideredirect(True)
                        sw = self.root.winfo_screenwidth()
                        sh = self.root.winfo_screenheight()
                        ov.geometry(f"{sw}x{sh}+0+0")
                        try:
                            ov.attributes('-topmost', True)
                        except Exception:
                            pass

                        try:
                            ov.attributes('-alpha', 0.8)
                        except Exception:
                            pass
                        try:
                            ov.configure(fg_color = 'black')
                        except Exception:
                            try:
                                ov.configure(bg = 'black')
                            except Exception:
                                pass

                        def _quick_fade(step = 0, steps = None):
                            try:
                                if not getattr(ov, 'winfo_exists', lambda:False)():
                                    return

                                dur = random.uniform(0.2, 0.4)
                                target_fps = 165
                                if not steps:
                                    try:
                                        steps = max(1, int(dur *target_fps))
                                    except Exception:
                                        steps = 60

                                try:
                                    interval_ms = max(1, int((dur *1000.0)/float(steps)))
                                except Exception:
                                    interval_ms = max(1, int((dur *1000.0)/60))

                                t = float(step)/float(steps)if steps else 1.0
                                smooth = t *t *(3.0 -2.0 *t)
                                alpha = 0.8 *(1.0 -smooth)
                                alpha = max(0.0, min(1.0, alpha))
                                try:
                                    ov.attributes('-alpha', alpha)
                                except Exception:
                                    pass

                                if step <steps:
                                    ov.after(int(interval_ms), lambda:_quick_fade(step +1, steps))
                                else:
                                    try:
                                        ov.destroy()
                                    except Exception:
                                        pass
                            except Exception:
                                try:
                                    ov.destroy()
                                except Exception:
                                    pass

                        ov.after(int(random.uniform(10, 30)), lambda:_quick_fade(1, None))
                        return ov
                    except Exception:
                        return None

                try:
                    self.root.after(0, _create_quick_dark)
                except Exception:
                    pass
                return True
            except Exception:
                return False

        def _do_throw_sequence(location, throwable_item):
            try:

                try:

                    def _consume_throwable_from_list(lst, target):
                        try:
                            for i, it in enumerate(lst):
                                if it is target:
                                    if isinstance(it, dict):
                                        qty = it.get('quantity')
                                        if isinstance(qty, (int, float))and qty >1:
                                            try:
                                                it['quantity']= int(qty)-1
                                                return True
                                            except Exception:
                                                pass
                                        else:
                                            try:
                                                lst.pop(i)
                                                return True
                                            except Exception:
                                                pass
                                    return False
                        except Exception:
                            pass
                        return False

                    if location =='hands':
                        hands_list = save_data.get('hands', {}).get('items', [])
                        _consume_throwable_from_list(hands_list, throwable_item)
                    elif location =='equipment':
                        for slot_name, eq_item in save_data.get('equipment', {}).items():
                            if not eq_item or not isinstance(eq_item, dict):
                                continue
                            if 'items'in eq_item and isinstance(eq_item['items'], list):
                                if _consume_throwable_from_list(eq_item['items'], throwable_item):
                                    break
                            if 'subslots'in eq_item:
                                for sub in eq_item.get('subslots', []):
                                    try:
                                        curr = sub.get('current')
                                        if curr and isinstance(curr, dict)and 'items'in curr and isinstance(curr['items'], list):
                                            if _consume_throwable_from_list(curr['items'], throwable_item):
                                                break
                                    except Exception:
                                        pass
                except Exception:
                    pass

                try:
                    self._save_file(save_data)
                except Exception:
                    pass

                try:
                    self._safe_sound_play('', 'sounds/misc/throwable/pin.ogg')
                except Exception:
                    pass
                time.sleep(random.uniform(0.2, 0.5))
                try:
                    self._safe_sound_play('', 'sounds/misc/throwable/throw.ogg')
                except Exception:
                    pass
                time.sleep(random.uniform(0.2, 0.3))
                try:
                    self._safe_sound_play('', 'sounds/misc/throwable/spoon.ogg')
                except Exception:
                    pass

                fuse = float(throwable_item.get('fuse_time')or throwable_item.get('fuse', 3))
                start_t = time.time()
                end_t = start_t +fuse

                time.sleep(random.uniform(0.8, 1.3))
                try:
                    idx = random.randint(0, 3)
                    self._safe_sound_play('', f'sounds/misc/throwable/bounce{idx}.ogg')
                except Exception:
                    pass

                extra = random.randint(0, 3)
                for bi in range(extra):

                    if time.time()>=end_t and str(throwable_item.get('type', '')).lower()in('fragmentation', 'stun', '9-bang', '9bang', '9_bang'):
                        break
                    if bi ==0:
                        time.sleep(random.uniform(0.2, 0.3))
                    elif bi ==1:
                        time.sleep(random.uniform(0.2, 0.3))
                    else:
                        time.sleep(random.uniform(0.1, 0.2))
                    try:
                        idx = random.randint(0, 3)
                        self._safe_sound_play('', f'sounds/misc/throwable/bounce{idx}.ogg')
                    except Exception:
                        pass

                typ = str(throwable_item.get('type', '')).lower()

                remaining = end_t -time.time()
                if remaining >0:
                    time.sleep(remaining)

                if typ =='fragmentation':
                    try:

                        try:
                            _handle_fragmentation_flash_effects()
                        except Exception:
                            pass

                        try:
                            if _has_flash_goggles():
                                try:
                                    _handle_goggle_dark_flash_effects()
                                except Exception:
                                    pass
                        except Exception:
                            pass
                        self._safe_sound_play('', 'sounds/misc/throwable/explosion.ogg')
                    except Exception:
                        pass
                elif typ =='smoke':
                    try:
                        self._safe_sound_play('', 'sounds/misc/throwable/smoke.ogg')
                    except Exception:
                        pass
                elif typ in('stun', 'flashbang', 'flash'):

                    try:
                        _handle_flashbang_effects(bang_count = 1)
                        self._safe_sound_play('', 'sounds/misc/throwable/flashbang.ogg')
                        try:

                            if _has_flash_goggles():
                                try:
                                    _handle_goggle_dark_flash_effects()
                                except Exception:
                                    pass
                        except Exception:
                            pass
                    except Exception:
                        pass
                elif typ in('9-bang', '9bang', '9_bang'):
                    try:
                        _handle_flashbang_effects(bang_count = 9)
                        for i in range(9):
                            try:
                                self._safe_sound_play('', 'sounds/misc/throwable/flashbang.ogg')

                                try:
                                    if _has_flash_goggles():
                                        try:
                                            _handle_goggle_dark_flash_effects()
                                        except Exception:
                                            pass
                                except Exception:
                                    pass
                            except Exception:
                                pass
                            if i <8:
                                time.sleep(random.uniform(0.3, 0.5))
                    except Exception:
                        pass

                try:
                    update_weapon_view()
                except Exception:
                    pass
            except Exception:
                logging.exception('Throwable sequence failed')

        def throw_throwable():
            all_throw = _find_throwables_in_inventory()
            if not all_throw:
                self._popup_show_info('Throw', 'No throwables in inventory')
                return

            popup = customtkinter.CTkToplevel(self.root)
            popup.title('Select Throwable')
            popup.transient(self.root)
            self._center_popup_on_window(popup, 420, 320)

            lab = customtkinter.CTkLabel(popup, text = 'Select a throwable to throw:', font = customtkinter.CTkFont(size = 12))
            lab.pack(pady = 8)

            sel_var = customtkinter.StringVar(value = '0')
            frame = customtkinter.CTkScrollableFrame(popup, fg_color = 'transparent')
            frame.pack(fill = 'both', expand = True, padx = 10, pady = 10)
            for idx, (loc, itm)in enumerate(all_throw):
                name = itm.get('name')or itm.get('type')or f'Throwable {idx}'
                qty = int(itm.get('quantity')or 1)if isinstance(itm.get('quantity'), (int, float, str))else 1
                qty_text = f" x{qty}"if qty >1 else ""
                desc = f"{name}{qty_text} - {loc} - fuse {itm.get('fuse_time')or itm.get('fuse', '?')}s"
                rb = customtkinter.CTkRadioButton(frame, text = desc, variable = sel_var, value = str(idx))
                rb.pack(anchor = 'w', pady = 2)

            def do_throw():
                try:
                    idx = int(sel_var.get())
                    loc, itm = all_throw[idx]
                except Exception:
                    popup.destroy()
                    return
                popup.destroy()

                try:
                    threading.Thread(target = _do_throw_sequence, args =(loc, itm), daemon = True).start()
                except Exception:
                    _do_throw_sequence(loc, itm)

            bframe = customtkinter.CTkFrame(popup, fg_color = 'transparent')
            bframe.pack(fill = 'x', padx = 10, pady = 6)
            customtkinter.CTkButton(bframe, text = 'Throw', command = do_throw, width = 120).pack(side = 'left', padx = 6)
            customtkinter.CTkButton(bframe, text = 'Cancel', command = popup.destroy, width = 120).pack(side = 'left', padx = 6)
            try:
                popup.grab_set()
                popup.lift()
                self._safe_focus(popup)
            except Exception:
                pass

        def use_consumable():

            all_consumables = _find_consumables_in_inventory()
            if not all_consumables:
                self._popup_show_info('Use Consumable', 'No consumables in inventory(hands/equipment)')
                return

            popup = customtkinter.CTkToplevel(self.root)
            popup.title('Select Consumable')
            popup.transient(self.root)
            self._center_popup_on_window(popup, 500, 400)

            lab = customtkinter.CTkLabel(popup, text = 'Select a consumable to use:', font = customtkinter.CTkFont(size = 12))
            lab.pack(pady = 8)

            sel_var = customtkinter.StringVar(value = '0')
            frame = customtkinter.CTkScrollableFrame(popup, fg_color = 'transparent')
            frame.pack(fill = 'both', expand = True, padx = 10, pady = 10)

            for idx, (loc, itm)in enumerate(all_consumables):
                name = itm.get('name')or f'Consumable {idx}'
                uses = itm.get('uses_left')
                loc_display = loc.replace('equipment.', '').replace('.subslots.', ' > ').replace('.current', '')
                if uses:
                    uses_text = f"{uses} use{'s'if uses !=1 else ''}"
                elif itm.get('used_up'):
                    uses_text = "1 use"
                else:
                    uses_text = "âˆž uses"
                desc = f"{name}({uses_text}) - {loc_display}"
                rb = customtkinter.CTkRadioButton(frame, text = desc, variable = sel_var, value = str(idx))
                rb.pack(anchor = 'w', pady = 2)

            def do_consume():
                try:
                    idx = int(sel_var.get())
                    loc, itm = all_consumables[idx]
                except Exception:
                    popup.destroy()
                    return
                popup.destroy()

                item_id = itm.get('id')
                item_name = itm.get('name')

                actual_item = None
                if loc =="hands":
                    for inv_item in save_data.get('hands', {}).get('items', []):
                        if isinstance(inv_item, dict)and inv_item.get('id')==item_id and inv_item.get('name')==item_name:
                            actual_item = inv_item
                            break
                elif loc.startswith("equipment."):
                    parts = loc.split(".")
                    slot = parts[1]
                    eq = save_data.get("equipment", {}).get(slot)
                    if eq and isinstance(eq, dict):
                        if len(parts)>=5 and parts[2]=="subslots":
                            try:
                                subslot_idx = int(parts[3])
                                subslots = eq.get("subslots", [])
                                if subslot_idx <len(subslots):
                                    subslot = subslots[subslot_idx]
                                    curr = subslot.get("current")if isinstance(subslot, dict)else None
                                    if curr and isinstance(curr, dict):
                                        if curr.get('id')==item_id and curr.get('name')==item_name:
                                            actual_item = curr
                                        elif 'items'in curr:
                                            for inv_item in curr.get('items', []):
                                                if isinstance(inv_item, dict)and inv_item.get('id')==item_id and inv_item.get('name')==item_name:
                                                    actual_item = inv_item
                                                    break
                            except(ValueError, IndexError):
                                pass
                        else:
                            for inv_item in eq.get('items', []):
                                if isinstance(inv_item, dict)and inv_item.get('id')==item_id and inv_item.get('name')==item_name:
                                    actual_item = inv_item
                                    break

                if actual_item is None:
                    self._popup_show_info('Error', 'Could not find item in inventory', sound = 'error')
                    return

                def on_consume_complete():
                    try:
                        update_weapon_view()
                    except Exception:
                        pass

                self._consume_item(actual_item, loc, save_data, on_complete = on_consume_complete)

            bframe = customtkinter.CTkFrame(popup, fg_color = 'transparent')
            bframe.pack(fill = 'x', padx = 10, pady = 6)
            customtkinter.CTkButton(bframe, text = 'Use', command = do_consume, width = 120).pack(side = 'left', padx = 6)
            customtkinter.CTkButton(bframe, text = 'Cancel', command = popup.destroy, width = 120).pack(side = 'left', padx = 6)

            try:
                popup.grab_set()
                popup.lift()
                self._safe_focus(popup)
            except Exception:
                pass

        def _show_more_actions():
            try:
                popup = customtkinter.CTkToplevel(self.root)
                popup.title('More Actions')
                popup.geometry('520x420')
                popup.transient(self.root)

                frame = customtkinter.CTkScrollableFrame(popup, fg_color = 'transparent')
                frame.pack(fill = 'both', expand = True, padx = 10, pady = 10)

                def _add(name, cmd, width = 200, height = 44, fg = None):
                    try:

                        def _wrap():
                            try:
                                cmd()
                            except Exception:
                                pass
                            try:
                                popup.destroy()
                            except Exception:
                                pass

                        btn = self._create_sound_button(frame, text = name, command = _wrap, width = width, height = height, font = customtkinter.CTkFont(size = 12))
                        if fg:
                            try:
                                btn.configure(fg_color = fg)
                            except Exception:
                                pass
                        btn.pack(pady = 6)
                        return btn
                    except Exception:
                        pass
                    return None

                if check_clean_btn is not None:
                    _add('Check Cleanliness', check_cleanliness)
                if check_mag_btn is not None:
                    _add('Check Magazine', check_magazine)
                # expose cycle action in More Actions as well
                try:
                    _add('Cycle Action', cycle_bolt)
                except Exception:
                    pass
                if throw_btn is not None:
                    _add('Throw', throw_throwable)
                if manage_attach_btn is not None:
                    _add('Manage Attachments', manage_attachments)

                try:
                    bs_btn = _add('Barrel Swap', _barrel_swap_current)

                    try:
                        w_check = None
                        try:
                            w_check = current_weapon_state.get('weapon')if isinstance(current_weapon_state, dict)else None
                        except Exception:
                            w_check = None
                        if not w_check:
                            w_check = current_weapon
                        if not w_check or not bool((w_check.get('barrel_swap')if isinstance(w_check, dict)else False)):
                            if bs_btn is not None:
                                try:
                                    bs_btn.configure(state = 'disabled')
                                except Exception:
                                    pass
                    except Exception:
                        pass
                except Exception:
                    pass

                try:
                    has_consumables = len(_find_consumables_in_inventory())>0

                    def _wrap_consume():
                        try:
                            use_consumable()
                        except Exception:
                            pass
                        try:
                            popup.destroy()
                        except Exception:
                            pass

                    consume_btn = self._create_sound_button(frame, text = 'Use Consumable', command = _wrap_consume, width = 200, height = 44, font = customtkinter.CTkFont(size = 12))
                    if not has_consumables:
                        consume_btn.configure(state = 'disabled')
                    consume_btn.pack(pady = 6)
                except Exception:
                    pass

                try:
                    b = customtkinter.CTkButton(popup, text = 'Close', command = popup.destroy, width = 120)
                    b.pack(pady = 6)
                except Exception:
                    pass

                try:
                    popup.grab_set()
                    popup.lift()
                    self._safe_focus(popup)
                except Exception:
                    pass
            except Exception:
                pass

        try:
            self._create_sound_button(actions_frame, text = 'More Actions', command = _show_more_actions, width = 150, height = 50, font = customtkinter.CTkFont(size = 14)).pack(side = 'left', padx = 10, pady = 10)
        except Exception:
            pass

        try:
            throw_btn = self._create_sound_button(actions_frame, text = 'Throw', command = throw_throwable, width = 150, height = 50, font = customtkinter.CTkFont(size = 14), fg_color = '#333333', hover_color = '#444444')
        except Exception:
            throw_btn = None
        try:
            manage_attach_btn = self._create_sound_button(
            actions_frame,
            text = "Manage Attachments",
            command = manage_attachments,
            width = 170,
            height = 50,
            font = customtkinter.CTkFont(size = 14)
            )
        except Exception:
            manage_attach_btn = None

        if global_variables.get("devmode", {}).get("value", False):
            devmode_outer_frame = customtkinter.CTkFrame(main_frame)
            devmode_outer_frame.pack(fill = "x", pady =(0, 20))

            devmode_frame = customtkinter.CTkScrollableFrame(devmode_outer_frame, orientation = "horizontal", height = 60, fg_color = "transparent")
            devmode_frame.pack(fill = "x", expand = True)

            customtkinter.CTkLabel(
            devmode_frame,
            text = "DevMode:",
            font = customtkinter.CTkFont(size = 12)
            ).pack(side = "left", padx = 10)

            def get_variant_choices():
                choices =[]
                weapon_obj = current_weapon_state.get("weapon")or {}
                raw_cal = weapon_obj.get("caliber")

                cal = None
                if isinstance(raw_cal, (list, tuple)):
                    cal = raw_cal[0]if raw_cal else None
                elif isinstance(raw_cal, str):
                    cal = raw_cal

                w_sounds = weapon_obj.get("sounds")or weapon_obj.get("sound_folder")or weapon_obj.get("ammo_type")
                if not cal:
                    active_ub = combat_state.get("active_underbarrel")

                    if active_ub and isinstance(active_ub, dict)and active_ub.get("parent_index")==combat_state.get("current_weapon_index"):
                        aid = active_ub.get("accessory_id")
                        aname = active_ub.get("accessory_name")

                        parent_entry = equipped_weapons[combat_state.get("current_weapon_index")]
                        parent_slot = parent_entry.get("slot", "")
                        if "->"in parent_slot:
                            parent_slot = parent_slot.split("->")[0].strip()
                        parent_item = save_data.get("equipment", {}).get(parent_slot)
                        acc = None
                        if parent_item and isinstance(parent_item, dict):
                            for acc_entry in parent_item.get("accessories", [])or[]:
                                cur = acc_entry.get("current")
                                if isinstance(cur, dict):
                                    if aid is not None and cur.get("id")==aid:
                                        acc = cur ;break
                                    if aname and cur.get("name")==aname:
                                        acc = cur ;break
                                else:
                                    try:
                                        if aid is not None and(isinstance(cur, int)or(isinstance(cur, str)and cur.isdigit()))and int(cur)==int(aid):

                                            tables = table_data.get("tables", {})if isinstance(table_data, dict)else {}
                                            for arr in tables.values():
                                                if isinstance(arr, list):
                                                    for it in arr:
                                                        if isinstance(it, dict)and it.get("id")==int(cur):
                                                            acc = it ;break
                                                    if acc:break
                                    except Exception:
                                        pass
                        if acc and isinstance(acc, dict):
                            raw_cal2 = acc.get("caliber")
                            if isinstance(raw_cal2, (list, tuple)):
                                cal = raw_cal2[0]if raw_cal2 else None
                            elif isinstance(raw_cal2, str):
                                cal = raw_cal2
                            if not cal:
                                w_sounds = acc.get("sounds")or acc.get("sound_folder")or acc.get("ammo_type")

                try:
                    dev_cal_var = current_weapon_state.get("dev_caliber_var")
                    if dev_cal_var and hasattr(dev_cal_var, 'get'):
                        sel = dev_cal_var.get()
                        if sel:
                            cal = sel
                except Exception:
                    pass

                ammo_tables = table_data.get("tables", {}).get("ammunition", [])if table_data else[]
                for ammo in ammo_tables:
                    try:

                        ammo_cal = ammo.get("caliber")
                        match_cal = False
                        if cal and ammo_cal:
                            if isinstance(ammo_cal, (list, tuple)):
                                match_cal = any((isinstance(a, str)and a ==cal)for a in ammo_cal)
                            elif isinstance(ammo_cal, str):
                                match_cal =(ammo_cal ==cal)

                        if match_cal:
                            for var in ammo.get("variants", [])or[]:
                                choices.append(var.get("name", "Unknown"))
                            continue

                        if w_sounds and(ammo.get("sounds")==w_sounds or ammo.get("ammo_type")==w_sounds):
                            for var in ammo.get("variants", [])or[]:
                                choices.append(var.get("name", "Unknown"))
                    except Exception:
                        pass
                return choices or["Ball"]

            variant_var = customtkinter.StringVar(value = get_variant_choices()[0])
            customtkinter.CTkLabel(
            devmode_frame,
            text = "Variant:",
            font = customtkinter.CTkFont(size = 12)
            ).pack(side = "left", padx = 5)

            try:

                wpn_for_dev =(current_weapon_state.get("weapon")if isinstance(current_weapon_state, dict)else None)or {}
                raw_cal_list = wpn_for_dev.get("caliber")if isinstance(wpn_for_dev, dict)else None
                calib_values =[]
                if isinstance(raw_cal_list, (list, tuple)):
                    calib_values =[str(x)for x in raw_cal_list if x is not None]
                elif isinstance(raw_cal_list, str):
                    calib_values =[raw_cal_list]

                if not calib_values:
                    calib_values =[]

                caliber_var = customtkinter.StringVar(value =(calib_values[0]if calib_values else ""))

                def _on_caliber_change(val):
                    try:
                        current_weapon_state["dev_caliber_var"]= caliber_var

                        try:
                            new_choices = get_variant_choices()

                            try:
                                if variant_menu:
                                    variant_menu.configure(values = new_choices)
                                    if variant_var.get()not in new_choices:
                                        variant_var.set(new_choices[0])
                            except Exception:
                                try:
                                    variant_menu.set_values(new_choices)
                                    if variant_var.get()not in new_choices:
                                        variant_var.set(new_choices[0])
                                except Exception:
                                    pass
                        except Exception:
                            pass
                    except Exception:
                        pass

                calib_vals_for_widget = calib_values if calib_values else["None"]
                caliber_menu = customtkinter.CTkOptionMenu(devmode_frame, values = calib_vals_for_widget, variable = caliber_var, command = _on_caliber_change, width = 140)
                caliber_menu.pack(side = "left", padx = 5)
                if len(calib_values)<=1:
                    try:
                        caliber_menu.configure(state = "disabled")
                    except Exception:
                        pass
                current_weapon_state["dev_caliber_menu_ref"]= caliber_menu
                current_weapon_state["dev_caliber_var"]= caliber_var
            except Exception:
                logging.exception("Failed to create DevMode caliber menu")

            variant_menu = customtkinter.CTkOptionMenu(
            devmode_frame,
            values = get_variant_choices(),
            variable = variant_var,
            width = 120
            )
            variant_menu.pack(side = "left", padx = 5)

            current_weapon_state["dev_variant_menu_ref"]= variant_menu
            current_weapon_state["dev_variant_var"]= variant_var

            def add_ammo():
                try:
                    current_weapon = current_weapon_state["weapon"]
                    mag_type = current_weapon.get("magazinetype", "Unknown")
                    capacity = current_weapon.get("capacity", 30)

                    caliber_name = caliber_var.get()if caliber_var.get()else current_weapon.get('caliber', ['rnd'])[0]
                    variant_name = variant_var.get()

                    ammo_tables = table_data.get("tables", {}).get("ammunition", [])if table_data else[]
                    ammo_sounds = None
                    ammo_entry = None
                    for ammo in ammo_tables:
                        try:
                            ammo_cal = ammo.get("caliber")
                            if ammo_cal ==caliber_name:
                                ammo_sounds = ammo.get("sounds")
                                ammo_entry = ammo
                                break

                            if isinstance(ammo_cal, (list, tuple))and caliber_name in ammo_cal:
                                ammo_sounds = ammo.get("sounds")
                                ammo_entry = ammo
                                break
                        except Exception:
                            pass

                    dummy_round = {
                    "name":f"{caliber_name} | {variant_name}",
                    "caliber":caliber_name,
                    "variant":variant_name
                    }
                    if ammo_sounds:
                        dummy_round["sounds"]= ammo_sounds

                    if ammo_entry:
                        for var in ammo_entry.get("variants", [])or[]:
                            if var.get("name")==variant_name:
                                if var.get("type"):
                                    dummy_round["type"]= var.get("type")
                                if var.get("pen"):
                                    dummy_round["pen"]= var.get("pen")
                                if var.get("tip"):
                                    dummy_round["tip"]= var.get("tip")
                                if var.get("modifiers"):
                                    dummy_round["modifiers"]= var.get("modifiers")
                                break

                    loaded_mag = {
                    "magazinetype":mag_type,
                    "magazinesystem":current_weapon.get("magazinesystem"),
                    "capacity":capacity,
                    "rounds":[dict(dummy_round)for _ in range(capacity)]
                    }
                    current_weapon["loaded"]= loaded_mag

                    if loaded_mag["rounds"]:
                        current_weapon["chambered"]= loaded_mag["rounds"].pop(0)

                    self._popup_show_info("DevMode Ammo", f"Filled mag({mag_type}) with {capacity} {caliber_name} {variant_name} rounds and chambered one")
                    update_weapon_view()
                except Exception as e:
                    self._popup_show_info("DevMode Error", str(e))

            def devmode_debug():
                try:
                    wpn = current_weapon_state.get("weapon")or {}
                    cal =(wpn.get("caliber")or[])
                    if isinstance(cal, (list, tuple)):
                        cal_val = cal[0]if cal else None
                    else:
                        cal_val = cal
                    w_sounds = wpn.get("sounds")or wpn.get("sound_folder")or wpn.get("ammo_type")
                    ammo_tables = table_data.get("tables", {}).get("ammunition", [])if table_data else[]
                    matches =[]
                    for ammo in ammo_tables:
                        try:
                            if cal_val and ammo.get("caliber")==cal_val:
                                matches.append(ammo.get("name"))
                            elif w_sounds and(ammo.get("sounds")==w_sounds or ammo.get("ammo_type")==w_sounds):
                                matches.append(ammo.get("name"))
                        except Exception:
                            pass

                    msg = f"Weapon: {wpn.get('name')}\ncaliber: {cal_val}\nsounds: {w_sounds}\nMatched ammo: {matches}"
                    self._popup_show_info("DevMode Debug", msg)
                except Exception as e:
                    logging.exception("DevMode debug failed: %s", e)

            customtkinter.CTkButton(devmode_frame, text = "Debug Variants", command = devmode_debug, width = 140).pack(side = "left", padx = 8)

            def add_all_throwables():
                try:

                    found =[]
                    tables = table_data.get("tables", {})if table_data else {}
                    for tname, items in tables.items():
                        if not isinstance(items, list):
                            continue
                        try:
                            for it in items:
                                if not isinstance(it, dict):
                                    continue
                                try:
                                    typ = str(it.get('type', '')).lower()
                                    if typ in('fragmentation', 'smoke', 'stun', '9-bang', '9bang', '9_bang'):
                                        item_copy = it.copy()
                                        item_copy = add_subslots_to_item(item_copy)
                                        found.append(item_copy)
                                except Exception:
                                    pass
                        except Exception:
                            pass

                    if not found:

                        found =[
                        {"name":"Fragmentation Grenade", "type":"fragmentation", "fuse":3},
                        {"name":"Smoke Grenade", "type":"smoke", "fuse":3},
                        {"name":"Stun Grenade", "type":"stun", "fuse":3},
                        {"name":"9-Bang", "type":"9-bang", "fuse":3},
                        ]

                    if not currentsave:
                        self._popup_show_info('DevMode Error', 'No active save to modify.', sound = 'error')
                        return
                    save_path = os.path.join(saves_folder or "", (currentsave or "")+".sldsv")
                    if not os.path.exists(save_path):
                        self._popup_show_info('DevMode Error', f'Save file not found: {save_path}', sound = 'error')
                        return

                    added = 0
                    sd = globals().get('save_data')if 'save_data'in globals()else None
                    logging.debug(f"DevMode Add Throwables: currentsave={currentsave}, save_path={save_path}, in_memory_save_present={isinstance(sd, dict)}")
                    if isinstance(sd, dict):
                        try:
                            before = len(sd.get('hands', {}).get('items', []))if sd.get('hands')else 0
                            sd.setdefault('hands', {})
                            sd['hands'].setdefault('items', [])
                            for itm in found:
                                try:
                                    sd['hands']['items'].append(itm.copy()if isinstance(itm, dict)else itm)
                                    added +=1
                                except Exception:
                                    logging.exception('Failed to append throwable to in-memory hands')
                            after = len(sd.get('hands', {}).get('items', []))
                            logging.debug(f"Added to in-memory hands: before={before}, after={after}, added={added}")

                            try:
                                globals()['save_data']= sd
                            except Exception:
                                pass

                            try:
                                self._save_file(sd)
                            except Exception:
                                logging.exception('Failed to persist save_data after adding throwables')

                            try:
                                if 'save_data'in globals():

                                    outer = globals().get('save_data')
                                    if outer is not sd and isinstance(outer, dict)and isinstance(sd, dict):
                                        outer.clear()
                                        outer.update(sd)
                                        globals()['save_data']= outer
                                        logging.debug('Synchronized global save_data object in-place after in-memory save')
                            except Exception:
                                logging.exception('Failed to synchronize save_data object in-place')
                        except Exception:
                            logging.exception('Failed to add throwables to in-memory save_data')
                    else:

                        try:
                            file_sd = self._read_save_from_path(save_path)
                            if file_sd is None:
                                file_sd = {}
                        except Exception:
                            file_sd = {}
                        try:
                            before = len(file_sd.get('hands', {}).get('items', []))if file_sd.get('hands')else 0
                            file_sd.setdefault('hands', {})
                            file_sd['hands'].setdefault('items', [])
                            for itm in found:
                                try:
                                    file_sd['hands']['items'].append(itm.copy()if isinstance(itm, dict)else itm)
                                    added +=1
                                except Exception:
                                    logging.exception('Failed to append throwable to save file hands')
                            after = len(file_sd.get('hands', {}).get('items', []))
                            logging.debug(f"Added to file hands: before={before}, after={after}, added={added}")

                            try:
                                self._save_file(file_sd)
                            except Exception:
                                logging.exception('Failed to persist save file after adding throwables')

                            try:
                                loaded = self._load_file(currentsave)
                                if loaded and isinstance(loaded, dict):

                                    globals()['save_data']= loaded
                                    logging.debug('Reloaded save into memory after DevMode add_all_throwables')

                                    try:

                                        if isinstance(save_data, dict):
                                            save_data.clear()
                                            save_data.update(loaded)
                                            logging.debug('Updated enclosing save_data object in-place after reload')
                                    except Exception:
                                        logging.debug('No enclosing save_data to update in-place or update failed')
                            except Exception:
                                logging.exception('Failed to reload save into memory after adding throwables')
                        except Exception:
                            logging.exception('Failed to add throwables to save file')

                    self._popup_show_info('DevMode', f'Added {added} throwables to hands', sound = 'success')
                    try:
                        update_weapon_view()
                    except Exception:
                        pass
                except Exception as e:
                    logging.exception('Failed to add throwables: %s', e)
                    self._popup_show_info('DevMode Error', str(e), sound = 'error')

            customtkinter.CTkButton(devmode_frame, text = "Add All Throwables", command = add_all_throwables, width = 160).pack(side = "left", padx = 8)

            def reset_temperature():
                try:
                    current_weapon = current_weapon_state["weapon"]
                    weapon_id = str(current_weapon.get("id"))
                    combat_state["barrel_temperatures"][weapon_id]= combat_state["ambient_temperature"]
                    self._popup_show_info("DevMode Temp", f"Barrel temperature reset to ambient")
                    update_weapon_view()
                except Exception as e:
                    self._popup_show_info("DevMode Error", str(e))

            def reset_cleanliness():
                try:
                    current_weapon = current_weapon_state["weapon"]
                    weapon_id = str(current_weapon.get("id"))
                    combat_state["barrel_cleanliness"][weapon_id]= 100
                    self._popup_show_info("DevMode Clean", f"Barrel cleanliness reset to 100%")
                    update_weapon_view()
                except Exception as e:
                    self._popup_show_info("DevMode Error", str(e))

            def add_individual_rounds():

                try:
                    current_weapon = current_weapon_state["weapon"]
                    raw_cal = current_weapon.get("caliber", [])or[]
                    if isinstance(raw_cal, (list, tuple)):
                        caliber = raw_cal[0]if raw_cal else None
                    else:
                        caliber = raw_cal

                    ammo_tables = table_data.get("tables", {}).get("ammunition", [])if table_data else[]
                    ammo_def = None
                    for a in ammo_tables:
                        try:
                            a_cal = a.get("caliber")

                            if caliber is not None:
                                if isinstance(a_cal, (list, tuple))and isinstance(caliber, str)and caliber in a_cal:
                                    ammo_def = a ;break
                                if isinstance(a_cal, str)and isinstance(caliber, str)and a_cal ==caliber:
                                    ammo_def = a ;break

                            a_id = a.get("id")
                            if a_id is not None and str(a_id)==str(caliber):
                                ammo_def = a ;break

                            w_sounds = None
                            if isinstance(caliber, str):
                                w_sounds = caliber
                            if w_sounds and(a.get("sounds")==w_sounds or a.get("ammo_type")==w_sounds):
                                ammo_def = a ;break
                        except Exception:
                            continue

                    if not ammo_def:
                        self._popup_show_info("DevMode Error", f"No ammunition definition found for {repr(caliber)}")
                        return

                    variant_name = variant_var.get()
                    variant_info = None
                    for var in ammo_def.get("variants", []):
                        if var.get("name")==variant_name:
                            variant_info = var
                            break
                    if not variant_info and ammo_def.get("variants"):
                        variant_info = ammo_def["variants"][0]

                    single_round = {
                    "name":f"{caliber} | {variant_name}",
                    "caliber":caliber,
                    "variant":variant_name,
                    "weight":ammo_def.get("weight", 0.01),
                    "value":ammo_def.get("value", 0),
                    "sounds":ammo_def.get("sounds", ""),
                    "description":f"{caliber} - {variant_name}"
                    }
                    if variant_info:
                        if variant_info.get("type"):
                            single_round["type"]= variant_info.get("type")
                        if variant_info.get("pen"):
                            single_round["pen"]= variant_info.get("pen")
                        if variant_info.get("tip"):
                            single_round["tip"]= variant_info.get("tip")
                        if variant_info.get("modifiers"):
                            single_round["modifiers"]= variant_info.get("modifiers")

                    hands = save_data.get("hands", {})
                    if "items"not in hands or not isinstance(hands.get("items"), list):
                        hands["items"]=[]
                        save_data["hands"]= hands

                    ammo_item = dict(single_round)
                    ammo_item["quantity"]= 500
                    hands["items"].append(ammo_item)

                    self._popup_show_info("DevMode Ammo", f"Added 500 rounds(stacked) to hands")
                    update_weapon_view()
                except Exception as e:
                    logging.error(f"Error adding rounds: {e}")
                    self._popup_show_info("DevMode Error", str(e))

            def add_individual_magazine():

                try:

                    current_weapon = current_weapon_state.get("weapon", {})
                    mag_system = current_weapon.get("magazinesystem")or current_weapon.get("submagazinesystem")or current_weapon.get("submagazinetype")

                    if not mag_system:
                        self._popup_show_info("DevMode Error", "Weapon doesn't use detachable magazines")
                        return

                    magazines_table = table_data.get("tables", {}).get("magazines", [])
                    compatible_mags =[m for m in magazines_table if(m.get("magazinesystem")==mag_system or m.get("magazinetype")==mag_system)]

                    if not compatible_mags:
                        self._popup_show_info("DevMode Error", f"No magazines in table for {mag_system}")
                        return

                    mag_template = compatible_mags[0]
                    new_mag = {
                    'name':mag_template.get('name'),
                    'id':mag_template.get('id'),
                    'magazinetype':mag_template.get('magazinetype', 'Unknown'),
                    'magazinesystem':mag_system,
                    'capacity':mag_template.get('capacity', 30),
                    'rounds':[]
                    }

                    save_data.setdefault('hands', {}).setdefault('items', []).append(new_mag)
                    update_weapon_view()
                    self._popup_show_info('DevMode Ammo', f"Added {new_mag.get('name')} to hands(empty)")
                except Exception as e:
                    logging.error(f"Error adding magazine: {e}")
                    self._popup_show_info("DevMode Error", str(e))

            def add_belt():
                try:
                    self._popup_show_info("DevMode", "Belt functionality removed.")
                    return
                except Exception:
                    return

            self._create_sound_button(
            devmode_frame,
            text = "Fill Magazine",
            command = add_ammo,
            width = 120,
            height = 40,
            font = customtkinter.CTkFont(size = 12),
            fg_color = "#8B4513",
            hover_color = "#A0522D"
            ).pack(side = "left", padx = 5, pady = 10)

            self._create_sound_button(
            devmode_frame,
            text = "Add Rounds",
            command = add_individual_rounds,
            width = 120,
            height = 40,
            font = customtkinter.CTkFont(size = 12),
            fg_color = "#8B4513",
            hover_color = "#A0522D"
            ).pack(side = "left", padx = 5, pady = 10)

            self._create_sound_button(
            devmode_frame,
            text = "Add Magazine",
            command = add_individual_magazine,
            width = 120,
            height = 40,
            font = customtkinter.CTkFont(size = 12),
            fg_color = "#8B4513",
            hover_color = "#A0522D"
            ).pack(side = "left", padx = 5, pady = 10)

            self._create_sound_button(
            devmode_frame,
            text = "Add Belt",
            command = add_belt,
            width = 120,
            height = 40,
            font = customtkinter.CTkFont(size = 12),
            fg_color = "#8B4513",
            hover_color = "#A0522D"
            ).pack(side = "left", padx = 5, pady = 10)

            self._create_sound_button(
            devmode_frame,
            text = "Reset Temp",
            command = reset_temperature,
            width = 120,
            height = 40,
            font = customtkinter.CTkFont(size = 12),
            fg_color = "#8B4513",
            hover_color = "#A0522D"
            ).pack(side = "left", padx = 5, pady = 10)

            self._create_sound_button(
            devmode_frame,
            text = "Reset Clean",
            command = reset_cleanliness,
            width = 120,
            height = 40,
            font = customtkinter.CTkFont(size = 12),
            fg_color = "#8B4513",
            hover_color = "#A0522D"
            ).pack(side = "left", padx = 5, pady = 10)

        list_label = customtkinter.CTkLabel(
        main_frame,
        text = "Available Weapons",
        font = customtkinter.CTkFont(size = 14, weight = "bold")
        )
        list_label.pack(pady =(10, 5))

        list_frame = customtkinter.CTkFrame(main_frame)
        list_frame.pack(fill = "both", padx = 10, pady =(0, 20))

        for idx, weapon_data in enumerate(equipped_weapons):
            weapon_item = weapon_data["item"]
            is_selected =(idx ==combat_state["current_weapon_index"])

            weapon_btn_frame = customtkinter.CTkFrame(
            list_frame,
            fg_color = "#2D3B45"if is_selected else "#1F2B35"
            )
            weapon_btn_frame.pack(fill = "x", pady = 2)

            weapon_label = customtkinter.CTkLabel(
            weapon_btn_frame,
            text = f"{weapon_data['display_name']} - {weapon_data['slot']}",
            font = customtkinter.CTkFont(size = 12),
            text_color = "#00FF00"if is_selected else "#FFFFFF"
            )
            weapon_label.pack(side = "left", padx = 10, pady = 5)

            def switch_to(w_idx = idx, w_item = weapon_item):

                try:
                    self._play_firearm_sound(w_item, "equip")
                except Exception:
                    pass
                combat_state["current_weapon_index"]= w_idx
                refresh_weapon_display()

            self._create_sound_button(
            weapon_btn_frame,
            text = "Select",
            command = switch_to,
            width = 100,
            height = 30,
            font = customtkinter.CTkFont(size = 11)
            ).pack(side = "right", padx = 10, pady = 5)

        poll_cancel = None

        def poll_temperature_update():

            nonlocal poll_cancel
            try:
                wpn = current_weapon_state["weapon"]
                weapon_id = str(wpn.get("id"))
                current_temp = combat_state.get("barrel_temperatures", {}).get(weapon_id)

                if current_temp is not None and current_temp !=combat_state.get("ambient_temperature", 70):
                    now_ts = time.time()
                    last_used = combat_state.get("weapon_last_used", {}).get(weapon_id)
                    if last_used is None and weapon_id in combat_state.get("barrel_temperatures", {}):

                        assumed_interval = combat_state.get("temp_poll_interval", 15)
                        last_used = now_ts -float(assumed_interval)
                    elapsed = max(0.0, now_ts -last_used)if last_used is not None else 0.0

                    if elapsed >0:
                        ambient = combat_state.get("ambient_temperature", 70)
                        default_k = math.log(2.0)/300.0
                        magic_k = math.log(2.0)/600.0
                        magicsys_local = str(wpn.get("magicsoundsystem")or "").lower()
                        is_magic_local =(str(wpn.get("type")or "").lower()=="magic")or(magicsys_local in("hg", "at", "mg", "rf"))
                        k = magic_k if is_magic_local else default_k
                        new_temp = ambient +(current_temp -ambient)*math.exp(-k *elapsed)
                        low = min(ambient, current_temp)
                        high = max(ambient, current_temp)
                        new_temp = min(max(new_temp, low), high)
                        combat_state["barrel_temperatures"][weapon_id]= new_temp
                        combat_state.setdefault("weapon_last_used", {})[weapon_id]= now_ts

                        update_weapon_view()
                        logging.debug(f"Temperature cooled from {current_temp:.2f}Â°F to {new_temp:.2f}Â°F")

                        try:
                            cookoff_thresh = float(combat_state.get("cookoff_temp", 1500))
                        except Exception:
                            cookoff_thresh = 1500.0
                        if new_temp >=cookoff_thresh:

                            per_sec_prob = min(0.02, max(0.0, (new_temp -cookoff_thresh)/10000.0))
                            cookoff_prob = 1.0 -((1.0 -per_sec_prob)**max(1.0, elapsed))
                            if random.random()<cookoff_prob:
                                try:

                                    fired = False
                                    if isinstance(wpn, dict)and wpn.get("chambered"):
                                        wpn["chambered"]= None
                                        fired = True
                                    elif isinstance(wpn, dict)and wpn.get("loaded")and isinstance(wpn.get("loaded"), dict)and wpn["loaded"].get("rounds"):
                                        try:
                                            wpn["loaded"]["rounds"].pop(0)
                                            fired = True
                                        except Exception:
                                            fired = False
                                    elif isinstance(wpn, dict)and wpn.get("rounds"):
                                        try:
                                            wpn["rounds"].pop(0)
                                            fired = True
                                        except Exception:
                                            fired = False

                                    if fired:
                                        try:

                                            self._play_firearm_sound(wpn, "fire")
                                        except Exception:
                                            pass

                                        try:
                                            temp_gain = float(wpn.get("temp_gain_per_shot", wpn.get("temp_gain", 7)))
                                        except Exception:
                                            temp_gain = 7.0
                                        if self._check_weapon_suppressed(wpn):
                                            temp_gain *=1.5
                                        new_temp = new_temp +(temp_gain *0.5)
                                        combat_state["barrel_temperatures"][weapon_id]= new_temp
                                        combat_state.setdefault("weapon_last_used", {})[weapon_id]= now_ts
                                        update_weapon_view()
                                        logging.warning("Cook-off occurred for weapon %s at %.1fÂ°F", wpn.get("name", weapon_id), new_temp)
                                except Exception:
                                    logging.exception("Cook-off handling failed")

                poll_cancel = self.root.after(15000, poll_temperature_update)
            except Exception as e:
                logging.debug(f"Temperature polling error: {e}")

                poll_cancel = self.root.after(15000, poll_temperature_update)

        poll_cancel = self.root.after(15000, poll_temperature_update)

        def exit_combat():

            nonlocal poll_cancel, reload_pending_id

            if poll_cancel:
                try:
                    self.root.after_cancel(poll_cancel)
                except Exception:
                    pass

            try:
                if reload_pending_id and reload_pending_id[0]:
                    try:
                        self.root.after_cancel(reload_pending_id[0])
                    except Exception:
                        pass
                    reload_pending_id[0]= None
            except Exception:
                pass

            try:
                for k in("<Left>", "<Right>", "<space>", "r", "R"):
                    try:
                        self.root.unbind(k)
                    except Exception:
                        pass
            except Exception:
                pass

            self._save_combat_state(save_data)

            try:
                prev = current_weapon_state.get('prev_tk_scaling')
                if prev is not None:
                    try:
                        self.root.tk.call('tk', 'scaling', float(prev))
                    except Exception:
                        pass
            except Exception:
                pass

            # Generate and show combat report only if enabled in the active table
            try:
                tbl_addl = globals().get('table_data', {}).get('additional_settings', {})
                combat_reports_enabled = bool(tbl_addl.get('combat_repots') or tbl_addl.get('combat_reports'))
            except Exception:
                combat_reports_enabled = False

            if combat_reports_enabled:
                try:
                    report = self._generate_combat_report_data(save_data)
                    if report and report.get('rounds_fired', 0) > 0:
                        self._clear_window()
                        self._build_main_menu()
                        self._show_combat_report_animation(report)
                        return
                except Exception:
                    logging.exception('Failed to generate/show combat report on exit')

            self._clear_window()
            self._build_main_menu()

        self._create_sound_button(
        main_frame,
        text = "Exit Combat Mode",
        command = exit_combat,
        fg_color = "#8B0000",
        hover_color = "#A52A2A",
        height = 50,
        font = customtkinter.CTkFont(size = 14)
        ).pack(pady = 10)

        try:

            main_frame.update_idletasks()
            req_w = main_frame.winfo_reqwidth()or 1
            req_h = main_frame.winfo_reqheight()or 1
            sw = self.root.winfo_screenwidth()or 1
            sh = self.root.winfo_screenheight()or 1
            margin = 40
            if req_w +margin >sw or req_h +margin >sh:
                scale_w = float(sw -margin)/float(req_w)
                scale_h = float(sh -margin)/float(req_h)
                new_scale = min(scale_w, scale_h, 1.0)

                new_scale = max(new_scale, 0.6)
                try:
                    prev_scale = float(self.root.tk.call('tk', 'scaling'))
                except Exception:
                    prev_scale = 1.0

                try:
                    current_weapon_state['prev_tk_scaling']= prev_scale
                except Exception:
                    pass
                try:
                    self.root.tk.call('tk', 'scaling', new_scale)
                    main_frame.update_idletasks()
                except Exception:
                    pass
        except Exception:
            pass

        self._save_combat_state(save_data)
        self._save_combat_state(save_data)

    def _get_equipped_weapons(self, save_data, table_data):

        weapons =[]
        import copy

        def _resolve_table_item(tid):
            try:

                tables = table_data.get("tables", {})if isinstance(table_data, dict)else {}
                for tname, arr in tables.items():
                    if isinstance(arr, list):
                        for it in arr:
                            if isinstance(it, dict)and it.get("id")==tid:
                                return copy.deepcopy(it)
            except Exception:
                pass
            return None

        for slot_name, item in save_data.get("equipment", {}).items():
            if item and isinstance(item, dict)and item.get("firearm"):
                weapons.append({
                "item":item,
                "slot":slot_name,
                "display_name":item.get("name", "Unknown Weapon")
                })

            if item and isinstance(item, dict)and "subslots"in item:
                for subslot in item["subslots"]:
                    if subslot.get("current")and isinstance(subslot.get("current"), dict)and subslot["current"].get("firearm"):
                        weapons.append({
                        "item":subslot["current"],
                        "slot":f"{slot_name} -> {subslot['name']}",
                        "display_name":subslot["current"].get("name", "Unknown Weapon")
                        })

            try:
                if item and isinstance(item, dict)and item.get("accessories"):
                    for acc in(item.get("accessories")or[]):
                        cur = acc.get("current")
                        resolved = None
                        if cur and isinstance(cur, dict):
                            resolved = cur
                        else:

                            try:
                                if isinstance(cur, int)or(isinstance(cur, str)and cur.isdigit()):
                                    tid = int(cur)
                                    resolved = _resolve_table_item(tid)
                            except Exception:
                                resolved = None

                        if resolved and isinstance(resolved, dict)and resolved.get("underbarrel_weapon"):
                            weapons.append({
                            "item":resolved,
                            "slot":f"{slot_name} -> {acc.get('name', 'Underbarrel')}",
                            "display_name":resolved.get("name", "Underbarrel Weapon"),
                            "underbarrel":True,
                            "parent_slot":slot_name,
                            "underbarrel_platform":resolved.get("underbarrel_platform")or resolved.get("platform")
                            })
            except Exception:
                pass

        return weapons

    def _apply_item_overrides(self, weapon):

        import copy

        MISSING = object()

        applied = weapon.get("_applied_overrides", {})or {}
        if applied:
            try:
                logging.info("_apply_item_overrides: restoring previous applied overrides keys=%s for weapon id=%s", list(applied.keys()), weapon.get('id'))
            except Exception:
                pass
        for k, orig in list(applied.items()):
            try:
                if orig is MISSING:
                    if k in weapon:
                        del weapon[k]
                else:
                    weapon[k]= orig
            except Exception:

                pass

        weapon["_applied_overrides"]= {}

        def _resolve_table_current(cur_val):

            if cur_val and isinstance(cur_val, dict):
                return cur_val
            try:
                if isinstance(cur_val, int)or(isinstance(cur_val, str)and str(cur_val).isdigit()):
                    tid = int(cur_val)
                else:
                    return None
            except Exception:
                return None

            try:
                tdata = globals().get('table_data')
                if isinstance(tdata, dict):
                    tables = tdata.get('tables', {})
                    for arr in tables.values():
                        if isinstance(arr, list):
                            for it in arr:
                                if isinstance(it, dict)and it.get('id')==tid:
                                    return it
            except Exception:
                pass

            try:
                import json, os, glob
                table_files = sorted(glob.glob(os.path.join('tables', f"*{global_variables.get('table_extension', '.sldtbl')}")))
                for tf in table_files:
                    try:
                        with open(tf, 'r', encoding = 'utf-8')as fh:
                            td = json.load(fh)
                    except Exception:
                        continue
                    for arr in td.get('tables', {}).values():
                        if isinstance(arr, list):
                            for it in arr:
                                if isinstance(it, dict)and it.get('id')==tid:
                                    return it
            except Exception:
                pass

            return None

        for acc in weapon.get("accessories", [])or[]:
            cur_raw = acc.get("current")
            cur = _resolve_table_current(cur_raw)if cur_raw is not None else None

            if cur and isinstance(cur, dict):
                try:
                    logging.debug("_apply_item_overrides: found accessory for overrides: id=%s name=%s on weapon id=%s", cur.get('id'), cur.get('name'), weapon.get('id'))
                except Exception:
                    pass
                overrides = cur.get("overrides")or {}
                if isinstance(overrides, dict):
                    for k, v in overrides.items():

                        if k not in weapon.get("_applied_overrides", {}):
                            orig = weapon.get(k, MISSING)
                            weapon.setdefault("_applied_overrides", {})[k]= orig
                            try:
                                logging.debug("_apply_item_overrides: recording original value for key=%s orig=%s", k, orig)
                            except Exception:
                                pass

                        try:
                            weapon[k]= copy.deepcopy(v)
                        except Exception:
                            weapon[k]= v
                        try:
                            logging.debug("_apply_item_overrides: applied override key=%s value=%s from accessory id=%s", k, v, cur.get('id'))
                        except Exception:
                            pass

        try:
            agg = {"stats":{}}
            for acc in weapon.get("accessories", [])or[]:
                cur = _resolve_table_current(acc.get("current"))if acc.get("current")is not None else None

                def _wavelength_allows(item):
                    try:
                        if not item or not isinstance(item, dict):
                            return True
                        wl = item.get("wavelength")
                        if not wl:
                            return True
                        if isinstance(wl, str):
                            if wl.lower()in("infrared", "ir", "infra-red"):

                                try:
                                    cs = globals().get('combat_state')or {}
                                    return bool(cs.get('nvg_active'))
                                except Exception:
                                    return False

                            return True

                        return True
                    except Exception:
                        return True

                if cur and isinstance(cur, dict):
                    mods = cur.get("modifiers")or {}
                    if isinstance(mods, dict):
                        stats = mods.get("stats")or {}
                        if isinstance(stats, dict):

                                if _wavelength_allows(cur):
                                    for sname, sval in stats.items():
                                        try:
                                            agg["stats"][sname]= agg["stats"].get(sname, 0)+(int(sval)if isinstance(sval, (int, float))else 0)
                                        except Exception:
                                            pass

                    try:
                        modes = cur.get("modes")or[]
                        if isinstance(modes, list)and modes:
                            mode_index = acc.get("_mode_index")
                            if mode_index is None:

                                mode_index = acc.get("mode_index")
                            try:
                                mi = int(mode_index)if mode_index is not None else 0
                            except Exception:
                                mi = 0
                            mi = max(0, min(mi, len(modes)-1))
                            mode = modes[mi]
                            if isinstance(mode, dict):
                                mm = mode.get("modifiers")or {}
                                if isinstance(mm, dict):
                                    mstats = mm.get("stats")or {}
                                    if isinstance(mstats, dict):

                                                if _wavelength_allows(mode):
                                                    for sname, sval in mstats.items():
                                                        try:
                                                            agg["stats"][sname]= agg["stats"].get(sname, 0)+(int(sval)if isinstance(sval, (int, float))else 0)
                                                        except Exception:
                                                            pass

                                try:
                                    mode_overrides = mode.get("overrides")if isinstance(mode, dict)else None
                                    if isinstance(mode_overrides, dict):
                                        for k, v in mode_overrides.items():
                                            if k not in weapon.get("_applied_overrides", {}):
                                                orig = weapon.get(k, MISSING)
                                                weapon.setdefault("_applied_overrides", {})[k]= orig
                                                try:
                                                    logging.debug("_apply_item_overrides: recording original value for key=%s orig=%s(mode override)", k, orig)
                                                except Exception:
                                                    pass
                                            try:
                                                weapon[k]= copy.deepcopy(v)
                                            except Exception:
                                                weapon[k]= v
                                            try:
                                                logging.debug("_apply_item_overrides: applied mode override key=%s value=%s from accessory id=%s", k, v, cur.get('id'))
                                            except Exception:
                                                pass
                                except Exception:
                                    pass
                    except Exception:

                        pass
            weapon["_active_modifiers"]= agg
        except Exception:

            try:
                weapon["_active_modifiers"]= {"stats":{}}
            except Exception:
                pass

        try:
            wid = str(weapon.get("id"))
            act = weapon.get("action")
            acc_names =[]
            for a in weapon.get("accessories", [])or[]:
                try:
                    cur = a.get("current")
                    if cur and isinstance(cur, dict):
                        acc_names.append(cur.get("name")or str(cur.get("id")or "?"))
                except Exception:
                    pass
            logging.debug("_apply_item_overrides: weapon id=%s action=%s installed_attachments=%s", wid, act, acc_names)
        except Exception:
            pass

    def _display_weapon_details(self, parent, weapon, combat_state, save_data, table_data, current_weapon_state = None):

        detail_frame = customtkinter.CTkFrame(parent)
        detail_frame.pack(fill = "both", expand = True, padx = 10, pady = 10)

        name_label = customtkinter.CTkLabel(
        detail_frame,
        text = weapon.get("name", "Unknown Weapon"),
        font = customtkinter.CTkFont(size = 16, weight = "bold")
        )
        name_label.pack(pady = 5)

        stats_text = f"Platform: {weapon.get('platform', 'Unknown')}\n"
        stats_text +=f"Caliber: {', '.join(weapon.get('caliber', ['Unknown']))}\n"
        stats_text +=f"Action: {', '.join(weapon.get('action', ['Unknown']))}\n"
        if weapon.get("burst_cyclic"):
            stats_text +=f"Cyclic Rate: {weapon.get('cyclic', 0)} RPM({weapon.get('burst_cyclic', 0)} RPM burst)\n"
        else:
            stats_text +=f"Cyclic Rate: {weapon.get('cyclic', 0)} RPM\n"
        stats_text +=f"Magazine Type: {weapon.get('magazinetype', 'Unknown')}\n"

        if weapon.get("magazinesystem"):
            stats_text +=f"Magazine System: {weapon.get('magazinesystem')}\n"

        if weapon.get("capacity"):
            stats_text +=f"Capacity: {weapon.get('capacity')}\n"

        customtkinter.CTkLabel(
        detail_frame,
        text = stats_text,
        font = customtkinter.CTkFont(size = 12),
        justify = "left"
        ).pack(pady = 5)

        try:
            def _resolve_current(cur):

                if isinstance(cur, dict):
                    return cur
                try:
                    if isinstance(cur, int)or(isinstance(cur, str)and cur.isdigit()):
                        tid = int(cur)
                        tables = table_data.get("tables", {})if isinstance(table_data, dict)else {}
                        for arr in tables.values():
                            if isinstance(arr, list):
                                for it in arr:
                                    if isinstance(it, dict)and it.get("id")==tid:
                                        return it
                except Exception:
                    pass
                return None

            active = combat_state.get("active_underbarrel")

            try:
                equipped_weapons = self._get_equipped_weapons(save_data, table_data)
            except Exception:
                equipped_weapons =[]
            is_displaying_ub = False
            resolved_acc_for_display = None
            if active and isinstance(active, dict)and active.get("parent_index")==combat_state.get("current_weapon_index"):

                aid = active.get("accessory_id")
                aname = active.get("accessory_name")
                parent_slot = equipped_weapons[combat_state.get("current_weapon_index")].get("slot", "")
                if "->"in parent_slot:
                    parent_slot = parent_slot.split("->")[0].strip()
                parent_item = save_data.get("equipment", {}).get(parent_slot)
                if parent_item and isinstance(parent_item, dict):
                    for acc_entry in parent_item.get("accessories", [])or[]:
                        cur = acc_entry.get("current")
                        if isinstance(cur, dict):
                            if aid is not None and cur.get("id")==aid:
                                resolved_acc_for_display = cur ;break
                            if aname and cur.get("name")==aname:
                                resolved_acc_for_display = cur ;break
                        else:
                            try:
                                if aid is not None and(isinstance(cur, int)or(isinstance(cur, str)and cur.isdigit()))and int(cur)==int(aid):
                                    tables = table_data.get("tables", {})if isinstance(table_data, dict)else {}
                                    for arr in tables.values():
                                        if isinstance(arr, list):
                                            for it in arr:
                                                if isinstance(it, dict)and it.get("id")==int(cur):
                                                    resolved_acc_for_display = it ;break
                                            if resolved_acc_for_display:break
                            except Exception:
                                pass

                if not resolved_acc_for_display:
                    for sub in parent_item.get("subslots", [])or[]:
                        try:
                            logging.info("Checking parent subslot '%s' for active accessory", sub.get("name"))
                        except Exception:
                            pass
                        sub_cur = sub.get("current")if isinstance(sub, dict)else None
                        if not sub_cur or not isinstance(sub_cur, dict):
                            continue
                        for acc_entry in sub_cur.get("accessories", [])or[]:
                            cur = acc_entry.get("current")
                            if isinstance(cur, dict):
                                if aid is not None and cur.get("id")==aid:
                                    resolved_acc_for_display = cur ;break
                                if aname and cur.get("name")==aname:
                                    resolved_acc_for_display = cur ;break
                            else:
                                try:
                                    if aid is not None and(isinstance(cur, int)or(isinstance(cur, str)and cur.isdigit()))and int(cur)==int(aid):
                                        tables = table_data.get("tables", {})if isinstance(table_data, dict)else {}
                                        for arr in tables.values():
                                            if isinstance(arr, list):
                                                for it in arr:
                                                    if isinstance(it, dict)and it.get("id")==int(cur):
                                                        resolved_acc_for_display = it ;break
                                                if resolved_acc_for_display:break
                                except Exception:
                                    pass
                if resolved_acc_for_display and isinstance(resolved_acc_for_display, dict):
                    try:
                        logging.info("Resolved active accessory for display: id=%s name=%s", resolved_acc_for_display.get("id"), resolved_acc_for_display.get("name"))
                    except Exception:
                        pass
                    is_displaying_ub = True

            try:
                logging.info("Underbarrel display decision: is_displaying_ub=%s resolved=%s active=%s", is_displaying_ub, getattr(resolved_acc_for_display, 'get', lambda k:None)('name')if isinstance(resolved_acc_for_display, dict)else resolved_acc_for_display, active)
            except Exception:
                pass

            if is_displaying_ub:
                def _switch_to_parent():
                    try:

                        ub = resolved_acc_for_display
                        ub_pf = ub.get("underbarrel_platform")or ub.get("platform")if isinstance(ub, dict)else None
                        if ub_pf:
                            wf = os.path.join("sounds", "firearms", "weaponsounds", str(ub_pf).lower())
                            candidates = glob.glob(os.path.join(wf, "unselect*.ogg"))+glob.glob(os.path.join(wf, "holster*.ogg"))
                            if candidates:
                                self._safe_sound_play("", random.choice(candidates), block = True)

                        combat_state.pop("active_underbarrel", None)
                        try:
                            logging.info("Cleared active_underbarrel for parent_index=%s", combat_state.get("current_weapon_index"))
                        except Exception:
                            pass
                        try:
                            self._save_combat_state(save_data)
                        except Exception:
                            pass
                        try:
                            self._open_combat_mode_tool()
                        except Exception:
                            pass
                    except Exception:
                        pass

                customtkinter.CTkButton(detail_frame, text = "Switch to Parent", command = _switch_to_parent, width = 160).pack(pady = 6)
            else:

                ub_found = None
                try:
                    logging.debug("Underbarrel detection: weapon_id=%s accessories=%s", weapon.get("id"), weapon.get("accessories"))
                except Exception:
                    pass
                for acc in weapon.get("accessories", [])or[]:
                    cur = acc.get("current")
                    resolved = _resolve_current(cur)
                    try:
                        logging.debug("Resolving accessory current=%s -> resolved=%s", repr(cur), getattr(resolved, 'get', lambda k, d = None:None)('id', resolved))
                    except Exception:
                        logging.debug("Resolving accessory current=%s -> resolved=%s", repr(cur), str(resolved))
                    if resolved and isinstance(resolved, dict)and resolved.get("underbarrel_weapon"):
                        ub_found = resolved
                        break

                if ub_found:
                    def _switch_to_underbarrel():
                        try:

                            ub_pf = ub_found.get("underbarrel_platform")or ub_found.get("platform")
                            played = False
                            if ub_pf:
                                wf = os.path.join("sounds", "firearms", "weaponsounds", str(ub_pf).lower())
                                candidates = glob.glob(os.path.join(wf, "select*.ogg"))+glob.glob(os.path.join(wf, "draw*.ogg"))
                                if candidates:
                                    self._safe_sound_play("", random.choice(candidates), block = False)
                                    played = True
                            if not played:
                                try:
                                    self._play_firearm_sound(ub_found, "equip")
                                except Exception:
                                    pass

                            combat_state["active_underbarrel"]= {
                            "parent_index":combat_state.get("current_weapon_index"),
                            "accessory_id":ub_found.get("id")if isinstance(ub_found, dict)else None,
                            "accessory_name":ub_found.get("name")if isinstance(ub_found, dict)else None
                            }
                            try:
                                logging.debug("Set active_underbarrel: parent_index=%s accessory_id=%s accessory_name=%s", combat_state.get("current_weapon_index"), ub_found.get("id"), ub_found.get("name"))
                            except Exception:
                                pass
                            try:
                                self._save_combat_state(save_data)
                            except Exception:
                                pass
                            try:
                                self._open_combat_mode_tool()
                            except Exception:
                                pass
                        except Exception:
                            pass

                    customtkinter.CTkButton(detail_frame, text = "Switch to Underbarrel", command = _switch_to_underbarrel, width = 160).pack(pady = 6)
        except Exception:
            pass

        weapon_id = weapon.get("id")
        temperature = combat_state.get("barrel_temperatures", {}).get(str(weapon_id), combat_state["ambient_temperature"])
        cleanliness = combat_state.get("barrel_cleanliness", {}).get(str(weapon_id), 100)

        has_hud = self._check_for_hud(save_data)

        def _has_equipped_item(save_data, target_id):
            try:
                for slot_name, item in save_data.get("equipment", {}).items():
                    if not item or not isinstance(item, dict):
                        continue

                    if item.get("id")==target_id:
                        return True

                    for sub in(item.get("items")or[]):
                        try:
                            if sub and isinstance(sub, dict)and sub.get("id")==target_id:
                                return True
                        except Exception:
                            pass

                    for subslot in(item.get("subslots")or[]):
                        try:
                            curr = subslot.get("current")
                            if curr and isinstance(curr, dict):
                                if curr.get("id")==target_id:
                                    return True
                                for s in(curr.get("items")or[]):
                                    try:
                                        if s and isinstance(s, dict)and s.get("id")==target_id:
                                            return True
                                    except Exception:
                                        pass
                        except Exception:
                            pass
            except Exception:
                return False
            return False

        has_csad = _has_equipped_item(save_data, 37)

        gunlink_on_weapon = False
        try:
            for acc in(weapon.get("accessories")or[]):
                if not acc or not isinstance(acc, dict):
                    continue
                cur = acc.get("current")

                try:
                    if isinstance(cur, int)and cur in(85, 94):
                        gunlink_on_weapon = True
                        break
                except Exception:
                    pass

                try:
                    if isinstance(cur, dict):
                        cid = cur.get("id")
                        cname = str(cur.get("name")or "").lower()
                        if(isinstance(cid, int)and cid in(85, 94))or("gun link"in cname):
                            gunlink_on_weapon = True
                            break
                except Exception:
                    pass
        except Exception:
            gunlink_on_weapon = False

        temp_exact = bool(has_hud or has_csad)
        clean_exact = bool(has_hud or(has_csad and gunlink_on_weapon))
        ammo_exact = bool(has_hud or(has_csad and gunlink_on_weapon))

        if appearance_settings["units"]=="metric":
            display_temp =(temperature -32)*5 /9
            temp_unit = "Â°C"
        else:
            display_temp = temperature
            temp_unit = "Â°F"

        if temperature >=1200:
            temp_color = "#FF5E00"
        elif temperature >=1000:
            temp_color = "#FF3000"
        elif temperature >=800:
            temp_color = "#CC0000"
        elif temperature >=700:
            temp_color = "#AA2200"
        elif temperature >=600:
            temp_color = "#A65A2E"
        elif temperature >=500:
            temp_color = "#8040A0"
        elif temperature >=400:
            temp_color = "#4060C0"
        elif temperature >=300:
            temp_color = "#00A0FF"
        elif temperature >=212:
            temp_color = "#00C878"
        elif temperature >=120:
            temp_color = "#00AA00"
        else:
            temp_color = "#007700"

        if temp_exact:
            temp_text = f"Barrel Temperature: {display_temp:.2f}{temp_unit}"
        else:

            if temperature >200:
                temp_desc = "Critical hot"
            elif temperature >150:
                temp_desc = "Very hot"
            elif temperature >100:
                temp_desc = "Hot"
            elif temperature >80:
                temp_desc = "Warm"
            else:
                temp_desc = "Cool"
            temp_text = f"Barrel Temperature: {temp_desc}"

        customtkinter.CTkLabel(
        detail_frame,
        text = temp_text,
        font = customtkinter.CTkFont(size = 14),
        text_color = temp_color
        ).pack(pady = 5)

        clean_color = "#00FF00"
        if cleanliness <30:
            clean_color = "#FF0000"
        elif cleanliness <50:
            clean_color = "#FFA500"
        elif cleanliness <70:
            clean_color = "#FFFF00"

        clean_text = f"Cleanliness: {cleanliness:.2f}%"if clean_exact else "Cleanliness: Status only"
        clean_label = customtkinter.CTkLabel(
        detail_frame,
        text = clean_text,
        font = customtkinter.CTkFont(size = 14),
        text_color = clean_color
        )
        clean_label.pack(pady = 5)

        if current_weapon_state is not None:
            current_weapon_state["clean_label_ref"]= clean_label

        mag_checked = current_weapon_state.get("mag_checked", False)if current_weapon_state else False
        mag_windowed = False
        try:
            loaded_mag_local = weapon.get("loaded")
            if isinstance(loaded_mag_local, dict)and(loaded_mag_local.get("windowed_magazine")or loaded_mag_local.get("window")):
                mag_windowed = True
            elif weapon.get("windowed_magazine")or weapon.get("window"):
                mag_windowed = True
        except Exception:
            mag_windowed = False
        show_variant = bool(ammo_exact)and(mag_checked or mag_windowed or(has_csad and gunlink_on_weapon))
        ammo_text = self._get_ammo_display(weapon, bool(ammo_exact), show_variant = show_variant)

        ammo_label = customtkinter.CTkLabel(
        detail_frame,
        text = ammo_text,
        font = customtkinter.CTkFont(size = 14)
        )
        ammo_label.pack(pady = 5)

        if current_weapon_state is not None:
            current_weapon_state["ammo_label_ref"]= ammo_label
            current_weapon_state["original_ammo_text"]= ammo_text

        if weapon.get("accessories"):
            customtkinter.CTkLabel(
            detail_frame,
            text = "Attachments:",
            font = customtkinter.CTkFont(size = 14, weight = "bold")
            ).pack(pady =(10, 5))

            for accessory in weapon["accessories"]:
                if accessory.get("current"):
                    att_text = f"â€¢ {accessory['name']}: {accessory['current'].get('name', 'Unknown')}"
                else:
                    att_text = f"â€¢ {accessory['name']}: Empty"

                customtkinter.CTkLabel(
                detail_frame,
                text = att_text,
                font = customtkinter.CTkFont(size = 12)
                ).pack(anchor = "w", padx = 20)

    def _check_for_hud(self, save_data):

        for slot_name, item in save_data.get("equipment", {}).items():
            if item and isinstance(item, dict)and item.get("hud"):
                return True
        return False

    def _get_ammo_display(self, weapon, has_hud, show_variant = False):

        loaded_mag = weapon.get("loaded")
        chambered = weapon.get("chambered")
        magazine_type = weapon.get("magazinetype", "").lower()

        is_internal = "internal"in magazine_type or "tube"in magazine_type
        is_revolver = "revolver"in weapon.get("platform", "").lower()

        def _resolve_ref(obj):
            if isinstance(obj, dict):
                return obj
            try:
                td = globals().get('table_data')or {}
                tables = td.get('tables', {})if isinstance(td, dict)else {}
                iid = None
                if isinstance(obj, (int, float)):
                    iid = int(obj)
                elif isinstance(obj, str)and str(obj).isdigit():
                    iid = int(obj)
                if iid is None:
                    return None
                for arr in tables.values():
                    if isinstance(arr, list):
                        for cand in arr:
                            try:
                                if isinstance(cand, dict)and cand.get('id')==iid:
                                    return cand
                            except Exception:
                                pass
            except Exception:
                pass

            try:
                iid_local = iid if 'iid'in locals()else None
                if iid_local is not None:
                    seen = set()
                    def _search(obj):
                        try:
                            oid = id(obj)
                            if oid in seen:
                                return None
                            seen.add(oid)
                        except Exception:
                            pass
                        if isinstance(obj, dict):
                            try:
                                if obj.get('id')==iid_local:
                                    return obj
                            except Exception:
                                pass
                            for v in obj.values():
                                try:
                                    res = _search(v)
                                    if res:
                                        return res
                                except Exception:
                                    pass
                        elif isinstance(obj, list):
                            for it in obj:
                                try:
                                    res = _search(it)
                                    if res:
                                        return res
                                except Exception:
                                    pass
                        return None

                    sd = globals().get('save_data')or getattr(self, '_current_save_data', None)
                    if isinstance(sd, dict):

                        for root_key in('storage', 'hands', 'equipment'):
                            try:
                                root = sd.get(root_key)
                                if root:
                                    found = _search(root)
                                    if found:
                                        return found
                            except Exception:
                                pass

                    if isinstance(sd, dict):
                        found = _search(sd)
                        if found:
                            return found
            except Exception:
                pass

            return None

        loaded_mag_obj = _resolve_ref(loaded_mag)or(loaded_mag if isinstance(loaded_mag, dict)else None)
        chambered_obj = _resolve_ref(chambered)or(chambered if isinstance(chambered, dict)else None)

        try:
            mag_windowed = False
            if loaded_mag_obj and isinstance(loaded_mag_obj, dict)and(loaded_mag_obj.get('windowed_magazine')or loaded_mag_obj.get('window')):
                mag_windowed = True
            elif chambered_obj and isinstance(chambered_obj, dict)and(chambered_obj.get('windowed_magazine')or chambered_obj.get('window')):
                mag_windowed = True
            elif isinstance(weapon, dict)and(weapon.get('windowed_magazine')or weapon.get('window')):
                mag_windowed = True
        except Exception:
            mag_windowed = False

        try:
            logging.debug("_get_ammo_display: loaded_mag_raw=%s loaded_mag_resolved=%s chambered_resolved=%s mag_windowed=%s has_hud=%s", repr(loaded_mag), repr(loaded_mag_obj), repr(chambered_obj), mag_windowed, has_hud)
        except Exception:
            pass

        effective_has_hud = bool(has_hud)or bool(mag_windowed)

        next_variant = None
        if show_variant:
            try:
                if chambered_obj and isinstance(chambered_obj, dict):
                    next_variant = chambered_obj.get("variant")or chambered_obj.get("name")
                if not next_variant:
                    if is_internal or is_revolver:
                        _int_rounds = weapon.get("rounds", [])
                        if _int_rounds and isinstance(_int_rounds, list)and len(_int_rounds)>0:
                            _nr = _int_rounds[0]
                            if isinstance(_nr, dict):
                                next_variant = _nr.get("variant")or _nr.get("name")
                    else:
                        _mag_obj = loaded_mag_obj or(loaded_mag if isinstance(loaded_mag, dict)else None)
                        if _mag_obj and isinstance(_mag_obj, dict):
                            _mag_rounds = _mag_obj.get("rounds", [])
                            if _mag_rounds and isinstance(_mag_rounds, list)and len(_mag_rounds)>0:
                                _nr = _mag_rounds[0]
                                if isinstance(_nr, dict):
                                    next_variant = _nr.get("variant")or _nr.get("name")
            except Exception:
                next_variant = None
        variant_text = f" [{next_variant}]"if next_variant else ""

        if is_internal or is_revolver:

            internal_rounds = weapon.get("rounds", [])
            total_rounds = len(internal_rounds)
            if chambered:
                total_rounds +=1

            if effective_has_hud:
                chamber_text = "(+1 chambered)"if chambered else ""
                capacity = weapon.get("capacity", 0)
                return f"Ammo: {total_rounds}/{capacity} rounds{chamber_text}{variant_text}"
            else:
                if total_rounds ==0:
                    return "Ammo: Empty(no rounds)"
                return f"Ammo: Loaded(exact count unknown){variant_text}"

        if not loaded_mag and not chambered:
            return "Ammo: Empty(no magazine)"

        total_rounds = 0
        if chambered:
            total_rounds +=1

        if loaded_mag:
            rounds_in_mag = len(loaded_mag.get("rounds", []))
            total_rounds +=rounds_in_mag

        if effective_has_hud:

            chamber_text = "(+1 chambered)"if chambered else ""
            if loaded_mag and not loaded_mag.get("rounds"):
                return f"Ammo: 0 rounds(empty magazine loaded){chamber_text}{variant_text}"
            return f"Ammo: {total_rounds} rounds{chamber_text}{variant_text}"
        else:

            if not loaded_mag and chambered:
                return f"Ammo: Unknown(mag out, round chambered){variant_text}"
            if not loaded_mag:
                return "Ammo: No magazine"
            if not loaded_mag.get("rounds"):
                return "Ammo: Empty magazine loaded(check/reload)"
            return f"Ammo: Unknown(remove mag to check){variant_text}"

    def _save_combat_state(self, save_data):

        try:

            self._save_file(save_data)
            logging.info("Combat state saved for %s", (currentsave or "<unknown>"))
        except Exception as e:
            logging.error(f"Failed to save combat state: {e}")

    def _get_firearm_sound_folder(self, weapon):

        try:
            if isinstance(weapon, dict):
                sf = weapon.get("sounds")or weapon.get("sound_folder")or weapon.get("fire_sounds")or weapon.get("fire_sound")
                if sf:
                    if isinstance(sf, (list, tuple)):
                        sf = sf[0]if sf else None
                    if sf:
                        return sf
        except Exception:
            pass

        caliber = weapon.get("caliber", [])[0]if weapon.get("caliber")else None

        if not caliber:
            return None

        caliber_map = {
        "5.56x45mm NATO":"556",
        ".45 ACP":"45acp",
        "9x19mm Parabellum":"9x19",
        "12 Gauge":"12gauge",
        "7.62x51mm NATO":"762_51",
        "7.62x39mm":"762_39",
        "7.62x54mmR":"762_54",
        ".308 Winchester":"308",
        ".223 Remington":"223",
        ".380 ACP":"380acp",
        "5.45x39mm":"545_39",
        "9x18mm Makarov":"9x18",
        ".357 Magnum":"357mag",
        ".44 Magnum":"44mag",
        ".38 Special":"38special",
        ".50 AE":"50ae",
        "20 Gauge":"20gauge",
        ".410 Bore":"410bore",
        ".45-70 Government":"45_70",
        ".30-06 Springfield":"30_06",
        ".30-30 Winchester":"30_30",
        ".277 Wolverine":"277baker",
        ".224 Valkyrie":"224baker",
        ".303 British":"303"
        }

        caliber_map.update({
        "6.5x45mm":"277baker",
        "6.5x45mm Colt":"277baker",
        "6.5x45 Colt":"277baker",
        "6.5x45":"277baker",
        "5.7x28mm":"224baker",
        "5.7x28mm NATO":"224baker",
        "5.7x28":"224baker",
        })

        extra_map = {
        "10mm Auto":"45acp",
        "10mm":"45acp",
        ".10mm":"45acp"
        }

        return caliber_map.get(caliber)or extra_map.get(caliber)

    def _caliber_to_sound_folder(self, caliber):

        if not caliber or not isinstance(caliber, str):
            return None

        try:
            td = globals().get('table_data')or {}
            ammo_tables = td.get('tables', {}).get('ammunition', [])if isinstance(td, dict)else[]
            if isinstance(ammo_tables, list):
                cal_lower = caliber.strip().lower()
                for ammo_entry in ammo_tables:
                    if not isinstance(ammo_entry, dict):
                        continue
                    a_cal = ammo_entry.get('caliber')
                    if not a_cal:
                        continue
                    if isinstance(a_cal, (list, tuple)):
                        match = any(str(x).strip().lower()==cal_lower for x in a_cal)
                    else:
                        match = str(a_cal).strip().lower()==cal_lower
                    if match and ammo_entry.get('sounds'):
                        return str(ammo_entry.get('sounds'))
        except Exception:
            pass

        caliber_map = {
        "5.56x45mm NATO":"556",
        ".45 ACP":"45acp",
        "9x19mm Parabellum":"9x19",
        "12 Gauge":"12gauge",
        "7.62x51mm NATO":"762_51",
        "7.62x39mm":"762_39",
        "7.62x39mm Soviet":"762_39",
        "7.62x54mmR":"762_54",
        ".308 Winchester":"308",
        ".223 Remington":"223",
        ".380 ACP":"380acp",
        "5.45x39mm":"545_39",
        "5.45x39mm Soviet":"545_39",
        "9x18mm Makarov":"9x18",
        ".357 Magnum":"357mag",
        ".44 Magnum":"44mag",
        ".38 Special":"38special",
        ".50 AE":"50ae",
        "20 Gauge":"20gauge",
        ".410 Bore":"410bore",
        ".45-70 Government":"45_70",
        ".30-06 Springfield":"30_06",
        ".30-30 Winchester":"30_30",
        ".277 Wolverine":"277baker",
        ".224 Valkyrie":"224baker",
        ".303 British":"303",
        "6.5x45mm":"308",
        "6.5x45mm Colt":"308",
        "6.5x45 Colt":"308",
        "6.5x45":"308",
        "5.7x28mm":"223",
        "5.7x28mm NATO":"223",
        "5.7x28":"223",
        "10mm Auto":"45acp",
        "10mm":"45acp",
        ".10mm":"45acp",
        ".40 S&W":"45acp",
        ".30 Carbine":"30_30",
        }

        return caliber_map.get(caliber)

    def _check_weapon_suppressed(self, weapon):

        try:
            if weapon.get("suppressed")or weapon.get("integrally_suppressed"):
                return True
        except Exception:
            pass

        if weapon.get("accessories"):
            for accessory in weapon["accessories"]:
                if accessory.get("current")and accessory["current"].get("suppressor"):
                    return True

        return False

    def _play_firearm_sound(self, weapon, sound_type = "fire", fired_round = None):

        try:

            try:
                if isinstance(weapon, dict):

                    sf = weapon.get("sounds")or weapon.get("sound_folder")or weapon.get("ammo_type")
                    if isinstance(sf, str)and sf:

                        if sf.lower()in("40mm_grenade", "40mm"):
                            weapon_platform_hack = "40mm_grenade"

                            weapon.setdefault("platform", weapon_platform_hack)

                            weapon.setdefault("sound_folder", "40mm_grenade")
                            weapon.setdefault("sounds", "40mm_grenade")
                    else:

                        name =(weapon.get("name")or "").lower()
                        calib = weapon.get("caliber")
                        calib_ok = False
                        if isinstance(calib, (list, tuple)):
                            for c in calib:
                                if isinstance(c, str)and "40"in c and "mm"in c:
                                    calib_ok = True
                                    break
                        elif isinstance(calib, str)and "40"in calib and "mm"in calib:
                            calib_ok = True
                        if calib_ok or "40mm"in name or "40x46"in name or "40 x 46"in name:
                            weapon.setdefault("platform", "40mm_grenade")
                            weapon.setdefault("sound_folder", "40mm_grenade")
                            weapon.setdefault("sounds", "40mm_grenade")
            except Exception:
                pass

            if sound_type =="equip"and weapon.get("custom_equip_sound"):
                sound_path = weapon["custom_equip_sound"]
                if os.path.exists(sound_path):
                    self._safe_sound_play("", sound_path)
                    return

            sound_folder = self._get_firearm_sound_folder(weapon)

            raw_platform = weapon.get("platform", "")or ""
            if isinstance(raw_platform, (list, tuple)):
                raw_platform = raw_platform[0]if raw_platform else ""

            platform_folder = str(raw_platform).lower()if raw_platform else None

            try:
                pf_key =(weapon.get("platform")or weapon.get("underbarrel_platform")or "")
                if isinstance(pf_key, (list, tuple)):
                    pf_key = pf_key[0]if pf_key else ""
                if pf_key and pf_key in self.PLATFORM_DEFAULTS:
                    mapped_folder = self.PLATFORM_DEFAULTS[pf_key].get("reload_sound_folder")
                    if mapped_folder:
                        wf_map = os.path.join("sounds", "firearms", "weaponsounds", str(mapped_folder).lower())
                        candidates =[]
                        if sound_type =="equip":
                            candidates = glob.glob(os.path.join(wf_map, "equip*.ogg"))+glob.glob(os.path.join(wf_map, "draw*.ogg"))
                        elif sound_type =="reload":
                            candidates = glob.glob(os.path.join(wf_map, "reload*.ogg"))+glob.glob(os.path.join(wf_map, "load*.ogg"))+glob.glob(os.path.join(wf_map, "pump*.ogg"))
                        else:

                            candidates = glob.glob(os.path.join(wf_map, f"{sound_type}*.ogg"))
                        if candidates:
                            self._safe_sound_play("", random.choice(candidates), block =(sound_type in("reload", "unselect", "holster")))
                            return
            except Exception:
                pass

            if not sound_folder:

                if platform_folder:
                    wf_rel = os.path.join("weaponsounds", platform_folder)
                    wf_path = os.path.join("sounds", "firearms", wf_rel)
                    if os.path.isdir(wf_path):
                        sound_folder = wf_rel
                    else:

                        direct_pf = os.path.join("sounds", "firearms", platform_folder)
                        if os.path.isdir(direct_pf):
                            sound_folder = platform_folder

            if sound_type =="equip":

                tried = False
                if platform_folder:
                    wf = os.path.join("sounds", "firearms", "weaponsounds", platform_folder)
                    candidates = glob.glob(os.path.join(wf, "equip*.ogg"))+glob.glob(os.path.join(wf, "draw*.ogg"))
                    if candidates:
                        sound_file = random.choice(candidates)
                        self._safe_sound_play("", sound_file)
                        return
                    tried = True

                if sound_folder:
                    base_equip_candidates = glob.glob(os.path.join("sounds", "firearms", sound_folder, "equip*.ogg"))+glob.glob(os.path.join("sounds", "firearms", sound_folder, "draw*.ogg"))
                    if base_equip_candidates:
                        sound_file = random.choice(base_equip_candidates)
                        self._safe_sound_play("", sound_file)
                        return

                uni_candidates = glob.glob(os.path.join("sounds", "firearms", "universal", "equip*.ogg"))+glob.glob(os.path.join("sounds", "firearms", "universal", "draw*.ogg"))
                if uni_candidates:
                    sound_file = random.choice(uni_candidates)
                    self._safe_sound_play("", sound_file)
                    return

                logging.info(f"No equip/draw sound found for {weapon.get('name')}(checked platform, {sound_folder}, and universal)")
                return

            is_suppressed = self._check_weapon_suppressed(weapon)

            base_path = f"sounds/firearms/{sound_folder}"if sound_folder else None
            wf_platform = None
            if platform_folder:
                wf_platform = os.path.join("sounds", "firearms", "weaponsounds", platform_folder)

            def _dbg(msg, *args):
                try:
                    gv = globals().get('global_variables')or {}
                    if gv.get('debugmode', {}).get('value'):
                        logging.debug(msg, *args)
                except Exception:
                    logging.debug(msg, *args)

            def _select_from_folder(folder):
                try:
                    if not folder or not os.path.isdir(folder):
                        _dbg("_select_from_folder: missing folder %s", folder)
                        return None
                    _dbg("_select_from_folder: scanning folder %s(suppressed=%s)", folder, is_suppressed)
                    if is_suppressed:
                        cands = glob.glob(os.path.join(folder, "fire*_suppressed.wav"))+glob.glob(os.path.join(folder, "fire*_suppressed.ogg"))
                        _dbg("_select_from_folder: found %d suppressed candidates in %s", len(cands), folder)
                        if cands:
                            sel = random.choice(cands)
                            _dbg("_select_from_folder: selected %s", sel)
                            return sel
                        _dbg("_select_from_folder: no suppressed candidates in %s", folder)
                        return None
                    else:
                        cands = glob.glob(os.path.join(folder, "fire*.wav"))+glob.glob(os.path.join(folder, "fire*.ogg"))

                        cands =[f for f in cands if "_suppressed"not in os.path.basename(f)]
                        _dbg("_select_from_folder: found %d non-suppressed candidates in %s", len(cands), folder)
                        if cands:
                            sel = random.choice(cands)
                            _dbg("_select_from_folder: selected %s", sel)
                            return sel
                        _dbg("_select_from_folder: no non-suppressed candidates in %s", folder)
                        return None
                except Exception:
                    _dbg("_select_from_folder: exception scanning %s", folder)
                    return None

            if sound_type =="fire"and wf_platform:
                sel = _select_from_folder(wf_platform)
                if sel:
                    self._safe_sound_play("", sel)
                    return

            ammo_folder = None
            try:

                if fired_round and isinstance(fired_round, dict):
                    if fired_round.get("sounds"):
                        ammo_folder = fired_round.get("sounds")
                    elif fired_round.get("caliber"):

                        round_cal = fired_round.get("caliber")
                        if isinstance(round_cal, (list, tuple)):
                            round_cal = round_cal[0]if round_cal else None
                        if round_cal:
                            ammo_folder = self._caliber_to_sound_folder(round_cal)

                if not ammo_folder:
                    ch = weapon.get("chambered")if isinstance(weapon, dict)else None
                    if isinstance(ch, dict):
                        if ch.get("sounds"):
                            ammo_folder = ch.get("sounds")
                        elif ch.get("caliber"):
                            ch_cal = ch.get("caliber")
                            if isinstance(ch_cal, (list, tuple)):
                                ch_cal = ch_cal[0]if ch_cal else None
                            if ch_cal:
                                ammo_folder = self._caliber_to_sound_folder(ch_cal)

                if not ammo_folder:
                    loaded = weapon.get("loaded")if isinstance(weapon, dict)else None
                    if isinstance(loaded, dict):
                        rds = loaded.get("rounds")or[]
                        if isinstance(rds, list)and rds:
                            first = rds[0]
                            if isinstance(first, dict):
                                if first.get("sounds"):
                                    ammo_folder = first.get("sounds")
                                elif first.get("caliber"):
                                    first_cal = first.get("caliber")
                                    if isinstance(first_cal, (list, tuple)):
                                        first_cal = first_cal[0]if first_cal else None
                                    if first_cal:
                                        ammo_folder = self._caliber_to_sound_folder(first_cal)

                if not ammo_folder:
                    at = weapon.get("ammo_type")or weapon.get("ammo")
                    if isinstance(at, str)and at:
                        ammo_folder = at
            except Exception:
                ammo_folder = None

            if ammo_folder:

                wf_ammo_map = os.path.join("sounds", "firearms", "weaponsounds", str(ammo_folder).lower())
                sel = _select_from_folder(wf_ammo_map)
                if sel:
                    self._safe_sound_play("", sel)
                    return
                wf_ammo = os.path.join("sounds", "firearms", str(ammo_folder))
                sel = _select_from_folder(wf_ammo)
                if sel:
                    self._safe_sound_play("", sel)
                    return

            try:
                if not ammo_folder:
                    td = globals().get('table_data')or {}
                    ammo_tables = td.get('tables', {}).get('ammunition', [])if isinstance(td, dict)else[]

                    cal_list = weapon.get('caliber')if isinstance(weapon, dict)else None
                    if cal_list and isinstance(ammo_tables, list):
                        for ammo_entry in ammo_tables:
                            try:
                                if not isinstance(ammo_entry, dict):
                                    continue
                                a_cal = ammo_entry.get('caliber')
                                if not a_cal:
                                    continue

                                if isinstance(a_cal, (list, tuple)):
                                    match = any(str(x).strip().lower()in[str(c).strip().lower()for c in(cal_list or[])]for x in a_cal)
                                else:
                                    match = any(str(a_cal).strip().lower()==str(c).strip().lower()for c in(cal_list or[]))
                                if match and ammo_entry.get('sounds'):

                                    af = str(ammo_entry.get('sounds'))
                                    wf_ammo_map = os.path.join('sounds', 'firearms', 'weaponsounds', af.lower())
                                    sel = _select_from_folder(wf_ammo_map)
                                    if sel:
                                        self._safe_sound_play('', sel)
                                        return
                                    wf_ammo2 = os.path.join('sounds', 'firearms', af.lower())
                                    sel = _select_from_folder(wf_ammo2)
                                    if sel:
                                        self._safe_sound_play('', sel)
                                        return
                            except Exception:
                                pass
            except Exception:
                pass

            try:
                if weapon.get("has_ammo_in_pool")is False:
                    fs = weapon.get("fire_sounds")or weapon.get("fire_sound")
                    if fs:

                        wf = os.path.join("sounds", "firearms", "weaponsounds", str(fs).lower())
                        sel = _select_from_folder(wf)
                        if sel:
                            logging.debug("Fire sound selected(weapon.fire_sounds): %s", sel)
                            self._safe_sound_play("", sel)
                            return
                        wf2 = os.path.join("sounds", "firearms", str(fs).lower())
                        sel = _select_from_folder(wf2)
                        if sel:
                            logging.debug("Fire sound selected(weapon.fire_sounds): %s", sel)
                            self._safe_sound_play("", sel)
                            return
            except Exception:
                pass

            if base_path:
                sel = _select_from_folder(base_path)
                if sel:
                    self._safe_sound_play("", sel)
                    return

            subtype = weapon.get("subtype", "")

            if is_suppressed:

                if subtype =="shotgun":
                    shotgun_supp = glob.glob("sounds/firearms/universal/shotgunfire_suppressed.wav")+glob.glob("sounds/firearms/universal/shotgunfire_suppressed.ogg")
                    if shotgun_supp:
                        self._safe_sound_play("", random.choice(shotgun_supp))
                        return

                    rifle_supp = glob.glob("sounds/firearms/universal/riflefire_suppressed.wav")+glob.glob("sounds/firearms/universal/riflefire_suppressed.ogg")
                    if rifle_supp:
                        self._safe_sound_play("", random.choice(rifle_supp))
                        return
                elif subtype in["rifle", "mg"]:
                    rifle_supp = glob.glob("sounds/firearms/universal/riflefire_suppressed.wav")+glob.glob("sounds/firearms/universal/riflefire_suppressed.ogg")
                    if rifle_supp:
                        self._safe_sound_play("", random.choice(rifle_supp))
                        return
                elif subtype in["pistol", "smg"]:
                    pistol_supp = glob.glob("sounds/firearms/universal/pistolfire_suppressed.wav")+glob.glob("sounds/firearms/universal/pistolfire_suppressed.ogg")
                    if pistol_supp:
                        self._safe_sound_play("", random.choice(pistol_supp))
                        return
            else:

                if subtype =="shotgun":
                    shot = glob.glob("sounds/firearms/universal/shotgunfire.wav")
                    if shot:
                        self._safe_sound_play("", random.choice(shot))
                        return

                    rifle = glob.glob("sounds/firearms/universal/riflefire.wav")
                    if rifle:
                        self._safe_sound_play("", random.choice(rifle))
                        return
                elif subtype in["rifle", "mg"]:
                    rifle = glob.glob("sounds/firearms/universal/riflefire.wav")
                    if rifle:
                        self._safe_sound_play("", random.choice(rifle))
                        return
                elif subtype in["pistol", "smg"]:
                    pistol = glob.glob("sounds/firearms/universal/pistolfire.wav")
                    if pistol:
                        self._safe_sound_play("", random.choice(pistol))
                        return

            logging.warning(f"No fire sounds found for platform_folder={platform_folder} sound_folder={sound_folder} ammo_folder={ammo_folder}")

        except Exception as e:
            logging.error(f"Error playing firearm sound: {e}")

    def _play_weapon_action_sound(self, weapon, action_type, block = False):

        try:
            platform = weapon.get("platform", "").lower()
            mag_type = weapon.get("magazinetype", "").lower()

            platform_folder = platform if platform else None

            is_belt =("belt"in mag_type)or("belt"in(platform or ""))or("m249"in(platform or ""))

            should_block = bool(block)

            try:
                weapon_type = str(weapon.get("type")or "").lower()
                if weapon_type =="caseless":

                    if any(k in action_type.lower()for k in("eject", "shelleject", "caseeject")):
                        logging.debug("Skipping ejection sound for caseless weapon: %s", weapon.get("name"))
                        return
            except Exception:
                pass

            try:
                reload_actions =("reload", "magin", "magout", "magdrop", "pouchout", "pouchin", "boxin", "boxout", "coveropen", "coverclose")
                if action_type in reload_actions:

                    fs = weapon.get("fire_sounds")or weapon.get("sounds")or weapon.get("sound_folder")or weapon.get("reload_sounds")
                    candidates =[]

                    if fs:
                        wf = os.path.join("sounds", "firearms", str(fs).lower())
                        candidates = glob.glob(os.path.join(wf, f"{action_type}*.ogg"))+glob.glob(os.path.join(wf, f"{action_type}*.wav"))
                        if not candidates:

                            wf2 = os.path.join("sounds", "firearms", "weaponsounds", str(fs).lower())
                            candidates = glob.glob(os.path.join(wf2, f"{action_type}*.ogg"))+glob.glob(os.path.join(wf2, f"{action_type}*.wav"))

                    if not candidates and platform_folder:
                        wf = os.path.join("sounds", "firearms", "weaponsounds", platform_folder)
                        candidates = glob.glob(os.path.join(wf, f"{action_type}*.ogg"))+glob.glob(os.path.join(wf, f"{action_type}*.wav"))

                    if not candidates:
                        uni = os.path.join("sounds", "firearms", "universal")

                        action_map = {
                        "magin":["riflemagin*.ogg", "pistolmagin*.ogg", "magin*.ogg"],
                        "magout":["riflemagout*.ogg", "pistolmagout*.ogg", "magout*.ogg"],
                        "magdrop":["magdrop*.ogg"],
                        "pouchout":["pouchout*.ogg"],
                        "pouchin":["pouchin*.ogg"],
                        "reload":["reload*.ogg", "riflemagin*.ogg"],
                        }
                        patterns = action_map.get(action_type, [f"{action_type}*.ogg"])
                        for pat in patterns:
                            candidates +=glob.glob(os.path.join(uni, pat))
                    if candidates:
                        sound_file = random.choice(candidates)
                        logging.debug("Reload action sound: %s -> %s", action_type, sound_file)

                        if action_type =="magin":

                            try:
                                self._safe_sound_play("", sound_file, block = True)
                            except Exception:
                                try:
                                    self._safe_sound_play("", sound_file, block = should_block)
                                except Exception:
                                    pass

                            try:
                                if should_block:
                                    time.sleep(random.uniform(0.15, 0.35))
                                else:
                                    time.sleep(random.uniform(0.05, 0.12))
                            except Exception:
                                pass
                        else:
                            self._safe_sound_play("", sound_file, block = should_block)
                        return
            except Exception:
                logging.exception("Error in reload action sound lookup")
                pass

            try:
                if weapon.get("has_ammo_in_pool")is False:
                    fs = weapon.get("reload_sounds")or weapon.get("action_sounds")or weapon.get("sounds")or weapon.get("sound_folder")or weapon.get("fire_sounds")
                    if fs:
                        wf = os.path.join("sounds", "firearms", "weaponsounds", str(fs).lower())
                        candidates = glob.glob(os.path.join(wf, f"{action_type}*.ogg"))+glob.glob(os.path.join(wf, f"{action_type}*.wav"))
                        if candidates:
                            import random as _r
                            sound_file = _r.choice(candidates)
                            self._safe_sound_play("", sound_file, block = should_block)
                            return
            except Exception:
                pass

            if platform_folder:
                wf = os.path.join("sounds", "firearms", "weaponsounds", platform_folder)
                candidates =[]
                if action_type.startswith("tubeinsert")or action_type =="tubeinsert":
                    candidates = glob.glob(os.path.join(wf, "tubeinsert*.ogg"))
                elif action_type.startswith("bulletinsert"):
                    candidates = glob.glob(os.path.join(wf, "bulletinsert*.ogg"))
                else:

                    pattern_candidates = glob.glob(os.path.join(wf, f"{action_type}*.ogg"))+glob.glob(os.path.join(wf, f"{action_type}*.wav"))
                    if pattern_candidates:
                        candidates = pattern_candidates
                    else:

                        exact_ogg = os.path.join(wf, f"{action_type}.ogg")
                        exact_wav = os.path.join(wf, f"{action_type}.wav")
                        if os.path.exists(exact_ogg):
                            candidates =[exact_ogg]
                        elif os.path.exists(exact_wav):
                            candidates =[exact_wav]

                if candidates:
                    sound_file = random.choice(candidates)
                    logging.debug("_play_weapon_action_sound: platform-specific %s -> %s", action_type, sound_file)
                    self._safe_sound_play("", sound_file, block = should_block)
                    return

            internal_sounds = {
            "tubeinsert":"sounds/firearms/universal/tubeinsert.ogg",
            "bulletinsert0":"sounds/firearms/universal/bulletinsert0.ogg",
            "bulletinsert1":"sounds/firearms/universal/bulletinsert1.ogg",
            "cylinderopen":"sounds/firearms/universal/cylinderopen.ogg",
            "cylinderclose":"sounds/firearms/universal/cylinderclose.ogg",
            "cylinderrelease":"sounds/firearms/universal/cylinderrelease.ogg",
            }

            if action_type.startswith("tubeinsert")or action_type =="tubeinsert":

                uni_folder = os.path.join("sounds", "firearms", "universal")
                tube_candidates = glob.glob(os.path.join(uni_folder, "tubeinsert*.ogg"))
                if tube_candidates:
                    sound_file = random.choice(tube_candidates)
                    logging.debug("_play_weapon_action_sound: tubeinsert -> %s", sound_file)
                    self._safe_sound_play("", sound_file, block = should_block)
                    return

                if os.path.exists(internal_sounds["tubeinsert"]):
                    self._safe_sound_play("", internal_sounds["tubeinsert"], block = should_block)
                    return

            if action_type.startswith("bulletinsert"):

                uni_folder = os.path.join("sounds", "firearms", "universal")
                bullet_candidates = glob.glob(os.path.join(uni_folder, "bulletinsert*.ogg"))
                if bullet_candidates:
                    sound_file = random.choice(bullet_candidates)
                    logging.debug("_play_weapon_action_sound: bulletinsert -> %s", sound_file)
                    self._safe_sound_play("", sound_file, block = should_block)
                    return

                sound_file = internal_sounds.get(action_type)
                if sound_file and os.path.exists(sound_file):
                    self._safe_sound_play("", sound_file, block = should_block)
                    return

            if "revolver"in platform.lower()or "cylinder"in action_type:
                if action_type =="cylinderopen"and os.path.exists(internal_sounds["cylinderopen"]):
                    logging.debug("_play_weapon_action_sound: revolver cylinderopen -> %s", internal_sounds["cylinderopen"])
                    self._safe_sound_play("", internal_sounds["cylinderopen"], block = should_block)
                    return
                elif action_type =="cylinderclose"and os.path.exists(internal_sounds["cylinderclose"]):
                    logging.debug("_play_weapon_action_sound: revolver cylinderclose -> %s", internal_sounds["cylinderclose"])
                    self._safe_sound_play("", internal_sounds["cylinderclose"], block = should_block)
                    return
                elif action_type =="cylinderrelease"and os.path.exists(internal_sounds["cylinderrelease"]):
                    logging.debug("_play_weapon_action_sound: revolver cylinderrelease -> %s", internal_sounds["cylinderrelease"])
                    self._safe_sound_play("", internal_sounds["cylinderrelease"], block = should_block)
                    return
                elif action_type in("bulletinsert0", "bulletinsert1")and os.path.exists(internal_sounds[action_type]):
                    logging.debug("_play_weapon_action_sound: revolver bulletinsert -> %s", internal_sounds[action_type])
                    self._safe_sound_play("", internal_sounds[action_type], block = should_block)
                    return

            if action_type =="magin":
                mag_type = weapon.get("magazinetype", "").lower()
                if any(k in mag_type for k in("internal", "tube", "cylinder"))or "revolver"in platform.lower()or is_belt:
                    return

            if action_type in("coveropen", "coverclose", "boxout", "boxin"):
                preferred_map = {
                "coveropen":["pouchout"],
                "coverclose":["pouchin"],
                "boxout":["magdrop0", "magdrop1"],
                "boxin":["riflemagin", "pistolmagin"]
                }
                pf = platform_folder
                names = preferred_map.get(action_type, [action_type])

                if pf:
                    wf = os.path.join("sounds", "firearms", "weaponsounds", pf)
                    for nm in names:
                        for ext in(".ogg", ".wav"):
                            cand = os.path.join(wf, nm +ext)
                            if os.path.exists(cand):
                                logging.debug("_play_weapon_action_sound: platform preferred %s -> %s", action_type, cand)
                                self._safe_sound_play("", cand, block = should_block)
                                return

                uni_folder = os.path.join("sounds", "firearms", "universal")
                for nm in names:
                    for ext in(".ogg", ".wav"):
                        cand = os.path.join(uni_folder, nm +ext)
                        if os.path.exists(cand):
                            logging.debug("_play_weapon_action_sound: universal preferred %s -> %s", action_type, cand)
                            self._safe_sound_play("", cand, block = should_block)
                            return

            universal_sounds = {
            "magin":["riflemagin", "pistolmagin"],
            "magout":["riflemagout", "pistolmagout"],
            "boltback":["rifleboltback", "pistolslideback", "boltactionback"],
            "boltforward":["rifleboltforward", "pistolslideforward", "boltactionforward"],
            "pumpback":["shotgunpumpback", "pumpback"],
            "pumpforward":["shotgunpumpforward", "pumpforward"],
            "cleaning":["cleaning"],

            "coveropen":["pouchout", "magdrop0"],
            "coverclose":["pouchin"],
            "boxout":["magdrop0", "magdrop1"],
            "boxin":["magin", "riflemagin"]
            }

            if action_type in universal_sounds:
                for sound_name in universal_sounds[action_type]:
                    sound_path = f"sounds/firearms/universal/{sound_name}.ogg"
                    if os.path.exists(sound_path):
                        logging.debug("_play_weapon_action_sound: universal %s -> %s", action_type, sound_path)

                        if action_type =="magin":
                            try:
                                self._safe_sound_play("", sound_path, block = True)
                            except Exception:
                                try:
                                    self._safe_sound_play("", sound_path, block = should_block)
                                except Exception:
                                    pass
                            try:
                                if should_block:
                                    time.sleep(random.uniform(0.15, 0.35))
                                else:
                                    time.sleep(random.uniform(0.05, 0.12))
                            except Exception:
                                pass
                        else:
                            self._safe_sound_play("", sound_path, block = should_block)
                        break

        except Exception as e:
            logging.error(f"Error playing weapon action sound: {e}")

    def _cycle_bolt_sounds(self, weapon, single_forward = False, delay = 0.12):

        try:
            bolt_setting = str(weapon.get("bolt")or "").lower()
            bolt_catch = bool(weapon.get("bolt_catch", False))

            if bolt_setting =="open":
                if single_forward:
                    if bolt_catch:

                        self._play_weapon_action_sound(weapon, "boltback", block = True)
                    else:
                        self._play_weapon_action_sound(weapon, "boltforward")
                        time.sleep(delay)

                        self._play_weapon_action_sound(weapon, "boltback", block = True)
                else:

                    self._play_weapon_action_sound(weapon, "boltforward")
                    time.sleep(delay)
                    self._play_weapon_action_sound(weapon, "boltback", block = True)
            else:

                if single_forward:
                    if bolt_catch:
                        self._play_weapon_action_sound(weapon, "boltforward")
                    else:

                        self._play_weapon_action_sound(weapon, "boltback", block = True)
                        time.sleep(delay)
                        self._play_weapon_action_sound(weapon, "boltforward")
                else:

                    self._play_weapon_action_sound(weapon, "boltback", block = True)
                    time.sleep(delay)
                    self._play_weapon_action_sound(weapon, "boltforward")
        except Exception:
            try:

                self._play_weapon_action_sound(weapon, "boltforward")
                time.sleep(delay)
                self._play_weapon_action_sound(weapon, "boltback", block = True)
            except Exception:
                pass

    def _play_weapon_action_sound_strict(self, weapon, action_type, block = False):

        try:
            platform = weapon.get("platform", "").lower()
            platform_folder = platform if platform else None

            equivalents = {
            "boltback":["rifleboltback", "pistolslideback", "boltactionback"],
            "boltforward":["rifleboltforward", "pistolslideforward", "boltactionforward"],
            "coveropen":["pouchout"],
            "coverclose":["pouchin"],
            "boxout":["magdrop0", "magdrop1"],
            "boxin":["riflemagin", "pistolmagin"],
            "magout":["riflemagout", "pistolmagout", "magdrop0", "magdrop1"],
            "magin":["riflemagin", "pistolmagin"],
            "pouchout":["pouchout"],
            "pouchin":["pouchin"]
            }

            names = equivalents.get(action_type, [action_type])

            if platform_folder:
                wf = os.path.join("sounds", "firearms", "weaponsounds", platform_folder)
                exact = os.path.join(wf, action_type +".ogg")
                if os.path.exists(exact):
                    logging.debug("_play_weapon_action_sound_strict: platform exact %s -> %s", action_type, exact)
                    self._safe_sound_play("", exact, block = block)
                    return True

            uni = os.path.join("sounds", "firearms", "universal")
            for nm in names:
                cand = os.path.join(uni, nm +".ogg")
                if os.path.exists(cand):
                    logging.debug("_play_weapon_action_sound_strict: universal exact %s -> %s", action_type, cand)
                    self._safe_sound_play("", cand, block = block)
                    return True

            logging.debug("_play_weapon_action_sound_strict: no file for action '%s'(platform=%s)", action_type, platform_folder)
            return False
        except Exception as e:
            logging.error(f"_play_weapon_action_sound_strict error: {e}")
            return False

    def _perform_belt_reload_sequence(self, weapon):
        try:
            save_data = globals().get('save_data')or {}

            capacity = None
            try:
                capacity = int(weapon.get('capacity')or(weapon.get('loaded')or {}).get('capacity')or 0)
            except Exception:
                capacity = 0
            if not capacity:
                try:
                    capacity = int(weapon.get('mag_capacity')or 200)
                except Exception:
                    capacity = 200

            current_rounds = weapon.get('rounds')or[]
            try:
                if not isinstance(current_rounds, list):
                    current_rounds =[]
            except Exception:
                current_rounds =[]

            need = max(0, capacity -len(current_rounds))
            if need <=0:
                try:
                    self._popup_show_info('Reload Belt', 'Belt already full')
                except Exception:
                    pass
                return

            rounds_collected =[]

            def round_matches(r, calib_list):
                try:
                    if not isinstance(r, dict):
                        return True
                    rcal = r.get('caliber')or r.get('cal')or None
                    if not rcal:
                        return True
                    if not calib_list:
                        return True
                    for c in calib_list:
                        try:
                            if str(rcal)==str(c):
                                return True
                        except Exception:
                            pass
                    return False
                except Exception:
                    return True

            calibers =[]
            try:
                c = weapon.get('caliber')or weapon.get('calibers')or[]
                if isinstance(c, (list, tuple)):
                    calibers = c
                elif c:
                    calibers =[c]
            except Exception:
                calibers =[]

            try:

                hands = save_data.get('hands', {}).get('items', [])
                for hi in range(len(hands)-1, -1, -1):
                    if need <=0:
                        break
                    itm = hands[hi]
                    if not isinstance(itm, dict):
                        continue
                    if itm is weapon:
                        continue
                    if itm.get('magazinesystem')or itm.get('capacity'):

                        continue

                    if isinstance(itm.get('rounds'), list)and itm.get('rounds'):
                        take =[]
                        keep =[]
                        rlist = itm.get('rounds')or[]
                        for r in rlist:
                            if len(take)<need and round_matches(r, calibers):
                                take.append(r)
                            else:
                                keep.append(r)
                        for r in take:
                            rounds_collected.append(r)
                            need -=1
                        itm['rounds']= keep
                        if not itm.get('rounds'):
                            try:
                                hands.pop(hi)
                            except Exception:
                                pass
                        continue

                    qty = int(itm.get('quantity')or 0)if isinstance(itm.get('quantity'), (int, float))else 0
                    if qty >0 and('caliber'in itm or 'name'in itm):
                        take_n = min(need, qty)
                        for _ in range(take_n):
                            r = {k:v for k, v in itm.items()if k !='quantity'}
                            rounds_collected.append(r)
                            need -=1
                        itm['quantity']= qty -take_n
                        if itm['quantity']<=0:
                            try:
                                hands.pop(hi)
                            except Exception:
                                pass
                        continue

                    if itm.get('caliber'):
                        try:
                            hands.pop(hi)
                            rounds_collected.append(itm)
                            need -=1
                        except Exception:
                            pass

                for slot_name, eq_item in list(save_data.get('equipment', {}).items()):
                    if need <=0:
                        break
                    if not eq_item or not isinstance(eq_item, dict):
                        continue
                    for itm in list(eq_item.get('items', [])or[]):
                        if need <=0:
                            break
                        if not isinstance(itm, dict):
                            continue
                        if itm.get('magazinesystem')or itm.get('capacity'):
                            continue
                        if isinstance(itm.get('rounds'), list)and itm.get('rounds'):
                            take =[]
                            keep =[]
                            rlist = itm.get('rounds')or[]
                            for r in rlist:
                                if len(take)<need and round_matches(r, calibers):
                                    take.append(r)
                                else:
                                    keep.append(r)
                            for r in take:
                                rounds_collected.append(r)
                                need -=1
                            itm['rounds']= keep
                            if not itm.get('rounds'):
                                try:
                                    eq_item['items'].remove(itm)
                                except Exception:
                                    pass
                            continue
                        qty = int(itm.get('quantity')or 0)if isinstance(itm.get('quantity'), (int, float))else 0
                        if qty >0 and('caliber'in itm or 'name'in itm):
                            take_n = min(need, qty)
                            for _ in range(take_n):
                                r = {k:v for k, v in itm.items()if k !='quantity'}
                                rounds_collected.append(r)
                                need -=1
                            itm['quantity']= qty -take_n
                            if itm['quantity']<=0:
                                try:
                                    eq_item['items'].remove(itm)
                                except Exception:
                                    pass
                            continue
            except Exception:
                logging.exception('Error collecting loose rounds for belt reload')

            if not rounds_collected:
                try:
                    self._popup_show_info('Reload Belt', 'No loose rounds available in hands or equipment to load belt')
                except Exception:
                    pass
                return

            try:
                self._play_weapon_action_sound(weapon, 'coveropen')
            except Exception:
                pass
            time.sleep(random.uniform(0.1, 0.2))

            try:
                self._play_weapon_action_sound(weapon, 'magout')
            except Exception:
                pass
            time.sleep(random.uniform(1.0, 1.5))

            try:
                self._play_weapon_action_sound(weapon, 'magin')
            except Exception:
                pass

            try:
                self._play_weapon_action_sound(weapon, 'beltalign')
            except Exception:
                pass
            time.sleep(random.uniform(0.1, 0.2))

            try:
                self._play_weapon_action_sound(weapon, 'coverclose')
            except Exception:
                pass
            time.sleep(random.uniform(0.1, 0.2))

            try:
                self._play_weapon_action_sound(weapon, 'boltback')
            except Exception:
                pass

            try:
                self._play_weapon_action_sound(weapon, 'boltforward')
            except Exception:
                pass

            try:
                existing = weapon.get('rounds')or[]
                if not isinstance(existing, list):
                    existing =[]
                weapon['rounds']= existing +rounds_collected

                try:
                    if 'loaded'in weapon:
                        weapon['loaded']= None
                except Exception:
                    pass
            except Exception:
                logging.exception('Failed to insert collected rounds into weapon rounds')

            try:
                self._popup_show_info('Reload Belt', f'Loaded {len(rounds_collected)} rounds into belt')
            except Exception:
                pass
            try:

                update_weapon_view()
            except Exception:
                pass
        except Exception:
            logging.exception('_perform_belt_reload_sequence error')

    def _perform_dualfeed_belt_reload_sequence(self, weapon):
        try:

            self._perform_belt_reload_sequence(weapon)
        except Exception:
            logging.exception('_perform_dualfeed_belt_reload_sequence error')

    def _roll_d20_dice(self, num_rolls):

        rolls =[secrets.randbelow(20)+1 for _ in range(num_rolls)]

        n = len(rolls)
        if n ==0:
            return rolls, 0
        avg = sum(rolls)/n
        rounded = int(math.floor(avg +0.5))

        return rolls, rounded

    def _copy_to_clipboard(self, text):
        try:
            pyperclip.copy(text)
            logging.info(f"Copied to clipboard: {text}")
            return True
        except Exception as e:
            logging.warning(f"Failed to copy to clipboard: {e}")
            return False

    def _fire_weapon_impl(self, weapon, combat_state, rounds_to_fire = 3, fire_mode = None, save_data = None):# type: ignore

        weapon_id = str(weapon.get("id"))
        logging.info(
        "_fire_weapon start: id=%s name=%s rounds=%s mode=%s",
        weapon_id,
        weapon.get("name", "Unknown"),
        rounds_to_fire,
        fire_mode or "unknown"
        )

        roll_summary_text = None

        chambered = weapon.get("chambered")
        loaded_mag = weapon.get("loaded")
        magazine_type = str(weapon.get("magazinetype", "")or "").lower()

        raw_platform = weapon.get("platform", "")or ""
        if isinstance(raw_platform, (list, tuple)):
            raw_platform = raw_platform[0]if raw_platform else ""
        platform = str(raw_platform)

        is_internal = "internal"in magazine_type or "tube"in magazine_type or "cylinder"in magazine_type or "revolver"in platform.lower()or("belt"in magazine_type)or("m249"in platform.lower())

        is_belt = False

        raw_action = weapon.get("action", "")or ""
        if isinstance(raw_action, (list, tuple)):
            action_list =[str(a).lower()for a in raw_action if a is not None]
        else:
            action_list =[str(raw_action).lower()]

        is_pump =(
        "pump"in platform.lower()
        or any("pump"in a for a in action_list)
        or "pump"in magazine_type
        )

        fire_mode_norm = str(fire_mode or "").title()
        effective_is_pump = is_pump and fire_mode_norm =="Pump"

        magicsys = str(weapon.get("magicsoundsystem")or "").lower()
        is_magic =(str(weapon.get("type")or "").lower()=="magic")or(magicsys in("hg", "at", "mg", "rf"))

        if is_magic:

            magic_folder = os.path.join("sounds", "firearms", "magic", magicsys if magicsys else "hg")

            requires_charge = magicsys in("at", "rf")

            temperature = combat_state.get("barrel_temperatures", {}).get(weapon_id, combat_state.get("ambient_temperature", 70))

            pre_fire_temp = temperature

            if requires_charge:
                charge_file = os.path.join(magic_folder, "charge.ogg")
                if os.path.exists(charge_file):
                    try:
                        self._safe_sound_play("", charge_file, block = True)
                    except Exception:
                        logging.exception("Failed to play charge sound for magic weapon")

            if magicsys =="rf":
                prefire_file = os.path.join(magic_folder, "prefire.ogg")
                if os.path.exists(prefire_file):
                    try:
                        self._safe_sound_play("", prefire_file, block = True)
                    except Exception:
                        logging.exception("Failed to play prefire for rf magic weapon")

            try:
                nshots = max(1, int(rounds_to_fire or 1))
            except Exception:
                nshots = 1

            if magicsys in("at", "rf"):
                nshots = 1

            try:
                rpm = float(weapon.get("cyclic", weapon.get("rpm", 600))or 600)
                if rpm <=0:
                    rpm = 600.0
            except Exception:
                rpm = 600.0
            shot_delay = 60.0 /float(rpm)

            try:
                import glob as _glob
                fire_candidates = _glob.glob(os.path.join(magic_folder, "fire*.ogg"))
            except Exception:
                fire_candidates =[]

            try:
                temp_gain = float(weapon.get("temp_gain_per_shot", weapon.get("temp_gain", 20)or 20))
            except Exception:
                temp_gain = random.uniform(15, 25)
            if self._check_weapon_suppressed(weapon):
                temp_gain *=1.5

            for i in range(nshots):

                try:

                    block_this_shot = magicsys in("at", "rf")
                    if fire_candidates:
                        chosen = random.choice(fire_candidates)
                        self._safe_sound_play("", chosen, block = block_this_shot)
                    else:

                        fallback_path = os.path.join("sounds", weapon.get("sound_folder", ""), "fire.ogg")
                        self._safe_sound_play("", fallback_path, block = block_this_shot)
                except Exception:
                    logging.exception("Magic weapon fire sound failed")

                if magicsys in("at", "rf"):
                    try:
                        self._play_weapon_action_sound_strict(weapon, "boltback", block = False)
                    except Exception:
                        pass

                try:
                    temperature +=temp_gain
                except Exception:
                    temperature = temperature +(temp_gain if isinstance(temp_gain, (int, float))else 0)

                try:
                    if not(magicsys in("at", "rf")):

                        try:
                            if str(fire_mode or "").title()=="Semi":
                                jitter = random.uniform(-0.06, 0.06)
                                time.sleep(max(0.0, shot_delay +0.18 +jitter))
                            else:
                                time.sleep(shot_delay)
                        except Exception:

                            time.sleep(shot_delay)
                except Exception:
                    pass

            cooling_file = os.path.join(magic_folder, "cooling.ogg")
            if magicsys in("at", "rf")and os.path.exists(cooling_file):
                try:
                    self._safe_sound_play("", cooling_file, block = True)
                except Exception:
                    logging.exception("Failed to play cooling sound for magic weapon")

            try:
                cool_amount = float(weapon.get("temp_loss_per_cooling_cycle", weapon.get("temp_loss", 20)or 20))
            except Exception:
                cool_amount = random.uniform(5, 15)

            cool_amount = cool_amount *float(weapon.get("magic_cooling_multiplier", 1.8))

            temperature = max(pre_fire_temp, temperature -cool_amount)

            try:
                combat_state.setdefault("magic_weapon_ids", {})[weapon_id]= True
            except Exception:
                pass

            if magicsys in("at", "rf"):
                try:
                    self._play_weapon_action_sound(weapon, "boltforward")
                except Exception:
                    pass

            combat_state.setdefault("barrel_temperatures", {})[weapon_id]= temperature
            return "Fired(magic)"

        if is_internal:
            internal_rounds = weapon.get("rounds", [])

            if not chambered and not internal_rounds:
                logging.info("Weapon empty(internal) - no rounds present")
                self._safe_sound_play("", "sounds/firearms/universal/dryfire.ogg")
                return "Empty! No rounds loaded."
        else:

            if not chambered and not loaded_mag:
                logging.info("Weapon empty - no magazine loaded")
                self._safe_sound_play("", "sounds/firearms/universal/dryfire.ogg")
                return "Empty! No magazine loaded."

            if not chambered and loaded_mag and not loaded_mag.get("rounds"):
                logging.info("Weapon empty - magazine loaded but empty")
                self._safe_sound_play("", "sounds/firearms/universal/dryfire.ogg")
                return "Empty! Magazine loaded but no rounds."

        temperature = combat_state.get("barrel_temperatures", {}).get(weapon_id, combat_state["ambient_temperature"])
        cleanliness = combat_state.get("barrel_cleanliness", {}).get(weapon_id, 100)

        base_jamrate = weapon.get("jamrate", 0.01)

        ambient = combat_state.get("ambient_temperature", 70)
        temp_above_boiling = max(0, temperature -212)
        temp_mult = 1.0 +(temp_above_boiling /400.0)

        clean_mult = 1.0 -(cleanliness -50)/100.0
        clean_mult = max(0.5, min(1.5, clean_mult))

        total_jamrate = base_jamrate *temp_mult *clean_mult

        logging.debug(
        "Jam calc: base=%s temp_mult=%s clean_mult=%s total=%s temp=%s clean=%s",
        base_jamrate,
        temp_mult,
        clean_mult,
        total_jamrate,
        temperature,
        cleanliness
        )

        cyclic = weapon.get("cyclic", 600)or 600
        base_delay = max(0.0, 60.0 /cyclic)

        burst_cyclic = weapon.get("burst_cyclic")
        try:
            if burst_cyclic:
                burst_cyclic = float(burst_cyclic)
            else:
                burst_cyclic = None
        except Exception:
            burst_cyclic = None
        burst_base_delay = max(0.0, 60.0 /burst_cyclic)if burst_cyclic and burst_cyclic >0 else base_delay

        try:
            burst_pause = float(weapon.get("burst_pause"))
            if burst_pause <0:
                burst_pause = None
        except Exception:
            burst_pause = None
        if burst_pause is None:

            burst_pause = max(0.22, base_delay *1.5)

        actual_rounds_to_fire = rounds_to_fire
        burst_count = weapon.get("burst_count", 0)

        if fire_mode =="Bolt":
            actual_rounds_to_fire = 1
            logging.debug("Bolt-action fire mode: forcing rounds to 1")

        elif effective_is_pump:
            actual_rounds_to_fire = 1
            logging.debug("Pump-action weapon(selected): forcing rounds to 1")
        elif fire_mode =="Burst"and burst_count >0:

            actual_rounds_to_fire =((rounds_to_fire +burst_count -1)//burst_count)*burst_count
            logging.debug(
            "Burst fire mode: requested=%s burst_count=%s actual=%s",
            rounds_to_fire,
            burst_count,
            actual_rounds_to_fire
            )

        if weapon.get("gas_melted", False):
            actual_rounds_to_fire = 1
            logging.debug("Gas-melted weapon detected: forcing single-shot behavior")

        is_semi = fire_mode =="Semi"
        is_burst = fire_mode =="Burst"and burst_count >0
        is_auto = fire_mode =="Auto"

        is_bolt = fire_mode =="Bolt"or bool(weapon.get("gas_melted", False))

        rounds_fired = 0
        jammed = False

        fire_to_pump_delay = weapon.get("pump_fire_to_back_delay", 0.12)
        pump_back_to_forward_delay = weapon.get("pump_back_to_forward_delay", 0.15)

        if effective_is_pump:
            if actual_rounds_to_fire !=1:
                logging.debug("Pump-action weapon detected(selected): limiting actual_rounds_to_fire to 1")
            actual_rounds_to_fire = 1

        rotary_channel = None
        rotary_sound = None
        rotary_playing = False
        try:
            if weapon.get("rotary_gun"):
                def _find_sound_candidate(action_name):
                    try:
                        fs = weapon.get("fire_sounds")or weapon.get("sounds")or weapon.get("sound_folder")or weapon.get("reload_sounds")
                    except Exception:
                        fs = None

                    candidates =[]
                    if fs:
                        wf = os.path.join("sounds", "firearms", str(fs).lower())
                        for pat in(f"{action_name}*.ogg", f"{action_name}*.wav"):
                            candidates +=glob.glob(os.path.join(wf, pat))
                        if not candidates:
                            wf2 = os.path.join("sounds", "firearms", "weaponsounds", str(fs).lower())
                            for pat in(f"{action_name}*.ogg", f"{action_name}*.wav"):
                                candidates +=glob.glob(os.path.join(wf2, pat))

                    try:
                        plat = str(weapon.get("platform")or "").lower()
                    except Exception:
                        plat = None
                    if plat:
                        wf3 = os.path.join("sounds", "firearms", "weaponsounds", plat)
                        for pat in(f"{action_name}*.ogg", f"{action_name}*.wav"):
                            candidates +=glob.glob(os.path.join(wf3, pat))

                    uni = os.path.join("sounds", "firearms", "universal")
                    for pat in(f"{action_name}*.ogg", f"{action_name}*.wav"):
                        candidates +=glob.glob(os.path.join(uni, pat))

                    return candidates[0]if candidates else None

                try:
                    path_windup = _find_sound_candidate("rotarywindup")
                    if path_windup:
                        try:
                            self._safe_sound_play("", path_windup, block = True)
                        except Exception:
                            pass
                    else:

                        try:
                            self._safe_sound_play("", os.path.join("sounds", "firearms", "universal", "rotarywindup.ogg"), block = True)
                        except Exception:
                            pass
                except Exception:
                    pass

                try:
                    path_loop = _find_sound_candidate("rotaryloop")
                    if not path_loop:
                        path_loop = os.path.join("sounds", "firearms", "universal", "rotaryloop.ogg")
                    if os.path.exists(path_loop):
                        try:
                            rotary_sound = pygame.mixer.Sound(path_loop)
                            rotary_channel = pygame.mixer.find_channel()
                            if rotary_channel:
                                rotary_channel.play(rotary_sound, loops = -1)
                                rotary_playing = True
                        except Exception:
                            rotary_channel = None
                            rotary_sound = None
                except Exception:
                    rotary_channel = None
                    rotary_sound = None
        except Exception:
            rotary_channel = None
            rotary_sound = None

        for i in range(actual_rounds_to_fire):

            if random.random()<total_jamrate:
                jammed = True
                logging.info(f"Weapon jammed after {rounds_fired} rounds!")
                break

            fired_this_iteration = False
            fired_round = None
            if chambered:
                fired_round = chambered

                try:

                    self._play_firearm_sound(weapon, "fire", fired_round = fired_round)
                except Exception:
                    self._play_firearm_sound(weapon, "fire")
                rounds_fired +=1
                chambered = None
                fired_this_iteration = True
            elif is_internal and weapon.get("rounds"):
                chambered = weapon["rounds"].pop(0)
                fired_round = chambered
                try:
                    self._play_firearm_sound(weapon, "fire", fired_round = fired_round)
                except Exception:
                    self._play_firearm_sound(weapon, "fire")
                rounds_fired +=1
                fired_this_iteration = True
            elif loaded_mag and loaded_mag.get("rounds"):
                chambered = loaded_mag["rounds"].pop(0)
                fired_round = chambered
                try:
                    self._play_firearm_sound(weapon, "fire", fired_round = fired_round)
                except Exception:
                    self._play_firearm_sound(weapon, "fire")
                rounds_fired +=1
                fired_this_iteration = True
            else:

                logging.info("Ran out of ammo mid-burst after %s rounds", rounds_fired)
                break

            if fired_this_iteration:

                try:
                    if fired_round:

                        is_40mm = False
                        try:
                            if isinstance(fired_round, dict):
                                name = str(fired_round.get("name")or "").lower()
                                if "40x46"in name or "40mm"in name or "40 x 46"in name:
                                    is_40mm = True
                                calib = fired_round.get("caliber")
                                if calib and not is_40mm:
                                    if isinstance(calib, (list, tuple)):
                                        for c in calib:
                                            if isinstance(c, str)and "40"in c and "mm"in c:
                                                is_40mm = True
                                                break
                                    elif isinstance(calib, str)and "40"in calib and "mm"in calib:
                                        is_40mm = True

                                if not is_40mm and(str(fired_round.get("ammo_type")or "").lower()=="40mm_grenade"or str(fired_round.get("sounds")or "").lower()in("40mm_grenade", "40mm")):
                                    is_40mm = True
                        except Exception:
                            logging.exception("Error inspecting fired_round for 40mm detection")

                        if is_40mm:
                            try:
                                self._handle_40mm_post_fire_effects(weapon, fired_round)
                            except Exception:
                                logging.exception("Failed to schedule 40mm post-fire effects")
                except Exception:
                    logging.exception("Error checking fired_round for 40mm handling")

                try:
                    if isinstance(weapon, dict)and weapon.get("_ub_loaded")is not None:
                        try:
                            weapon["_ub_loaded"]= max(0, int(weapon.get("_ub_loaded", 0))-1)
                        except Exception:
                            weapon["_ub_loaded"]= 0
                        if weapon.get("_ub_loaded", 0)<=0:

                            pass
                except Exception:
                    logging.exception("Failed updating underbarrel loaded count after fire")

                try:
                    play_casing = False
                    if fired_round:
                        try:

                            is_40mm = False
                            if isinstance(fired_round, dict):
                                fname = str(fired_round.get("name")or "").lower()
                                if "40x46"in fname or "40mm"in fname or "40 x 46"in fname:
                                    is_40mm = True
                                fcal = fired_round.get("caliber")
                                if fcal and not is_40mm:
                                    if isinstance(fcal, (list, tuple)):
                                        for c in fcal:
                                            if isinstance(c, str)and "40"in c and "mm"in c:
                                                is_40mm = True
                                                break
                                    elif isinstance(fcal, str)and "40"in fcal and "mm"in fcal:
                                        is_40mm = True
                                if not is_40mm and(str(fired_round.get("ammo_type")or "").lower()=="40mm_grenade"or str(fired_round.get("sounds")or "").lower()in("40mm_grenade", "40mm")):
                                    is_40mm = True
                            if not is_40mm:
                                play_casing = True
                        except Exception:
                            logging.exception("Error detecting 40mm for casing logic")

                    if play_casing:
                        try:

                            try:
                                if str(weapon.get("type")or "").lower()=="caseless":

                                    play_casing = False

                            except Exception:
                                pass

                            is_shotgun = False
                            try:

                                if isinstance(fired_round, dict):
                                    fr_name = str(fired_round.get("name")or "").lower()
                                    fr_cal = fired_round.get("caliber")
                                    fr_cal_str = ""
                                    if isinstance(fr_cal, (list, tuple)):
                                        fr_cal_str = " ".join([str(x)for x in fr_cal]).lower()
                                    elif fr_cal:
                                        fr_cal_str = str(fr_cal).lower()
                                    if "gauge"in fr_name or "gauge"in fr_cal_str or "bore"in fr_cal_str:
                                        is_shotgun = True

                                if not is_shotgun:
                                    mag_type = str(weapon.get("magazinetype", "")or "").lower()
                                    platform = str(weapon.get("platform", "")or "").lower()
                                    calib = weapon.get("caliber")or[]
                                    calib_str = " ".join([str(x)for x in calib])if isinstance(calib, (list, tuple))else str(calib)
                                    if "tube"in mag_type or "shotgun"in platform or "gauge"in calib_str.lower()or "bore"in calib_str.lower():
                                        is_shotgun = True
                            except Exception:
                                pass

                            if is_shotgun:
                                candidates = glob.glob(os.path.join("sounds", "firearms", "universal", "shelldrop*.ogg"))+glob.glob(os.path.join("sounds", "firearms", "universal", "shelldrop*.wav"))
                            else:
                                candidates = glob.glob(os.path.join("sounds", "firearms", "universal", "casing*.ogg"))+glob.glob(os.path.join("sounds", "firearms", "universal", "casing*.wav"))

                            if candidates:
                                try:
                                    self._safe_sound_play("", random.choice(candidates))
                                except Exception:
                                    logging.exception("Failed to play casing/shelldrop sound")
                        except Exception:
                            logging.exception("Error selecting/playing casing sound")
                except Exception:
                    logging.exception("Casing/shelldrop handling failed")
                if effective_is_pump:

                    time.sleep(fire_to_pump_delay)
                    self._play_weapon_action_sound(weapon, "pumpback")
                    time.sleep(pump_back_to_forward_delay)

                    if is_internal and weapon.get("rounds"):
                        chambered = weapon["rounds"].pop(0)
                    elif loaded_mag and loaded_mag.get("rounds"):
                        chambered = loaded_mag["rounds"].pop(0)
                    self._play_weapon_action_sound(weapon, "pumpforward")
                else:

                    if not is_bolt:
                        if is_internal and weapon.get("rounds"):
                            chambered = weapon["rounds"].pop(0)
                        elif loaded_mag and loaded_mag.get("rounds"):
                            chambered = loaded_mag["rounds"].pop(0)

                try:
                    is_single_action = False
                    weapon_action = weapon.get("action", "")
                    if isinstance(weapon_action, (list, tuple)):
                        weapon_action = weapon_action[0]if weapon_action else ""
                    weapon_action = str(weapon_action).lower()
                    if weapon_action =="single":
                        is_single_action = True

                    is_cylinder = "cylinder"in magazine_type

                    if is_single_action and is_cylinder:
                        time.sleep(0.08)
                        self._play_cylinder_sound(weapon, "hammerdown")
                except Exception:
                    logging.exception("Error handling single-action hammer pull")
            else:

                logging.info("Ran out of ammo mid-burst after %s rounds", rounds_fired)
                break

            try:
                temp_gain = float(weapon.get("temp_gain_per_shot", weapon.get("temp_gain", None)))
            except Exception:
                temp_gain = None
            if temp_gain is None:

                temp_gain = random.uniform(5.0, 10.0)
            if self._check_weapon_suppressed(weapon):
                temp_gain *=1.5
            temperature +=temp_gain

            try:
                melt_temp = float(weapon.get("melt_temp", 3000))
            except Exception:
                melt_temp = 3000.0
            if temperature >=melt_temp and not weapon.get("gas_melted", False)and weapon.get("can_melt", True):
                weapon["gas_melted"]= True
                is_bolt = True
                logging.warning("Weapon %s gas system MELTED at %.1fÂ°F(in-shot)", weapon.get("name", weapon_id), temperature)

            cleanliness -=random.uniform(0.1, 0.3)
            cleanliness = max(0, cleanliness)

            if is_bolt:

                pass
            elif is_semi:

                time.sleep(base_delay +0.18)
            elif is_burst:

                shots_in_burst =(i +1)%burst_count
                if shots_in_burst ==0 and i +1 <actual_rounds_to_fire:

                    time.sleep(burst_pause)
                else:

                    time.sleep(burst_base_delay)
            else:

                time.sleep(base_delay)

        try:
            if rotary_playing and rotary_channel:
                try:
                    rotary_channel.stop()
                except Exception:
                    pass

                try:
                    def _find_winddown():
                        try:
                            fs = weapon.get("fire_sounds")or weapon.get("sounds")or weapon.get("sound_folder")or weapon.get("reload_sounds")
                        except Exception:
                            fs = None
                        cand_list =[]
                        if fs:
                            wf = os.path.join("sounds", "firearms", str(fs).lower())
                            cand_list +=glob.glob(os.path.join(wf, "rotarywinddown*.ogg"))+glob.glob(os.path.join(wf, "rotarywinddown*.wav"))
                            wf2 = os.path.join("sounds", "firearms", "weaponsounds", str(fs).lower())
                            cand_list +=glob.glob(os.path.join(wf2, "rotarywinddown*.ogg"))+glob.glob(os.path.join(wf2, "rotarywinddown*.wav"))

                        try:
                            plat = str(weapon.get("platform")or "").lower()
                        except Exception:
                            plat = None
                        if plat:
                            wf3 = os.path.join("sounds", "firearms", "weaponsounds", plat)
                            cand_list +=glob.glob(os.path.join(wf3, "rotarywinddown*.ogg"))+glob.glob(os.path.join(wf3, "rotarywinddown*.wav"))

                        uni = os.path.join("sounds", "firearms", "universal")
                        cand_list +=glob.glob(os.path.join(uni, "rotarywinddown*.ogg"))+glob.glob(os.path.join(uni, "rotarywinddown*.wav"))

                        return cand_list[0]if cand_list else None

                    winddown_path = _find_winddown()
                    if winddown_path:
                        try:
                            self._safe_sound_play("", winddown_path, block = True)
                        except Exception:
                            pass
                    else:
                        try:
                            self._safe_sound_play("", os.path.join("sounds", "firearms", "universal", "rotarywinddown.ogg"), block = True)
                        except Exception:
                            pass
                except Exception:
                    try:
                        self._safe_sound_play("", os.path.join("sounds", "firearms", "universal", "rotarywinddown.ogg"), block = True)
                    except Exception:
                        pass
        except Exception:
            pass

        weapon["chambered"]= chambered
        weapon["loaded"]= loaded_mag

        if "barrel_temperatures"not in combat_state:
            combat_state["barrel_temperatures"]= {}
        if "barrel_cleanliness"not in combat_state:
            combat_state["barrel_cleanliness"]= {}
        if "weapon_last_used"not in combat_state:
            combat_state["weapon_last_used"]= {}

        try:
            melt_temp = float(weapon.get("melt_temp", 3000))
        except Exception:
            melt_temp = 3000.0
        if temperature >=melt_temp and weapon.get("can_melt", True):
            weapon["gas_melted"]= True
            logging.warning("Weapon %s gas system MELTED at %.1fÂ°F", weapon.get("name", weapon_id), temperature)

        combat_state["barrel_temperatures"][weapon_id]= temperature
        combat_state["barrel_cleanliness"][weapon_id]= cleanliness
        combat_state["weapon_last_used"][weapon_id]= time.time()

        if is_bolt and rounds_fired >0 and not jammed:

            time.sleep(0.28)

            try:
                if is_internal:
                    if weapon.get("rounds"):
                        next_round = weapon["rounds"].pop(0)
                        weapon["chambered"]= next_round
                        cycle_result = "next round automatically chambered"
                    else:
                        weapon["chambered"]= None
                        cycle_result = "bolt cycled(no rounds left to chamber)"
                else:
                    if loaded_mag and loaded_mag.get("rounds"):
                        next_round = loaded_mag["rounds"].pop(0)
                        weapon["chambered"]= next_round
                        cycle_result = "next round automatically chambered"
                    else:
                        weapon["chambered"]= None
                        cycle_result = "bolt cycled(no rounds left to chamber)"
            except Exception:
                cycle_result = None

            try:
                if weapon.get("gas_melted", False):

                    self._cycle_bolt_sounds(weapon, single_forward = False, delay = 0.0)
                else:

                    if weapon.get("chambered")is None:

                        if bool(weapon.get("bolt_catch", False)):
                            try:
                                self._play_weapon_action_sound(weapon, "boltforward")
                            except Exception:
                                pass
                    else:

                        self._cycle_bolt_sounds(weapon, single_forward = False, delay = 0.12)
            except Exception:
                try:

                    self._cycle_bolt_sounds(weapon, single_forward = False, delay = 0.12)
                except Exception:
                    pass
        else:
            cycle_result = None

        if rounds_fired >0:
            rolls, median = self._roll_d20_dice(rounds_fired)
            weapon_name = weapon.get("name", "Unknown")
            caliber_list = weapon.get("caliber", [])or["Unknown"]
            caliber = caliber_list[0]

            variant = "Unknown"

            if chambered and isinstance(chambered, dict):
                variant = chambered.get("variant", "Unknown")

            elif loaded_mag and loaded_mag.get("rounds"):
                first_round = loaded_mag["rounds"][0]
                if isinstance(first_round, dict):
                    variant = first_round.get("variant", "Unknown")
                elif isinstance(first_round, str)and " | "in first_round:
                    variant = first_round.split(" | ")[1]

            elif chambered and isinstance(chambered, str)and " | "in chambered:
                variant = chambered.split(" | ")[1]

            effective_aim = 0
            try:

                if save_data and isinstance(save_data, dict):
                    sd_stats = save_data.get("stats", {})or {}
                    if isinstance(sd_stats, dict):
                        if "Aim"in sd_stats:
                            effective_aim +=float(sd_stats.get("Aim", 0)or 0)
                        else:

                            effective_aim +=float(sd_stats.get("aim", 0)or 0)
            except Exception:
                pass
            try:

                if isinstance(weapon, dict):
                    mods = weapon.get("_active_modifiers", {})or {}
                    stats_mods = mods.get("stats", {})if isinstance(mods, dict)else {}
                    if isinstance(stats_mods, dict):
                        effective_aim +=float(stats_mods.get("aim", 0)or 0)

                    wstats = weapon.get("stats", {})or {}
                    if isinstance(wstats, dict):
                        effective_aim +=float(wstats.get("aim", 0)or 0)
            except Exception:
                pass

            try:
                fired_round_for_bonus = chambered
                if not fired_round_for_bonus and loaded_mag and loaded_mag.get("rounds"):
                    fired_round_for_bonus = loaded_mag["rounds"][0]if loaded_mag["rounds"]else None

                if fired_round_for_bonus and isinstance(fired_round_for_bonus, dict):
                    round_mods = fired_round_for_bonus.get("modifiers", {})or {}
                    if isinstance(round_mods, dict):
                        round_stats = round_mods.get("stats", {})or {}
                        if isinstance(round_stats, dict):
                            effective_aim +=float(round_stats.get("aim", 0)or 0)
            except Exception:
                pass

            try:
                pre_clamp_aim = effective_aim
                clamp_val = None

                try:
                    if isinstance(weapon, dict)and weapon.get("bonus_clamp")is not None:
                        clamp_val = float(weapon.get("bonus_clamp"))
                except Exception:
                    clamp_val = None

                if clamp_val is None:
                    try:
                        current_tbl = global_variables.get('current_table')
                        if current_tbl:
                            tbl_path = os.path.join("tables", current_tbl)
                        else:
                            tbl_path = os.path.join("tables", sorted(glob.glob(os.path.join("tables", "*.sldtbl")))[0])if glob.glob(os.path.join("tables", "*.sldtbl"))else None
                        if tbl_path and os.path.exists(tbl_path):
                            with open(tbl_path, 'r', encoding = 'utf-8')as tf:
                                import json as _json
                                tdata = _json.load(tf)
                                clamp_val = tdata.get('additional_settings', {}).get('bonus_clamp')
                    except Exception:
                        clamp_val = None

                applied_clamp = False
                if clamp_val is not None:
                    try:
                        clamp_num = float(clamp_val)
                        if effective_aim >clamp_num:
                            effective_aim = clamp_num
                            applied_clamp = True
                    except Exception:
                        applied_clamp = False
                final_total = int(median)+int(round(effective_aim))
            except Exception:
                final_total = median

            round_display = str(caliber)
            try:

                if isinstance(variant, dict):
                    vname = variant.get("name")or variant.get("variant")or variant.get("variant_name")
                    if vname:
                        round_display = f"{caliber} {vname}"

                elif isinstance(variant, (list, tuple)):
                    try:
                        parts =[str(x).strip()for x in variant if x is not None]
                        if parts:
                            round_display = f"{caliber} {' '.join(parts)}"
                    except Exception:
                        pass
                elif isinstance(variant, str)and variant and variant !="Unknown":
                    maybe = variant.strip()

                    try:
                        simple = True

                        for ch in "{}[](), '\"":
                            if ch in maybe:
                                simple = False
                                break

                        if "caliber"in maybe.lower()or "variant"in maybe.lower():
                            simple = False
                        if simple and maybe:
                            round_display = f"{caliber} {maybe}"

                            maybe = None
                    except Exception:
                        pass
                    if not maybe:

                        pass
                    else:
                        parsed = None
                    parsed = None

                    if maybe[0]in("{", "[", "("):
                        try:
                            import ast as _ast
                            parsed = _ast.literal_eval(maybe)
                        except Exception:
                            parsed = None
                    if isinstance(parsed, dict):
                        vname = parsed.get("name")or parsed.get("variant")or parsed.get("variant_name")
                        if vname:
                            round_display = f"{caliber} {vname}"
                        elif parsed.get("caliber")and parsed.get("variant"):
                            round_display = f"{parsed.get('caliber')} {parsed.get('variant')}"
                    elif isinstance(parsed, (list, tuple)):
                        try:
                            parts =[str(x).strip()for x in parsed if x is not None]
                            if parts:
                                round_display = f"{caliber} {' '.join(parts)}"
                        except Exception:
                            pass
                    else:

                        try:
                            import re as _re
                            m = _re.search(r"variant\s*[:=]\s*['\"]([^'\"]+)['\"]", maybe, _re.IGNORECASE)
                            if m:
                                round_display = f"{caliber} {m.group(1)}"
                            else:

                                cleaned = maybe
                        except Exception:
                            cleaned = maybe

                        if(cleaned.startswith("{")and cleaned.endswith("}"))or(cleaned.startswith("[")and cleaned.endswith("]"))or(cleaned.startswith("(")and cleaned.endswith(")")):
                            cleaned = cleaned[1:-1]

                        parts =[p.strip().strip("'\"")for p in cleaned.split(", ")if p.strip()]
                        if len(parts)==1:
                            if parts[0]:
                                round_display = f"{caliber} {parts[0]}"
                        elif len(parts)>=2:

                            candidate = parts[-1]
                            try:
                                import re as _re

                                m = _re.search(r"['\"]([^'\"]+)['\"]", candidate)
                                if m:
                                    candidate = m.group(1)
                                else:

                                    m2 = _re.search(r"variant\s*[:=]\s*([^,}\)\]]+)", candidate, _re.IGNORECASE)
                                    if m2:
                                        candidate = m2.group(1).strip().strip("'\"{}[]() ")
                                    else:

                                        candidate = candidate.strip().strip("'\"{}[]() ")
                            except Exception:
                                candidate = candidate.strip().strip("'\"{}[]() ")
                            round_display = f"{caliber} {candidate}"
            except Exception:
                pass

            try:
                import re as _re

                round_display = _re.sub(r"[\s:|]+$", "", round_display)

                round_display = _re.sub(r"\s+", " ", round_display).strip()
            except Exception:
                try:
                    round_display = round_display.strip()
                except Exception:
                    pass

            try:
                if round_display ==str(caliber):
                    current_tbl = global_variables.get('current_table')
                    if current_tbl:
                        tbl_path = os.path.join("tables", current_tbl)
                    else:
                        tbl_path = os.path.join("tables", sorted(glob.glob(os.path.join("tables", "*.sldtbl")))[0])if glob.glob(os.path.join("tables", "*.sldtbl"))else None
                    if tbl_path and os.path.exists(tbl_path):
                        try:
                            with open(tbl_path, 'r', encoding = 'utf-8')as tf:
                                import json as _json
                                tdata = _json.load(tf)
                                ammo_arr = tdata.get('tables', {}).get('ammunition', [])
                                for a in ammo_arr:
                                    try:
                                        if a.get('caliber')==caliber:
                                            variants = a.get('variants')or[]
                                            if variants and isinstance(variants, list):
                                                first = variants[0]
                                                if isinstance(first, dict)and first.get('name'):
                                                    round_display = f"{caliber} {first.get('name')}"
                                                    break
                                                elif isinstance(first, str)and first:
                                                    round_display = f"{caliber} {first}"
                                                    break
                                    except Exception:
                                        continue
                        except Exception:
                            pass
            except Exception:
                pass

            is_suppressed = self._check_weapon_suppressed(weapon)
            suppressed_tag = " | Suppressed"if is_suppressed else ""
            clipboard_text = f"Roll: {final_total} | Weapon: {weapon_name} | Round: {round_display} | {rounds_fired} rounds fired{suppressed_tag}"
            self._copy_to_clipboard(clipboard_text)
            logging.info(f"D20 rolls: {rolls}, Rounded avg: {median}")

            try:
                sd_ref = save_data if isinstance(save_data, dict)else globals().get('save_data')or getattr(self, '_current_save_data', None)
                if isinstance(sd_ref, dict):
                    ts = sd_ref.setdefault('tracked_stats', {})
                    if isinstance(ts, dict):
                        ts['rounds_fired_total']= int(ts.get('rounds_fired_total', 0))+int(rounds_fired)
                        ts['d20_rolls_total']= int(ts.get('d20_rolls_total', 0))+len(rolls)
                        ts['d20_ones']= int(ts.get('d20_ones', 0))+sum(1 for r in rolls if r ==1)
                        ts['d20_twenties']= int(ts.get('d20_twenties', 0))+sum(1 for r in rolls if r ==20)
                        hist = ts.setdefault('d20_roll_history', [])
                        try:
                            hist.append({'weapon_id':weapon_id, 'rolls':rolls, 'time':time.time()})
                        except Exception:
                            pass
            except Exception:
                logging.exception('Failed updating tracked_stats after firing')

            # Update per-session combat report stats
            try:
                sd_ref2 = save_data if isinstance(save_data, dict) else globals().get('save_data') or getattr(self, '_current_save_data', None)
                fired_round_ref = None
                try:
                    fired_round_ref = fired_round  # type: ignore
                except Exception:
                    pass
                if fired_round_ref is None:
                    try:
                        if chambered and isinstance(chambered, dict):
                            fired_round_ref = chambered
                    except Exception:
                        pass
                self._update_session_fire_stats(sd_ref2, rounds_fired, rolls, fired_round=fired_round_ref)
            except Exception:
                logging.exception('Failed updating session fire stats')

            try:
                popup_lines =[
                f"Base roll(rounded avg): {median}",
                f"Aim bonus: {int(round(effective_aim))}",
                f"Final total: {final_total}",
                f"Weapon: {weapon_name}",
                f"Round: {round_display}",
                f"Rounds fired: {rounds_fired}"
                ]
                try:
                    if 'applied_clamp'in locals()and applied_clamp:
                        popup_lines.insert(2, f"Bonus clamp applied: +{int(clamp_num)}(was {int(round(pre_clamp_aim))})")
                except Exception:
                    pass
                roll_summary_text = "\n".join(popup_lines)
            except Exception:
                roll_summary_text = None

        if jammed:

            import random as _rand

            if loaded_mag and isinstance(loaded_mag, dict)and loaded_mag.get("magazinetype"):
                magazine_type = str(loaded_mag.get("magazinetype", "")or "").lower()
            else:
                magazine_type = str(weapon.get("magazinetype", "")or "").lower()

            sub_mag = str(weapon.get("submagazinetype", "")or "").lower()

            weapon_platform = str(weapon.get("platform", "")or "").lower()
            if weapon.get("infinite_ammo")and not loaded_mag:

                has_detachable_mag = "box"in magazine_type and not any(k in magazine_type for k in("internal", "tube", "cylinder"))and "revolver"not in weapon_platform
            else:
                has_detachable_mag = bool(loaded_mag)and not any(k in magazine_type for k in("internal", "tube", "cylinder"))and "revolver"not in weapon_platform

            progress = None
            try:
                progress = self._popup_progress("Clearing Jam", "Preparing to clear jam...")
            except Exception:
                progress = None

            try:
                if has_detachable_mag:
                    if progress:
                        progress["update"]("Dropping magazine...")

                    try:
                        mag_type_rt =(weapon.get("magazinetype", "")or "").lower()
                        plat_rt =(weapon.get("platform", "")or "").lower()
                        mag_type_rt =(weapon.get("magazinetype", "")or "").lower()
                        plat_rt =(weapon.get("platform", "")or "").lower()
                        is_belt_rt =("belt"in mag_type_rt)or("belt"in plat_rt)or("m249"in plat_rt)
                        if is_belt_rt:
                            if weapon.get("dualfeed")and(weapon.get("submagazinesystem")or weapon.get("submagazinetype")):
                                self._perform_dualfeed_belt_reload_sequence(weapon)
                            else:
                                self._perform_belt_reload_sequence(weapon)
                        else:
                            self._play_weapon_action_sound(weapon, "magout")
                    except Exception:

                        try:
                            self._play_weapon_action_sound(weapon, "magout")
                        except Exception:
                            pass

                if progress:
                    progress["update"]("Waiting(1.0-1.5s)...")
                time.sleep(_rand.uniform(1.0, 1.5))

                if progress:
                    if is_pump:
                        progress["update"]("Pumping action back...")
                    else:
                        progress["update"]("Racking bolt back...")

                if is_pump:
                    self._play_weapon_action_sound(weapon, "pumpback")
                else:

                    self._cycle_bolt_sounds(weapon, single_forward = False, delay = 0.1)

                time.sleep(0.1)

                if progress:
                    if is_pump:
                        progress["update"]("Pumping action forward...")
                    else:
                        progress["update"]("Racking bolt forward...")

                if is_pump:
                    self._play_weapon_action_sound(weapon, "pumpforward")
                else:

                    pass

                if progress:
                    progress["update"]("Waiting(3.5-5.0s)...")
                time.sleep(_rand.uniform(3.5, 5.0))

                if has_detachable_mag:
                    if progress:
                        progress["update"]("Inserting magazine...")
                    try:
                        mag_type_rt =(weapon.get("magazinetype", "")or "").lower()
                        plat_rt =(weapon.get("platform", "")or "").lower()
                        mag_type_rt =(weapon.get("magazinetype", "")or "").lower()
                        plat_rt =(weapon.get("platform", "")or "").lower()
                        is_belt_rt =("belt"in mag_type_rt)or("belt"in plat_rt)or("m249"in plat_rt)
                        if is_belt_rt:
                            if weapon.get("dualfeed")and(weapon.get("submagazinesystem")or weapon.get("submagazinetype")):
                                self._perform_dualfeed_belt_reload_sequence(weapon)
                            else:
                                self._perform_belt_reload_sequence(weapon)
                        else:
                            self._play_weapon_action_sound(weapon, "magin")
                    except Exception:
                        pass

                if progress:
                    progress["update"]("Waiting(1.0-1.5s)...")
                time.sleep(_rand.uniform(1.0, 1.5))

                if progress:
                    if is_pump:
                        progress["update"]("Pumping action back...")
                    else:
                        progress["update"]("Racking bolt back...")

                if is_pump:
                    self._play_weapon_action_sound(weapon, "pumpback")
                else:

                    self._cycle_bolt_sounds(weapon, single_forward = False, delay = 0.1)

                time.sleep(0.1)

                if progress:
                    if is_pump:
                        progress["update"]("Pumping action forward...")
                    else:
                        progress["update"]("Racking bolt forward...")

                if is_pump:
                    self._play_weapon_action_sound(weapon, "pumpforward")
                else:

                    pass
            finally:
                if progress:
                    try:
                        progress["close"]()
                    except Exception:
                        pass

            return f"Fired {rounds_fired} rounds - WEAPON JAMMED! Clear jam and try again."
        else:
            if is_bolt and rounds_fired >0 and cycle_result:
                base = f"Fired {rounds_fired} round(s) successfully - {cycle_result}."
            else:
                base = f"Fired {rounds_fired} rounds successfully."
            if roll_summary_text:
                return f"{base}\n{roll_summary_text}"
            return base

    def _fire_weapon(self, weapon, combat_state, rounds_to_fire = 3, fire_mode = None, save_data = None):
        try:
            return self._fire_weapon_impl(weapon, combat_state, rounds_to_fire = rounds_to_fire, fire_mode = fire_mode, save_data = save_data)
        except Exception:
            logging.exception("Unhandled exception in _fire_weapon for %s", weapon.get('name')if isinstance(weapon, dict)else str(weapon))
            return "Firing failed due to an internal error"

    def _reload_infinite_ammo_weapon(self, weapon, save_data):

        logging.info("_reload_infinite_ammo_weapon: %s", weapon.get("name", "Unknown"))

        try:

            caliber_list = weapon.get("caliber", [])or["Unknown"]
            caliber = caliber_list[0]if isinstance(caliber_list, list)else caliber_list

            mag_to_load = weapon.get("mag_to_load")
            has_magazine_in_pool = weapon.get("has_magazine_in_pool", True)

            table_data = None
            try:
                tbl_path = get_current_table_path()
                if tbl_path and os.path.exists(tbl_path):
                    with open(tbl_path, 'r', encoding = 'utf-8')as f:
                        table_data = json.load(f)
            except Exception:
                logging.exception("Failed to load table data for infinite ammo reload")

            new_mag = None

            if has_magazine_in_pool is False:

                if isinstance(mag_to_load, dict):
                    capacity = mag_to_load.get("capacity", 30)
                    if isinstance(capacity, list):
                        capacity = capacity[0]if capacity else 30
                    new_mag = {
                    "name":f"Infinite {caliber} Magazine",
                    "caliber":[caliber]if not isinstance(caliber, list)else caliber,
                    "capacity":capacity,
                    "magazinesystem":weapon.get("magazinesystem"),
                    "magazinetype":weapon.get("magazinetype", "Detachable box"),
                    "rounds":[],
                    "infinite":True
                    }

                    for _ in range(capacity):
                        new_mag["rounds"].append({
                        "name":f"{caliber} | Infinite",
                        "caliber":caliber,
                        "variant":"Infinite"
                        })
            elif mag_to_load is not None and table_data:

                mag_id = mag_to_load if isinstance(mag_to_load, int)else None
                if mag_id is not None:
                    magazines = table_data.get("tables", {}).get("magazines", [])
                    for mag in magazines:
                        if mag.get("id")==mag_id:

                            new_mag = json.loads(json.dumps(mag))
                            capacity = new_mag.get("capacity", 30)
                            new_mag["rounds"]=[]
                            new_mag["infinite"]= True

                            for _ in range(capacity):
                                new_mag["rounds"].append({
                                "name":f"{caliber} | Infinite",
                                "caliber":caliber,
                                "variant":"Infinite"
                                })
                            break

            if new_mag is None:
                capacity = 30
                loaded = weapon.get("loaded")
                if loaded and isinstance(loaded, dict):
                    capacity = loaded.get("capacity", 30)
                new_mag = {
                "name":f"Infinite {caliber} Magazine",
                "caliber":[caliber]if not isinstance(caliber, list)else caliber,
                "capacity":capacity,
                "magazinesystem":weapon.get("magazinesystem"),
                "magazinetype":weapon.get("magazinetype", "Detachable box"),
                "rounds":[],
                "infinite":True
                }
                for _ in range(capacity):
                    new_mag["rounds"].append({
                    "name":f"{caliber} | Infinite",
                    "caliber":caliber,
                    "variant":"Infinite"
                    })

            current_mag = weapon.get("loaded")
            is_gun_empty = not weapon.get("chambered")and(not current_mag or not current_mag.get("rounds", []))

            if current_mag:
                try:
                    self._play_weapon_action_sound(weapon, "magout", block = True)
                    time.sleep(random.uniform(0.5, 1.0))
                    magdrop_sound = f"magdrop{random.randint(0, 1)}"
                    self._safe_sound_play("", f"sounds/firearms/universal/{magdrop_sound}.ogg")
                except Exception:
                    pass

            time.sleep(random.uniform(0.25, 0.5))

            try:
                self._safe_sound_play("", "sounds/firearms/universal/pouchout.ogg")
            except Exception:
                pass
            time.sleep(random.uniform(0.5, 0.75))
            try:
                self._play_weapon_action_sound(weapon, "magin", block = True)
            except Exception:
                pass

            time.sleep(random.uniform(0.25, 0.5))

            rt_platform = str(weapon.get("platform", "")or "").lower()
            rt_mag_type = str(weapon.get("magazinetype", "")or "").lower()
            rt_action_raw = weapon.get("action", "")or ""
            if isinstance(rt_action_raw, (list, tuple)):
                rt_action_raw = rt_action_raw[0]if rt_action_raw else ""
            rt_action = str(rt_action_raw).lower()
            is_pump =("pump"in rt_platform or rt_action =="pump"or "pump"in rt_mag_type)

            if is_gun_empty:
                if is_pump:
                    try:
                        self._play_weapon_action_sound(weapon, "pumpback", block = True)
                        self._play_weapon_action_sound(weapon, "pumpforward")
                    except Exception:
                        pass
                elif not weapon.get("bolt_catch"):
                    try:
                        self._play_weapon_action_sound(weapon, "boltback", block = True)
                        self._play_weapon_action_sound(weapon, "boltforward")
                    except Exception:
                        pass
                else:
                    try:
                        self._play_weapon_action_sound(weapon, "boltforward")
                    except Exception:
                        pass

            rt_mag_type = str(weapon.get("magazinetype", "")or "").lower()

            if any(k in rt_mag_type for k in("internal", "tube", "cylinder")):
                cur_rounds = weapon.get("rounds", [])or[]

                cur_rounds.extend(list(new_mag.get("rounds", [])))
                weapon["rounds"]= cur_rounds
                if is_gun_empty and weapon["rounds"]and not is_pump:
                    weapon["chambered"]= weapon["rounds"].pop(0)
                elif is_gun_empty:
                    weapon["chambered"]= {
                    "name":f"{caliber} | Infinite",
                    "caliber":caliber,
                    "variant":"Infinite"
                    }
            else:
                weapon["loaded"]= new_mag

                if is_gun_empty and new_mag.get("rounds")and not is_pump:
                    weapon["chambered"]= new_mag["rounds"].pop(0)
                elif is_gun_empty:
                    weapon["chambered"]= {
                    "name":f"{caliber} | Infinite",
                    "caliber":caliber,
                    "variant":"Infinite"
                    }

            rounds_loaded = len(new_mag.get("rounds", []))
            capacity = new_mag.get("capacity", "?")
            return f"Reloaded with infinite ammo({rounds_loaded}/{capacity})"

        except Exception as e:
            logging.exception("Failed to reload infinite ammo weapon")
            return f"Reload failed: {e}"

    def _reload_weapon(self, weapon, save_data, combat_reload = False):

        logging.info(
        "_reload_weapon start: name=%s magsystem=%s combat_reload=%s",
        weapon.get("name", "Unknown"),
        weapon.get("magazinesystem"),
        combat_reload
        )

        try:
            pf = None
            if isinstance(weapon, dict):
                pf = weapon.get("platform")or weapon.get("underbarrel_platform")
            if weapon.get("underbarrel_weapon")or(pf and pf in self.PLATFORM_DEFAULTS):
                return self._reload_underbarrel(weapon, save_data, combat_reload)
        except Exception:
            logging.exception("Underbarrel reload handler check failed")

        if weapon.get("infinite_ammo"):
            return self._reload_infinite_ammo_weapon(weapon, save_data)

        magazine_type = weapon.get("magazinetype", "")or ""
        magazine_type = magazine_type.lower()if isinstance(magazine_type, str)else str(magazine_type).lower()
        magazine_system = weapon.get("magazinesystem")

        if not magazine_system:

            if weapon.get("magazinetype"):
                magazine_system = weapon.get("magazinetype")
            else:

                loaded_mag = weapon.get("loaded")
                if isinstance(loaded_mag, dict)and loaded_mag.get("magazinesystem"):
                    magazine_system = loaded_mag.get("magazinesystem")
                else:

                    found_ms = None

                    for item in save_data.get("hands", {}).get("items", []):
                        if item and isinstance(item, dict)and("rounds"in item or "capacity"in item):
                            if item.get("magazinesystem"):
                                found_ms = item.get("magazinesystem");break
                            if item.get("magazinetype"):
                                found_ms = item.get("magazinetype");break

                    if not found_ms:
                        for slot_name, eq_item in save_data.get("equipment", {}).items():
                            if eq_item and isinstance(eq_item, dict)and("rounds"in eq_item or "capacity"in eq_item):
                                if eq_item.get("magazinesystem"):
                                    found_ms = eq_item.get("magazinesystem");break
                                if eq_item.get("magazinetype"):
                                    found_ms = eq_item.get("magazinetype");break
                    if found_ms:
                        magazine_system = found_ms

        if "internal"in magazine_type:
            return self._reload_internal_magazine(weapon, save_data, magazine_type)

        if "cylinder"in magazine_type:
            return self._reload_cylinder(weapon, save_data)

        if "revolver"in weapon.get("platform", "").lower():
            return self._reload_revolver(weapon, save_data)

        if not magazine_system:
            try:
                sugg = self.suggest_magazine_for_weapon(weapon)
                caps = sugg.get('suggested_capacities')if isinstance(sugg, dict)else None
                nid = sugg.get('next_id')if isinstance(sugg, dict)else None
                note = f"Weapon doesn't use magazines.Suggested capacities: {caps} Next ID: {nid}"
                return note
            except Exception:
                return "Weapon doesn't use magazines."

    def suggest_magazine_for_weapon(self, weapon):

        try:
            name =(weapon.get('name')or '').strip()
        except Exception:
            name = ''
        try:
            calib_raw = weapon.get('caliber')
            if isinstance(calib_raw, (list, tuple))and calib_raw:
                calib = str(calib_raw[0])
            else:
                calib = str(calib_raw or '')
        except Exception:
            calib = ''

        results = {
        'weapon_name':name,
        'caliber':calib,
        'wiki_matches':[],
        'suggested_capacities':[],
        'suggested_mag_item':None,
        'next_id':0,
        'notes':[]
        }

        caliber_map = {
        '9x19':[15, 17, 30],
        '9mm':[15, 17, 30],
        '5.56x45':[30],
        '5.56':[30],
        '7.62x39':[30],
        '7.62x51':[20, 30],
        '7.62':[20, 30],
        '.45 acp':[7, 8, 10],
        '.45':[7, 8, 10],
        '.308':[10, 20, 30],
        '.30-06':[5, 10],
        '12 gauge':[1, 4, 5, 8],
        '40mm':[1]
        }

        def _norm(s):
            try:
                return re.sub(r"[^0-9a-zA-Z\.x\-\s]", '', str(s or '')).strip().lower()
            except Exception:
                return ''

        wiki_candidates =[]
        session = requests.Session()
        try:
            if name:
                q = name
                url = 'https://en.wikipedia.org/w/api.php'
                params = {
                'action':'query',
                'list':'search',
                'srsearch':q,
                'format':'json',
                'srlimit':5
                }
                r = session.get(url, params = params, timeout = 6)
                j = r.json()
                for s in j.get('query', {}).get('search', [])or[]:
                    wiki_candidates.append(s.get('title'))
        except Exception:
            results['notes'].append('Wikipedia search failed for weapon name')

        try:
            if calib:
                q = calib
                url = 'https://en.wikipedia.org/w/api.php'
                params = {
                'action':'query',
                'list':'search',
                'srsearch':q,
                'format':'json',
                'srlimit':5
                }
                r = session.get(url, params = params, timeout = 6)
                j = r.json()
                for s in j.get('query', {}).get('search', [])or[]:
                    if s.get('title')not in wiki_candidates:
                        wiki_candidates.append(s.get('title'))
        except Exception:
            results['notes'].append('Wikipedia search failed for caliber')

        capacities_found =[]
        try:
            url = 'https://en.wikipedia.org/w/api.php'
            for title in wiki_candidates[:6]:
                try:
                    params = {
                    'action':'query',
                    'prop':'extracts',
                    'explaintext':1,
                    'titles':title,
                    'format':'json',
                    'exintro':1
                    }
                    r = session.get(url, params = params, timeout = 6)
                    j = r.json()
                    pages = j.get('query', {}).get('pages', {})or {}
                    text = ''
                    for p in pages.values():
                        text =(p.get('extract')or '')
                        break
                    if not text:

                        params['exintro']= 0
                        r = session.get(url, params = params, timeout = 6)
                        j = r.json()
                        pages = j.get('query', {}).get('pages', {})or {}
                        for p in pages.values():
                            text =(p.get('extract')or '')
                            break
                    if not text:
                        continue
                    results['wiki_matches'].append({'title':title, 'snippet':text[:800]})

                    lower = text.lower()

                    for m in re.finditer(r"magazine", lower):
                        start = max(0, m.start()-120)
                        end = min(len(lower), m.end()+120)
                        context = lower[start:end]
                        nums = re.findall(r"(\d{1, 3})\s*(?:-round|rounds|round|rd|rnd)", context)
                        for n in nums:
                            try:
                                capacities_found.append(int(n))
                            except Exception:
                                pass

                    for m in re.finditer(r"capacity|standard|commonly|usually", lower):
                        start = max(0, m.start()-120)
                        end = min(len(lower), m.end()+120)
                        context = lower[start:end]
                        nums = re.findall(r"(\d{1, 3})\s*(?:rounds|round|rnd|-round)", context)
                        for n in nums:
                            try:
                                capacities_found.append(int(n))
                            except Exception:
                                pass

                    nums = re.findall(r"(\d{1, 3})\s*-?\s*round(?:s)?", lower)
                    for n in nums:
                        try:
                            capacities_found.append(int(n))
                        except Exception:
                            pass
                except Exception:
                    continue
        except Exception:
            results['notes'].append('Failed fetching/parsing Wikipedia extracts')

        caps =[]
        try:
            if capacities_found:

                freq = {}
                for c in capacities_found:
                    freq[c]= freq.get(c, 0)+1
                caps = sorted(freq.keys(), key = lambda x:(-freq[x], x))[:5]
        except Exception:
            caps =[]

        try:
            if not caps and calib:
                ncal = _norm(calib)
                for k, v in caliber_map.items():
                    if k in ncal or ncal in k:
                        caps = v[:3]
                        break
        except Exception:
            pass

        if not caps:
            caps =[10, 20, 30]

        results['suggested_capacities']= caps

        try:
            table_files = glob.glob(os.path.join('tables', '*.sldtbl'))
            maxid = 0
            for tf in table_files:
                try:
                    with open(tf, 'r', encoding = 'utf-8')as fh:
                        td = json.load(fh)
                    tables = td.get('tables', {})
                    for sub, items in tables.items():
                        if isinstance(items, list):
                            for it in items:
                                try:
                                    if isinstance(it, dict)and 'id'in it:
                                        iid = it.get('id')
                                        try:
                                            if iid is None:
                                                continue
                                            iv = int(iid)
                                            if iv >maxid:
                                                maxid = iv
                                        except Exception:
                                            pass
                                except Exception:
                                    pass
                except Exception:
                    continue
            next_id = maxid +1
        except Exception:
            next_id = 0

        results['next_id']= next_id

        try:
            cap = caps[0]if caps else 30
            mag_name = f"Synthetic Mag({cap})"
            mag_item = {
            'id':next_id,
            'name':mag_name,
            'capacity':int(cap),
            'magazinetype':weapon.get('magazinetype')or 'detachable box',
            'magazinesystem':weapon.get('magazinesystem')or weapon.get('magazinetype')or '',
            'rounds':[]
            }

            try:
                round_name =(calib or 'Unknown')+' | FMJ'
            except Exception:
                round_name = 'FMJ'
            for i in range(int(cap)):
                mag_item['rounds'].append({'name':round_name, 'caliber':calib or None, 'variant':'fmj'})
            results['suggested_mag_item']= mag_item
        except Exception:
            results['notes'].append('Failed to build suggested_mag_item')

        return results

    def _categorize_40mm_round(self, round_info):

        try:
            if not isinstance(round_info, dict):
                return None
            keys = {}
            for k in("type", "variant", "subtype", "name"):
                v = round_info.get(k)
                if isinstance(v, str):
                    keys[k]= v.lower()
            name = keys.get("name", "")
            typ = keys.get("type", "")or keys.get("variant", "")or keys.get("subtype", "")

            if "airburst"in name or "air burst"in name or "airburst"in typ or "air burst"in typ:
                return "airburst"
            if "high-explosive"in name or "high explosive"in name or "he"==typ or "high-explosive"in typ:
                return "he"
            if "dual"in name and("high"in name or "explosive"in name or "dp"in name):
                return "hedp"
            if "apers"in name or "ap ers"in name or "ap"in typ or "anti-personnel"in name:
                return "apers"
            if "smoke"in name or "smoke"in typ:
                return "smoke"
            if "gas"in name or "gas"in typ:
                return "gas"

            if "expl"in name:
                return "he"
        except Exception:
            pass
        return None

    def _handle_40mm_post_fire_effects(self, weapon, round_info):

        try:

            platform_key =(weapon.get("platform")or weapon.get("underbarrel_platform")or "").strip()
            if isinstance(platform_key, (list, tuple)):
                platform_key = platform_key[0]if platform_key else ""
            wf = None
            if platform_key and platform_key in self.PLATFORM_DEFAULTS:
                wf = os.path.join("sounds", "firearms", "weaponsounds", str(self.PLATFORM_DEFAULTS[platform_key].get("reload_sound_folder", platform_key)).lower())
            else:

                pf = str(platform_key).lower()
                wf = os.path.join("sounds", "firearms", "weaponsounds", pf)

            cat = self._categorize_40mm_round(round_info)or "he"

            def play_pattern(patterns, block = False):
                candidates =[]
                try:
                    for p in patterns:

                        candidates +=glob.glob(os.path.join(wf, p))
                        try:
                            wav_pat = p.replace('.ogg', '.wav')if '.ogg'in p else p +'.wav'
                            candidates +=glob.glob(os.path.join(wf, wav_pat))
                        except Exception:
                            pass
                except Exception:
                    pass

                if not candidates:
                    for p in patterns:
                        candidates +=glob.glob(os.path.join("sounds", "firearms", "40mm_grenade", p))
                        try:
                            wav_pat = p.replace('.ogg', '.wav')if '.ogg'in p else p +'.wav'
                            candidates +=glob.glob(os.path.join("sounds", "firearms", "40mm_grenade", wav_pat))
                        except Exception:
                            pass
                if candidates:
                    self._safe_sound_play("", random.choice(candidates), block = block)

            import threading
            import random as _r

            if cat =="apers":

                play_pattern(["apers*.ogg"], block = False)
                return

            if cat =="airburst":

                def _airburst():
                    play_pattern(["explode*.ogg"], block = False)
                t = threading.Timer(5.0, _airburst)
                t.daemon = True
                t.start()
                return

            if cat in("he", "hedp"):

                delay = _r.uniform(0.2, 1.0)
                def _do_he():

                    play_pattern(["explode*.ogg"], block = False)
                    if cat =="he":

                        time.sleep(0.08)
                        play_pattern(["explode*.ogg"], block = False)
                t = threading.Timer(delay, _do_he)
                t.daemon = True
                t.start()
                return

            if cat in("smoke", "gas"):
                delay = _r.uniform(0.5, 2.5)
                def _do_smoke():

                    play_pattern(["smoke*.ogg"], block = False)
                t = threading.Timer(delay, _do_smoke)
                t.daemon = True
                t.start()
                return

            delay = _r.uniform(0.2, 1.0)
            def _do_default():
                play_pattern(["explode*.ogg"], block = False)
            t = threading.Timer(delay, _do_default)
            t.daemon = True
            t.start()
            return
        except Exception:
            logging.exception("Error in _handle_40mm_post_fire_effects")
            return

    def _reload_underbarrel(self, accessory, save_data, combat_reload = False):

        try:
            platform = None
            if isinstance(accessory, dict):
                platform = accessory.get("platform")or accessory.get("underbarrel_platform")

            if not platform and isinstance(accessory, dict):
                try:
                    aname = str(accessory.get("name")or "").lower()
                    if "m203"in aname or "m-203"in aname or "203"in aname:
                        platform = "M203"
                except Exception:
                    pass

            try:
                ub_type = None
                if isinstance(accessory, dict):
                    ub_type = accessory.get("underbarrel_type")or accessory.get("underbarrel")

                if isinstance(ub_type, str):
                    ut = ub_type.lower()
                    if "shot"in ut or "gauge"in ut or "12"in ut:
                        defaults = {"ammo_type":"12 Gauge", "capacity":accessory.get("capacity", 1)or 1, "reload_sound_folder":"12gauge", "magazinetype":accessory.get("magazinetype", "internal")}
                    elif "40"in ut or "m203"in ut or "grenade"in ut:
                        defaults = {"ammo_type":"40mm_grenade", "capacity":accessory.get("capacity", 1)or 1, "reload_sound_folder":"m203", "magazinetype":accessory.get("magazinetype", "single")}
                    else:
                        defaults = self.PLATFORM_DEFAULTS.get(platform or "", {"ammo_type":"40mm_grenade", "capacity":1, "reload_sound_folder":"40mm_grenade"})
                else:
                    defaults = self.PLATFORM_DEFAULTS.get(platform or "", {"ammo_type":"40mm_grenade", "capacity":1, "reload_sound_folder":"40mm_grenade"})
            except Exception:
                defaults = self.PLATFORM_DEFAULTS.get(platform or "", {"ammo_type":"40mm_grenade", "capacity":1, "reload_sound_folder":"40mm_grenade"})

            capacity = defaults.get("capacity", 1)

            try:
                ub_type = None
                ub_sub = None
                if isinstance(accessory, dict):
                    ub_type = accessory.get("underbarrel_type")or accessory.get("type")
                    ub_sub = accessory.get("underbarrel_subtype")or accessory.get("underbarrel_subtype")

                is_conventional = False
                if isinstance(ub_type, str)and ub_type.lower()=="conventional":
                    is_conventional = True
                if isinstance(ub_sub, str)and "shot"in ub_sub.lower():
                    is_conventional = True

                if is_conventional:
                    mag_type = accessory.get("magazinetype")or defaults.get("magazinetype")or "internal"
                    logging.debug("Underbarrel reload: treating as conventional underbarrel(underbarrel_type=%s, underbarrel_subtype=%s, magazinetype=%s)", ub_type, ub_sub, mag_type)
                    mt_l = str(mag_type).lower()
                    if any(k in mt_l for k in("internal", "tube", "box")):
                        return self._reload_internal_magazine(accessory, save_data, mag_type)
                    if "revolver"in mt_l:
                        return self._reload_revolver(accessory, save_data)
                    return self._reload_weapon(accessory, save_data, combat_reload)
            except Exception:
                logging.exception("Failed to delegate underbarrel reload to normal handlers; falling back to custom logic")

            def _is_compatible_ammo(it, desired):
                try:
                    if not isinstance(it, dict):
                        return False
                    name =(it.get("name")or "").lower()
                    calib = it.get("caliber")
                    ammo_type_field =(it.get("ammo_type")or "").lower()
                    desired_l =(desired or "").lower()

                    if "40"in desired_l or "40mm"in desired_l or "grenade"in desired_l:
                        if "40x46"in name or "40mm"in name or "40 x 46"in name:
                            return True
                        if calib:
                            if isinstance(calib, (list, tuple)):
                                for c in calib:
                                    if isinstance(c, str)and "40"in c and "mm"in c:
                                        return True
                            elif isinstance(calib, str)and "40"in calib and "mm"in calib:
                                return True
                        if ammo_type_field =="40mm_grenade":
                            return True
                        return False

                    if "gauge"in desired_l or "12"in desired_l:
                        if "gauge"in name or "12 gauge"in name or(isinstance(calib, str)and "12"in calib.lower()and "gauge"in calib.lower()):
                            return True
                        if isinstance(calib, (list, tuple)):
                            for c in calib:
                                if isinstance(c, str)and "12"in c and "gauge"in c.lower():
                                    return True
                        if ammo_type_field and("12"in ammo_type_field or "gauge"in ammo_type_field):
                            return True
                        return False

                    if calib:
                        if isinstance(calib, (list, tuple))and any((isinstance(c, str)and desired_l in c.lower())for c in calib):
                            return True
                        if isinstance(calib, str)and desired_l in calib.lower():
                            return True
                    if desired_l and(desired_l ==ammo_type_field or desired_l in name or desired_l in(it.get("sounds")or "")):
                        return True
                except Exception:
                    pass
                return False

            found_item = None
            found_location = None

            want_mag = False
            mag_type_hint =(defaults.get("magazinetype")or "").lower()
            if "mag"in mag_type_hint or "box"in mag_type_hint or "detachable"in mag_type_hint:
                want_mag = True

            hands_list = save_data.get("hands", {}).get("items", [])
            for idx, it in enumerate(list(hands_list)):
                try:

                    if want_mag and isinstance(it, dict)and it.get("rounds"):
                        if defaults.get("magazinesystem"):
                            if str(it.get("magazinesystem")or "").lower()==str(defaults.get("magazinesystem")or "").lower():
                                found_item = it
                                found_location =("hands", idx)
                                break
                        else:
                            found_item = it
                            found_location =("hands", idx)
                            break

                    if _is_compatible_ammo(it, defaults.get("ammo_type")):
                        found_item = it
                        found_location =("hands", idx)
                        break
                except Exception:
                    continue

            if not found_item:
                for storage_idx, container in enumerate(save_data.get("storage", [])or[]):
                    try:
                        if isinstance(container, dict)and container.get("items"):
                            for idx, it in enumerate(list(container.get("items", []))):
                                try:
                                    if want_mag and isinstance(it, dict)and it.get("rounds"):
                                        if defaults.get("magazinesystem"):
                                            if str(it.get("magazinesystem")or "").lower()==str(defaults.get("magazinesystem")or "").lower():
                                                found_item = it
                                                found_location =("storage", storage_idx, idx)
                                                break
                                        else:
                                            found_item = it
                                            found_location =("storage", storage_idx, idx)
                                            break
                                    if _is_compatible_ammo(it, defaults.get("ammo_type")):
                                        found_item = it
                                        found_location =("storage", storage_idx, idx)
                                        break
                                except Exception:
                                    continue
                            if found_item:
                                break
                    except Exception:
                        pass

            if not found_item:
                return f"No {defaults.get('ammo_type', 'compatible')} rounds/magazines found in inventory!"

            try:
                if found_location and found_location[0]=="hands":
                    _, idx = found_location
                    hand_items = save_data.get("hands", {}).get("items", [])
                    if idx <len(hand_items):
                        target = hand_items[idx]

                        if isinstance(target, dict)and target.get("quantity")and isinstance(target.get("quantity"), (int, float)):
                            try:
                                target["quantity"]-=1
                                if target["quantity"]<=0:
                                    hand_items.pop(idx)
                            except Exception:
                                hand_items.pop(idx)
                        else:

                            hand_items.pop(idx)
                elif found_location and found_location[0]=="storage":
                    _, storage_idx, idx = found_location
                    storage_list = save_data.get("storage", [])
                    if storage_idx <len(storage_list):
                        container = storage_list[storage_idx]
                        if isinstance(container, dict)and container.get("items"):
                            items_list = container.get("items")or[]
                            if idx <len(items_list):
                                target = items_list[idx]
                                if isinstance(target, dict)and target.get("quantity")and isinstance(target.get("quantity"), (int, float)):
                                    try:
                                        target["quantity"]-=1
                                        if target["quantity"]<=0:
                                            items_list.pop(idx)
                                    except Exception:
                                        items_list.pop(idx)
                                else:
                                    items_list.pop(idx)
            except Exception:
                logging.exception("Failed to remove consumed underbarrel ammo/magazine from inventory")

            accessory["_ub_loaded"]= capacity
            try:
                sd_ref = save_data if isinstance(save_data, dict)else globals().get('save_data')or getattr(self, '_current_save_data', None)
                if isinstance(sd_ref, dict):
                    ts = sd_ref.setdefault('tracked_stats', {})
                    if isinstance(ts, dict):
                        ts['mags_reloaded_total']= int(ts.get('mags_reloaded_total', 0))+1
                        ts['bullets_loaded_total']= int(ts.get('bullets_loaded_total', 0))+int(capacity)
                        bh = ts.setdefault('bullets_loaded_history', [])
                        try:
                            bh.append({'weapon_id':str(accessory.get('id', 'ub')), 'count':int(capacity), 'time':time.time()})
                        except Exception:
                            pass
            except Exception:
                logging.exception('Failed updating tracked_stats after underbarrel reload')
            try:
                self._update_session_reload_stats(save_data, int(capacity))
            except Exception:
                logging.exception('Failed updating session reload stats after underbarrel reload')
            try:
                accessory["_ub_loaded_item"]= found_item.get("id")or found_item.get("name")
            except Exception:
                pass

            try:
                if isinstance(found_item, dict)and found_item.get("rounds"):

                    try:
                        mag_copy = dict(found_item)

                        mag_copy["rounds"]= list(found_item.get("rounds", []))
                        accessory["loaded"]= mag_copy

                        if accessory["loaded"].get("rounds"):
                            accessory["chambered"]= accessory["loaded"]["rounds"].pop(0)
                    except Exception:
                        logging.exception("Failed to attach magazine as underbarrel loaded")
                else:

                    round_cal = None
                    if isinstance(found_item, dict):
                        raw_cal = found_item.get("caliber")or defaults.get("ammo_type")
                        if isinstance(raw_cal, (list, tuple)):
                            round_cal = raw_cal[0]if raw_cal else None
                        else:
                            round_cal = raw_cal
                        round_variant = found_item.get("variant")or found_item.get("name")
                    else:
                        round_cal = defaults.get("ammo_type")
                        round_variant = None

                    single_round = {"name":f"{round_cal} | {round_variant}"if round_variant else f"{round_cal}", "caliber":round_cal, "variant":round_variant}

                    accessory["loaded"]= {"magazinetype":"underbarrel", "magazinesystem":None, "capacity":capacity, "rounds":[dict(single_round)for _ in range(capacity)]}

                    if accessory["loaded"]["rounds"]:
                        accessory["chambered"]= accessory["loaded"]["rounds"].pop(0)
            except Exception:
                logging.exception("Failed to synthesize loaded rounds for underbarrel accessory")

            try:
                acc_id = accessory.get("id")
                acc_name = accessory.get("name")
                def _set_on_matching(obj):
                    try:
                        if not isinstance(obj, dict):
                            return False
                        if obj.get("id")==acc_id or obj.get("name")==acc_name:
                            obj["_ub_loaded"]= capacity
                            try:
                                obj["_ub_loaded_item"]= found_item.get("id")or found_item.get("name")
                            except Exception:
                                pass
                            return True

                        if obj.get("accessories")and isinstance(obj.get("accessories"), list):
                            for a in(obj.get("accessories")or[]):
                                cur = a.get("current")
                                if isinstance(cur, dict)and(cur.get("id")==acc_id or cur.get("name")==acc_name):
                                    cur["_ub_loaded"]= capacity
                                    try:
                                        cur["_ub_loaded_item"]= found_item.get("id")or found_item.get("name")
                                    except Exception:
                                        pass
                                    return True

                        if obj.get("items")and isinstance(obj.get("items"), list):
                            for it in(obj.get("items")or[]):
                                if isinstance(it, dict)and(it.get("id")==acc_id or it.get("name")==acc_name):
                                    it["_ub_loaded"]= capacity
                                    try:
                                        it["_ub_loaded_item"]= found_item.get("id")or found_item.get("name")
                                    except Exception:
                                        pass
                                    return True
                    except Exception:
                        pass
                    return False

                for slot_name, eq_item in(save_data.get("equipment")or {}).items():
                    if not eq_item or not isinstance(eq_item, dict):
                        continue
                    if _set_on_matching(eq_item):
                        break

                    if eq_item.get("subslots"):
                        for sub in(eq_item.get("subslots")or[]):
                            cur = sub.get("current")
                            if isinstance(cur, dict)and(cur.get("id")==acc_id or cur.get("name")==acc_name):
                                cur["_ub_loaded"]= capacity
                                try:
                                    cur["_ub_loaded_item"]= found_item.get("id")or found_item.get("name")
                                except Exception:
                                    pass
                                raise StopIteration

                for it in list(save_data.get("hands", {}).get("items", [])):
                    if isinstance(it, dict)and(it.get("id")==acc_id or it.get("name")==acc_name):
                        it["_ub_loaded"]= capacity
                        try:
                            it["_ub_loaded_item"]= found_item.get("id")or found_item.get("name")
                        except Exception:
                            pass
                        break
                for container in list(save_data.get("storage", [])):
                    try:
                        if isinstance(container, dict)and container.get("items"):
                            for it in(container.get("items")or[]):
                                if isinstance(it, dict)and(it.get("id")==acc_id or it.get("name")==acc_name):
                                    it["_ub_loaded"]= capacity
                                    try:
                                        it["_ub_loaded_item"]= found_item.get("id")or found_item.get("name")
                                    except Exception:
                                        pass
                                    raise StopIteration
                    except StopIteration:
                        break
            except Exception:
                logging.exception("Failed to persist underbarrel loaded state to save_data")

            wf = os.path.join("sounds", "firearms", "weaponsounds", str(defaults.get("reload_sound_folder", "40mm_grenade")).lower())
            logging.debug("Underbarrel reload: platform=%s wf=%s, defaults=%s, found_item=%s, found_location=%s", platform, wf, defaults, getattr(found_item, 'get', lambda k:None)('name')if isinstance(found_item, dict)else found_item, found_location)

            open_candidates = glob.glob(os.path.join(wf, "open*.ogg"))+glob.glob(os.path.join(wf, "open*.wav"))
            open_candidates +=glob.glob(os.path.join(wf, "door*.ogg"))+glob.glob(os.path.join(wf, "door*.wav"))
            logging.debug("Underbarrel reload: open_candidates=%s", open_candidates)
            if open_candidates:
                logging.debug("Playing underbarrel open sound: %s", open_candidates[0])
                self._safe_sound_play("", random.choice(open_candidates), block = True)
            else:

                alt_wf = os.path.join("sounds", "firearms", "weaponsounds", "m203")
                alt_open = glob.glob(os.path.join(alt_wf, "open*.ogg"))+glob.glob(os.path.join(alt_wf, "open*.wav"))
                alt_open +=glob.glob(os.path.join(alt_wf, "door*.ogg"))+glob.glob(os.path.join(alt_wf, "door*.wav"))
                logging.debug("Underbarrel reload: alt_open_candidates=%s", alt_open)
                if alt_open:
                    logging.debug("Playing underbarrel open sound from alt m203: %s", alt_open[0])
                    self._safe_sound_play("", random.choice(alt_open), block = True)
                else:
                    try:
                        self._play_firearm_sound(accessory, "open")
                    except Exception:
                        pass

            time.sleep(random.uniform(1.0, 1.5))

            insert_candidates = glob.glob(os.path.join(wf, "insert*.ogg"))+glob.glob(os.path.join(wf, "insert*.wav"))
            logging.debug("Underbarrel reload: insert_candidates=%s", insert_candidates)
            if insert_candidates:
                logging.debug("Playing underbarrel insert sound: %s", insert_candidates[0])
                self._safe_sound_play("", random.choice(insert_candidates), block = True)
            else:
                alt_wf = os.path.join("sounds", "firearms", "weaponsounds", "m203")
                alt_insert = glob.glob(os.path.join(alt_wf, "insert*.ogg"))+glob.glob(os.path.join(alt_wf, "insert*.wav"))
                logging.debug("Underbarrel reload: alt_insert_candidates=%s", alt_insert)
                if alt_insert:
                    logging.debug("Playing underbarrel insert sound from alt m203: %s", alt_insert[0])
                    self._safe_sound_play("", random.choice(alt_insert), block = True)
                else:
                    try:
                        self._play_firearm_sound(accessory, "insert")
                    except Exception:
                        pass

            time.sleep(random.uniform(1.0, 1.5))

            close_candidates = glob.glob(os.path.join(wf, "close*.ogg"))+glob.glob(os.path.join(wf, "close*.wav"))
            close_candidates +=glob.glob(os.path.join(wf, "shut*.ogg"))+glob.glob(os.path.join(wf, "shut*.wav"))
            logging.debug("Underbarrel reload: close_candidates=%s", close_candidates)
            if close_candidates:
                logging.debug("Playing underbarrel close sound: %s", close_candidates[0])
                self._safe_sound_play("", random.choice(close_candidates), block = True)
            else:
                alt_wf = os.path.join("sounds", "firearms", "weaponsounds", "m203")
                alt_close = glob.glob(os.path.join(alt_wf, "close*.ogg"))+glob.glob(os.path.join(alt_wf, "close*.wav"))
                alt_close +=glob.glob(os.path.join(alt_wf, "shut*.ogg"))+glob.glob(os.path.join(alt_wf, "shut*.wav"))
                logging.debug("Underbarrel reload: alt_close_candidates=%s", alt_close)
                if alt_close:
                    logging.debug("Playing underbarrel close sound from alt m203: %s", alt_close[0])
                    self._safe_sound_play("", random.choice(alt_close), block = True)
                else:
                    try:
                        self._play_firearm_sound(accessory, "close")
                    except Exception:
                        pass

            return f"Reloaded {accessory.get('name', 'launcher')}({capacity})"
        except Exception:
            logging.exception("Failed to reload underbarrel accessory")
            return "Failed to reload underbarrel accessory"

    def _reload_internal_magazine(self, weapon, save_data, magazine_type):

        capacity = weapon.get("capacity", 10)
        current_rounds = weapon.get("rounds", [])

        compatible_ammo =[]
        caliber_list = weapon.get("caliber", [])or[]
        caliber = caliber_list[0]if caliber_list else None

        if not caliber:
            return "Weapon has no caliber defined."

        if weapon.get("infinite_ammo"):
            ammo_needed = capacity -len(current_rounds)
            ammo_loaded = 0
            for _ in range(ammo_needed):
                current_rounds.append({"name":f"{caliber} | Infinite", "caliber":caliber, "variant":"infinite"})
                ammo_loaded +=1

            had_chambered = bool(weapon.get("chambered"))
            if not had_chambered:
                rt_mag_type = str(weapon.get("magazinetype", "")or "").lower()
                rt_platform_raw = weapon.get("platform", "")or ""
                if isinstance(rt_platform_raw, (list, tuple)):
                    rt_platform_raw = rt_platform_raw[0]if rt_platform_raw else ""
                rt_platform = str(rt_platform_raw).lower()
                rt_action_raw = weapon.get("action", "")or ""
                if isinstance(rt_action_raw, (list, tuple)):
                    rt_action_raw = rt_action_raw[0]if rt_action_raw else ""
                rt_action = str(rt_action_raw).lower()
                is_pump_reload =("pump"in rt_platform or rt_action =="pump"or "pump"in rt_mag_type)

                if is_pump_reload:
                    try:
                        self._play_weapon_action_sound(weapon, "pumpforward")
                    except Exception:
                        pass
                else:
                    if not weapon.get("bolt_catch"):
                            self._play_weapon_action_sound(weapon, "boltback", block = True)

                            if weapon.get("gas_melted", False):
                                if current_rounds:
                                    weapon["chambered"]= current_rounds.pop(0)
                                self._play_weapon_action_sound(weapon, "boltforward")
                            else:
                                if current_rounds:
                                    weapon["chambered"]= current_rounds.pop(0)
                                self._play_weapon_action_sound(weapon, "boltforward")
                    else:
                        if current_rounds:
                            weapon["chambered"]= current_rounds.pop(0)
                        self._play_weapon_action_sound(weapon, "boltforward")

            weapon["rounds"]= current_rounds
        try:
            sd_ref = save_data if isinstance(save_data, dict)else globals().get('save_data')or getattr(self, '_current_save_data', None)
            if isinstance(sd_ref, dict):
                ts = sd_ref.setdefault('tracked_stats', {})
                if isinstance(ts, dict):
                    ts['mags_reloaded_total']= int(ts.get('mags_reloaded_total', 0))+1
                    try:
                        added = int(ammo_loaded)
                    except Exception:
                        added = 0
                    ts['bullets_loaded_total']= int(ts.get('bullets_loaded_total', 0))+added
                    bh = ts.setdefault('bullets_loaded_history', [])
                    try:
                        bh.append({'weapon_id':str(weapon.get('id', 'unknown')), 'count':added, 'time':time.time()})
                    except Exception:
                        pass
        except Exception:
            logging.exception('Failed updating tracked_stats after internal reload')
        try:
            self._update_session_reload_stats(save_data, int(ammo_loaded))
        except Exception:
            logging.exception('Failed updating session reload stats after internal reload')
            return f"Internal magazine reloaded with {ammo_loaded} rounds(total: {len(current_rounds)}/{capacity})"

        for item in save_data.get("hands", {}).get("items", []):
            if item and isinstance(item, dict)and item.get("caliber")==caliber:
                qty = item.get("quantity", 0)
                if qty >0:
                    compatible_ammo.append((item, qty))

        for slot_name, eq_item in save_data.get("equipment", {}).items():
            if eq_item and "items"in eq_item:
                for item in eq_item["items"]:
                    if item and isinstance(item, dict)and item.get("caliber")==caliber:
                        qty = item.get("quantity", 0)
                        if qty >0:
                            compatible_ammo.append((item, qty))

        if not compatible_ammo:
            if weapon.get("infinite_ammo"):

                ammo_needed = capacity -len(current_rounds)
                for _ in range(ammo_needed):
                    current_rounds.append({"name":f"{caliber} | Infinite", "caliber":caliber, "variant":"infinite"})

                time.sleep(0.1)
                self._play_weapon_action_sound(weapon, "cylinderclose")
                weapon["rounds"]= current_rounds
                return f"Revolver reloaded with {ammo_needed} rounds(total: {len(current_rounds)}/{capacity})"
            return "No compatible ammunition found!"

        ammo_needed = capacity -len(current_rounds)
        ammo_loaded = 0

        def make_round_obj(ammo_item):

            variant = ammo_item.get("variant")if isinstance(ammo_item, dict)else None
            name = ammo_item.get("name")if isinstance(ammo_item, dict)else None
            if variant:
                rnd_name = f"{caliber} | {variant}"
            elif name:
                rnd_name = f"{caliber} | {name}"
            else:
                rnd_name = f"{caliber}"
            return {"name":rnd_name, "caliber":caliber, "variant":variant}

        if "tube"in magazine_type:

            while ammo_loaded <ammo_needed and compatible_ammo:
                ammo_item, qty = compatible_ammo[0]
                rounds_to_load = min(1, qty, ammo_needed -ammo_loaded)

                for _ in range(rounds_to_load):

                    self._play_weapon_action_sound(weapon, "tubeinsert", block = True)
                    current_rounds.append(make_round_obj(ammo_item))
                    ammo_loaded +=1
                    ammo_item["quantity"]-=1

                if ammo_item["quantity"]<=0:
                    compatible_ammo.pop(0)

        elif "box"in magazine_type:

            rt_action_raw = weapon.get("action", "")or ""
            if isinstance(rt_action_raw, (list, tuple)):
                rt_action_raw = rt_action_raw[0]if rt_action_raw else ""
            rt_action = str(rt_action_raw).lower()
            is_bolt_action =(rt_action =="bolt"or "bolt"in rt_action)

            boltback_performed = False

            if is_bolt_action:
                self._play_weapon_action_sound(weapon, "boltback", block = True)
                time.sleep(0.2)
                boltback_performed = True

            insert_index = 0
            while ammo_loaded <ammo_needed and compatible_ammo:
                ammo_item, qty = compatible_ammo[0]
                rounds_to_load = min(1, qty, ammo_needed -ammo_loaded)

                for _ in range(rounds_to_load):
                    sound_action = f"bulletinsert{insert_index %2}"

                    self._play_weapon_action_sound(weapon, sound_action, block = False)
                    time.sleep(0.5)
                    current_rounds.append(make_round_obj(ammo_item))
                    ammo_loaded +=1
                    insert_index +=1
                    ammo_item["quantity"]-=1

                if ammo_item["quantity"]<=0:
                    compatible_ammo.pop(0)

        if ammo_loaded >0:

            had_chambered = bool(weapon.get("chambered"))
            if not had_chambered:

                rt_mag_type = str(weapon.get("magazinetype", "")or "").lower()
                rt_platform_raw = weapon.get("platform", "")or ""
                if isinstance(rt_platform_raw, (list, tuple)):
                    rt_platform_raw = rt_platform_raw[0]if rt_platform_raw else ""
                rt_platform = str(rt_platform_raw).lower()
                rt_action_raw = weapon.get("action", "")or ""
                if isinstance(rt_action_raw, (list, tuple)):
                    rt_action_raw = rt_action_raw[0]if rt_action_raw else ""
                rt_action = str(rt_action_raw).lower()
                is_pump_reload =("pump"in rt_platform or rt_action =="pump"or "pump"in rt_mag_type)

                if is_pump_reload:

                    cycle_result = "reloaded(pump required to chamber)"

                    try:
                        self._play_weapon_action_sound(weapon, "pumpforward")
                    except Exception:
                        pass
                else:

                    if not weapon.get("bolt_catch"):

                        if not boltback_performed:
                            self._play_weapon_action_sound(weapon, "boltback", block = True)

                        if weapon.get("gas_melted", False):
                            if current_rounds:
                                weapon["chambered"]= current_rounds.pop(0)
                            self._play_weapon_action_sound(weapon, "boltforward")
                        else:
                            if current_rounds:
                                weapon["chambered"]= current_rounds.pop(0)
                            self._play_weapon_action_sound(weapon, "boltforward")
                    else:

                        if current_rounds:
                            weapon["chambered"]= current_rounds.pop(0)
                        self._play_weapon_action_sound(weapon, "boltforward")

        weapon["rounds"]= current_rounds
        try:
            sd_ref = save_data if isinstance(save_data, dict)else globals().get('save_data')or getattr(self, '_current_save_data', None)
            if isinstance(sd_ref, dict):
                ts = sd_ref.setdefault('tracked_stats', {})
                if isinstance(ts, dict):
                    ts['mags_reloaded_total']= int(ts.get('mags_reloaded_total', 0))+1
                    try:
                        added = int(ammo_loaded)
                    except Exception:
                        added = 0
                    ts['bullets_loaded_total']= int(ts.get('bullets_loaded_total', 0))+added
                    bh = ts.setdefault('bullets_loaded_history', [])
                    try:
                        bh.append({'weapon_id':str(weapon.get('id', 'unknown')), 'count':added, 'time':time.time()})
                    except Exception:
                        pass
        except Exception:
            logging.exception('Failed updating tracked_stats after internal reload')
        try:
            self._update_session_reload_stats(save_data, int(ammo_loaded))
        except Exception:
            logging.exception('Failed updating session reload stats after internal reload 2')
        return f"Internal magazine reloaded with {ammo_loaded} rounds(total: {len(current_rounds)}/{capacity})"

    def _reload_revolver(self, weapon, save_data):

        capacity = weapon.get("capacity", 6)
        current_rounds = weapon.get("rounds", [])

        compatible_ammo =[]
        caliber_list = weapon.get("caliber", [])or[]
        caliber = caliber_list[0]if caliber_list else None

        if not caliber:
            return "Weapon has no caliber defined."

        for item in save_data.get("hands", {}).get("items", []):
            if item and isinstance(item, dict)and item.get("caliber")==caliber:
                qty = item.get("quantity", 0)
                if qty >0:
                    compatible_ammo.append((item, qty))

        for slot_name, eq_item in save_data.get("equipment", {}).items():
            if eq_item and "items"in eq_item:
                for item in eq_item["items"]:
                    if item and isinstance(item, dict)and item.get("caliber")==caliber:
                        qty = item.get("quantity", 0)
                        if qty >0:
                            compatible_ammo.append((item, qty))

        if not compatible_ammo:
            return "No compatible ammunition found!"

        ammo_needed = capacity -len(current_rounds)
        ammo_loaded = 0

        self._play_weapon_action_sound(weapon, "cylinderopen", block = True)
        time.sleep(0.2)

        self._play_weapon_action_sound(weapon, "cylinderrelease", block = True)
        time.sleep(0.15)
        current_rounds.clear()

        insert_index = 0
        while ammo_loaded <ammo_needed and compatible_ammo:
            ammo_item, qty = compatible_ammo[0]
            rounds_to_load = min(1, qty, ammo_needed -ammo_loaded)

            for _ in range(rounds_to_load):

                sound_action = f"bulletinsert{insert_index %2}"

                self._play_weapon_action_sound(weapon, sound_action, block = False)
                time.sleep(0.5)
                current_rounds.append(f"{caliber}")
                ammo_loaded +=1
                insert_index +=1
                ammo_item["quantity"]-=1

            if ammo_item["quantity"]<=0:
                compatible_ammo.pop(0)

        time.sleep(0.1)
        self._play_weapon_action_sound(weapon, "cylinderclose")
        time.sleep(0.1)

        weapon["rounds"]= current_rounds
        try:
            sd_ref = save_data if isinstance(save_data, dict)else globals().get('save_data')or getattr(self, '_current_save_data', None)
            if isinstance(sd_ref, dict):
                ts = sd_ref.setdefault('tracked_stats', {})
                if isinstance(ts, dict):
                    ts['mags_reloaded_total']= int(ts.get('mags_reloaded_total', 0))+1
                    try:
                        added = int(ammo_loaded)
                    except Exception:
                        added = 0
                    ts['bullets_loaded_total']= int(ts.get('bullets_loaded_total', 0))+added
                    bh = ts.setdefault('bullets_loaded_history', [])
                    try:
                        bh.append({'weapon_id':str(weapon.get('id', 'unknown')), 'count':added, 'time':time.time()})
                    except Exception:
                        pass
        except Exception:
            logging.exception('Failed updating tracked_stats after revolver reload')
        try:
            self._update_session_reload_stats(save_data, int(ammo_loaded))
        except Exception:
            logging.exception('Failed updating session reload stats after revolver reload')
        return f"Revolver reloaded with {ammo_loaded} rounds(total: {len(current_rounds)}/{capacity})"

    def _reload_cylinder(self, weapon, save_data):

        capacity = weapon.get("capacity", 6)
        current_rounds = weapon.get("rounds", [])

        compatible_ammo =[]
        caliber_list = weapon.get("caliber", [])or[]
        caliber = caliber_list[0]if caliber_list else None

        if not caliber:
            return "Weapon has no caliber defined."

        for item in save_data.get("hands", {}).get("items", []):
            if item and isinstance(item, dict)and item.get("caliber")==caliber:
                qty = item.get("quantity", 0)
                if qty >0:
                    compatible_ammo.append((item, qty))

        for slot_name, eq_item in save_data.get("equipment", {}).items():
            if eq_item and "items"in eq_item:
                for item in eq_item["items"]:
                    if item and isinstance(item, dict)and item.get("caliber")==caliber:
                        qty = item.get("quantity", 0)
                        if qty >0:
                            compatible_ammo.append((item, qty))

        if not compatible_ammo:
            return "No compatible ammunition found!"

        ammo_needed = capacity -len(current_rounds)
        ammo_loaded = 0

        self._play_cylinder_sound(weapon, "cylinderopen", block = True)
        time.sleep(0.2)

        self._play_cylinder_sound(weapon, "cylinderrelease", block = True)
        time.sleep(0.15)
        current_rounds.clear()

        insert_index = 0
        while ammo_loaded <ammo_needed and compatible_ammo:
            ammo_item, qty = compatible_ammo[0]
            rounds_to_load = min(1, qty, ammo_needed -ammo_loaded)

            for _ in range(rounds_to_load):
                sound_action = f"bulletinsert{insert_index %2}"
                self._play_cylinder_sound(weapon, sound_action, block = False)
                time.sleep(0.5)
                current_rounds.append(f"{caliber}")
                ammo_loaded +=1
                insert_index +=1
                ammo_item["quantity"]-=1

            if ammo_item["quantity"]<=0:
                compatible_ammo.pop(0)

        time.sleep(0.1)
        self._play_cylinder_sound(weapon, "cylinderclose")
        time.sleep(0.1)

        weapon["rounds"]= current_rounds

        action = weapon.get("action", "")
        if isinstance(action, (list, tuple)):
            action = action[0]if action else ""
        action = str(action).lower()
        if action =="single":
            time.sleep(0.1)
            self._play_cylinder_sound(weapon, "hammerdown")

        try:
            sd_ref = save_data if isinstance(save_data, dict)else globals().get('save_data')or getattr(self, '_current_save_data', None)
            if isinstance(sd_ref, dict):
                ts = sd_ref.setdefault('tracked_stats', {})
                if isinstance(ts, dict):
                    ts['mags_reloaded_total']= int(ts.get('mags_reloaded_total', 0))+1
                    try:
                        added = int(ammo_loaded)
                    except Exception:
                        added = 0
                    ts['bullets_loaded_total']= int(ts.get('bullets_loaded_total', 0))+added
                    bh = ts.setdefault('bullets_loaded_history', [])
                    try:
                        bh.append({'weapon_id':str(weapon.get('id', 'unknown')), 'count':added, 'time':time.time()})
                    except Exception:
                        pass
        except Exception:
            logging.exception('Failed updating tracked_stats after cylinder reload')
        try:
            self._update_session_reload_stats(save_data, int(ammo_loaded))
        except Exception:
            logging.exception('Failed updating session reload stats after cylinder reload')
        return f"Cylinder reloaded with {ammo_loaded} rounds(total: {len(current_rounds)}/{capacity})"

    def _play_cylinder_sound(self, weapon, action_type, block = False):

        try:
            platform = str(weapon.get("platform", "")or "").lower()
            sound_folder = weapon.get("sounds")or weapon.get("sound_folder")or weapon.get("fire_sounds")or weapon.get("reload_sounds")

            candidates =[]

            if sound_folder:
                wf = os.path.join("sounds", "firearms", "weaponsounds", str(sound_folder).lower())
                candidates = glob.glob(os.path.join(wf, f"{action_type}*.ogg"))+glob.glob(os.path.join(wf, f"{action_type}*.wav"))

            if not candidates and platform:
                wf = os.path.join("sounds", "firearms", "weaponsounds", platform)
                candidates = glob.glob(os.path.join(wf, f"{action_type}*.ogg"))+glob.glob(os.path.join(wf, f"{action_type}*.wav"))

            if not candidates:
                uni = os.path.join("sounds", "firearms", "universal")
                candidates = glob.glob(os.path.join(uni, f"{action_type}*.ogg"))+glob.glob(os.path.join(uni, f"{action_type}*.wav"))

            if candidates:
                sound_file = random.choice(candidates)
                logging.debug("_play_cylinder_sound: %s -> %s", action_type, sound_file)
                self._safe_sound_play("", sound_file, block = block)
            else:
                logging.debug("_play_cylinder_sound: no sound found for %s", action_type)
        except Exception as e:
            logging.error(f"Error playing cylinder sound: {e}")

    def _clean_weapon(self, weapon, combat_state):

        weapon_id = str(weapon.get("id"))
        logging.info("_clean_weapon start: id=%s name=%s", weapon_id, weapon.get("name", "Unknown"))

        self._play_weapon_action_sound(weapon, "cleaning")

        if "barrel_cleanliness"not in combat_state:
            combat_state["barrel_cleanliness"]= {}

        combat_state["barrel_cleanliness"][weapon_id]= 100

        try:
            if weapon.get("gas_melted", False):
                weapon["gas_melted"]= False
                logging.info("Weapon %s gas system repaired by cleaning", weapon.get("name", weapon_id))
        except Exception:
            pass

        return "Weapon cleaned and maintained."

    def _cycle_bolt(self, weapon):

        logging.info("_cycle_bolt start: name=%s", weapon.get("name", "Unknown"))

        actions = weapon.get("action", [])
        magazine_type = (weapon.get("magazinetype") or "").lower()
        is_internal = "internal" in magazine_type or "tube" in magazine_type
        is_revolver = "revolver" in (weapon.get("platform", "") or "").lower()

        chambered = weapon.get("chambered")
        if chambered:
            logging.info("Cycle action: ejecting chambered round")
            self._play_weapon_action_sound(weapon, "boltback", block = True)
            self._play_weapon_action_sound(weapon, "shelleject")
            time.sleep(0.2)

            weapon["chambered"]= None
            message = "Ejected chambered round. "
        else:
            message = ""

        if is_internal or is_revolver:
            internal_rounds = weapon.get("rounds", [])
            if not internal_rounds:
                self._play_weapon_action_sound(weapon, "boltback", block = True)
                self._play_weapon_action_sound(weapon, "boltforward")
                return message + "No rounds in magazine - action cycled but no round chambered."

            self._play_weapon_action_sound(weapon, "boltback", block = True)
            next_round = internal_rounds.pop(0)
            weapon["chambered"] = next_round
            self._play_weapon_action_sound(weapon, "boltforward")
            next_var = next_round.get("variant") or next_round.get("name") if isinstance(next_round, dict) else str(next_round)
            return message + f"Action cycled - chambered {next_var or 'a round'}."

        loaded_mag = weapon.get("loaded")

        if not loaded_mag:
            self._play_weapon_action_sound(weapon, "boltback", block = True)
            self._play_weapon_action_sound(weapon, "boltforward")
            return message +"No magazine loaded - action cycled but no round chambered."

        rounds = loaded_mag.get("rounds", [])
        if not rounds:
            self._play_weapon_action_sound(weapon, "boltback", block = True)
            self._play_weapon_action_sound(weapon, "boltforward")
            return message +"Magazine empty - action cycled but no round chambered."

        self._play_weapon_action_sound(weapon, "boltback", block = True)
        next_round = rounds.pop(0)
        weapon["chambered"]= next_round
        self._play_weapon_action_sound(weapon, "boltforward")
        next_var = next_round.get("variant") or next_round.get("name") if isinstance(next_round, dict) else str(next_round)
        return message +f"Action cycled - chambered {next_var or 'a round'}."

    def _show_magazine_selection_menu(self, weapon, save_data, table_data, current_weapon_state, update_callback):

        magazine_system = weapon.get("magazinesystem")
        platform = str(weapon.get("platform", "")or "").lower()
        mag_type_weapon = str(weapon.get("magazinetype", "")or "").lower()

        is_belt_weapon =("belt"in mag_type_weapon)or("m249"in platform)
        sub_mag_type = str(weapon.get("submagazinetype", "")or "").lower()

        compatible_mags =[]

        def mag_is_compatible(mag):

            if not mag or not isinstance(mag, dict):
                return False

            try:
                if mag.get("firearm")is True:
                    return False
            except Exception:
                pass

            compat = False

            try:
                if magazine_system and mag.get("magazinesystem")==magazine_system:
                    compat = True
            except Exception:
                pass

            try:
                mag_type = str(mag.get("magazinetype", "")or "").lower()
                if is_belt_weapon and("belt"in mag_type):
                    compat = True
            except Exception:
                pass

            try:
                if sub_mag_type and mag_type ==sub_mag_type:
                    compat = True
            except Exception:
                pass

            try:
                if is_belt_weapon and weapon.get("beltlink")and mag.get("beltlink")and str(mag.get("beltlink")).lower()==str(weapon.get("beltlink")).lower():
                    compat = True
            except Exception:
                pass

            if not compat:
                return False

            try:
                dev_cal_var = None
                if isinstance(current_weapon_state, dict):
                    dev_cal_var = current_weapon_state.get("dev_caliber_var")
                if dev_cal_var and hasattr(dev_cal_var, 'get'):
                    sel_cal = dev_cal_var.get()
                    if sel_cal:
                        def _mag_matches_cal(m, c):
                            try:
                                mcal = m.get("caliber")
                                if isinstance(mcal, (list, tuple)):
                                    for e in mcal:
                                        try:
                                            if str(e)==str(c):
                                                return True
                                        except Exception:
                                            pass
                                elif isinstance(mcal, str):
                                    if str(mcal)==str(c):
                                        return True

                                rds = m.get("rounds")
                                if isinstance(rds, list)and rds:
                                    first = rds[0]
                                    if isinstance(first, dict):
                                        if str(first.get("caliber"))==str(c):
                                            return True
                                    elif isinstance(first, str):
                                        if str(c)in first:
                                            return True
                            except Exception:
                                pass
                            return False

                        if not _mag_matches_cal(mag, sel_cal):
                            return False
            except Exception:
                pass

            return True

        if weapon.get("has_magazine_in_pool")is not False:
            for item in save_data.get("hands", {}).get("items", []):
                if mag_is_compatible(item)and len(item.get("rounds", []))>0:
                    compatible_mags.append(("hands", item))

        for slot_name, item in save_data.get("equipment", {}).items():
                if item:

                    if "items"in item and isinstance(item["items"], list):
                        for mag in item["items"]:
                            if mag_is_compatible(mag)and len(mag.get("rounds", []))>0:
                                compatible_mags.append(("equipment", mag))

                    if "subslots"in item:
                        for subslot in item["subslots"]:
                            if subslot.get("current"):
                                curr = subslot["current"]
                                if "items"in curr and isinstance(curr["items"], list):
                                    for mag in curr["items"]:
                                        if mag_is_compatible(mag)and len(mag.get("rounds", []))>0:
                                            compatible_mags.append(("equipment", mag))

        if not compatible_mags:
            if is_belt_weapon:

                try:
                    self._perform_belt_reload_sequence(weapon)
                    return
                except Exception:
                    try:
                        self._popup_show_info("Magazine", "No belts or compatible magazines in inventory for this weapon!")
                    except Exception:
                        pass
                    return
            else:
                self._popup_show_info("Magazine", f"No compatible magazines in inventory for {magazine_system} system!")
            return

        popup = customtkinter.CTkToplevel(self.root)
        popup.title("Select Magazine")
        popup.transient(self.root)
        self._center_popup_on_window(popup, 500, 450)

        label = customtkinter.CTkLabel(
        popup,
        text = f"Select a magazine for {weapon.get('name')}:",
        font = customtkinter.CTkFont(size = 13),
        wraplength = 450
        )
        label.pack(pady = 10, padx = 20)

        scroll_frame = customtkinter.CTkScrollableFrame(popup, fg_color = "transparent")
        scroll_frame.pack(fill = "both", expand = True, padx = 10, pady = 10)

        selected_mag = customtkinter.StringVar(value = "0")

        for idx, (location, mag_item)in enumerate(compatible_mags):
            mag_name = mag_item.get("name", "Unknown Magazine")
            capacity = mag_item.get("capacity", "?")
            rounds = len(mag_item.get("rounds", []))

            mag_cal_display = None
            try:
                mag_cals =[]
                rds = mag_item.get('rounds')if isinstance(mag_item, dict)else[]
                if isinstance(rds, list)and rds:

                    seen =[]
                    for first in rds:
                        try:
                            if isinstance(first, dict):
                                fc = first.get('caliber')
                                if isinstance(fc, (list, tuple)):
                                    for x in fc:
                                        if x and str(x)not in seen:
                                            seen.append(str(x))
                                elif isinstance(fc, str)and fc and str(fc)not in seen:
                                    seen.append(str(fc))
                            elif isinstance(first, str)and first:
                                calpart = first.split('|', 1)[0].strip()
                                if calpart and calpart not in seen:
                                    seen.append(calpart)
                        except Exception:
                            continue
                    if seen:
                        mag_cals = seen

                if mag_cals:
                    mag_cal_display = ", ".join(mag_cals)
            except Exception:
                mag_cal_display = None

            radio_frame = customtkinter.CTkFrame(scroll_frame, fg_color = "transparent")
            radio_frame.pack(fill = "x", pady = 5, padx = 5)

            radio_text = f"{mag_name}({rounds}/{capacity})"
            if mag_cal_display:
                radio_text +=f" - {mag_cal_display}"
            radio_text +=f" - from {location}"
            _mag_rds_list = mag_item.get("rounds", [])
            if _mag_rds_list and isinstance(_mag_rds_list, list) and len(_mag_rds_list) > 0:
                _mnr = _mag_rds_list[0]
                if isinstance(_mnr, dict):
                    _mnv = _mnr.get("variant") or _mnr.get("name")
                    if _mnv:
                        radio_text += f" [next: {_mnv}]"
            radio = customtkinter.CTkRadioButton(
            radio_frame,
            text = radio_text,
            variable = selected_mag,
            value = str(idx),
            font = customtkinter.CTkFont(size = 11)
            )
            radio.pack(anchor = "w")

        def give_magazine():
            if not selected_mag.get():
                self._popup_show_info("Magazine", "Please select a magazine!")
                return

            idx = int(selected_mag.get())
            location, mag_item = compatible_mags[idx]

            try:
                wpn_cal_raw = weapon.get('caliber')or[]
                wpn_calibers = set()
                if isinstance(wpn_cal_raw, (list, tuple)):
                    for c in wpn_cal_raw:
                        if c:
                            wpn_calibers.add(str(c).lower().strip())
                elif isinstance(wpn_cal_raw, str)and wpn_cal_raw:
                    wpn_calibers.add(wpn_cal_raw.lower().strip())

                mag_rounds = mag_item.get('rounds', [])if isinstance(mag_item, dict)else[]
                if wpn_calibers and mag_rounds:
                    for rd in mag_rounds:
                        try:
                            rd_cals = set()
                            if isinstance(rd, dict):
                                rcal = rd.get('caliber')
                                if isinstance(rcal, (list, tuple)):
                                    for rc in rcal:
                                        if rc:
                                            rd_cals.add(str(rc).lower().strip())
                                elif isinstance(rcal, str)and rcal:
                                    rd_cals.add(rcal.lower().strip())
                            elif isinstance(rd, str)and rd:
                                if '|'in rd:
                                    rd_cal_part = rd.split('|', 1)[0].strip()
                                else:
                                    rd_cal_part = rd.strip()
                                if rd_cal_part:
                                    rd_cals.add(rd_cal_part.lower().strip())

                            if rd_cals and not(rd_cals &wpn_calibers):
                                self._popup_show_info("Magazine Incompatible", f"Cannot insert magazine: it contains rounds of an incompatible caliber({next(iter(rd_cals))}).", sound = "error")
                                return
                        except Exception:
                            self._popup_show_info("Magazine Incompatible", "Cannot insert magazine: failed to validate contained rounds.", sound = "error")
                            return
            except Exception:
                pass

            import time

            current_mag = weapon.get("loaded")
            chambered = weapon.get("chambered")
            is_gun_empty = not chambered and(not current_mag or not current_mag.get("rounds", []))

            if current_mag:
                try:
                    self._play_weapon_action_sound(weapon, "magout")
                except Exception:
                    pass

                time.sleep(random.uniform(1.0, 1.5))

                try:
                    self._safe_sound_play("", "sounds/firearms/universal/pouchin.wav")
                except Exception:
                    pass
                time.sleep(random.uniform(1.0, 1.5))

            try:
                self._safe_sound_play("", "sounds/firearms/universal/pouchout.ogg")
            except Exception:
                pass
            time.sleep(random.uniform(1.0, 1.5))

            mag_type = weapon.get("magazinetype", "").lower()
            platform = weapon.get("platform", "").lower()
            if not any(k in mag_type for k in("internal", "tube", "cylinder"))and "revolver"not in platform:
                try:
                    self._play_weapon_action_sound(weapon, "magin")
                except Exception:
                    pass

                time.sleep(random.uniform(0.5, 1.0))

            rt_mag_type = str(weapon.get("magazinetype", "")or "").lower()
            rt_platform_raw = weapon.get("platform", "")or ""
            if isinstance(rt_platform_raw, (list, tuple)):
                rt_platform_raw = rt_platform_raw[0]if rt_platform_raw else ""
            rt_platform = str(rt_platform_raw).lower()
            rt_action_raw = weapon.get("action", "")or ""
            if isinstance(rt_action_raw, (list, tuple)):
                rt_action_raw = rt_action_raw[0]if rt_action_raw else ""
            rt_action = str(rt_action_raw).lower()
            is_pump_reload_local =("pump"in rt_platform or rt_action =="pump"or "pump"in rt_mag_type)

            if is_gun_empty:
                if is_pump_reload_local:
                    try:
                        self._play_weapon_action_sound(weapon, "pumpback", block = True)
                    except Exception:
                        pass
                    try:
                        self._play_weapon_action_sound(weapon, "pumpforward")
                    except Exception:
                        pass
                elif not weapon.get("bolt_catch"):
                    try:
                        self._play_weapon_action_sound(weapon, "boltback", block = True)
                    except Exception:
                        pass
                    try:
                        self._play_weapon_action_sound(weapon, "boltforward")
                    except Exception:
                        pass
                else:

                    try:
                        self._play_weapon_action_sound(weapon, "boltforward")
                    except Exception:
                        pass

            if current_mag and not weapon.get("infinite_ammo"):

                save_data.get("hands", {}).get("items", []).append(current_mag)

            if not weapon.get("infinite_ammo"):
                weapon["loaded"]= mag_item
                weapon["chambered"]= None
            else:
                weapon["chambered"]= None

            if not weapon.get("infinite_ammo")and is_gun_empty and mag_item.get("rounds", [])and not is_pump_reload_local:
                weapon["chambered"]= mag_item["rounds"].pop(0)
            elif weapon.get("infinite_ammo")and is_gun_empty and not is_pump_reload_local:
                caliber_list = weapon.get("caliber", [])or["Unknown"]
                caliber = caliber_list[0]
                weapon["chambered"]= {"name":f"{caliber} | Infinite", "caliber":caliber, "variant":"infinite"}

            if not weapon.get("infinite_ammo"):
                if location =="hands":
                    if mag_item in save_data.get("hands", {}).get("items", []):
                        save_data["hands"]["items"].remove(mag_item)
                elif location =="equipment":

                    for slot_name, item in save_data.get("equipment", {}).items():
                        if item:
                            if "items"in item and isinstance(item["items"], list):
                                if mag_item in item["items"]:
                                    item["items"].remove(mag_item)
                            if "subslots"in item:
                                for subslot in item["subslots"]:
                                    if subslot.get("current"):
                                        curr = subslot["current"]
                                        if "items"in curr and isinstance(curr["items"], list):
                                            if mag_item in curr["items"]:
                                                curr["items"].remove(mag_item)

            popup.destroy()
            mag_name = mag_item.get("name", "magazine")
            rounds = len(mag_item.get("rounds", []))

            chambered_info = " +1 in chamber"if is_gun_empty and weapon.get("chambered")else ""
            self._popup_show_info("Magazine", f"Loaded {mag_name}({rounds}{chambered_info} rounds)!")
            update_callback()

        button_frame = customtkinter.CTkFrame(popup, fg_color = "transparent")
        button_frame.pack(fill = "x", padx = 10, pady = 10)

        load_btn = customtkinter.CTkButton(
        button_frame,
        text = "Load Magazine",
        command = give_magazine,
        width = 150,
        height = 40
        )
        load_btn.pack(side = "left", padx = 5)

        cancel_btn = customtkinter.CTkButton(
        button_frame,
        text = "Cancel",
        command = popup.destroy,
        width = 150,
        height = 40,
        fg_color = "#444444",
        hover_color = "#555555"
        )
        cancel_btn.pack(side = "left", padx = 5)

        popup.update_idletasks()
        popup_width = popup.winfo_reqwidth()
        popup_height = popup.winfo_reqheight()
        screen_width = popup.winfo_screenwidth()
        screen_height = popup.winfo_screenheight()
        x =(screen_width //2)-(popup_width //2)
        y =(screen_height //2)-(popup_height //2)
        popup.geometry(f"+{x}+{y}")
        popup.deiconify()
        popup.grab_set()
        popup.lift()
        self._safe_focus(popup)

    def _check_for_reloader_item(self, save_data):

        for slot_name, item in save_data.get("equipment", {}).items():

            if isinstance(item, list):
                for sub_item in item:
                    if sub_item and isinstance(sub_item, dict)and sub_item.get("reloader"):
                        return True
                    if sub_item and isinstance(sub_item, dict)and "subslots"in sub_item:
                        for subslot in sub_item.get("subslots", []):
                            if subslot.get("current")and subslot["current"].get("reloader"):
                                return True
                continue

            if item and isinstance(item, dict)and item.get("reloader"):
                return True

            if item and isinstance(item, dict)and "subslots"in item:
                for subslot in item["subslots"]:
                    if subslot.get("current")and subslot["current"].get("reloader"):
                        return True

        for item in save_data.get("hands", {}).get("items", []):
            if item and isinstance(item, dict)and item.get("reloader"):
                return True

        return False

    def _reload_magazine(self, magazine, save_data, max_rounds = None, has_ammo_in_pool = True, on_complete = None, is_loaded_in_weapon = False, weapon = None, variant_filter = None):

        logging.info("_reload_magazine start: capacity=%s, variant_filter=%s", magazine.get("capacity"), variant_filter)

        capacity = magazine.get("capacity", 0)
        current_rounds = magazine.get("rounds", [])
        rounds_to_add = capacity -len(current_rounds)
        if max_rounds is not None:
            try:
                rounds_to_add = min(int(max_rounds), rounds_to_add)
            except Exception:
                pass
        initial_to_add = rounds_to_add

        if rounds_to_add <=0:
            msg = f"Magazine already has {len(current_rounds)} rounds(capacity: {capacity})"
            if on_complete:
                on_complete(msg)
            return msg

        has_reloader = self._check_for_reloader_item(save_data)

        if not has_ammo_in_pool:
            msg = "No loose ammo available in pool to reload this magazine."
            if on_complete:
                on_complete(msg)
            return msg

        is_internal_box = False
        if weapon:
            mag_type = str(weapon.get("magazinetype", "")or "").lower()
            is_internal_box = "internal"in mag_type and "box"in mag_type

        rounds_collected =[]

        def round_matches_filter(r):

            if variant_filter is None:
                return True
            if not isinstance(r, dict):
                return True

            r_variant = r.get("variant")or r.get("name")or "Unknown"
            return str(r_variant).lower()==str(variant_filter).lower()

        try:
            hands_items = save_data.get("hands", {}).get("items", [])
            for hi in range(len(hands_items)-1, -1, -1):
                if rounds_to_add <=0:
                    break
                item = hands_items[hi]
                if not isinstance(item, dict):
                    continue
                if item is magazine:
                    continue

                if item.get('magazinesystem')or item.get('capacity'):
                    continue

                if isinstance(item.get("rounds"), list)and item.get("rounds"):

                    rounds_to_take =[]
                    remaining_rounds =[]
                    for r in item["rounds"]:
                        if round_matches_filter(r)and len(rounds_to_take)<rounds_to_add:
                            rounds_to_take.append(r)
                        else:
                            remaining_rounds.append(r)

                    for r in rounds_to_take:
                        rounds_collected.append(r)
                        rounds_to_add -=1

                    item["rounds"]= remaining_rounds
                    if not item.get("rounds"):
                        try:
                            hands_items.pop(hi)
                        except Exception:
                            pass
                    continue

                if variant_filter is not None:
                    item_variant = item.get("variant")or item.get("name")or "Unknown"
                    if str(item_variant).lower()!=str(variant_filter).lower():
                        continue

                qty = int(item.get("quantity")or 0)if isinstance(item.get("quantity"), (int, float))else 0
                if qty >0 and("caliber"in item or "name"in item):
                    take = min(rounds_to_add, qty)
                    for _ in range(take):
                        r = {k:v for k, v in item.items()if k !="quantity"}
                        rounds_collected.append(r)
                        rounds_to_add -=1
                    item["quantity"]= qty -take
                    if item["quantity"]<=0:
                        try:
                            hands_items.pop(hi)
                        except Exception:
                            pass
                    continue

                if item.get("caliber"):
                    try:
                        hands_items.pop(hi)
                        rounds_collected.append(item)
                        rounds_to_add -=1
                    except Exception:
                        pass
        except Exception:
            logging.exception("Failed to pull rounds from hands during reload")

        loaded_from_hands = len(rounds_collected)

        if loaded_from_hands <=0:
            msg = "No loose rounds available in hands to reload the magazine"
            if on_complete:
                on_complete(msg)
            return msg

        popup = customtkinter.CTkToplevel(self.root)
        popup.title("Reloading Magazine")
        popup.transient(self.root)
        self._center_popup_on_window(popup, 400, 150)
        popup.grab_set()

        status_text = "Using reloader..."if has_reloader else "Loading rounds manually..."
        status_label = customtkinter.CTkLabel(
        popup,
        text = status_text,
        font = customtkinter.CTkFont(size = 14)
        )
        status_label.pack(pady =(20, 10))

        progress_bar = customtkinter.CTkProgressBar(popup, width = 350)
        progress_bar.pack(pady = 10)
        progress_bar.set(0)

        count_label = customtkinter.CTkLabel(
        popup,
        text = f"0 / {loaded_from_hands} rounds",
        font = customtkinter.CTkFont(size = 12)
        )
        count_label.pack(pady = 5)

        reload_state = {
        "index":0,
        "reloader_channel":None,
        "reloader_sound":None
        }

        def play_insert_sound():
            insert_sound = f"bulletinsert{random.randint(0, 1)}"
            try:
                sound_path = os.path.join("sounds", "firearms", "universal", f"{insert_sound}.ogg")
                if os.path.exists(sound_path):
                    sound = pygame.mixer.Sound(sound_path)
                    channel = pygame.mixer.find_channel()
                    if channel:
                        channel.play(sound)
            except Exception as e:
                logging.warning(f"Failed to play {insert_sound}: {e}")

        def start_reloader_sound():
            reloader_sound_path = os.path.join("sounds", "firearms", "universal", "reloaderloop.ogg")
            if os.path.exists(reloader_sound_path):
                channel = pygame.mixer.find_channel()
                if channel:
                    try:
                        sound = pygame.mixer.Sound(reloader_sound_path)
                        channel.play(sound, loops = -1)
                        reload_state["reloader_channel"]= channel
                        reload_state["reloader_sound"]= sound
                    except Exception as e:
                        logging.warning(f"Failed to play reloader sound: {e}")

        def play_reloader_insert_sound():

            try:
                sound_path = os.path.join("sounds", "firearms", "universal", "reloaderroundinsert.ogg")
                if os.path.exists(sound_path):
                    sound = pygame.mixer.Sound(sound_path)
                    channel = pygame.mixer.find_channel()
                    if channel:
                        channel.play(sound)

                        return int(sound.get_length()*1000)
            except Exception as e:
                logging.warning(f"Failed to play reloader insert sound: {e}")
            return 0

        def play_magout_sound():

            if weapon:
                try:
                    self._play_weapon_action_sound(weapon, "magout")

                    return 500
                except Exception as e:
                    logging.warning(f"Failed to play magout sound: {e}")
            return 0

        def play_magin_sound():

            if weapon:
                try:
                    self._play_weapon_action_sound(weapon, "magin")
                except Exception as e:
                    logging.warning(f"Failed to play magin sound: {e}")

        def stop_reloader_sound():
            if reload_state["reloader_channel"]:
                try:
                    reload_state["reloader_channel"].stop()
                except Exception:
                    pass
                reload_state["reloader_channel"]= None

        def reload_step():
            idx = reload_state["index"]

            if idx >=loaded_from_hands:

                stop_reloader_sound()
                magazine["rounds"]= current_rounds

                if has_reloader:
                    message = f"Reloaded {loaded_from_hands} rounds using reloader(total: {len(current_rounds)}/{capacity})"
                else:
                    message = f"Manually reloaded {loaded_from_hands} rounds(total: {len(current_rounds)}/{capacity})"

                logging.info(message)

                if is_loaded_in_weapon:
                    play_magin_sound()

                try:
                    popup.destroy()
                except Exception:
                    pass

                if on_complete:
                    on_complete(message)
                return

            current_rounds.append(rounds_collected[idx])
            reload_state["index"]+=1

            progress = reload_state["index"]/loaded_from_hands
            progress_bar.set(progress)
            count_label.configure(text = f"{reload_state['index']} / {loaded_from_hands} rounds")

            play_insert_sound()

            if has_reloader:
                delay = 100
            else:
                delay = 500

            popup.after(delay, reload_step)

        initial_delay = 100

        is_bolt_action_reload = False
        try:
            if weapon:
                rt_action_raw = weapon.get("action", "")or ""
                if isinstance(rt_action_raw, (list, tuple)):
                    rt_action_raw = rt_action_raw[0]if rt_action_raw else ""
                rt_action = str(rt_action_raw).lower()
                is_bolt_action_reload =(rt_action =="bolt"or "bolt"in rt_action)
        except Exception:
            is_bolt_action_reload = False

        if is_loaded_in_weapon:
            magout_duration = play_magout_sound()
            initial_delay +=magout_duration

        if weapon and is_bolt_action_reload and not is_internal_box:
            try:
                self._play_weapon_action_sound(weapon, "boltback", block = True)
                time.sleep(0.12)
            except Exception:
                pass

        def play_boltback_for_internal(callback):

            if is_internal_box and weapon:
                try:

                    platform = weapon.get("platform", "").lower()
                    wf = os.path.join("sounds", "firearms", "weaponsounds", platform)if platform else None
                    sound_file = None
                    duration_ms = 800

                    if wf:
                        candidates = glob.glob(os.path.join(wf, "boltback*.ogg"))+glob.glob(os.path.join(wf, "boltback*.wav"))
                        if candidates:
                            sound_file = random.choice(candidates)

                    if sound_file and os.path.exists(sound_file):
                        try:
                            sound = pygame.mixer.Sound(sound_file)
                            duration_ms = int(sound.get_length()*1000)+100
                            channel = pygame.mixer.find_channel()
                            if channel:
                                channel.play(sound)
                        except Exception:
                            pass
                    else:

                        self._play_weapon_action_sound(weapon, "boltback", block = False)

                    popup.after(duration_ms, callback)
                    return
                except Exception:
                    pass

            callback()

        if has_reloader:

            insert_duration = play_reloader_insert_sound()

            def start_reloader_after_insert():
                start_reloader_sound()
                popup.after(100, reload_step)

            popup.after(initial_delay +insert_duration, start_reloader_after_insert)
        else:

            def start_reload_after_delay():
                play_boltback_for_internal(reload_step)

            popup.after(initial_delay, start_reload_after_delay)

        return "Reloading..."

    def _unload_magazine_rounds(self, magazine, save_data, max_rounds = None, on_complete = None, is_loaded_in_weapon = False, weapon = None, variant_filter = None):

        logging.info("_unload_magazine_rounds start: rounds=%s, variant_filter=%s", len(magazine.get("rounds", [])), variant_filter)

        current_rounds = magazine.get("rounds", [])
        if not isinstance(current_rounds, list):
            current_rounds =[]
            magazine["rounds"]= current_rounds

        if variant_filter:
            matching_count = sum(1 for r in current_rounds if isinstance(r, dict)and str(r.get('variant', 'Unknown')).lower()==str(variant_filter).lower())
            rounds_to_remove = matching_count
        else:
            rounds_to_remove = len(current_rounds)

        if max_rounds is not None:
            try:
                rounds_to_remove = min(int(max_rounds), rounds_to_remove)
            except Exception:
                pass

        if rounds_to_remove <=0:
            msg = "Magazine is already empty"
            if on_complete:
                on_complete(msg)
            return msg

        has_reloader = self._check_for_reloader_item(save_data)

        popup = customtkinter.CTkToplevel(self.root)
        popup.title("Unloading Magazine")
        popup.transient(self.root)
        self._center_popup_on_window(popup, 400, 150)
        popup.grab_set()

        status_text = "Using reloader..."if has_reloader else "Unloading rounds manually..."
        status_label = customtkinter.CTkLabel(
        popup,
        text = status_text,
        font = customtkinter.CTkFont(size = 14)
        )
        status_label.pack(pady =(20, 10))

        progress_bar = customtkinter.CTkProgressBar(popup, width = 350)
        progress_bar.pack(pady = 10)
        progress_bar.set(0)

        count_label = customtkinter.CTkLabel(
        popup,
        text = f"0 / {rounds_to_remove} rounds",
        font = customtkinter.CTkFont(size = 12)
        )
        count_label.pack(pady = 5)

        unload_state = {
        "index":0,
        "reloader_channel":None,
        "reloader_sound":None,
        "rounds_removed":[]
        }

        def play_insert_sound():
            insert_sound = f"bulletinsert{random.randint(0, 1)}"
            try:
                sound_path = os.path.join("sounds", "firearms", "universal", f"{insert_sound}.ogg")
                if os.path.exists(sound_path):
                    sound = pygame.mixer.Sound(sound_path)
                    channel = pygame.mixer.find_channel()
                    if channel:
                        channel.play(sound)
            except Exception as e:
                logging.warning(f"Failed to play {insert_sound}: {e}")

        def start_reloader_sound():
            reloader_sound_path = os.path.join("sounds", "firearms", "universal", "reloaderloop.ogg")
            if os.path.exists(reloader_sound_path):
                channel = pygame.mixer.find_channel()
                if channel:
                    try:
                        sound = pygame.mixer.Sound(reloader_sound_path)
                        channel.play(sound, loops = -1)
                        unload_state["reloader_channel"]= channel
                        unload_state["reloader_sound"]= sound
                    except Exception as e:
                        logging.warning(f"Failed to play reloader sound: {e}")

        def play_reloader_insert_sound():

            try:
                sound_path = os.path.join("sounds", "firearms", "universal", "reloaderroundinsert.ogg")
                if os.path.exists(sound_path):
                    sound = pygame.mixer.Sound(sound_path)
                    channel = pygame.mixer.find_channel()
                    if channel:
                        channel.play(sound)
                        return int(sound.get_length()*1000)
            except Exception as e:
                logging.warning(f"Failed to play reloader insert sound: {e}")
            return 0

        def play_magout_sound():

            if weapon:
                try:
                    self._play_weapon_action_sound(weapon, "magout")
                    return 500
                except Exception as e:
                    logging.warning(f"Failed to play magout sound: {e}")
            return 0

        def play_magin_sound():

            if weapon:
                try:
                    self._play_weapon_action_sound(weapon, "magin")
                except Exception as e:
                    logging.warning(f"Failed to play magin sound: {e}")

        def stop_reloader_sound():
            if unload_state["reloader_channel"]:
                try:
                    unload_state["reloader_channel"].stop()
                except Exception:
                    pass
                unload_state["reloader_channel"]= None

        def unload_step():
            idx = unload_state["index"]

            if idx >=rounds_to_remove:

                stop_reloader_sound()

                hands_items = save_data.get("hands", {}).get("items", [])
                self._add_rounds_to_container(hands_items, unload_state["rounds_removed"])

                if has_reloader:
                    message = f"Unloaded {len(unload_state['rounds_removed'])} rounds using reloader(remaining: {len(current_rounds)})"
                else:
                    message = f"Manually unloaded {len(unload_state['rounds_removed'])} rounds(remaining: {len(current_rounds)})"

                logging.info(message)

                if is_loaded_in_weapon:
                    play_magin_sound()

                    try:
                        if weapon and is_bolt_action_reload:
                            try:
                                self._play_weapon_action_sound(weapon, "boltforward")
                            except Exception:
                                pass
                    except Exception:
                        pass

                try:
                    popup.destroy()
                except Exception:
                    pass

                if on_complete:
                    on_complete(message)
                return

            if current_rounds:
                try:
                    removed = None
                    if variant_filter:

                        for i in range(len(current_rounds)-1, -1, -1):
                            r = current_rounds[i]
                            if isinstance(r, dict)and str(r.get('variant', 'Unknown')).lower()==str(variant_filter).lower():
                                removed = current_rounds.pop(i)
                                break
                    else:
                        removed = current_rounds.pop()

                    if removed is not None:
                        unload_state["rounds_removed"].append(removed)
                except Exception:
                    pass

            unload_state["index"]+=1

            progress = unload_state["index"]/rounds_to_remove
            progress_bar.set(progress)
            count_label.configure(text = f"{unload_state['index']} / {rounds_to_remove} rounds")

            play_insert_sound()

            if has_reloader:
                delay = 100
            else:
                delay = 500

            popup.after(delay, unload_step)

        initial_delay = 100

        if is_loaded_in_weapon:
            magout_duration = play_magout_sound()
            initial_delay +=magout_duration

        if has_reloader:

            insert_duration = play_reloader_insert_sound()

            def start_reloader_after_insert():
                start_reloader_sound()
                popup.after(100, unload_step)

            popup.after(initial_delay +insert_duration, start_reloader_after_insert)
        else:

            popup.after(initial_delay, unload_step)

        return "Unloading..."

    def _safe_exit(self):
        try:
            autosaved = False
            if currentsave is not None:

                try:
                    global_save = globals().get('save_data')
                    if isinstance(global_save, dict):
                        try:
                            self._save_file(global_save)
                            logging.info("Autosaved current save using globals()['save_data'].")
                            autosaved = True
                        except Exception as e:
                            logging.error(f"Autosave failed for globals()['save_data']: {e}")
                except Exception:
                    pass

                if not autosaved and hasattr(self, '_current_save_data')and isinstance(getattr(self, '_current_save_data'), dict):
                    try:
                        self._save_file(getattr(self, '_current_save_data'))
                        logging.info("Autosaved current save using self._current_save_data.")
                        autosaved = True
                    except Exception as e:
                        logging.error(f"Autosave failed for self._current_save_data: {e}")

                if not autosaved:
                    candidate_names =(
                    'current_save_data', '_current_save_data', 'save_data', '_save_data',
                    'current_data', 'data', '_data'
                    )
                    for name in candidate_names:
                        try:
                            if hasattr(self, name):
                                d = getattr(self, name)
                                if isinstance(d, dict):
                                    try:
                                        self._save_file(d)
                                        logging.info(f"Autosaved current save using attribute '{name}'.")
                                        autosaved = True
                                    except Exception as e:
                                        logging.error(f"Autosave failed using attribute '{name}': {e}")
                                    break
                        except Exception:
                            continue

                if not autosaved:
                    logging.info("Exiting with current save loaded(no in-memory autosave performed).")
            else:
                logging.info("No current save loaded at exit.")

            try:
                self._save_persistent_data()
            except Exception as e:
                logging.error(f"Failed to save persistent data on exit: {e}")

            logging.info("Program exited safely.")
        except Exception as e:
            logging.exception("Error during safe exit: %s", e)
        try:

            try:

                for w in list(self.root.winfo_children()):
                    try:
                        if getattr(w, 'grab_release', None):
                            w.grab_release()
                    except Exception:
                        pass
            except Exception:
                pass

            self.root.quit()
            try:

                self.root.update()
            except Exception:
                pass
            try:

                for w in list(self.root.winfo_children()):
                    try:
                        w.destroy()
                    except Exception:
                        pass
            except Exception:
                pass
            try:
                self.root.destroy()
            except Exception:
                pass
        except Exception:
            try:
                self.root.destroy()
            except Exception:
                pass

        try:
            pygame.mixer.quit()
        except Exception:
            pass
        try:
            pygame.quit()
        except Exception:
            pass

        try:
            import os as _os, sys as _sys
            _sys.exit(0)
        except SystemExit:
            try:
                _os._exit(0)
            except Exception:
                pass

    def _on_window_close(self):

        logging.info("Window close requested; prompting for confirmation.")
        try:
            def on_confirm(result):
                if result:
                    try:
                        self._safe_exit()
                    except Exception:
                        logging.exception("Error while exiting via window close")

            self._popup_confirm(
            "Confirm Exit",
            "Do you want to exit? Any unsaved changes will be autosaved before exiting.",
            on_confirm
            )
        except Exception:
            logging.info("Window close attempted but confirmation unavailable; ignored.")
    def _open_settings(self):
        logging.info("Settings definition called")

        self._clear_window()

        appearance_settings_initial = appearance_settings.copy()
        global_variables_initial = {k:v.copy()if isinstance(v, dict)else v for k, v in global_variables.items()}
        settings_modified =[False]

        builtin_themes =["dark-blue", "blue", "green"]
        themes_dir = os.path.join(os.getcwd(), "themes")
        custom_theme_files =[]
        if os.path.isdir(themes_dir):
            custom_theme_files =[f for f in os.listdir(themes_dir)if f.endswith(".json")]
        theme_sources = {name:name for name in builtin_themes}
        for fname in custom_theme_files:
            name = os.path.splitext(fname)[0]
            theme_sources[name]= os.path.join(themes_dir, fname)
        available_theme_names = list(theme_sources.keys())
        if not available_theme_names:
            available_theme_names =["dark-blue"]
            theme_sources = {"dark-blue":"dark-blue"}

        def update_appearance():
            settings_modified[0]= True
            customtkinter.set_appearance_mode(appearance_settings["appearance_mode"])
            theme_key = appearance_settings.get("color_theme", "dark-blue")
            theme_target = theme_sources.get(theme_key, "dark-blue")
            try:
                customtkinter.set_default_color_theme(theme_target)
            except Exception as e:
                logging.warning(f"Failed to load theme '{theme_target}': {e}")
                appearance_settings["color_theme"]= "dark-blue"
                fallback = theme_sources.get("dark-blue", "dark-blue")
                try:
                    customtkinter.set_default_color_theme(fallback)
                except Exception as e2:
                    logging.error(f"Fallback theme load failed: {e2}")

            try:
                appearance_settings_path = os.path.join(saves_folder or "saves", "appearance_settings.sldsv")
                with open(appearance_settings_path, 'w')as f:
                    json.dump(appearance_settings, f, indent = 4)
                logging.info(f"Appearance settings saved to {appearance_settings_path}")
            except Exception as e:
                logging.error(f"Failed to save appearance settings: {e}")

            self._clear_window()
            self._open_settings()
            try:
                self.root.geometry(appearance_settings["resolution"])
            except Exception as e:
                logging.warning(f"Failed to apply resolution {appearance_settings['resolution']}: {e}")
            self.root.attributes('-fullscreen', appearance_settings.get("fullscreen", False))
            if appearance_settings.get("borderless", False):
                self.root.overrideredirect(True)
            else:
                self.root.overrideredirect(False)

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)
        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew", padx = 20, pady = 20)
        main_frame.grid_columnconfigure((0, 1), weight = 1)
        main_frame.grid_rowconfigure(1, weight = 1)

        title = customtkinter.CTkLabel(main_frame, text = "Settings", font = customtkinter.CTkFont(size = 22, weight = "bold"))
        title.grid(row = 0, column = 0, columnspan = 2, pady =(0, 15))

        content = customtkinter.CTkFrame(main_frame)
        content.grid(row = 1, column = 0, columnspan = 2, sticky = "nsew")
        content.grid_columnconfigure((0, 1), weight = 1)

        appearance_frame = customtkinter.CTkFrame(content)
        appearance_frame.grid(row = 0, column = 0, sticky = "nsew", padx =(0, 10), pady = 10)
        appearance_frame.grid_columnconfigure(1, weight = 1)

        customtkinter.CTkLabel(appearance_frame, text = "Appearance", font = customtkinter.CTkFont(size = 16, weight = "bold")).grid(row = 0, column = 0, columnspan = 2, pady =(10, 5), sticky = "w")

        customtkinter.CTkLabel(appearance_frame, text = "Mode:").grid(row = 1, column = 0, sticky = "w", padx = 10, pady = 4)
        mode_box = customtkinter.CTkOptionMenu(
        appearance_frame,
        values =["system", "dark", "light"],
        command = lambda v:appearance_settings.__setitem__("appearance_mode", v)or update_appearance()
        )
        mode_box.set(appearance_settings.get("appearance_mode", "system"))
        mode_box.grid(row = 1, column = 1, sticky = "ew", padx = 10, pady = 4)

        customtkinter.CTkLabel(appearance_frame, text = "Color Theme:").grid(row = 2, column = 0, sticky = "w", padx = 10, pady = 4)
        theme_box = customtkinter.CTkOptionMenu(
        appearance_frame,
        values = available_theme_names,
        command = lambda v:appearance_settings.__setitem__("color_theme", v)or update_appearance()
        )
        selected_theme = appearance_settings.get("color_theme", "dark-blue")
        if selected_theme not in available_theme_names:
            selected_theme = "dark-blue"
        theme_box.set(selected_theme)
        theme_box.grid(row = 2, column = 1, sticky = "ew", padx = 10, pady = 4)

        customtkinter.CTkLabel(appearance_frame, text = "Resolution:").grid(row = 3, column = 0, sticky = "w", padx = 10, pady = 4)

        screen_w = self.root.winfo_screenwidth()
        screen_h = self.root.winfo_screenheight()

        common_res =[
        "5120x1440", "3840x2400", "3840x2160", "3840x1080", "2560x1600", "2560x1440",
        "2560x1080", "1920x1200", "1920x1080", "1680x1050", "1600x1200", "1600x900",
        "1440x900", "1366x768", "1280x960", "1280x800", "1280x720"
        ]

        def _fits(res_str:str)->bool:
            try:
                w, h = map(int, res_str.split("x"))
                return w <=screen_w and h <=screen_h
            except Exception:
                return False

        def _aspect_label(res_str:str)->str:
            try:
                w, h = map(int, res_str.split("x"))
                ratio = w /h if h else 0

                common_aspects =[
                (16, 9), (16, 10), (21, 9), (32, 9), (4, 3), (5, 4), (3, 2),
                (17, 9), (19, 10), (18, 9)
                ]
                closest = min(common_aspects, key = lambda a:abs(ratio -(a[0]/a[1])))if h else(w, h)
                closest_ratio = closest[0]/closest[1]if closest[1]else ratio

                if h and abs(ratio -closest_ratio)<=0.05:
                    aspect = f"{closest[0]}:{closest[1]}"
                else:
                    g = math.gcd(w, h)
                    aspect = f"{w //g}:{h //g}"if g else f"{w}:{h}"

                return f"{w}x{h}({aspect})"
            except Exception:
                return res_str

        filtered_res =[]
        seen = set()
        for r in common_res:
            if r not in seen and _fits(r):
                filtered_res.append(r)
                seen.add(r)

        current_res = appearance_settings.get("resolution", "1920x1080")
        if current_res not in filtered_res and _fits(current_res):
            filtered_res.insert(0, current_res)

        if not filtered_res:
            filtered_res =[f"{screen_w}x{screen_h}"]

        labeled_values =[_aspect_label(r)for r in filtered_res]

        current_label = _aspect_label(current_res)
        if current_label not in labeled_values and _fits(current_res):
            labeled_values.insert(0, current_label)

        def _on_resolution_change(label_val:str):
            res_val = label_val.split(" ")[0]
            appearance_settings["resolution"]= res_val
            update_appearance()

        resolution_box = customtkinter.CTkOptionMenu(
        appearance_frame,
        values = labeled_values,
        command = _on_resolution_change
        )
        resolution_box.set(current_label if current_label in labeled_values else labeled_values[0])
        resolution_box.grid(row = 3, column = 1, sticky = "ew", padx = 10, pady = 4)

        fullscreen_switch = customtkinter.CTkCheckBox(
        appearance_frame,
        text = "Fullscreen",
        command = lambda:(appearance_settings.__setitem__("fullscreen", bool(fullscreen_switch.get())), update_appearance())
        )
        fullscreen_switch.grid(row = 4, column = 0, columnspan = 2, sticky = "w", padx = 10, pady = 4)
        fullscreen_switch.select()if appearance_settings.get("fullscreen", False)else fullscreen_switch.deselect()

        borderless_switch = customtkinter.CTkCheckBox(
        appearance_frame,
        text = "Borderless",
        command = lambda:(appearance_settings.__setitem__("borderless", bool(borderless_switch.get())), update_appearance())
        )
        borderless_switch.grid(row = 5, column = 0, columnspan = 2, sticky = "w", padx = 10, pady = 4)
        borderless_switch.select()if appearance_settings.get("borderless", False)else borderless_switch.deselect()

        customtkinter.CTkLabel(appearance_frame, text = "Units:").grid(row = 6, column = 0, sticky = "w", padx = 10, pady = 4)
        units_box = customtkinter.CTkOptionMenu(
        appearance_frame,
        values =["imperial", "metric", "cheese"],
        command = lambda v:(appearance_settings.__setitem__("units", v), settings_modified.__setitem__(0, True))
        )
        units_box.set(appearance_settings.get("units", "imperial"))
        units_box.grid(row = 6, column = 1, sticky = "ew", padx = 10, pady = 4)

        customtkinter.CTkLabel(appearance_frame, text = "Sound Volume:").grid(row = 8, column = 0, sticky = "w", padx = 10, pady =(8, 4))
        volume_slider = customtkinter.CTkSlider(
        appearance_frame,
        from_ = 0,
        to = 100,
        number_of_steps = 100,
        command = lambda v:(appearance_settings.__setitem__("sound_volume", int(v)), settings_modified.__setitem__(0, True))
        )
        volume_slider.grid(row = 8, column = 1, sticky = "ew", padx = 10, pady =(8, 4))
        volume_slider.set(appearance_settings.get("sound_volume", 100))

        right_frame = customtkinter.CTkFrame(content)
        right_frame.grid(row = 0, column = 1, sticky = "nsew", padx =(10, 0), pady = 10)
        right_frame.grid_columnconfigure(1, weight = 1)

        customtkinter.CTkLabel(right_frame, text = "Data", font = customtkinter.CTkFont(size = 16, weight = "bold")).grid(row = 0, column = 0, columnspan = 2, pady =(10, 5), sticky = "w")

        customtkinter.CTkLabel(right_frame, text = "Table(.sldtbl):").grid(row = 1, column = 0, sticky = "w", padx = 10, pady = 4)
        try:
            table_files =[f for f in os.listdir("tables")if f.endswith(global_variables.get("table_extension", ".sldtbl"))]
        except FileNotFoundError:
            table_files =[]

        table_display_names =[]
        table_name_map = {}

        for table_file in table_files:
            try:
                table_path = os.path.join("tables", table_file)
                with open(table_path, 'r')as f:
                    table_data = json.load(f)
                pretty_name = table_data.get("prettyname", table_file)
                table_display_names.append(pretty_name)
                table_name_map[pretty_name]= table_file.replace(".sldtbl", "")
            except Exception as e:
                logging.warning(f"Failed to load table pretty name for {table_file}: {e}")
                table_display_names.append(table_file)
                table_name_map[table_file]= table_file.replace(".sldtbl", "")

        if not table_display_names:
            table_display_names =["<none>"]
            table_name_map["<none>"]= None

        table_box = customtkinter.CTkOptionMenu(
        right_frame,
        values = table_display_names,
        state = "disabled"if table_display_names ==["<none>"]else "normal",
        command = lambda v:(global_variables.__setitem__("current_table", table_name_map.get(v)), settings_modified.__setitem__(0, True))
        )

        current_table_val = global_variables.get("current_table")
        current_display_name = "<none>"
        if current_table_val:
            for display_name, filename in table_name_map.items():
                if filename ==current_table_val:
                    current_display_name = display_name
                    break

        table_box.set(current_display_name)
        table_box.grid(row = 1, column = 1, sticky = "ew", padx = 10, pady = 4)

        customtkinter.CTkLabel(right_frame, text = "Developer Flags", font = customtkinter.CTkFont(size = 14, weight = "bold")).grid(row = 2, column = 0, columnspan = 2, pady =(12, 4), sticky = "w")
        dev_enabled = global_variables.get("devmode", {}).get("value", False)

        def make_toggle(row, label, key):
            chk = customtkinter.CTkCheckBox(
            right_frame,
            text = label,
            state = "normal"if dev_enabled else "disabled",
            command = lambda k = key, c = lambda:chk.get():(global_variables[k].__setitem__("value", bool(c())), settings_modified.__setitem__(0, True))
            )
            chk.grid(row = row, column = 0, columnspan = 2, sticky = "w", padx = 10, pady = 4)
            if global_variables[key].get("value", False):
                chk.select()
            else:
                chk.deselect()
            return chk

        dev_chk = make_toggle(3, "Development Mode", "devmode")
        dm_chk = make_toggle(4, "DM Mode", "dmmode")
        debug_chk = make_toggle(5, "Debug Mode", "debugmode")

        if not dev_enabled:
            info_label = customtkinter.CTkLabel(right_frame, text = "Enable devmode to edit these", text_color = "gray")
            info_label.grid(row = 6, column = 0, columnspan = 2, sticky = "w", padx = 10, pady =(0, 8))

        button_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        button_frame.grid(row = 2, column = 0, columnspan = 2, pady =(10, 0))
        button_frame.grid_columnconfigure((0, 1), weight = 1)

        def save_settings():
            try:

                appearance_settings_path = os.path.join(saves_folder or "saves", "appearance_settings.sldsv")
                with open(appearance_settings_path, 'w')as f:
                    json.dump(appearance_settings, f, indent = 4)
                logging.info(f"Appearance settings saved to {appearance_settings_path}")

                settings_path = os.path.join(saves_folder or "saves", "settings.sldsv")
                with open(settings_path, 'w')as f:
                    json.dump(global_variables, f, indent = 4)
                logging.info(f"Global settings saved to {settings_path}")

                settings_modified[0]= False
                self._popup_show_info("Success", "Settings saved successfully!", sound = "success")
            except Exception as e:
                logging.error(f"Failed to save settings: {e}")
                self._popup_show_info("Error", f"Failed to save settings: {e}", sound = "error")

        def go_back():
            if settings_modified[0]:
                def confirm_leave():
                    self._clear_window()
                    self._build_main_menu()
                    confirm_window.destroy()

                def cancel_leave():
                    confirm_window.destroy()

                confirm_window = customtkinter.CTkToplevel(self.root)
                confirm_window.title("Unsaved Changes")
                confirm_window.transient(self.root)
                self._center_popup_on_window(confirm_window, 400, 150)

                msg_label = customtkinter.CTkLabel(
                confirm_window,
                text = "You have unsaved changes.\nDo you want to leave without saving?",
                font = customtkinter.CTkFont(size = 12)
                )
                msg_label.pack(pady = 20)

                button_frame_confirm = customtkinter.CTkFrame(confirm_window, fg_color = "transparent")
                button_frame_confirm.pack(pady = 10)
                button_frame_confirm.grid_columnconfigure((0, 1), weight = 1)

                leave_btn = self._create_sound_button(
                button_frame_confirm,
                "Leave",
                confirm_leave,
                width = 150,
                height = 35
                )
                leave_btn.grid(row = 0, column = 0, padx =(0, 10))

                cancel_btn = self._create_sound_button(
                button_frame_confirm,
                "Cancel",
                cancel_leave,
                width = 150,
                height = 35
                )
                cancel_btn.grid(row = 0, column = 1, padx =(10, 0))

                confirm_window.grab_set()
            else:
                self._clear_window()
                self._build_main_menu()

        save_button = self._create_sound_button(
        button_frame,
        "Save Settings",
        save_settings,
        width = 200,
        height = 40
        )
        save_button.grid(row = 0, column = 0, padx =(0, 10))

        back_button = self._create_sound_button(
        button_frame,
        "Back",
        go_back,
        width = 200,
        height = 40
        )
        back_button.grid(row = 0, column = 1, padx =(10, 0))
    def _open_add_item_by_id_tool(self):
        logging.info("Add Item By ID definition called")

        if currentsave is None:
            self._popup_show_info("Error", "No character loaded.", sound = "error")
            return

        try:
            tbl_path = get_current_table_path()
            if not tbl_path or not os.path.exists(tbl_path):
                self._popup_show_info("Error", "No table files found.", sound = "error")
                return

            with open(tbl_path, 'r')as f:
                table_data = json.load(f)

            all_items =[]
            for table_name, items in table_data.get("tables", {}).items():
                if not isinstance(items, list):
                    continue
                for item in items:
                    if not isinstance(item, dict)or item.get("id")is None:
                        continue
                    item_copy = item.copy()
                    item_copy["table_category"]= table_name
                    all_items.append(item_copy)

            all_items.sort(key = lambda x:x.get("id", 999999))

            if not all_items:
                self._popup_show_info("Error", "No items found in table.", sound = "error")
                return
        except Exception as e:
            logging.error(f"Failed to load table: {e}")
            self._popup_show_info("Error", f"Failed to load table: {e}", sound = "error")
            return

        self._clear_window()

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew", padx = 20, pady = 20)
        main_frame.grid_rowconfigure(2, weight = 1)
        main_frame.grid_columnconfigure(0, weight = 1)

        title = customtkinter.CTkLabel(main_frame, text = "Add Item to Inventory By ID", font = customtkinter.CTkFont(size = 20, weight = "bold"))
        title.grid(row = 0, column = 0, pady =(0, 10))

        search_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        search_frame.grid(row = 1, column = 0, sticky = "ew", pady = 10)
        search_frame.grid_columnconfigure(1, weight = 1)

        search_label = customtkinter.CTkLabel(search_frame, text = "Search(ID or Name):", font = customtkinter.CTkFont(size = 13))
        search_label.grid(row = 0, column = 0, padx =(0, 10), sticky = "w")

        search_entry = customtkinter.CTkEntry(search_frame, placeholder_text = "Enter item ID or name...")
        search_entry.grid(row = 0, column = 1, sticky = "ew", padx =(0, 10))

        ITEMS_PER_PAGE = 25
        current_page =[0]
        current_filtered =[all_items]
        search_timer =[None]

        info_label = customtkinter.CTkLabel(search_frame, text = f"Page 1 | {len(all_items)} items total", font = customtkinter.CTkFont(size = 11), text_color = "gray")
        info_label.grid(row = 0, column = 2, padx = 10)

        scroll_frame = customtkinter.CTkScrollableFrame(main_frame, width = 900, height = 450)
        scroll_frame.grid(row = 2, column = 0, sticky = "nsew", pady = 10)
        scroll_frame.grid_columnconfigure(0, weight = 1)

        pagination_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        pagination_frame.grid(row = 3, column = 0, pady = 5)

        def add_item_to_inventory(item):
            try:
                save_path = os.path.join(saves_folder or "", (currentsave or "")+".sldsv")
                save_data = self._read_save_from_path(save_path)
                if save_data is None:
                    file_sd = {}
                else:
                    file_sd = save_data

                item_to_add = {k:v for k, v in item.items()if k !="table_category"}

                item_to_add = add_subslots_to_item(item_to_add)

                try:
                    save_data.setdefault("hands", {})
                    save_data["hands"].setdefault("items", [])
                    save_data["hands"]["items"].append(item_to_add)
                    added_location = "hands"
                except Exception:

                    try:
                        save_data.setdefault("storage", [])
                        save_data["storage"].append(item_to_add)
                        added_location = "storage"
                    except Exception:
                        added_location = "unknown"

                self._save_file(save_data)

                logging.info(f"Added item ID {item.get('id')}({item.get('name')}) to {added_location}")
                self._popup_show_info("Success", f"Added '{item.get('name')}' to {added_location}!", sound = "success")
            except Exception as e:
                logging.error(f"Failed to add item: {e}")
                self._popup_show_info("Error", f"Failed to add item: {e}", sound = "error")

        def create_item_widget(item):

            item_frame = customtkinter.CTkFrame(scroll_frame)
            item_frame.pack(fill = "x", pady = 3, padx = 5)
            item_frame.grid_columnconfigure(1, weight = 1)

            id_label = customtkinter.CTkLabel(
            item_frame,
            text = f"ID: {item.get('id', 'N/A')}",
            font = customtkinter.CTkFont(size = 12, weight = "bold"),
            width = 80,
            fg_color =("gray75", "gray25"),
            corner_radius = 6
            )
            id_label.grid(row = 0, column = 0, padx = 8, pady = 8, sticky = "w")

            details_frame = customtkinter.CTkFrame(item_frame, fg_color = "transparent")
            details_frame.grid(row = 0, column = 1, sticky = "ew", padx = 8, pady = 8)

            name_label = customtkinter.CTkLabel(
            details_frame,
            text = item.get("name", "Unknown"),
            font = customtkinter.CTkFont(size = 13, weight = "bold"),
            anchor = "w"
            )
            name_label.pack(anchor = "w")

            category_label = customtkinter.CTkLabel(
            details_frame,
            text = f"{item.get('table_category', 'N/A')} | {item.get('rarity', 'N/A')} | ${item.get('value', 0)}",
            font = customtkinter.CTkFont(size = 10),
            text_color = "gray",
            anchor = "w"
            )
            category_label.pack(anchor = "w")

            add_button = self._create_sound_button(
            item_frame,
            "Add",
            lambda it = item:add_item_to_inventory(it),
            width = 80,
            height = 30,
            font = customtkinter.CTkFont(size = 11)
            )
            add_button.grid(row = 0, column = 2, padx = 8, pady = 8)

        def display_page(page_num):

            items = current_filtered[0]
            total_pages = max(1, (len(items)+ITEMS_PER_PAGE -1)//ITEMS_PER_PAGE)

            page_num = max(0, min(page_num, total_pages -1))
            current_page[0]= page_num

            for widget in scroll_frame.winfo_children():
                widget.destroy()

            if not items:
                no_results = customtkinter.CTkLabel(scroll_frame, text = "No items found.", font = customtkinter.CTkFont(size = 14), text_color = "gray")
                no_results.pack(pady = 20)
                info_label.configure(text = "No items found")
                update_pagination_controls(0, 0)
                return

            start_idx = page_num *ITEMS_PER_PAGE
            end_idx = min(start_idx +ITEMS_PER_PAGE, len(items))

            for i in range(start_idx, end_idx):
                create_item_widget(items[i])

            info_label.configure(text = f"Page {page_num +1} of {total_pages} | {len(items)} items total")

            update_pagination_controls(page_num, total_pages)

            try:
                scroll_frame._parent_canvas.yview_moveto(0)
            except Exception:
                pass

        def update_pagination_controls(current, total):

            for widget in pagination_frame.winfo_children():
                widget.destroy()

            if total <=1:
                return

            first_btn = customtkinter.CTkButton(
            pagination_frame, text = "<<", width = 40, height = 30,
            command = lambda:display_page(0),
            state = "normal"if current >0 else "disabled"
            )
            first_btn.pack(side = "left", padx = 2)

            prev_btn = customtkinter.CTkButton(
            pagination_frame, text = "<", width = 40, height = 30,
            command = lambda:display_page(current -1),
            state = "normal"if current >0 else "disabled"
            )
            prev_btn.pack(side = "left", padx = 2)

            start_page = max(0, current -3)
            end_page = min(total, start_page +7)
            if end_page -start_page <7:
                start_page = max(0, end_page -7)

            for p in range(start_page, end_page):
                btn = customtkinter.CTkButton(
                pagination_frame,
                text = str(p +1),
                width = 35,
                height = 30,
                fg_color =("gray75", "gray25")if p ==current else None,
                command = lambda page = p:display_page(page)
                )
                btn.pack(side = "left", padx = 1)

            next_btn = customtkinter.CTkButton(
            pagination_frame, text = ">", width = 40, height = 30,
            command = lambda:display_page(current +1),
            state = "normal"if current <total -1 else "disabled"
            )
            next_btn.pack(side = "left", padx = 2)

            last_btn = customtkinter.CTkButton(
            pagination_frame, text = ">>", width = 40, height = 30,
            command = lambda:display_page(total -1),
            state = "normal"if current <total -1 else "disabled"
            )
            last_btn.pack(side = "left", padx = 2)

        def filter_items(search_term):

            search_lower = search_term.lower().strip()

            if search_lower:
                filtered =[
                item for item in all_items
                if search_lower in str(item.get("id", ""))or search_lower in item.get("name", "").lower()
                ]
            else:
                filtered = all_items

            current_filtered[0]= filtered
            current_page[0]= 0
            display_page(0)

        def on_search_change(*args):

            if search_timer[0]is not None:
                try:
                    self.root.after_cancel(search_timer[0])
                except Exception:
                    pass

            search_timer[0]= self.root.after(200, lambda:filter_items(search_entry.get()))# type: ignore

        search_entry.bind("<KeyRelease>", on_search_change)

        display_page(0)

        button_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        button_frame.grid(row = 4, column = 0, pady = 10)

        back_button = self._create_sound_button(
        button_frame,
        "Back",
        lambda:[self._clear_window(), self._open_modify_save_data_tool()],
        width = 200,
        height = 40,
        font = customtkinter.CTkFont(size = 14)
        )
        back_button.pack()
    def _open_modify_save_data_tool(self):
        logging.info("Modify Save Data definition called")
        self._clear_window()
        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.pack(fill = "both", expand = True, padx = 20, pady = 20)
        add_item_button = self._create_sound_button(main_frame, "Add Item to Inventory By ID", self._open_add_item_by_id_tool, width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        add_item_button.pack(pady = 10)
        back_button = self._create_sound_button(
        main_frame,
        "Back",
        lambda:[self._clear_window(), self._open_dev_tools()],
        width = 200,
        height = 40
        )
        back_button.pack(pady = 10)
    def _open_dev_tools(self):
        logging.info("Developer Tools definition called")
        self._clear_window()
        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.pack(fill = "both", expand = True, padx = 20, pady = 20)
        title_label = customtkinter.CTkLabel(main_frame, text = "Developer Tools", font = customtkinter.CTkFont(size = 20, weight = "bold"))
        title_label.pack(pady = 20)
        modify_data = self._create_sound_button(main_frame, "Modify Data", self._open_modify_save_data_tool, width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        modify_data.pack(pady = 10)
        back_button = self._create_sound_button(
        main_frame,
        "Back",
        lambda:[self._clear_window(), self._build_main_menu()],
        width = 500,
        height = 50,
        font = customtkinter.CTkFont(size = 16)
        )
        back_button.pack(pady = 10)
    def _open_dm_tools(self):
        logging.info("DM Tools definition called")
        self._clear_window()

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew")

        title_label = customtkinter.CTkLabel(main_frame, text = "DM Tools", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title_label.pack(pady = 20)

        scroll_frame = customtkinter.CTkScrollableFrame(main_frame)
        scroll_frame.pack(fill = "both", expand = True, padx = 20, pady = 20)

        encounter_roll_button = self._create_sound_button(scroll_frame, "Encounter Roll", self._open_encounter_roll_tool, width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        encounter_roll_button.pack(pady = 10)

        enemy_loot_button = self._create_sound_button(scroll_frame, "Individual Enemy Loot", self._open_enemy_loot_tool, width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        enemy_loot_button.pack(pady = 10)

        create_lootcrate_button = self._create_sound_button(scroll_frame, "Create Loot Crate", self._open_create_lootcrate_tool, width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        create_lootcrate_button.pack(pady = 10)

        create_item_transfer_button = self._create_sound_button(scroll_frame, "Create Item Transfer", self._open_create_item_transfer_tool, width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        create_item_transfer_button.pack(pady = 10)

        create_magazine_transfer_button = self._create_sound_button(scroll_frame, "Create Loaded Magazine Transfer", self._open_create_magazine_transfer_tool, width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        create_magazine_transfer_button.pack(pady = 10)

        create_belt_transfer_button = self._create_sound_button(scroll_frame, "Create Belt Transfer", self._open_create_belt_transfer_tool, width = 500, height = 50, font = customtkinter.CTkFont(size = 16), state = "disabled")
        create_belt_transfer_button.pack(pady = 10)

        modify_settings_button = self._create_sound_button(scroll_frame, "Modify Settings", self._open_modify_settings_tool, width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        modify_settings_button.pack(pady = 10)

        dungeon_generator_button = self._create_sound_button(scroll_frame, "Dungeon Generator", self._open_dungeon_generator, width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        dungeon_generator_button.pack(pady = 10)

        back_button = self._create_sound_button(main_frame, "Back to Main Menu", lambda:[self._clear_window(), self._build_main_menu()], width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        back_button.pack(pady = 20)

    def _open_dungeon_generator(self):

        try:
            existing = getattr(self, '_dg_window', None)
            if existing and getattr(existing, 'winfo_exists', lambda:False)():
                try:
                    existing.deiconify()
                    existing.lift()
                    existing.focus_force()
                    try:
                        self._popup_show_info("Dungeon Generator", "Dungeon Generator is already open.")
                    except Exception:
                        pass
                except Exception:
                    pass
                return

            try:
                theme = customtkinter.ThemeManager.theme
                toplevel_fg = theme.get('CTkToplevel', {}).get('fg_color')
            except Exception:
                toplevel_fg = None

            if toplevel_fg:
                dg = customtkinter.CTkToplevel(self.root, fg_color = toplevel_fg)
            else:
                dg = customtkinter.CTkToplevel(self.root)

            try:
                dg._is_persistent_window = True
            except Exception:
                pass

            dg.title("Dungeon Generator")
            dg.transient(self.root)
            dg.geometry("900x700")
            dg.minsize(700, 550)

            self._dg_map_window = None

            def _on_close():
                try:

                    if background_combat_timer[0]:
                        try:
                            dg.after_cancel(background_combat_timer[0])
                        except Exception:
                            pass
                        background_combat_timer[0]= None
                except Exception:
                    pass
                try:

                    continuous_gen_active[0]= False
                    if continuous_gen_timer[0]:
                        try:
                            dg.after_cancel(continuous_gen_timer[0])
                        except Exception:
                            pass
                        continuous_gen_timer[0]= None
                except Exception:
                    pass
                try:

                    if self._dg_map_window and self._dg_map_window.winfo_exists():
                        self._dg_map_window.destroy()
                    self._dg_map_window = None
                except Exception:
                    pass
                try:
                    dg.destroy()
                except Exception:
                    pass
                try:
                    self._dg_window = None
                except Exception:
                    self._dg_window = None

            def _confirm_close():
                try:
                    import tkinter as _tk_local
                    from tkinter import messagebox as _mb
                    if _mb.askyesno("Confirm", "Close Dungeon Generator?"):
                        _on_close()
                except Exception:
                    _on_close()

            dg.protocol("WM_DELETE_WINDOW", _confirm_close)

            frm = customtkinter.CTkFrame(dg)
            frm.pack(fill = "both", expand = True, padx = 12, pady = 12)
            lbl = customtkinter.CTkLabel(frm, text = "Dungeon Generator", font = customtkinter.CTkFont(size = 14))
            lbl.pack(pady = 8)

            main_content = customtkinter.CTkFrame(frm)
            main_content.pack(fill = "both", expand = True)

            left_column = customtkinter.CTkFrame(main_content)
            left_column.pack(side = "left", fill = "both", expand = True, padx =(0, 6))

            right_column = customtkinter.CTkFrame(main_content)
            right_column.pack(side = "right", fill = "both", expand = True, padx =(6, 0))

            controls = customtkinter.CTkFrame(left_column)
            controls.pack(fill = "x", pady = 8)

            try:
                self._dg_state = getattr(self, '_dg_state', {})
            except Exception:
                self._dg_state = {}

            diff_labels =["None/Friendly", "Easy", "Medium", "Hard", "Miniboss"]

            try:
                self._dg_state['levels']= _tk.IntVar(value = 1)
                self._dg_state.setdefault('floors', [])

                def _on_levels(v):
                    try:
                        iv = int(round(float(v)))
                        if iv <1:
                            iv = 1
                        if iv >3:
                            iv = 3
                        self._dg_state['levels'].set(iv)
                        lbl_levels.configure(text = f"Levels: {iv}")
                        _rebuild_floors()
                    except Exception:
                        pass

                lbl_levels = customtkinter.CTkLabel(controls, text = f"Levels: {self._dg_state['levels'].get()}")
                lbl_levels.pack(anchor = "w", pady = 4)
                s_levels = customtkinter.CTkSlider(controls, from_ = 1, to = 3, number_of_steps = 2, command = _on_levels)
                s_levels.set(self._dg_state['levels'].get())
                s_levels.pack(fill = "x", pady = 2)

                entrance_frame = customtkinter.CTkFrame(controls)

                floors_container = customtkinter.CTkFrame(left_column)
                floors_container.pack(fill = "x", expand = False, pady = 8)

                def _rebuild_floors():
                    try:
                        for w in floors_container.winfo_children():
                            try:
                                w.destroy()
                            except Exception:
                                pass
                        self._dg_state['floors']=[]
                        levels = max(1, min(3, int(self._dg_state['levels'].get())))
                        if levels !=3:
                            try:
                                entrance_frame.pack_forget()
                            except Exception:
                                pass
                        for i in range(levels):
                            ffrm = customtkinter.CTkFrame(floors_container)
                            ffrm.pack(fill = 'x', pady = 4, padx = 8)
                            floor_label = customtkinter.CTkLabel(ffrm, text = f"Floor {i +1}")
                            floor_label.pack(anchor = 'w')

                            fv_enemy = _tk.IntVar(value = 10)
                            def make_enemy_cb(var, lbl):
                                return lambda v:(var.set(int(round(float(v)))), lbl.configure(text = f"Enemies: {var.get()}"))
                            lbl_fe = customtkinter.CTkLabel(ffrm, text = f"Enemies: {fv_enemy.get()}")
                            lbl_fe.pack(anchor = 'w')
                            s_fe = customtkinter.CTkSlider(ffrm, from_ = 1, to = 50, number_of_steps = 49, command = make_enemy_cb(fv_enemy, lbl_fe))
                            s_fe.set(fv_enemy.get())
                            s_fe.pack(fill = 'x', pady = 2)

                            fv_diff = _tk.IntVar(value = 4)
                            def make_diff_cb(var, lbl):
                                return lambda v:(var.set(int(round(float(v)))), lbl.configure(text = f"Max Difficulty: {diff_labels[var.get()]}"))
                            lbl_fd = customtkinter.CTkLabel(ffrm, text = f"Max Difficulty: {diff_labels[fv_diff.get()]}")
                            lbl_fd.pack(anchor = 'w')
                            s_fd = customtkinter.CTkSlider(ffrm, from_ = 0, to = 4, number_of_steps = 4, command = make_diff_cb(fv_diff, lbl_fd))
                            s_fd.set(fv_diff.get())
                            s_fd.pack(fill = 'x', pady = 2)

                            try:
                                fv_x = _tk.IntVar(value = 20)
                                fv_y = _tk.IntVar(value = 20)

                                def make_x_cb(var, lbl):
                                    return lambda v:(var.set(int(round(float(v)))), lbl.configure(text = f"X Size: {var.get()}"))

                                def make_y_cb(var, lbl):
                                    return lambda v:(var.set(int(round(float(v)))), lbl.configure(text = f"Y Size: {var.get()}"))

                                lbl_x = customtkinter.CTkLabel(ffrm, text = f"X Size: {fv_x.get()}")
                                lbl_x.pack(anchor = 'w')
                                s_x = customtkinter.CTkSlider(ffrm, from_ = 10, to = 50, number_of_steps = 8, command = make_x_cb(fv_x, lbl_x))
                                s_x.set(fv_x.get())
                                s_x.pack(fill = 'x', pady = 2)

                                lbl_y = customtkinter.CTkLabel(ffrm, text = f"Y Size: {fv_y.get()}")
                                lbl_y.pack(anchor = 'w')
                                s_y = customtkinter.CTkSlider(ffrm, from_ = 10, to = 50, number_of_steps = 8, command = make_y_cb(fv_y, lbl_y))
                                s_y.set(fv_y.get())
                                s_y.pack(fill = 'x', pady = 2)
                            except Exception:
                                logging.exception("Failed to create per-floor size controls")

                            fv_transport = None
                            try:

                                try:
                                    tm_var = self._dg_state.get('transport_mode')
                                    tm = tm_var.get()if hasattr(tm_var, 'get')else(tm_var or 'Multiple')
                                except Exception:
                                    tm = 'Multiple'

                                if levels >1 and i <(levels -1)and not(tm =='Single'and i !=0):
                                    fv_transport = _tk.StringVar(value = "Stairs")
                                    lbl_ft = customtkinter.CTkLabel(ffrm, text = "Transport: Stairs")
                                    lbl_ft.pack(anchor = 'w')
                                    opt = customtkinter.CTkOptionMenu(ffrm, values =["Stairs", "Elevator"], command = lambda v, var = fv_transport, l = lbl_ft:(var.set(v), l.configure(text = f"Transport: {v}")))
                                    opt.set(fv_transport.get())
                                    opt.pack(fill = 'x', pady = 2)
                            except Exception:
                                logging.exception("Failed to create transport option for floor")

                            try:
                                self._dg_state['floors'].append({'enemy_count':fv_enemy, 'difficulty':fv_diff, 'transport':fv_transport, 'x_size':fv_x, 'y_size':fv_y})
                            except Exception:
                                self._dg_state['floors'].append({'enemy_count':fv_enemy, 'difficulty':fv_diff, 'transport':fv_transport})

                        try:
                            for w in entrance_frame.winfo_children():
                                try:
                                    w.destroy()
                                except Exception:
                                    pass
                            if levels ==3:

                                try:
                                    entrance_frame.pack(fill = 'x', pady = 4)
                                except Exception:
                                    pass
                                self._dg_state.setdefault('transport_mode', _tk.StringVar(value = 'Multiple'))
                                lbl_em = customtkinter.CTkLabel(entrance_frame, text = 'Transport Mode:')
                                lbl_em.pack(side = 'left', padx = 6)
                                def _set_transport_mode(v):
                                    try:
                                        self._dg_state['transport_mode'].set(v)
                                    except Exception:
                                        pass
                                    try:
                                        _rebuild_floors()
                                    except Exception:
                                        pass
                                opt_em = customtkinter.CTkOptionMenu(entrance_frame, values =['Multiple', 'Single'], command = _set_transport_mode)
                                opt_em.set(self._dg_state.get('transport_mode', _tk.StringVar(value = 'Multiple')).get())
                                opt_em.pack(side = 'left', padx = 6)
                        except Exception:
                            logging.exception('Failed to build entrance mode control')
                    except Exception:
                        logging.exception("Failed to rebuild floor controls")

                _rebuild_floors()
            except Exception:
                logging.exception("Failed to create levels/floors controls")

            dungeon_display_frame = customtkinter.CTkFrame(right_column)
            dungeon_display_frame.pack(fill = "both", expand = True, pady = 8)

            location_label = customtkinter.CTkLabel(dungeon_display_frame, text = "No dungeon generated", font = customtkinter.CTkFont(size = 12, weight = "bold"))
            location_label.pack(anchor = 'w', pady = 4)

            room_info_label = customtkinter.CTkLabel(dungeon_display_frame, text = "", font = customtkinter.CTkFont(size = 11), wraplength = 280, justify = "left")
            room_info_label.pack(anchor = 'w', pady = 4)

            grid_tiles = {}
            grid_rooms = {}
            TILE_SIZE = 20
            grid_canvas =[None]
            tooltip_label =[None]

            def _open_map_window():

                try:
                    if self._dg_map_window and self._dg_map_window.winfo_exists():
                        self._dg_map_window.focus_force()
                        self._dg_map_window.lift()
                        return
                except Exception:
                    pass

                try:
                    theme = customtkinter.ThemeManager.theme
                    toplevel_fg = theme.get('CTkToplevel', {}).get('fg_color')
                except Exception:
                    toplevel_fg = None

                if toplevel_fg:
                    map_win = customtkinter.CTkToplevel(dg, fg_color = toplevel_fg)
                else:
                    map_win = customtkinter.CTkToplevel(dg)

                map_win.title("Dungeon Map")
                map_win.transient(dg)

                dungeon = self._dg_state.get('generated_dungeon')
                if dungeon and dungeon.get("floors"):
                    floor_idx = self._dg_state.get('current_floor', 0)
                    floor = dungeon["floors"][floor_idx]if floor_idx <len(dungeon["floors"])else dungeon["floors"][0]
                    x_size = floor.get("x_size", 20)
                    y_size = floor.get("y_size", 20)
                    win_width = min(max(x_size *TILE_SIZE +80, 400), 1000)
                    win_height = min(max(y_size *TILE_SIZE +120, 350), 800)
                else:
                    win_width = 500
                    win_height = 400

                map_win.geometry(f"{win_width}x{win_height}")

                def _on_map_close():
                    try:
                        grid_canvas[0]= None
                        tooltip_label[0]= None
                        map_win.destroy()
                        self._dg_map_window = None
                    except Exception:
                        pass

                map_win.protocol("WM_DELETE_WINDOW", _on_map_close)
                self._dg_map_window = map_win

                map_frm = customtkinter.CTkFrame(map_win)
                map_frm.pack(fill = "both", expand = True, padx = 8, pady = 8)

                map_title = customtkinter.CTkLabel(map_frm, text = "Dungeon Map", font = customtkinter.CTkFont(size = 12, weight = "bold"))
                map_title.pack(pady = 4)

                canvas = _tk.Canvas(map_frm, bg = "#1a1a1a", highlightthickness = 0)
                canvas.pack(fill = 'both', expand = True, pady = 4)
                grid_canvas[0]= canvas # type: ignore

                tip_label = customtkinter.CTkLabel(map_frm, text = "", font = customtkinter.CTkFont(size = 10), wraplength = 400, justify = "left", fg_color =("gray80", "gray20"), corner_radius = 6)
                tooltip_label[0]= tip_label # type: ignore

                def _on_tile_hover(event):

                    try:
                        if not grid_canvas[0]:
                            return
                        canvas_x = grid_canvas[0].canvasx(event.x)
                        canvas_y = grid_canvas[0].canvasy(event.y)
                        tile_x = int(canvas_x //TILE_SIZE)
                        tile_y = int(canvas_y //TILE_SIZE)

                        room = grid_rooms.get((tile_x, tile_y))
                        if room:
                            info_lines =[]
                            info_lines.append(f"Room: {room.get('name', 'Unknown')}")
                            info_lines.append(f"Type: {room.get('type', 'unknown')}")

                            enemies =[e for e in room.get("enemies", [])if e.get("alive", True)]
                            if enemies:
                                enemy_info =[]
                                for e in enemies:
                                    name = e.get("name", "Unknown")
                                    health = e.get("health", 100)
                                    enemy_info.append(f"{name}({health}HP)")
                                info_lines.append(f"Enemies: {', '.join(enemy_info)}")

                            friendlies =[f for f in room.get("friendlies", [])if f.get("alive", True)]
                            if friendlies:
                                friendly_info =[]
                                for f in friendlies:
                                    name = f.get("name", "Unknown")
                                    health = f.get("health", 100)
                                    friendly_info.append(f"{name}({health}HP)")
                                info_lines.append(f"Friendlies: {', '.join(friendly_info)}")

                            loot_spawn = room.get("loot_spawn", [])
                            if loot_spawn:
                                info_lines.append(f"Loot spawns: {len(loot_spawn)}")

                            doors = room.get("doors_state", {})
                            if doors:
                                door_info =[]
                                for pos, state in doors.items():
                                    lock_status = "ðŸ”’"if state.get("locked")and not state.get("picked")else "ðŸ”“"
                                    door_info.append(f"{pos}: {lock_status}")
                                info_lines.append(f"Doors: {', '.join(door_info)}")

                            if room.get("type")=="transport":
                                transport_info =[]
                                if room.get("is_entry_transport")and room.get("leads_to_floor"):
                                    transport_info.append(f"â†‘ Floor {room.get('leads_to_floor')}")
                                if room.get("is_exit_transport")and room.get("leads_to_floor"):
                                    transport_info.append(f"â†“ Floor {room.get('leads_to_floor')}")
                                if room.get("also_leads_to_floor"):
                                    transport_info.append(f"â†“ Floor {room.get('also_leads_to_floor')}")
                                if transport_info:
                                    info_lines.append("Transport: "+", ".join(transport_info))
                                else:
                                    info_lines.append(f"â†’ Floor {room.get('leads_to_floor', '?')}")

                            if room.get("visited"):
                                info_lines.append("(Visited)")

                            if tooltip_label[0]:
                                tooltip_label[0].configure(text = "\n".join(info_lines))
                                tooltip_label[0].pack(anchor = 'w', pady = 2)
                        else:
                            if tooltip_label[0]:
                                tooltip_label[0].configure(text = "Empty")
                                tooltip_label[0].pack(anchor = 'w', pady = 2)
                    except Exception:
                        pass

                def _on_tile_leave(event):

                    try:
                        if tooltip_label[0]:
                            tooltip_label[0].pack_forget()
                    except Exception:
                        pass

                def _on_tile_click(event):

                    try:
                        if not grid_canvas[0]:
                            return
                        canvas_x = grid_canvas[0].canvasx(event.x)
                        canvas_y = grid_canvas[0].canvasy(event.y)
                        tile_x = int(canvas_x //TILE_SIZE)
                        tile_y = int(canvas_y //TILE_SIZE)

                        clicked_room = grid_rooms.get((tile_x, tile_y))
                        if not clicked_room:
                            return

                        current_room = _get_current_room()
                        if not current_room:
                            return

                        exits = _get_available_exits()
                        for exit_info in exits:
                            if exit_info.get("to_room")==clicked_room.get("room_id"):
                                _move_to_room(exit_info)
                                return

                    except Exception:
                        pass

                canvas.bind("<Motion>", _on_tile_hover)
                canvas.bind("<Leave>", _on_tile_leave)
                canvas.bind("<Button-1>", _on_tile_click)

                map_win.bind("<Up>", _handle_arrow_key)
                map_win.bind("<Down>", _handle_arrow_key)
                map_win.bind("<Left>", _handle_arrow_key)
                map_win.bind("<Right>", _handle_arrow_key)
                map_win.bind("<w>", lambda e:_handle_arrow_key(type('Event', (), {'keysym':'Up'})()))
                map_win.bind("<s>", lambda e:_handle_arrow_key(type('Event', (), {'keysym':'Down'})()))
                map_win.bind("<a>", lambda e:_handle_arrow_key(type('Event', (), {'keysym':'Left'})()))
                map_win.bind("<d>", lambda e:_handle_arrow_key(type('Event', (), {'keysym':'Right'})()))
                map_win.bind("<W>", lambda e:_handle_arrow_key(type('Event', (), {'keysym':'Up'})()))
                map_win.bind("<S>", lambda e:_handle_arrow_key(type('Event', (), {'keysym':'Down'})()))
                map_win.bind("<A>", lambda e:_handle_arrow_key(type('Event', (), {'keysym':'Left'})()))
                map_win.bind("<D>", lambda e:_handle_arrow_key(type('Event', (), {'keysym':'Right'})()))

                map_win.bind("<Shift-Up>", lambda e:_handle_floor_transport(type('Event', (), {'keysym':'Up'})()))
                map_win.bind("<Shift-Down>", lambda e:_handle_floor_transport(type('Event', (), {'keysym':'Down'})()))
                map_win.bind("<Shift-w>", lambda e:_handle_floor_transport(type('Event', (), {'keysym':'Up'})()))
                map_win.bind("<Shift-s>", lambda e:_handle_floor_transport(type('Event', (), {'keysym':'Down'})()))
                map_win.bind("<Shift-W>", lambda e:_handle_floor_transport(type('Event', (), {'keysym':'Up'})()))
                map_win.bind("<Shift-S>", lambda e:_handle_floor_transport(type('Event', (), {'keysym':'Down'})()))

                map_win.focus_force()

                _draw_grid()

            def _flash_muzzle(rx, ry, original_color):

                try:
                    if not grid_canvas[0]or not grid_canvas[0].winfo_exists():
                        return
                    if(rx, ry)not in grid_tiles:
                        return

                    tile_id = grid_tiles[(rx, ry)]

                    grid_canvas[0].itemconfigure(tile_id, fill = "#ffff00")

                    def restore():
                        try:
                            if grid_canvas[0]and grid_canvas[0].winfo_exists()and(rx, ry)in grid_tiles:
                                grid_canvas[0].itemconfigure(grid_tiles[(rx, ry)], fill = original_color)
                        except Exception:
                            pass

                    dg.after(80, restore)
                except Exception:
                    pass

            def _schedule_muzzle_flashes(rx, ry, shots, cyclic_delay, start_delay):

                combat_color = "#cc6633"

                for i in range(shots):
                    shot_delay = start_delay +(i *cyclic_delay)
                    dg.after(shot_delay, lambda x = rx, y = ry, c = combat_color:_flash_muzzle(x, y, c))

            def _draw_grid():

                try:
                    if not grid_canvas[0]:
                        return
                    grid_canvas[0].delete("all")
                    grid_tiles.clear()
                    grid_rooms.clear()

                    dungeon = self._dg_state.get('generated_dungeon')
                    if not dungeon:
                        return

                    floor_idx = self._dg_state.get('current_floor', 0)
                    if floor_idx >=len(dungeon["floors"]):
                        return

                    floor = dungeon["floors"][floor_idx]
                    x_size = floor.get("x_size", 20)
                    y_size = floor.get("y_size", 20)
                    current_room_id = self._dg_state.get('current_room_id')

                    canvas_width = x_size *TILE_SIZE +2
                    canvas_height = y_size *TILE_SIZE +2
                    grid_canvas[0].configure(width = min(canvas_width, 800), height = min(canvas_height, 600))

                    for gx in range(x_size):
                        for gy in range(y_size):
                            x1 = gx *TILE_SIZE
                            y1 = gy *TILE_SIZE
                            x2 = x1 +TILE_SIZE -1
                            y2 = y1 +TILE_SIZE -1
                            tile_id = grid_canvas[0].create_rectangle(x1, y1, x2, y2, fill = "#1a1a1a", outline = "#333333")
                            grid_tiles[(gx, gy)]= tile_id

                    for room in floor["rooms"]:
                        pos = room.get("position", {})
                        rx = pos.get("x", 0)
                        ry = pos.get("y", 0)

                        if rx <0 or rx >=x_size or ry <0 or ry >=y_size:
                            continue

                        enemies =[e for e in room.get("enemies", [])if e.get("alive", True)]
                        friendlies =[f for f in room.get("friendlies", [])if f.get("alive", True)]
                        loot_spawn = room.get("loot_spawn", [])
                        enemies_cleared = room.get("enemies_cleared", False)
                        has_pending_loot = room.get("pending_loot", [])

                        if enemies and friendlies:
                            fill_color = "#cc6633"
                        elif enemies:
                            fill_color = "#cc3333"
                        elif friendlies:
                            fill_color = "#3366cc"
                        elif has_pending_loot:
                            fill_color = "#33cc33"
                        elif loot_spawn:
                            fill_color = "#33cc33"
                        elif room.get("type")=="transport":
                            fill_color = "#3399ff"
                        elif room.get("visited"):
                            fill_color = "#808080"
                        else:
                            fill_color = "#e0e0e0"

                        outline_color = "#333333"
                        outline_width = 1

                        if room.get("type")=="transport":
                            outline_color = "#00ffff"
                            outline_width = 2

                        if friendlies and not enemies:
                            outline_color = "#00ff00"
                            outline_width = 2
                        elif friendlies and enemies:
                            outline_color = "#ffaa00"
                            outline_width = 2

                        if room.get("room_id")==current_room_id:
                            outline_color = "#ffcc00"
                            outline_width = 3

                        x1 = rx *TILE_SIZE
                        y1 = ry *TILE_SIZE
                        x2 = x1 +TILE_SIZE -1
                        y2 = y1 +TILE_SIZE -1

                        if(rx, ry)in grid_tiles:
                            grid_canvas[0].delete(grid_tiles[(rx, ry)])
                        tile_id = grid_canvas[0].create_rectangle(x1, y1, x2, y2, fill = fill_color, outline = outline_color, width = outline_width)
                        grid_tiles[(rx, ry)]= tile_id
                        grid_rooms[(rx, ry)]= room

                        room_type = room.get("type", "")
                        indicator = ""
                        if room_type =="entrance":
                            indicator = "E"
                        elif room_type =="transport":
                            indicator = "T"
                        elif room_type =="hallway":
                            indicator = "H"
                        elif room_type =="room":
                            indicator = "R"

                        if indicator:
                            text_color = "#000000"if fill_color in["#e0e0e0", "#33cc33", "#808080", "#3399ff", "#3366cc"]else "#ffffff"
                            grid_canvas[0].create_text(x1 +TILE_SIZE //2, y1 +TILE_SIZE //2, text = indicator, fill = text_color, font =("Arial", 8, "bold"))

                    for conn in floor.get("connections", []):
                        from_room = None
                        to_room = None
                        for room in floor["rooms"]:
                            if room.get("room_id")==conn.get("from_room"):
                                from_room = room
                            if room.get("room_id")==conn.get("to_room"):
                                to_room = room

                        if from_room and to_room:
                            from_pos = from_room.get("position", {})
                            to_pos = to_room.get("position", {})
                            fx = from_pos.get("x", 0)*TILE_SIZE +TILE_SIZE //2
                            fy = from_pos.get("y", 0)*TILE_SIZE +TILE_SIZE //2
                            tx = to_pos.get("x", 0)*TILE_SIZE +TILE_SIZE //2
                            ty = to_pos.get("y", 0)*TILE_SIZE +TILE_SIZE //2
                            grid_canvas[0].create_line(fx, fy, tx, ty, fill = "#666666", width = 2)

                except Exception as e:
                    logging.exception("Failed to draw grid")

            nav_frame = customtkinter.CTkFrame(dungeon_display_frame)
            nav_frame.pack(fill = 'x', pady = 8)

            door_frame = customtkinter.CTkFrame(dungeon_display_frame)
            door_frame.pack(fill = 'x', pady = 4)

            door_status_label = customtkinter.CTkLabel(door_frame, text = "", font = customtkinter.CTkFont(size = 11))
            door_status_label.pack(side = 'left', padx = 6)

            pick_door_btn = customtkinter.CTkButton(door_frame, text = "Door Picked Successfully", state = "disabled", width = 180)
            pick_door_btn.pack(side = 'left', padx = 6)

            combat_frame = customtkinter.CTkFrame(dungeon_display_frame)
            combat_frame.pack(fill = 'x', pady = 4)

            kill_enemy_btn = customtkinter.CTkButton(combat_frame, text = "Mark Enemies Killed", state = "disabled", width = 160)
            kill_enemy_btn.pack(side = 'left', padx = 6)

            collect_loot_btn = customtkinter.CTkButton(combat_frame, text = "Collect Loot", state = "disabled", width = 120)
            collect_loot_btn.pack(side = 'left', padx = 6)

            combat_log_frame = customtkinter.CTkFrame(dungeon_display_frame)
            combat_log_frame.pack(fill = 'x', pady = 4)

            combat_log_label = customtkinter.CTkLabel(combat_log_frame, text = "Combat Log:", font = customtkinter.CTkFont(size = 10, weight = "bold"))
            combat_log_label.pack(anchor = 'w', padx = 6)

            combat_log_text = customtkinter.CTkTextbox(combat_log_frame, height = 80, font = customtkinter.CTkFont(size = 9))
            combat_log_text.pack(fill = 'x', padx = 6, pady = 2)
            combat_log_text.configure(state = "disabled")

            def _add_combat_log(message):

                try:
                    combat_log_text.configure(state = "normal")
                    timestamp = datetime.now().strftime("%H:%M:%S")
                    combat_log_text.insert("end", f"[{timestamp}]{message}\n")
                    combat_log_text.see("end")

                    lines = combat_log_text.get("1.0", "end").split("\n")
                    if len(lines)>50:
                        combat_log_text.delete("1.0", f"{len(lines)-50}.0")
                    combat_log_text.configure(state = "disabled")
                except Exception:
                    pass

            background_combat_timer =[None]
            continuous_gen_active =[False]
            continuous_gen_timer =[None]
            map_editor_window =[None]

            def _open_map_editor():

                try:
                    if map_editor_window[0]and map_editor_window[0].winfo_exists():
                        map_editor_window[0].focus_force()
                        map_editor_window[0].lift()
                        return
                except Exception:
                    pass

                try:
                    theme = customtkinter.ThemeManager.theme
                    toplevel_fg = theme.get('CTkToplevel', {}).get('fg_color')
                except Exception:
                    toplevel_fg = None

                if toplevel_fg:
                    editor_win = customtkinter.CTkToplevel(dg, fg_color = toplevel_fg)
                else:
                    editor_win = customtkinter.CTkToplevel(dg)

                editor_win.title("Map Editor")
                editor_win.transient(dg)
                editor_win.geometry("800x600")
                editor_win.minsize(600, 400)
                map_editor_window[0]= editor_win # type: ignore

                editor_state = {
                'current_tool':'select',
                'selected_room':None,
                'grid_size_x':20,
                'grid_size_y':20,
                }

                def _on_editor_close():
                    try:
                        map_editor_window[0]= None
                        editor_win.destroy()
                    except Exception:
                        pass

                editor_win.protocol("WM_DELETE_WINDOW", _on_editor_close)

                editor_frame = customtkinter.CTkFrame(editor_win)
                editor_frame.pack(fill = "both", expand = True, padx = 8, pady = 8)

                toolbar = customtkinter.CTkFrame(editor_frame)
                toolbar.pack(fill = "x", pady = 4)

                tool_label = customtkinter.CTkLabel(toolbar, text = "Tool:")
                tool_label.pack(side = "left", padx = 4)

                tool_buttons = {}

                def _set_tool(tool_name):
                    editor_state['current_tool']= tool_name
                    for name, btn in tool_buttons.items():
                        if name ==tool_name:
                            btn.configure(fg_color =("#3B8ED0", "#1F6AA5"))
                        else:
                            btn.configure(fg_color =("gray70", "gray30"))

                for tool in['select', 'room', 'hallway', 'transport', 'entrance', 'delete']:
                    btn = customtkinter.CTkButton(toolbar, text = tool.capitalize(), width = 70,
                    command = lambda t = tool:_set_tool(t),
                    fg_color =("gray70", "gray30"))
                    btn.pack(side = "left", padx = 2)
                    tool_buttons[tool]= btn

                tool_buttons['select'].configure(fg_color =("#3B8ED0", "#1F6AA5"))

                size_frame = customtkinter.CTkFrame(toolbar)
                size_frame.pack(side = "right", padx = 8)

                def _update_grid_size():
                    try:
                        editor_state['grid_size_x']= int(x_size_entry.get())
                        editor_state['grid_size_y']= int(y_size_entry.get())
                        _redraw_editor_grid()
                    except ValueError:
                        pass

                customtkinter.CTkLabel(size_frame, text = "X:").pack(side = "left")
                x_size_entry = customtkinter.CTkEntry(size_frame, width = 40)
                x_size_entry.insert(0, "20")
                x_size_entry.pack(side = "left", padx = 2)

                customtkinter.CTkLabel(size_frame, text = "Y:").pack(side = "left")
                y_size_entry = customtkinter.CTkEntry(size_frame, width = 40)
                y_size_entry.insert(0, "20")
                y_size_entry.pack(side = "left", padx = 2)

                resize_btn = customtkinter.CTkButton(size_frame, text = "Resize", width = 60, command = _update_grid_size)
                resize_btn.pack(side = "left", padx = 4)

                canvas_frame = customtkinter.CTkFrame(editor_frame)
                canvas_frame.pack(fill = "both", expand = True, pady = 4)

                editor_canvas = _tk.Canvas(canvas_frame, bg = "#1a1a1a", highlightthickness = 0)
                editor_canvas.pack(fill = "both", expand = True)

                EDITOR_TILE_SIZE = 25
                editor_rooms = {}
                editor_connections =[]
                room_id_counter =[0]

                def _redraw_editor_grid():
                    editor_canvas.delete("all")
                    x_size = editor_state['grid_size_x']
                    y_size = editor_state['grid_size_y']

                    for x in range(x_size +1):
                        editor_canvas.create_line(x *EDITOR_TILE_SIZE, 0,
                        x *EDITOR_TILE_SIZE, y_size *EDITOR_TILE_SIZE,
                        fill = "#333333")
                    for y in range(y_size +1):
                        editor_canvas.create_line(0, y *EDITOR_TILE_SIZE,
                        x_size *EDITOR_TILE_SIZE, y *EDITOR_TILE_SIZE,
                        fill = "#333333")

                    for(rx, ry), room in editor_rooms.items():
                        x1 = rx *EDITOR_TILE_SIZE
                        y1 = ry *EDITOR_TILE_SIZE
                        x2 = x1 +EDITOR_TILE_SIZE -1
                        y2 = y1 +EDITOR_TILE_SIZE -1

                        room_type = room.get("type", "room")
                        if room_type =="entrance":
                            color = "#ffcc00"
                        elif room_type =="transport":
                            color = "#3399ff"
                        elif room_type =="hallway":
                            color = "#666666"
                        else:
                            color = "#808080"

                        editor_canvas.create_rectangle(x1, y1, x2, y2, fill = color, outline = "#ffffff")

                        indicator = room_type[0].upper()
                        editor_canvas.create_text(x1 +EDITOR_TILE_SIZE //2, y1 +EDITOR_TILE_SIZE //2,
                        text = indicator, fill = "#ffffff", font =("Arial", 10, "bold"))

                    for conn in editor_connections:
                        if conn['from']in editor_rooms and conn['to']in editor_rooms:
                            fx, fy = conn['from']
                            tx, ty = conn['to']
                            editor_canvas.create_line(
                            fx *EDITOR_TILE_SIZE +EDITOR_TILE_SIZE //2,
                            fy *EDITOR_TILE_SIZE +EDITOR_TILE_SIZE //2,
                            tx *EDITOR_TILE_SIZE +EDITOR_TILE_SIZE //2,
                            ty *EDITOR_TILE_SIZE +EDITOR_TILE_SIZE //2,
                            fill = "#00ff00", width = 2
                            )

                def _on_editor_click(event):
                    x = event.x //EDITOR_TILE_SIZE
                    y = event.y //EDITOR_TILE_SIZE

                    if x <0 or x >=editor_state['grid_size_x']or y <0 or y >=editor_state['grid_size_y']:
                        return

                    tool = editor_state['current_tool']

                    if tool =='select':
                        editor_state['selected_room']=(x, y)if(x, y)in editor_rooms else None
                    elif tool =='delete':
                        if(x, y)in editor_rooms:
                            del editor_rooms[(x, y)]

                            editor_connections[:]=[c for c in editor_connections
                            if c['from']!=(x, y)and c['to']!=(x, y)]
                    elif tool in['room', 'hallway', 'transport', 'entrance']:
                        if(x, y)not in editor_rooms:
                            room_id_counter[0]+=1
                            editor_rooms[(x, y)]= {
                            'room_id':room_id_counter[0],
                            'type':tool,
                            'name':f"{tool.capitalize()} {room_id_counter[0]}",
                            'position':{'x':x, 'y':y},
                            'attachment_points':[],
                            'doors':[],
                            'enemies':[],
                            'friendlies':[],
                            'loot_spawn':[],
                            }

                            for dx, dy, direction in[(0, -1, 'top'), (0, 1, 'bottom'), (-1, 0, 'left'), (1, 0, 'right')]:
                                adj =(x +dx, y +dy)
                                if adj in editor_rooms:
                                    editor_connections.append({'from':(x, y), 'to':adj, 'direction':direction})

                    _redraw_editor_grid()

                editor_canvas.bind("<Button-1>", _on_editor_click)

                bottom_frame = customtkinter.CTkFrame(editor_frame)
                bottom_frame.pack(fill = "x", pady = 4)

                def _apply_to_dungeon():

                    if not editor_rooms:
                        self._popup_show_info("Error", "No rooms placed!", sound = "error")
                        return

                    floor_data = {
                    'floor_number':1,
                    'x_size':editor_state['grid_size_x'],
                    'y_size':editor_state['grid_size_y'],
                    'rooms':[],
                    'connections':[],
                    'enemies_remaining':0
                    }

                    for(rx, ry), room in editor_rooms.items():
                        floor_data['rooms'].append(room.copy())

                    for conn in editor_connections:
                        from_room = editor_rooms.get(conn['from'])
                        to_room = editor_rooms.get(conn['to'])
                        if from_room and to_room:
                            floor_data['connections'].append({
                            'from_room':from_room['room_id'],
                            'to_room':to_room['room_id'],
                            'direction':conn.get('direction', 'bottom')
                            })

                    dungeon = {
                    'floors':[floor_data],
                    'metadata':{'generated_at':datetime.now().isoformat(), 'manual_edit':True}
                    }

                    self._dg_state['generated_dungeon']= dungeon
                    self._dg_state['current_floor']= 0

                    start_room = None
                    for room in floor_data['rooms']:
                        if room.get('type')=='entrance':
                            start_room = room['room_id']
                            break
                    if start_room is None and floor_data['rooms']:
                        start_room = floor_data['rooms'][0]['room_id']
                    self._dg_state['current_room_id']= start_room

                    _update_display()
                    _draw_grid()
                    self._popup_show_info("Map Editor", f"Applied layout with {len(floor_data['rooms'])} rooms!")

                def _clear_editor():
                    editor_rooms.clear()
                    editor_connections.clear()
                    room_id_counter[0]= 0
                    _redraw_editor_grid()

                def _load_current_floor():

                    dungeon = self._dg_state.get('generated_dungeon')
                    if not dungeon or not dungeon.get('floors'):
                        self._popup_show_info("Error", "No dungeon to load!", sound = "error")
                        return

                    floor_idx = self._dg_state.get('current_floor', 0)
                    floor = dungeon['floors'][floor_idx]

                    editor_rooms.clear()
                    editor_connections.clear()

                    editor_state['grid_size_x']= floor.get('x_size', 20)
                    editor_state['grid_size_y']= floor.get('y_size', 20)
                    x_size_entry.delete(0, 'end')
                    x_size_entry.insert(0, str(editor_state['grid_size_x']))
                    y_size_entry.delete(0, 'end')
                    y_size_entry.insert(0, str(editor_state['grid_size_y']))

                    max_id = 0
                    for room in floor.get('rooms', []):
                        pos = room.get('position', {})
                        rx, ry = pos.get('x', 0), pos.get('y', 0)
                        editor_rooms[(rx, ry)]= room.copy()
                        max_id = max(max_id, room.get('room_id', 0))

                    room_id_counter[0]= max_id

                    for conn in floor.get('connections', []):
                        from_id = conn.get('from_room')
                        to_id = conn.get('to_room')
                        from_pos = None
                        to_pos = None
                        for(pos, room)in editor_rooms.items():
                            if room.get('room_id')==from_id:
                                from_pos = pos
                            if room.get('room_id')==to_id:
                                to_pos = pos
                        if from_pos and to_pos:
                            editor_connections.append({
                            'from':from_pos,
                            'to':to_pos,
                            'direction':conn.get('direction')
                            })

                    _redraw_editor_grid()
                    self._popup_show_info("Map Editor", f"Loaded floor {floor_idx +1} with {len(editor_rooms)} rooms")

                apply_btn = customtkinter.CTkButton(bottom_frame, text = "Apply to Dungeon", width = 120, command = _apply_to_dungeon)
                apply_btn.pack(side = "left", padx = 4)

                load_btn = customtkinter.CTkButton(bottom_frame, text = "Load Current Floor", width = 120, command = _load_current_floor)
                load_btn.pack(side = "left", padx = 4)

                clear_btn = customtkinter.CTkButton(bottom_frame, text = "Clear", width = 80, command = _clear_editor)
                clear_btn.pack(side = "left", padx = 4)

                close_btn = customtkinter.CTkButton(bottom_frame, text = "Close", width = 80, command = _on_editor_close)
                close_btn.pack(side = "right", padx = 4)

                info_label = customtkinter.CTkLabel(editor_frame,
                text = "Click to place rooms.Select tool to view, Delete to remove.Rooms auto-connect to neighbors.",
                font = customtkinter.CTkFont(size = 10))
                info_label.pack(pady = 2)

                _redraw_editor_grid()

            map_btn_frame = customtkinter.CTkFrame(dungeon_display_frame)
            map_btn_frame.pack(fill = 'x', pady = 4)
            open_map_btn = customtkinter.CTkButton(map_btn_frame, text = "Open Map", width = 120, command = lambda:_open_map_window())
            open_map_btn.pack(side = 'left', padx = 6)

            edit_map_btn = customtkinter.CTkButton(map_btn_frame, text = "Map Editor", width = 100, command = _open_map_editor)
            edit_map_btn.pack(side = 'left', padx = 6)

            self._dg_state.setdefault('generated_dungeon', None)
            self._dg_state.setdefault('current_floor', 0)
            self._dg_state.setdefault('current_room_id', None)
            self._dg_state.setdefault('pending_door', None)
            self._dg_state.setdefault('movement_locked', False)

            def _load_rooms_table():

                try:
                    tbl_path = get_current_table_path()
                    if not tbl_path or not os.path.exists(tbl_path):
                        return[]
                    with open(tbl_path, 'r')as f:
                        table_data = json.load(f)
                    return table_data.get("tables", {}).get("rooms", [])
                except Exception as e:
                    logging.exception("Failed to load rooms table")
                    return[]

            def _load_enemies_table():

                try:
                    tbl_path = get_current_table_path()
                    if not tbl_path or not os.path.exists(tbl_path):
                        return[]
                    with open(tbl_path, 'r')as f:
                        table_data = json.load(f)
                    return table_data.get("tables", {}).get("enemy_drops", [])
                except Exception as e:
                    logging.exception("Failed to load enemies table")
                    return[]

            def _play_distant_combat_sound(sound_path, volume = 0.15):

                try:
                    if not os.path.exists(sound_path):
                        return
                    sound = pygame.mixer.Sound(sound_path)
                    sound.set_volume(volume)
                    channel = pygame.mixer.find_channel()
                    if channel:
                        channel.play(sound)
                except Exception as e:
                    logging.debug(f"Failed to play distant combat sound: {e}")

            def _play_dungeon_sound(sound_name, volume = 0.3):

                try:
                    sound_paths = {
                    "step":[
                    os.path.join("sounds", "misc", "dungeon", f"step{i}.ogg")
                    for i in range(4)
                    ],
                    "locked":os.path.join("sounds", "misc", "dungeon", "locked.ogg"),
                    "door":os.path.join("sounds", "misc", "dungeon", "door.ogg"),
                    "elevator":os.path.join("sounds", "misc", "dungeon", "elevator.wav"),
                    "unlock":os.path.join("sounds", "misc", "lockpicking", "unlock.ogg"),
                    }

                    if sound_name =="step":

                        available_steps =[p for p in sound_paths["step"]if os.path.exists(p)]
                        if available_steps:
                            sound_path = random.choice(available_steps)
                        else:
                            return
                    else:
                        sound_path = sound_paths.get(sound_name)
                        if not sound_path or not os.path.exists(sound_path):
                            return

                    sound = pygame.mixer.Sound(sound_path)
                    sound.set_volume(volume)
                    channel = pygame.mixer.find_channel()
                    if channel:
                        channel.play(sound)
                except Exception as e:
                    logging.debug(f"Failed to play dungeon sound '{sound_name}': {e}")

            def _get_weapon_sound_for_npc(npc):

                try:
                    items = npc.get("items", [])

                    for item in items:
                        if isinstance(item, dict):
                            item_id = item.get("id")

                            if item_id:

                                caliber_folders =["556", "762_39", "9x19", "45acp", "308", "12gauge", "223"]
                                for cal in caliber_folders:
                                    sound_dir = os.path.join("sounds", "firearms", cal)
                                    if os.path.isdir(sound_dir):
                                        sounds = glob.glob(os.path.join(sound_dir, "*.wav"))+glob.glob(os.path.join(sound_dir, "*.ogg"))
                                        if sounds:
                                            return random.choice(sounds)

                    fallback_cals =["556", "762_39", "9x19"]
                    for cal in fallback_cals:
                        sound_dir = os.path.join("sounds", "firearms", cal)
                        if os.path.isdir(sound_dir):
                            sounds = glob.glob(os.path.join(sound_dir, "*.wav"))+glob.glob(os.path.join(sound_dir, "*.ogg"))
                            if sounds:
                                return random.choice(sounds)
                except Exception as e:
                    logging.debug(f"Failed to get weapon sound: {e}")
                return None

            def _get_npc_weapon_info(npc):

                try:
                    items = npc.get("items", [])
                    for item in items:
                        if isinstance(item, dict)and item.get("firearm"):
                            return item
                        elif isinstance(item, (int, float)):

                            for category in["rifles", "smgs", "pistols", "shotguns", "machineguns", "snipers"]:
                                weapons = table_data.get("tables", {}).get(category, [])
                                for weapon in weapons:
                                    if weapon.get("id")==item:
                                        return weapon
                except Exception as e:
                    logging.debug(f"Failed to get NPC weapon info: {e}")
                return None

            def _is_manual_action(weapon):

                if not weapon:
                    return False
                actions = weapon.get("action", [])
                manual_actions =["Bolt", "Pump", "Lever", "Single", "Break"]

                if actions and all(a in manual_actions for a in actions):
                    return True
                return False

            def _get_weapon_firemode(weapon):

                if not weapon:
                    return "Semi"
                actions = weapon.get("action", ["Semi"])
                if not actions:
                    return "Semi"
                return random.choice(actions)

            def _get_shots_for_firemode(firemode, weapon):

                if firemode in["Bolt", "Pump", "Lever", "Single", "Break"]:
                    return 1
                elif firemode =="Semi":
                    return random.randint(1, 4)
                elif firemode =="Burst":
                    burst_count = weapon.get("burst_count", 3)if weapon else 3
                    return burst_count
                elif firemode =="Auto":
                    return random.randint(3, 10)
                else:
                    return random.randint(1, 3)

            def _get_weapon_caliber_folder(weapon):

                if not weapon:
                    return "556"
                calibers = weapon.get("caliber", [])
                if not calibers:
                    return "556"
                caliber = calibers[0].lower()if calibers else ""

                caliber_map = {
                "5.56x45mm":"556", "5.56":"556", "5.56x45mm nato":"556",
                "7.62x39mm":"762_39", "7.62x39":"762_39",
                "7.62x51mm":"762_51", "7.62x51mm nato":"762_51", ".308":"308", "308 winchester":"308",
                "7.62x54mmr":"762_54", "7.62x54r":"762_54",
                "9x19mm":"9x19", "9mm":"9x19", "9x19mm parabellum":"9x19",
                "9x18mm":"9x18", "9x18mm makarov":"9x18",
                ".45 acp":"45acp", "45 acp":"45acp", ".45acp":"45acp",
                "12 gauge":"12gauge", "12gauge":"12gauge",
                "20 gauge":"20gauge", "20gauge":"20gauge",
                ".223":"223", "223 remington":"223", ".223 remington":"223",
                ".50 bmg":"50ae", "50 bmg":"50ae",
                ".338":"338", "338 lapua":"338", ".338 lapua":"338",
                "5.45x39mm":"545_39", "5.45x39":"545_39",
                ".357 magnum":"357mag", "357 magnum":"357mag",
                ".44 magnum":"44mag", "44 magnum":"44mag",
                ".380 acp":"380acp", "380 acp":"380acp",
                ".38 special":"38special", "38 special":"38special",
                ".30-06":"30_06", "30-06":"30_06",
                ".30-30":"30_30", "30-30":"30_30",
                ".300":"300", "300 win mag":"300",
                ".303":"303", "303 british":"303",
                }

                for key, folder in caliber_map.items():
                    if key in caliber:
                        return folder
                return "556"

            def _is_weapon_suppressed(weapon):

                if not weapon:
                    return False

                if weapon.get("integrally_suppressed", False):
                    return True

                attachments = weapon.get("attachments", [])
                for attachment in attachments:
                    if isinstance(attachment, dict):

                        if attachment.get("suppressor", False):
                            return True

                        current = attachment.get("current")
                        if isinstance(current, dict)and current.get("suppressor", False):
                            return True

                return False

            def _get_magazine_capacity(weapon):

                if not weapon:
                    return 30
                return weapon.get("magazine_capacity", weapon.get("capacity", 30))

            def _get_weapon_platform_folder(weapon):

                if not weapon:
                    return None
                platform = weapon.get("platform", "").lower().replace(" ", "-").replace("_", "-")
                if platform:
                    sound_dir = os.path.join("sounds", "firearms", "weaponsounds", platform)
                    if os.path.isdir(sound_dir):
                        return platform
                return None

            def _play_action_sound(weapon, volume = 0.1, delay = 0):

                def _play():
                    try:
                        platform_folder = _get_weapon_platform_folder(weapon)
                        if platform_folder:
                            sound_dir = os.path.join("sounds", "firearms", "weaponsounds", platform_folder)

                            bolt_back = os.path.join(sound_dir, "boltback.ogg")
                            bolt_forward = os.path.join(sound_dir, "boltforward.ogg")

                            if os.path.isfile(bolt_back):
                                _play_distant_combat_sound(bolt_back, volume = volume)
                            if os.path.isfile(bolt_forward):

                                dg.after(300, lambda:_play_distant_combat_sound(bolt_forward, volume = volume))
                    except Exception as e:
                        logging.debug(f"Failed to play action sound: {e}")

                if delay >0:
                    dg.after(delay, _play)
                else:
                    _play()

            def _get_cyclic_delay(weapon, firemode):

                if not weapon:
                    return 100

                if firemode in["Bolt", "Pump", "Lever", "Single", "Break"]:
                    return 1500

                if firemode =="Burst":
                    burst_cyclic = weapon.get("burst_cyclic", weapon.get("cyclic", 600))
                    return max(50, int(60000 /burst_cyclic))

                cyclic = weapon.get("cyclic", 600)

                return max(50, int(60000 /cyclic))

            def _schedule_combat_sounds(sound_dir, weapon, firemode, shots, volume, start_delay, is_suppressed = False, callback = None):

                cyclic_delay = _get_cyclic_delay(weapon, firemode)
                is_manual = _is_manual_action(weapon)

                def play_shot(shot_num):
                    try:
                        if os.path.isdir(sound_dir):

                            all_sounds = glob.glob(os.path.join(sound_dir, "*.wav"))+glob.glob(os.path.join(sound_dir, "*.ogg"))

                            if is_suppressed:

                                suppressed_sounds =[s for s in all_sounds if "_suppressed"in s.lower()]
                                sounds = suppressed_sounds if suppressed_sounds else all_sounds

                                actual_volume = volume *0.5
                            else:

                                sounds =[s for s in all_sounds if "_suppressed"not in s.lower()]
                                actual_volume = volume

                            if sounds:
                                sound_path = random.choice(sounds)
                                _play_distant_combat_sound(sound_path, volume = actual_volume)
                    except Exception:
                        pass

                for i in range(shots):
                    shot_delay = start_delay +(i *cyclic_delay)
                    dg.after(shot_delay, lambda num = i:play_shot(num))

                if is_manual and shots >0:
                    action_delay = start_delay +(shots *cyclic_delay)+100
                    _play_action_sound(weapon, volume = volume *0.7, delay = action_delay)

                total_duration = start_delay +(shots *cyclic_delay)
                if is_manual:
                    total_duration +=500

                if callback:
                    dg.after(total_duration +100, callback)

                return total_duration

            def _process_background_combat():

                try:
                    dungeon = self._dg_state.get('generated_dungeon')
                    if not dungeon:
                        return

                    floor_idx = self._dg_state.get('current_floor', 0)
                    if floor_idx >=len(dungeon["floors"]):
                        return

                    floor = dungeon["floors"][floor_idx]
                    player_room_id = self._dg_state.get('current_room_id')
                    combat_occurred = False
                    player_room_combat = False

                    player_room = None
                    for room in floor["rooms"]:
                        if room.get("room_id")==player_room_id:
                            player_room = room
                            break

                    if player_room:
                        player_enemies =[e for e in player_room.get("enemies", [])if e.get("alive", True)]
                        player_friendlies =[f for f in player_room.get("friendlies", [])if f.get("alive", True)]

                        if not(player_enemies and player_friendlies):
                            self._dg_state['movement_locked']= False

                    combat_actions =[]
                    current_delay = 0
                    TURN_PAUSE = 800
                    RELOAD_TIME = 1500

                    npc_shots_fired = {}

                    for room in floor["rooms"]:

                        is_player_room = room.get("room_id")==player_room_id

                        enemies =[e for e in room.get("enemies", [])if e.get("alive", True)]
                        friendlies =[f for f in room.get("friendlies", [])if f.get("alive", True)]

                        armed_enemies =[e for e in enemies if _get_npc_weapon_info(e)is not None]
                        armed_friendlies =[f for f in friendlies if _get_npc_weapon_info(f)is not None]

                        if armed_enemies and armed_friendlies:
                            combat_occurred = True
                            if is_player_room:
                                player_room_combat = True

                                self._dg_state['movement_locked']= True

                            combat_volume = 0.35 if is_player_room else 0.12

                            room_name = room.get("name", f"Room {room.get('room_id', '?')}")
                            room_pos = room.get("position", {})
                            room_loc = f"({room_pos.get('x', '?')}, {room_pos.get('y', '?')})"

                            for enemy in armed_enemies:
                                if random.random()<0.6:
                                    alive_friendlies =[f for f in armed_friendlies if f.get("alive", True)]
                                    if not alive_friendlies:
                                        break

                                    target = random.choice(alive_friendlies)
                                    weapon = _get_npc_weapon_info(enemy)
                                    if not weapon:
                                        continue

                                    is_manual = _is_manual_action(weapon)
                                    firemode = _get_weapon_firemode(weapon)
                                    shots = 1 if is_manual else _get_shots_for_firemode(firemode, weapon)
                                    is_suppressed = _is_weapon_suppressed(weapon)

                                    enemy_name = enemy.get("name", "Enemy")
                                    target_name = target.get("name", "Friendly")

                                    caliber_folder = _get_weapon_caliber_folder(weapon)
                                    sound_dir = os.path.join("sounds", "firearms", caliber_folder)

                                    enemy_id = id(enemy)
                                    npc_shots_fired[enemy_id]= npc_shots_fired.get(enemy_id, 0)+shots
                                    mag_capacity = _get_magazine_capacity(weapon)

                                    needs_reload = npc_shots_fired[enemy_id]>=mag_capacity

                                    hits = 0
                                    total_damage = 0

                                    for shot_num in range(shots):
                                        if not target.get("alive", True):
                                            alive_friendlies =[f for f in armed_friendlies if f.get("alive", True)]
                                            if alive_friendlies:
                                                target = random.choice(alive_friendlies)
                                                target_name = target.get("name", "Friendly")
                                            else:
                                                break

                                        if random.random()<0.4:
                                            damage = random.randint(8, 25)
                                            target["health"]= target.get("health", 100)-damage
                                            hits +=1
                                            total_damage +=damage

                                            if target["health"]<=0:
                                                target["alive"]= False

                                    cyclic_delay = _get_cyclic_delay(weapon, firemode)
                                    shot_duration = shots *cyclic_delay

                                    _schedule_combat_sounds(sound_dir, weapon, firemode, shots, combat_volume, current_delay, is_suppressed)

                                    if not is_suppressed:
                                        rx, ry = room_pos.get('x', 0), room_pos.get('y', 0)
                                        _schedule_muzzle_flashes(rx, ry, shots, cyclic_delay, current_delay)

                                    log_delay = current_delay
                                    suppressed_tag = "[suppressed]"if is_suppressed else ""
                                    if hits >0:
                                        if not target.get("alive", True):
                                            dg.after(log_delay, lambda rl = room_loc, en = enemy_name, s = shots, fm = firemode, tn = target_name, st = suppressed_tag:
                                            _add_combat_log(f"{rl} {en} fired {s}x({fm}){st}, killed {tn}!"))
                                        else:
                                            dg.after(log_delay, lambda rl = room_loc, en = enemy_name, s = shots, fm = firemode, h = hits, td = total_damage, st = suppressed_tag:
                                            _add_combat_log(f"{rl} {en} fired {s}x({fm}){st}, hit {h}x for {td} dmg"))
                                    else:
                                        dg.after(log_delay, lambda rl = room_loc, en = enemy_name, s = shots, fm = firemode, st = suppressed_tag:
                                        _add_combat_log(f"{rl} {en} fired {s}x({fm}){st}, missed"))

                                    current_delay +=shot_duration +(300 if is_manual else 100)

                                    if needs_reload:
                                        dg.after(current_delay, lambda en = enemy_name, rl = room_loc:
                                        _add_combat_log(f"{rl} {en} reloading..."))
                                        current_delay +=RELOAD_TIME
                                        npc_shots_fired[enemy_id]= 0

                            current_delay +=TURN_PAUSE

                            for friendly in armed_friendlies:
                                if not friendly.get("alive", True):
                                    continue
                                if random.random()<0.6:
                                    alive_enemies =[e for e in armed_enemies if e.get("alive", True)]
                                    if not alive_enemies:
                                        break

                                    target = random.choice(alive_enemies)
                                    weapon = _get_npc_weapon_info(friendly)
                                    if not weapon:
                                        continue

                                    is_manual = _is_manual_action(weapon)
                                    firemode = _get_weapon_firemode(weapon)
                                    shots = 1 if is_manual else _get_shots_for_firemode(firemode, weapon)
                                    is_suppressed = _is_weapon_suppressed(weapon)

                                    friendly_name = friendly.get("name", "Friendly")
                                    target_name = target.get("name", "Enemy")

                                    caliber_folder = _get_weapon_caliber_folder(weapon)
                                    sound_dir = os.path.join("sounds", "firearms", caliber_folder)

                                    friendly_id = id(friendly)
                                    npc_shots_fired[friendly_id]= npc_shots_fired.get(friendly_id, 0)+shots
                                    mag_capacity = _get_magazine_capacity(weapon)

                                    needs_reload = npc_shots_fired[friendly_id]>=mag_capacity

                                    hits = 0
                                    total_damage = 0

                                    for shot_num in range(shots):
                                        if not target.get("alive", True):
                                            alive_enemies =[e for e in armed_enemies if e.get("alive", True)]
                                            if alive_enemies:
                                                target = random.choice(alive_enemies)
                                                target_name = target.get("name", "Enemy")
                                            else:
                                                break

                                        if random.random()<0.45:
                                            damage = random.randint(10, 30)
                                            target["health"]= target.get("health", 100)-damage
                                            hits +=1
                                            total_damage +=damage

                                            if target["health"]<=0:
                                                target["alive"]= False
                                                if "pending_loot"not in room:
                                                    room["pending_loot"]=[]
                                                room["pending_loot"].append(target.copy())

                                    cyclic_delay = _get_cyclic_delay(weapon, firemode)
                                    shot_duration = shots *cyclic_delay

                                    _schedule_combat_sounds(sound_dir, weapon, firemode, shots, combat_volume, current_delay, is_suppressed)

                                    if not is_suppressed:
                                        rx, ry = room_pos.get('x', 0), room_pos.get('y', 0)
                                        _schedule_muzzle_flashes(rx, ry, shots, cyclic_delay, current_delay)

                                    log_delay = current_delay
                                    suppressed_tag = "[suppressed]"if is_suppressed else ""
                                    if hits >0:
                                        if not target.get("alive", True):
                                            dg.after(log_delay, lambda rl = room_loc, fn = friendly_name, s = shots, fm = firemode, tn = target_name, st = suppressed_tag:
                                            _add_combat_log(f"{rl} {fn} fired {s}x({fm}){st}, killed {tn}!"))
                                        else:
                                            dg.after(log_delay, lambda rl = room_loc, fn = friendly_name, s = shots, fm = firemode, h = hits, td = total_damage, st = suppressed_tag:
                                            _add_combat_log(f"{rl} {fn} fired {s}x({fm}){st}, hit {h}x for {td} dmg"))
                                    else:
                                        dg.after(log_delay, lambda rl = room_loc, fn = friendly_name, s = shots, fm = firemode, st = suppressed_tag:
                                        _add_combat_log(f"{rl} {fn} fired {s}x({fm}){st}, missed"))

                                    current_delay +=shot_duration +(300 if is_manual else 100)

                                    if needs_reload:
                                        dg.after(current_delay, lambda fn = friendly_name, rl = room_loc:
                                        _add_combat_log(f"{rl} {fn} reloading..."))
                                        current_delay +=RELOAD_TIME
                                        npc_shots_fired[friendly_id]= 0

                            current_delay +=TURN_PAUSE

                    if combat_occurred:

                        dg.after(current_delay +500, _draw_grid)

                        if player_room_combat:
                            dg.after(current_delay +500, lambda:self._dg_state.update({'movement_locked':False}))

                except Exception as e:
                    logging.debug(f"Background combat error: {e}")
                finally:

                    try:
                        if dg.winfo_exists():

                            next_delay = max(3000, current_delay +2000)if combat_occurred else random.randint(3000, 5000)
                            background_combat_timer[0]= dg.after(next_delay, _process_background_combat)# type: ignore
                    except Exception:
                        pass

            def _calculate_distance(pos1, pos2):

                return abs(pos1.get("x", 0)-pos2.get("x", 0))+abs(pos1.get("y", 0)-pos2.get("y", 0))

            def _get_adjacent_rooms(room, floor):

                adjacent =[]
                room_id = room.get("room_id")
                for conn in floor.get("connections", []):
                    if conn.get("from_room")==room_id:
                        adjacent.append(conn.get("to_room"))
                    elif conn.get("to_room")==room_id:
                        adjacent.append(conn.get("from_room"))
                return adjacent

            def _find_path_bfs(start_room_id, target_room_id, floor):

                if start_room_id ==target_room_id:
                    return[start_room_id]

                from collections import deque

                adj_map = {}
                for room in floor.get("rooms", []):
                    rid = room.get("room_id")
                    adj_map[rid]= _get_adjacent_rooms(room, floor)

                queue = deque([(start_room_id, [start_room_id])])
                visited = {start_room_id}

                while queue:
                    current_id, path = queue.popleft()

                    for neighbor_id in adj_map.get(current_id, []):
                        if neighbor_id ==target_room_id:
                            return path +[neighbor_id]

                        if neighbor_id not in visited:
                            visited.add(neighbor_id)
                            queue.append((neighbor_id, path +[neighbor_id]))

                return None

            def _get_path_distance(start_room_id, target_room_id, floor):

                path = _find_path_bfs(start_room_id, target_room_id, floor)
                if path:
                    return len(path)-1
                return float('inf')

            def _get_next_room_on_path(start_room_id, target_room_id, floor):

                path = _find_path_bfs(start_room_id, target_room_id, floor)
                if path and len(path)>1:

                    next_room_id = path[1]
                    for room in floor.get("rooms", []):
                        if room.get("room_id")==next_room_id:
                            return room
                return None

            npc_movement_timer =[None]

            def _find_combat_rooms(floor):

                combat_rooms =[]
                for room in floor.get("rooms", []):
                    enemies =[e for e in room.get("enemies", [])if e.get("alive", True)]
                    friendlies =[f for f in room.get("friendlies", [])if f.get("alive", True)]
                    if enemies and friendlies:
                        combat_rooms.append(room)
                return combat_rooms

            def _move_npc_towards(npc, npc_list, room, target_room_id, floor, npc_type = "enemies"):

                room_id = room.get("room_id")

                if room_id ==target_room_id:
                    return None

                next_room = _get_next_room_on_path(room_id, target_room_id, floor)

                if next_room:
                    npc_list.remove(npc)
                    next_room.setdefault(npc_type, []).append(npc)
                    return next_room
                return None

            def _move_npcs_support():

                try:
                    dungeon = self._dg_state.get('generated_dungeon')
                    if not dungeon:
                        return

                    floor_idx = self._dg_state.get('current_floor', 0)
                    if floor_idx >=len(dungeon["floors"]):
                        return

                    floor = dungeon["floors"][floor_idx]
                    player_room_id = self._dg_state.get('current_room_id')

                    player_room = None
                    for r in floor["rooms"]:
                        if r.get("room_id")==player_room_id:
                            player_room = r
                            break

                    combat_rooms = _find_combat_rooms(floor)

                    npcs_moved = False
                    backup_arrived =[]
                    enemies_arrived =[]

                    for room in floor["rooms"]:
                        room_pos = room.get("position", {})
                        room_id = room.get("room_id")

                        if room in combat_rooms:
                            continue

                        adjacent_room_ids = _get_adjacent_rooms(room, floor)
                        if not adjacent_room_ids:
                            continue

                        for enemy in list(room.get("enemies", [])):
                            if not enemy.get("alive", True):
                                continue

                            enemy_name = enemy.get("name", "Unknown")
                            enemy_health = enemy.get("health", 100)

                            nearest_combat = None
                            nearest_dist = float('inf')
                            for combat_room in combat_rooms:
                                combat_room_id = combat_room.get("room_id")
                                dist = _get_path_distance(room_id, combat_room_id, floor)
                                if dist <=10 and dist <nearest_dist:
                                    nearest_dist = dist
                                    nearest_combat = combat_room

                            if nearest_combat:
                                combat_room_id = nearest_combat.get("room_id")
                                dest_room = _move_npc_towards(enemy, room["enemies"], room, combat_room_id, floor, "enemies")
                                if dest_room:
                                    npcs_moved = True

                                    if dest_room.get("room_id")==player_room_id:
                                        enemies_arrived.append({
                                        "name":enemy_name,
                                        "health":enemy_health,
                                        "reason":"combat support"
                                        })

                            elif room_id !=player_room_id and player_room:
                                dist_to_player = _get_path_distance(room_id, player_room_id, floor)
                                if dist_to_player <=10 and random.random()<0.4:
                                    dest_room = _move_npc_towards(enemy, room["enemies"], room, player_room_id, floor, "enemies")
                                    if dest_room:
                                        npcs_moved = True

                                        if dest_room.get("room_id")==player_room_id:
                                            enemies_arrived.append({
                                            "name":enemy_name,
                                            "health":enemy_health,
                                            "reason":"hunting"
                                            })

                        for friendly in list(room.get("friendlies", [])):
                            if not friendly.get("alive", True):
                                continue

                            friendly_name = friendly.get("name", "Unknown")
                            friendly_health = friendly.get("health", 100)

                            nearest_combat = None
                            nearest_dist = float('inf')
                            for combat_room in combat_rooms:
                                combat_room_id = combat_room.get("room_id")
                                dist = _get_path_distance(room_id, combat_room_id, floor)
                                if dist <=10 and dist <nearest_dist:
                                    nearest_dist = dist
                                    nearest_combat = combat_room

                            if nearest_combat:
                                combat_room_id = nearest_combat.get("room_id")
                                dest_room = _move_npc_towards(friendly, room["friendlies"], room, combat_room_id, floor, "friendlies")
                                if dest_room:
                                    npcs_moved = True

                                    if dest_room.get("room_id")==player_room_id:
                                        backup_arrived.append({
                                        "name":friendly_name,
                                        "health":friendly_health,
                                        "reason":"combat support"
                                        })

                            elif room_id !=player_room_id and player_room:
                                dist_to_player = _get_path_distance(room_id, player_room_id, floor)
                                if dist_to_player <=10 and random.random()<0.5:
                                    dest_room = _move_npc_towards(friendly, room["friendlies"], room, player_room_id, floor, "friendlies")
                                    if dest_room:
                                        npcs_moved = True

                                        if dest_room.get("room_id")==player_room_id:
                                            backup_arrived.append({
                                            "name":friendly_name,
                                            "health":friendly_health,
                                            "reason":"patrol"
                                            })

                    if backup_arrived:
                        names =[f"{b['name']}({b['health']}HP)"for b in backup_arrived]
                        title = "ðŸ›¡ï¸ Backup Arrived!"
                        if len(backup_arrived)==1:
                            b = backup_arrived[0]
                            message = f"{b['name']} has arrived at your position!\nHealth: {b['health']}HP\nReason: {b['reason'].title()}"
                        else:
                            message = f"{len(backup_arrived)} friendlies have arrived!\n"+"\n".join(names)

                        try:
                            send_windows_notification(title, message)
                        except Exception:
                            pass

                        _add_combat_log(f"âš” BACKUP: {', '.join(names)} arrived!")

                    if enemies_arrived:
                        names =[f"{e['name']}({e['health']}HP)"for e in enemies_arrived]
                        title = "âš ï¸ Enemy Reinforcements!"
                        if len(enemies_arrived)==1:
                            e = enemies_arrived[0]
                            message = f"{e['name']} has found your position!\nHealth: {e['health']}HP\nReason: {e['reason'].title()}"
                        else:
                            message = f"{len(enemies_arrived)} enemies have arrived!\n"+"\n".join(names)

                        try:
                            send_windows_notification(title, message)
                        except Exception:
                            pass

                        _add_combat_log(f"âš  ENEMIES: {', '.join(names)} arrived!")

                    if npcs_moved:
                        _draw_grid()

                except Exception as e:
                    logging.debug(f"NPC support movement error: {e}")
                finally:

                    try:
                        if dg.winfo_exists():
                            npc_movement_timer[0]= dg.after(10000, _move_npcs_support)# type: ignore
                    except Exception:
                        pass

            def _move_npcs_once():

                try:
                    dungeon = self._dg_state.get('generated_dungeon')
                    if not dungeon:
                        return

                    floor_idx = self._dg_state.get('current_floor', 0)
                    if floor_idx >=len(dungeon["floors"]):
                        return

                    floor = dungeon["floors"][floor_idx]
                    player_room_id = self._dg_state.get('current_room_id')
                    player_room = None

                    for room in floor["rooms"]:
                        if room.get("room_id")==player_room_id:
                            player_room = room
                            break

                    for room in floor["rooms"]:
                        room_id = room.get("room_id")
                        distance_to_player = _get_path_distance(room_id, player_room_id, floor)if player_room else float('inf')

                        has_enemies = any(e.get("alive", True)for e in room.get("enemies", []))

                        adjacent_room_ids = _get_adjacent_rooms(room, floor)
                        if not adjacent_room_ids:
                            continue

                        for enemy in list(room.get("enemies", [])):
                            if not enemy.get("alive", True):
                                continue

                            if random.random()>0.6:
                                continue

                            if distance_to_player <=5:

                                next_room = _get_next_room_on_path(room_id, player_room_id, floor)
                                if next_room:
                                    room["enemies"].remove(enemy)
                                    next_room.setdefault("enemies", []).append(enemy)
                            else:

                                target_room_id = random.choice(adjacent_room_ids)
                                for r in floor["rooms"]:
                                    if r.get("room_id")==target_room_id:
                                        room["enemies"].remove(enemy)
                                        r.setdefault("enemies", []).append(enemy)
                                        break

                        if not has_enemies:
                            for friendly in list(room.get("friendlies", [])):
                                if not friendly.get("alive", True):
                                    continue

                                if random.random()>0.4:
                                    continue

                                nearest_enemy_room = None
                                nearest_enemy_dist = float('inf')
                                for other_room in floor["rooms"]:
                                    other_room_id = other_room.get("room_id")
                                    dist_to_room = _get_path_distance(room_id, other_room_id, floor)
                                    if dist_to_room <=5:
                                        alive_enemies =[e for e in other_room.get("enemies", [])if e.get("alive", True)]
                                        if alive_enemies and dist_to_room <nearest_enemy_dist:
                                            nearest_enemy_dist = dist_to_room
                                            nearest_enemy_room = other_room

                                if nearest_enemy_room and nearest_enemy_dist >0:

                                    enemy_room_id = nearest_enemy_room.get("room_id")
                                    next_room = _get_next_room_on_path(room_id, enemy_room_id, floor)
                                    if next_room:
                                        room["friendlies"].remove(friendly)
                                        next_room.setdefault("friendlies", []).append(friendly)
                                elif player_room and distance_to_player >0:

                                    next_room = _get_next_room_on_path(room_id, player_room_id, floor)
                                    if next_room:
                                        room["friendlies"].remove(friendly)
                                        next_room.setdefault("friendlies", []).append(friendly)

                except Exception as e:
                    logging.debug(f"NPC movement error: {e}")

            def _kill_enemies_in_room():

                try:
                    room = _get_current_room()
                    if not room:
                        return

                    enemies = room.get("enemies", [])
                    killed_count = 0

                    for enemy in enemies:
                        if enemy.get("alive", True):
                            enemy["alive"]= False
                            killed_count +=1

                            if "pending_loot"not in room:
                                room["pending_loot"]=[]
                            room["pending_loot"].append(enemy.copy())

                    room["enemies_cleared"]= True

                    self._dg_state['movement_locked']= False

                    if killed_count >0:
                        self._popup_show_info("Combat", f"Defeated {killed_count} enemy(s)! Loot is now available.")

                    _update_display()
                    _draw_grid()

                except Exception as e:
                    logging.exception("Failed to kill enemies")

            def _collect_loot_from_room():

                try:
                    room = _get_current_room()
                    if not room:
                        return

                    pending_loot = room.get("pending_loot", [])
                    if not pending_loot:
                        self._popup_show_info("Loot", "No loot to collect.")
                        return

                    table_data = None
                    try:
                        tbl_path = get_current_table_path()
                        if tbl_path and os.path.exists(tbl_path):
                            with open(tbl_path, 'r')as f:
                                full_table = json.load(f)

                                table_data = {
                                "rarity_weights":full_table.get("rarity_weights", {}),
                                "tables":full_table.get("tables", {})
                                }
                    except Exception as e:
                        logging.error(f"Failed to load table data: {e}")

                    files_generated =[]

                    for enemy in pending_loot:
                        enemy_name = enemy.get("name", "Unknown Enemy")

                        if table_data:

                            loot_items = self._generate_enemy_loot(enemy, table_data)
                            if loot_items:

                                self._save_enemy_loot_transfer_silent(enemy_name, loot_items)
                                files_generated.append(f"enemyloot_{enemy_name.replace(' ', '_').lower()}")
                        else:

                            self._save_enemy_loot_transfer_silent(enemy_name, enemy.get("items", []))
                            files_generated.append(f"enemyloot_{enemy_name.replace(' ', '_').lower()}")

                    loot_spawn = room.get("loot_spawn", [])
                    if loot_spawn and table_data:
                        lootcrates_table = table_data.get("lootcrates", [])
                        for spawn in loot_spawn:
                            spawn_type = spawn.get("type", "lootcrate")
                            spawn_id = spawn.get("id", 0)
                            to_spawn = spawn.get("to_spawn", {"min":1, "max":1})
                            spawn_count = random.randint(to_spawn.get("min", 1), to_spawn.get("max", 1))

                            for _ in range(spawn_count):

                                lootcrate_def = None
                                for lc in lootcrates_table:
                                    if lc.get("id_lct")==spawn_id:
                                        lootcrate_def = lc
                                        break

                                if lootcrate_def:

                                    crate_items = self._generate_lootcrate_contents(lootcrate_def, table_data)
                                    if crate_items:
                                        crate_name = lootcrate_def.get("name", "Lootcrate")
                                        self._save_lootcrate_transfer_silent(crate_name, crate_items)
                                        files_generated.append(f"lootcrate_{crate_name.replace(' ', '_').lower()}")

                        room["loot_spawn"]=[]

                    room["pending_loot"]=[]

                    if files_generated:
                        self._popup_show_info("Loot Generated", f"Generated {len(files_generated)} loot file(s):\n"+"\n".join(files_generated[:10])+("\n..."if len(files_generated)>10 else ""))
                    else:
                        self._popup_show_info("Loot", "No loot items were generated.")

                    _update_display()
                    _draw_grid()

                except Exception as e:
                    logging.exception("Failed to collect loot")
                    logging.exception("Failed to collect loot")

            def _generate_dungeon():

                try:
                    rooms_table = _load_rooms_table()
                    enemies_table = _load_enemies_table()
                    if not rooms_table:
                        self._popup_show_info("Error", "No rooms table found.", sound = "error")
                        return

                    floors_config = self._dg_state.get('floors', [])
                    num_floors = len(floors_config)
                    if num_floors ==0:
                        self._popup_show_info("Error", "No floors configured.", sound = "error")
                        return

                    diff_map = {0:"None/Friendly", 1:"Easy", 2:"Medium", 3:"Hard", 4:"Miniboss"}
                    diff_order =["None/Friendly", "Friendly", "Easy", "Medium", "Hard", "Miniboss"]
                    opposite_dir = {"top":"bottom", "bottom":"top", "left":"right", "right":"left"}
                    dir_offset = {"top":(0, -1), "bottom":(0, 1), "left":(-1, 0), "right":(1, 0)}

                    dungeon = {"floors":[], "metadata":{"generated_at":datetime.now().isoformat()}}

                    for floor_idx, floor_cfg in enumerate(floors_config):

                        try:
                            enemy_count = floor_cfg.get('enemy_count')
                            enemy_count = enemy_count.get()if hasattr(enemy_count, 'get')else(enemy_count or 10)
                            max_diff_idx = floor_cfg.get('difficulty')
                            max_diff_idx = max_diff_idx.get()if hasattr(max_diff_idx, 'get')else(max_diff_idx or 4)
                            x_size = floor_cfg.get('x_size')
                            x_size = x_size.get()if hasattr(x_size, 'get')else(x_size or 20)
                            y_size = floor_cfg.get('y_size')
                            y_size = y_size.get()if hasattr(y_size, 'get')else(y_size or 20)
                            transport_type = floor_cfg.get('transport')
                            transport_type = transport_type.get()if hasattr(transport_type, 'get')else transport_type
                        except Exception:
                            enemy_count, max_diff_idx, x_size, y_size, transport_type = 10, 4, 20, 20, None

                        max_diff = diff_map.get(max_diff_idx, "Miniboss")

                        entrance_rooms =[r for r in rooms_table if r.get("type")=="entrance"]
                        hallway_rooms =[r for r in rooms_table if r.get("type")=="hallway"]
                        regular_rooms =[r for r in rooms_table if r.get("type")=="room"]
                        transport_rooms =[r for r in rooms_table if r.get("type")=="transport"and r.get("subtype", "").lower()==(transport_type or "stairs").lower()]

                        if not transport_rooms:
                            transport_rooms =[r for r in rooms_table if r.get("type")=="transport"]
                            logging.warning(f"No transport rooms found for subtype '{transport_type or 'stairs'}', using all transports: {len(transport_rooms)} found")

                        logging.info(f"Loaded rooms: {len(entrance_rooms)} entrances, {len(hallway_rooms)} hallways, {len(regular_rooms)} rooms, {len(transport_rooms)} transports(subtype: {transport_type or 'stairs'})")

                        max_diff_order = diff_order.index(max_diff)if max_diff in diff_order else len(diff_order)
                        eligible_enemies =[e for e in enemies_table if diff_order.index(e.get("difficulty", "Medium"))<=max_diff_order if e.get("difficulty", "Medium")in diff_order]

                        floor_data = {
                        "floor_number":floor_idx +1,
                        "x_size":x_size,
                        "y_size":y_size,
                        "rooms":[],
                        "connections":[],
                        "enemies_remaining":enemy_count,
                        "transport_type":transport_type or "stairs"
                        }

                        grid =[[None for _ in range(x_size)]for _ in range(y_size)]

                        open_attachments =[]
                        room_id = 0
                        enemies_to_place = enemy_count

                        def _get_room_attachments(room):

                            return[ap.get("attachment_point")for ap in room.get("attachment_points", [])]

                        def _rotate_direction(direction, times = 1):

                            rotation_order =["top", "right", "bottom", "left"]
                            if direction not in rotation_order:
                                return direction
                            idx = rotation_order.index(direction)
                            return rotation_order[(idx +times)%4]

                        def _rotate_room_template(template, times = 1):

                            import copy
                            if times ==0:
                                return template.copy()
                            rotated = copy.deepcopy(template)

                            if "attachment_points"in rotated:
                                for ap in rotated["attachment_points"]:
                                    if "attachment_point"in ap:
                                        ap["attachment_point"]= _rotate_direction(ap["attachment_point"], times)

                            if "doors"in rotated:
                                for door in rotated["doors"]:
                                    if "position"in door:
                                        door["position"]= _rotate_direction(door["position"], times)
                            return rotated

                        def _check_room_fits(template, x, y, needed_attachment):

                            attachments = _get_room_attachments(template)
                            for att in attachments:
                                if att ==needed_attachment:
                                    continue
                                dx, dy = dir_offset[att]
                                nx, ny = x +dx, y +dy

                                if nx <0 or nx >=x_size or ny <0 or ny >=y_size:
                                    return False
                            return True

                        def _has_unconnected_adjacency(template, x, y, needed_attachment):

                            attachments = _get_room_attachments(template)

                            for direction in["top", "bottom", "left", "right"]:
                                dx, dy = dir_offset[direction]
                                nx, ny = x +dx, y +dy
                                if 0 <=nx <x_size and 0 <=ny <y_size:
                                    if grid[ny][nx]is not None:

                                        if direction not in attachments and direction !=opposite_dir.get(needed_attachment):
                                            return True
                            return False

                        def _find_fitting_room(needed_attachment, room_pool, target_x, target_y, allow_rotation = True):

                            candidates =[r for r in room_pool if needed_attachment in _get_room_attachments(r)]

                            if not candidates:

                                if allow_rotation:
                                    for original in room_pool:
                                        for rot in range(1, 4):
                                            rotated = _rotate_room_template(original, rot)
                                            if needed_attachment in _get_room_attachments(rotated):
                                                if _check_room_fits(rotated, target_x, target_y, needed_attachment):

                                                    if not _has_unconnected_adjacency(rotated, target_x, target_y, needed_attachment):
                                                        return rotated

                                    for original in room_pool:
                                        for rot in range(1, 4):
                                            rotated = _rotate_room_template(original, rot)
                                            if needed_attachment in _get_room_attachments(rotated):
                                                if _check_room_fits(rotated, target_x, target_y, needed_attachment):
                                                    return rotated
                                return None

                            random.shuffle(candidates)
                            good_candidates =[]
                            fallback_candidates =[]
                            for candidate in candidates:
                                if _check_room_fits(candidate, target_x, target_y, needed_attachment):
                                    if not _has_unconnected_adjacency(candidate, target_x, target_y, needed_attachment):
                                        good_candidates.append(candidate)
                                    else:
                                        fallback_candidates.append(candidate)

                            if good_candidates:
                                return random.choice(good_candidates)
                            if fallback_candidates:
                                return random.choice(fallback_candidates)

                            if allow_rotation:
                                for original in room_pool:
                                    original_atts = _get_room_attachments(original)

                                    for rot in range(1, 4):
                                        rotated = _rotate_room_template(original, rot)
                                        rotated_atts = _get_room_attachments(rotated)
                                        if needed_attachment in rotated_atts:
                                            if _check_room_fits(rotated, target_x, target_y, needed_attachment):
                                                if not _has_unconnected_adjacency(rotated, target_x, target_y, needed_attachment):
                                                    return rotated

                                for original in room_pool:
                                    for rot in range(1, 4):
                                        rotated = _rotate_room_template(original, rot)
                                        if needed_attachment in _get_room_attachments(rotated):
                                            if _check_room_fits(rotated, target_x, target_y, needed_attachment):
                                                return rotated

                            for candidate in candidates:
                                return candidate

                            return None

                        def _find_fitting_room_weighted(needed_attachment, room_pool, target_x, target_y, prefer_complex = True, allow_rotation = True):

                            candidates =[r for r in room_pool if needed_attachment in _get_room_attachments(r)]

                            rotated_candidates =[]
                            if allow_rotation:
                                for original in room_pool:
                                    for rot in range(1, 4):
                                        rotated = _rotate_room_template(original, rot)
                                        if needed_attachment in _get_room_attachments(rotated):
                                            if _check_room_fits(rotated, target_x, target_y, needed_attachment):
                                                rotated_candidates.append(rotated)

                            fitting_direct =[c for c in candidates if _check_room_fits(c, target_x, target_y, needed_attachment)]
                            all_fitting = fitting_direct +rotated_candidates

                            if not all_fitting:

                                return _find_fitting_room(needed_attachment, room_pool, target_x, target_y, allow_rotation)

                            good_rooms =[r for r in all_fitting if not _has_unconnected_adjacency(r, target_x, target_y, needed_attachment)]
                            fallback_rooms =[r for r in all_fitting if _has_unconnected_adjacency(r, target_x, target_y, needed_attachment)]

                            rooms_to_use = good_rooms if good_rooms else fallback_rooms

                            if not prefer_complex:
                                return random.choice(rooms_to_use)if rooms_to_use else random.choice(all_fitting)

                            weighted =[]
                            for r in rooms_to_use:
                                att_count = len(_get_room_attachments(r))

                                weight = att_count *att_count
                                if att_count >=3:
                                    weight *=2
                                weighted.extend([r]*weight)

                            return random.choice(weighted)if weighted else random.choice(all_fitting)

                        def _prepare_room(template, rid, x, y):

                            import copy
                            room = copy.deepcopy(template)
                            room["room_id"]= rid
                            room["position"]= {"x":x, "y":y}
                            room["doors_state"]= {}
                            for door in room.get("doors", []):
                                is_locked = door.get("locked", "random")
                                if is_locked =="random":
                                    is_locked = random.choice([True, False])
                                room["doors_state"][door.get("position", "unknown")]= {"locked":is_locked, "picked":False}
                            room["enemies"]=[]
                            room["friendlies"]=[]
                            room["visited"]= False
                            room["enemies_cleared"]= False
                            return room

                        def _spawn_enemies(room):

                            nonlocal enemies_to_place
                            if room.get("enemy_spawn_possible", False)and eligible_enemies:

                                hostile_npcs =[e for e in eligible_enemies if e.get("difficulty")not in("Friendly", "None/Friendly")]
                                friendly_npcs =[e for e in eligible_enemies if e.get("difficulty")in("Friendly", "None/Friendly")]

                                if enemies_to_place >0 and hostile_npcs and random.random()<0.4:

                                    spawn_count = random.randint(1, min(2, enemies_to_place))
                                    for _ in range(spawn_count):
                                        enemy = random.choice(hostile_npcs).copy()
                                        enemy["alive"]= True
                                        room["enemies"].append(enemy)
                                        enemies_to_place -=1

                                if friendly_npcs:
                                    if random.random()<0.15:
                                        if random.random()<0.5:

                                            friendly_count = random.randint(1, 2)
                                            for _ in range(friendly_count):
                                                friendly = random.choice(friendly_npcs).copy()
                                                friendly["alive"]= True
                                                friendly["health"]= 100
                                                room["friendlies"].append(friendly)

                        def _place_room(room, x, y):

                            grid[y][x]= room["room_id"]
                            floor_data["rooms"].append(room)

                            for direction in _get_room_attachments(room):
                                dx, dy = dir_offset[direction]
                                nx, ny = x +dx, y +dy
                                if 0 <=nx <x_size and 0 <=ny <y_size:
                                    if grid[ny][nx]is None:
                                        open_attachments.append((room["room_id"], direction, nx, ny))

                        def _find_room_with_attachment(needed_direction, room_pool):

                            candidates =[r for r in room_pool if needed_direction in _get_room_attachments(r)]
                            return random.choice(candidates)if candidates else None

                        def _connect_rooms(from_room_id, to_room_id, direction):

                            conn = {"from_room":from_room_id, "to_room":to_room_id, "direction":direction}
                            rev_conn = {"from_room":to_room_id, "to_room":from_room_id, "direction":opposite_dir[direction]}
                            if conn not in floor_data["connections"]and rev_conn not in floor_data["connections"]:
                                floor_data["connections"].append(conn)

                                from_room = None
                                to_room = None
                                for room in floor_data["rooms"]:
                                    if room.get("room_id")==from_room_id:
                                        from_room = room
                                    if room.get("room_id")==to_room_id:
                                        to_room = room

                                if from_room and to_room:
                                    opp_direction = opposite_dir[direction]
                                    from_door = from_room.get("doors_state", {}).get(direction, {})
                                    to_door = to_room.get("doors_state", {}).get(opp_direction, {})

                                    is_locked = from_door.get("locked", False)and to_door.get("locked", False)
                                    is_picked = from_door.get("picked", False)or to_door.get("picked", False)

                                    if direction in from_room.get("doors_state", {}):
                                        from_room["doors_state"][direction]= {"locked":is_locked, "picked":is_picked}
                                    if opp_direction in to_room.get("doors_state", {}):
                                        to_room["doors_state"][opp_direction]= {"locked":is_locked, "picked":is_picked}

                        transport_mode_var = self._dg_state.get('transport_mode')
                        transport_mode = transport_mode_var.get()if hasattr(transport_mode_var, 'get')else 'Multiple'
                        is_multi_entrance = transport_mode =='Multiple'

                        is_top_floor = floor_idx ==0
                        is_bottom_floor = floor_idx ==num_floors -1
                        is_middle_floor = not is_top_floor and not is_bottom_floor

                        start_x = random.randint(1, x_size -2)
                        start_y = random.randint(1, y_size -2)

                        if is_top_floor and entrance_rooms:

                            entrance_template = random.choice(entrance_rooms)
                            rotation = random.randint(0, 3)
                            rotated_entrance = _rotate_room_template(entrance_template, rotation)
                            entrance = _prepare_room(rotated_entrance, room_id, start_x, start_y)
                            _place_room(entrance, start_x, start_y)
                            room_id +=1
                        elif transport_rooms:

                            entry_transport_template = random.choice(transport_rooms)
                            rotation = random.randint(0, 3)
                            rotated_transport = _rotate_room_template(entry_transport_template, rotation)
                            entry_transport = _prepare_room(rotated_transport, room_id, start_x, start_y)
                            entry_transport["leads_to_floor"]= floor_idx
                            entry_transport["is_entry_transport"]= True
                            _place_room(entry_transport, start_x, start_y)
                            room_id +=1

                            if is_middle_floor and not is_multi_entrance:
                                entry_transport["leads_to_floor"]= floor_idx
                                entry_transport["also_leads_to_floor"]= floor_idx +2
                        else:

                            if hallway_rooms:
                                entry_hallway = _find_fitting_room("bottom", hallway_rooms, start_x, start_y)
                                if entry_hallway:
                                    hallway = _prepare_room(entry_hallway, room_id, start_x, start_y)
                                    _spawn_enemies(hallway)
                                    _place_room(hallway, start_x, start_y)
                                    room_id +=1

                        target_rooms = max(15, (x_size *y_size)//6)

                        need_transport_down = False
                        if is_top_floor and not is_bottom_floor:
                            need_transport_down = True
                        elif is_middle_floor and is_multi_entrance:
                            need_transport_down = True

                        logging.info(f"Floor {floor_idx +1}: is_top={is_top_floor}, is_bottom={is_bottom_floor}, is_middle={is_middle_floor}, need_transport_down={need_transport_down}, transport_rooms={len(transport_rooms)}")

                        need_transport = need_transport_down
                        max_iterations = target_rooms *20
                        iterations = 0

                        def _score_room_complexity(room_template):

                            attachments = _get_room_attachments(room_template)
                            return len(attachments)

                        def _weighted_room_select(room_list, prefer_complex = True):

                            if not room_list:
                                return None
                            if not prefer_complex:
                                return random.choice(room_list)

                            weighted =[]
                            for r in room_list:
                                score = _score_room_complexity(r)

                                weight = score *score
                                weighted.extend([r]*weight)
                            return random.choice(weighted)if weighted else random.choice(room_list)

                        def _calculate_sprawl_score(x, y, placed_rooms):

                            if not placed_rooms:
                                return 1

                            avg_x = sum(r["position"]["x"]for r in placed_rooms)/len(placed_rooms)
                            avg_y = sum(r["position"]["y"]for r in placed_rooms)/len(placed_rooms)
                            dist_from_center = abs(x -avg_x)+abs(y -avg_y)

                            edge_bonus = min(x, y, x_size -1 -x, y_size -1 -y)
                            edge_score = max(0, 3 -edge_bonus)
                            return dist_from_center +edge_score

                        def _select_sprawling_attachment(attachments, placed_rooms):

                            if not attachments:
                                return None

                            scored =[]
                            for att in attachments:
                                _, _, x, y = att
                                score = _calculate_sprawl_score(x, y, placed_rooms)
                                scored.append((att, score))

                            scored.sort(key = lambda x:x[1], reverse = True)

                            top_half = scored[:max(1, len(scored)//2)]
                            weights =[i +1 for i in range(len(top_half), 0, -1)]
                            weighted_list =[]
                            for(att, _), w in zip(top_half, weights):
                                weighted_list.extend([att]*w)
                            return random.choice(weighted_list)if weighted_list else attachments[0]

                        while len(floor_data["rooms"])<target_rooms and open_attachments and iterations <max_iterations:
                            iterations +=1

                            selected = _select_sprawling_attachment(open_attachments, floor_data["rooms"])
                            if not selected:
                                break
                            open_attachments.remove(selected)
                            from_room_id, from_direction, target_x, target_y = selected

                            if grid[target_y][target_x]is not None:

                                existing_room_id = grid[target_y][target_x]
                                for room in floor_data["rooms"]:
                                    if room["room_id"]==existing_room_id:
                                        if opposite_dir[from_direction]in _get_room_attachments(room):
                                            _connect_rooms(from_room_id, existing_room_id, from_direction)
                                        break
                                continue

                            needed_attachment = opposite_dir[from_direction]

                            progress = len(floor_data["rooms"])/target_rooms

                            room_pool =[]
                            roll = random.random()

                            straight_hallways =[h for h in hallway_rooms if len(_get_room_attachments(h))==2
                            and set(_get_room_attachments(h))in[{"top", "bottom"}, {"left", "right"}]]
                            branching_hallways =[h for h in hallway_rooms if len(_get_room_attachments(h))>=3]
                            corner_hallways =[h for h in hallway_rooms if len(_get_room_attachments(h))==2
                            and set(_get_room_attachments(h))not in[{"top", "bottom"}, {"left", "right"}]]

                            if progress <0.4:
                                if roll <0.5 and straight_hallways:
                                    room_pool = straight_hallways
                                elif roll <0.75 and corner_hallways:
                                    room_pool = corner_hallways
                                elif roll <0.9 and branching_hallways:
                                    room_pool = branching_hallways
                                elif hallway_rooms:
                                    room_pool = hallway_rooms

                            elif progress <0.7:
                                if roll <0.35 and branching_hallways:
                                    room_pool = branching_hallways
                                elif roll <0.6 and corner_hallways:
                                    room_pool = corner_hallways
                                elif roll <0.8 and straight_hallways:
                                    room_pool = straight_hallways
                                elif hallway_rooms:
                                    room_pool = hallway_rooms

                            elif progress <0.85:
                                if roll <0.5 and hallway_rooms:
                                    room_pool = hallway_rooms
                                elif regular_rooms:
                                    room_pool = regular_rooms

                            else:
                                if roll <0.3 and hallway_rooms:
                                    room_pool = hallway_rooms
                                elif regular_rooms:
                                    room_pool = regular_rooms

                            if not room_pool:
                                room_pool = hallway_rooms +regular_rooms

                            prefer_complex = progress <0.7
                            new_template = _find_fitting_room_weighted(needed_attachment, room_pool, target_x, target_y, prefer_complex)
                            if not new_template:
                                continue

                            new_room = _prepare_room(new_template, room_id, target_x, target_y)
                            _spawn_enemies(new_room)
                            _place_room(new_room, target_x, target_y)
                            _connect_rooms(from_room_id, room_id, from_direction)
                            room_id +=1

                        transport_placed_early = False
                        if need_transport and transport_rooms and open_attachments:
                            logging.info(f"Floor {floor_idx +1}: Attempting early transport placement, {len(open_attachments)} open attachments")

                            for i, (from_room_id, from_direction, target_x, target_y)in enumerate(list(open_attachments)):
                                if grid[target_y][target_x]is not None:
                                    continue
                                needed_attachment = opposite_dir[from_direction]
                                transport_template = _find_fitting_room(needed_attachment, transport_rooms, target_x, target_y)
                                if transport_template:
                                    transport = _prepare_room(transport_template, room_id, target_x, target_y)
                                    transport["leads_to_floor"]= floor_idx +2
                                    transport["is_exit_transport"]= True
                                    _place_room(transport, target_x, target_y)
                                    _connect_rooms(from_room_id, room_id, from_direction)
                                    open_attachments.pop(i)
                                    room_id +=1
                                    transport_placed_early = True
                                    logging.info(f"Placed exit transport(early) on floor {floor_idx +1} at({target_x}, {target_y})")
                                    break

                        fill_iterations = 0
                        max_fill = len(open_attachments)*2
                        while open_attachments and fill_iterations <max_fill:
                            fill_iterations +=1
                            from_room_id, from_direction, target_x, target_y = open_attachments.pop(0)

                            if grid[target_y][target_x]is not None:

                                existing_room_id = grid[target_y][target_x]
                                for room in floor_data["rooms"]:
                                    if room["room_id"]==existing_room_id:
                                        if opposite_dir[from_direction]in _get_room_attachments(room):
                                            _connect_rooms(from_room_id, existing_room_id, from_direction)
                                        break
                                continue

                            needed_attachment = opposite_dir[from_direction]

                            single_att_rooms =[r for r in regular_rooms if len(_get_room_attachments(r))==1]
                            terminal_template = _find_fitting_room(needed_attachment, single_att_rooms, target_x, target_y)

                            if not terminal_template:
                                terminal_template = _find_fitting_room(needed_attachment, regular_rooms +hallway_rooms, target_x, target_y)

                            if terminal_template:
                                new_room = _prepare_room(terminal_template, room_id, target_x, target_y)
                                _spawn_enemies(new_room)
                                _place_room(new_room, target_x, target_y)
                                _connect_rooms(from_room_id, room_id, from_direction)
                                room_id +=1

                        if need_transport and transport_rooms and not transport_placed_early:
                            placed_transport = False

                            for i, (from_room_id, from_direction, target_x, target_y)in enumerate(list(open_attachments)):
                                if grid[target_y][target_x]is not None:
                                    continue
                                needed_attachment = opposite_dir[from_direction]

                                transport_template = _find_fitting_room(needed_attachment, transport_rooms, target_x, target_y)
                                if transport_template:
                                    transport = _prepare_room(transport_template, room_id, target_x, target_y)
                                    transport["leads_to_floor"]= floor_idx +2
                                    transport["is_exit_transport"]= True
                                    _place_room(transport, target_x, target_y)
                                    _connect_rooms(from_room_id, room_id, from_direction)
                                    open_attachments.pop(i)
                                    room_id +=1
                                    placed_transport = True
                                    logging.info(f"Placed exit transport on floor {floor_idx +1} at({target_x}, {target_y})")
                                    break

                            if not placed_transport:

                                for room in floor_data["rooms"]:
                                    if placed_transport:
                                        break
                                    if room.get("type")=="transport":
                                        continue
                                    rx, ry = room["position"]["x"], room["position"]["y"]
                                    for att in _get_room_attachments(room):
                                        dx, dy = dir_offset[att]
                                        nx, ny = rx +dx, ry +dy
                                        if 0 <=nx <x_size and 0 <=ny <y_size and grid[ny][nx]is None:
                                            needed_attachment = opposite_dir[att]
                                            transport_template = _find_fitting_room(needed_attachment, transport_rooms, nx, ny)
                                            if transport_template:
                                                transport = _prepare_room(transport_template, room_id, nx, ny)
                                                transport["leads_to_floor"]= floor_idx +2
                                                transport["is_exit_transport"]= True
                                                _place_room(transport, nx, ny)
                                                _connect_rooms(room["room_id"], room_id, att)
                                                room_id +=1
                                                placed_transport = True
                                                logging.info(f"Placed exit transport on floor {floor_idx +1} at({nx}, {ny}) via room search")
                                                break

                        final_pass = 0
                        max_final = 100
                        while open_attachments and final_pass <max_final:
                            final_pass +=1
                            from_room_id, from_direction, target_x, target_y = open_attachments.pop(0)

                            if grid[target_y][target_x]is not None:
                                existing_room_id = grid[target_y][target_x]
                                for room in floor_data["rooms"]:
                                    if room["room_id"]==existing_room_id:
                                        if opposite_dir[from_direction]in _get_room_attachments(room):
                                            _connect_rooms(from_room_id, existing_room_id, from_direction)
                                        break
                                continue

                            needed_attachment = opposite_dir[from_direction]

                            single_att_rooms =[r for r in regular_rooms if len(_get_room_attachments(r))==1]
                            template = _find_fitting_room(needed_attachment, single_att_rooms, target_x, target_y)

                            if not template:
                                template = _find_fitting_room(needed_attachment, regular_rooms +hallway_rooms, target_x, target_y)

                            if not template:
                                continue

                            new_room = _prepare_room(template, room_id, target_x, target_y)
                            _spawn_enemies(new_room)
                            grid[target_y][target_x]= room_id
                            floor_data["rooms"].append(new_room)
                            _connect_rooms(from_room_id, room_id, from_direction)

                            for att in _get_room_attachments(new_room):
                                if att ==needed_attachment:
                                    continue
                                dx, dy = dir_offset[att]
                                nx, ny = target_x +dx, target_y +dy
                                if 0 <=nx <x_size and 0 <=ny <y_size and grid[ny][nx]is None:
                                    open_attachments.append((room_id, att, nx, ny))

                            room_id +=1

                        has_exit_transport = any(r.get("is_exit_transport")for r in floor_data["rooms"])

                        if need_transport_down and not has_exit_transport and transport_rooms:

                            logging.warning(f"Floor {floor_idx +1} missing exit transport, forcing placement...")

                            transport_placed = False
                            for room in floor_data["rooms"]:
                                if transport_placed:
                                    break
                                if room.get("type")=="transport":
                                    continue
                                rx, ry = room["position"]["x"], room["position"]["y"]
                                for att in _get_room_attachments(room):
                                    dx, dy = dir_offset[att]
                                    nx, ny = rx +dx, ry +dy
                                    if 0 <=nx <x_size and 0 <=ny <y_size and grid[ny][nx]is None:
                                        needed_attachment = opposite_dir[att]

                                        transport_template = _find_fitting_room(needed_attachment, transport_rooms, nx, ny)
                                        if transport_template:
                                            transport = _prepare_room(transport_template, room_id, nx, ny)
                                            transport["leads_to_floor"]= floor_idx +2
                                            transport["is_exit_transport"]= True
                                            grid[ny][nx]= room_id
                                            floor_data["rooms"].append(transport)
                                            _connect_rooms(room["room_id"], room_id, att)
                                            room_id +=1
                                            transport_placed = True
                                            logging.info(f"Forced transport placement on floor {floor_idx +1} at({nx}, {ny})")
                                            break

                            if not transport_placed:
                                logging.warning(f"Floor {floor_idx +1} - forcing transport with manual rotation...")
                                for room in floor_data["rooms"]:
                                    if transport_placed:
                                        break
                                    if room.get("type")=="transport":
                                        continue
                                    rx, ry = room["position"]["x"], room["position"]["y"]
                                    for att in _get_room_attachments(room):
                                        dx, dy = dir_offset[att]
                                        nx, ny = rx +dx, ry +dy
                                        if 0 <=nx <x_size and 0 <=ny <y_size and grid[ny][nx]is None:
                                            needed_attachment = opposite_dir[att]

                                            for transport_template in transport_rooms:
                                                if transport_placed:
                                                    break
                                                for rot in range(4):
                                                    rotated = _rotate_room_template(transport_template, rot)
                                                    if needed_attachment in _get_room_attachments(rotated):
                                                        transport = _prepare_room(rotated, room_id, nx, ny)
                                                        transport["leads_to_floor"]= floor_idx +2
                                                        transport["is_exit_transport"]= True
                                                        grid[ny][nx]= room_id
                                                        floor_data["rooms"].append(transport)
                                                        _connect_rooms(room["room_id"], room_id, att)
                                                        room_id +=1
                                                        transport_placed = True
                                                        logging.info(f"Forced rotated transport on floor {floor_idx +1} at({nx}, {ny})")
                                                        break
                                            if transport_placed:
                                                break

                            if not transport_placed:
                                logging.warning(f"Floor {floor_idx +1} - last resort transport placement...")
                                for room in floor_data["rooms"]:
                                    if transport_placed:
                                        break
                                    if room.get("type")=="transport":
                                        continue
                                    rx, ry = room["position"]["x"], room["position"]["y"]

                                    for direction in["top", "bottom", "left", "right"]:
                                        dx, dy = dir_offset[direction]
                                        nx, ny = rx +dx, ry +dy
                                        if 0 <=nx <x_size and 0 <=ny <y_size and grid[ny][nx]is None:
                                            needed_attachment = opposite_dir[direction]

                                            for transport_template in transport_rooms:
                                                if transport_placed:
                                                    break
                                                for rot in range(4):
                                                    rotated = _rotate_room_template(transport_template, rot)
                                                    if needed_attachment in _get_room_attachments(rotated):
                                                        transport = _prepare_room(rotated, room_id, nx, ny)
                                                        transport["leads_to_floor"]= floor_idx +2
                                                        transport["is_exit_transport"]= True
                                                        grid[ny][nx]= room_id
                                                        floor_data["rooms"].append(transport)

                                                        floor_data["connections"].append({
                                                        "from_room":room["room_id"],
                                                        "to_room":room_id,
                                                        "direction":direction,
                                                        "forced":True
                                                        })
                                                        room_id +=1
                                                        transport_placed = True
                                                        logging.info(f"Last resort transport on floor {floor_idx +1} at({nx}, {ny})")
                                                        break
                                            if transport_placed:
                                                break

                            if not transport_placed:
                                logging.error(f"Floor {floor_idx +1} - FAILED to place exit transport!")

                        dungeon["floors"].append(floor_data)

                    self._dg_state['generated_dungeon']= dungeon
                    self._dg_state['current_floor']= 0
                    self._dg_state['current_room_id']= 0 if dungeon["floors"][0]["rooms"]else None
                    self._dg_state['pending_door']= None

                    _update_display()
                    self._popup_show_info("Dungeon Generator", f"Generated dungeon with {num_floors} floor(s)!")
                    logging.info(f"Generated dungeon: {num_floors} floors")

                    if background_combat_timer[0]:
                        try:
                            dg.after_cancel(background_combat_timer[0])
                        except Exception:
                            pass

                    background_combat_timer[0]= dg.after(3000, _process_background_combat)# type: ignore

                    if npc_movement_timer[0]:
                        try:
                            dg.after_cancel(npc_movement_timer[0])
                        except Exception:
                            pass
                    npc_movement_timer[0]= dg.after(10000, _move_npcs_support)# type: ignore

                except Exception as e:
                    logging.exception("Failed to generate dungeon")
                    self._popup_show_info("Error", f"Failed to generate dungeon: {e}", sound = "error")

            def _get_current_room():

                try:
                    dungeon = self._dg_state.get('generated_dungeon')
                    if not dungeon:
                        return None
                    floor_idx = self._dg_state.get('current_floor', 0)
                    room_id = self._dg_state.get('current_room_id')
                    if floor_idx >=len(dungeon["floors"])or room_id is None:
                        return None
                    floor = dungeon["floors"][floor_idx]
                    for room in floor["rooms"]:
                        if room["room_id"]==room_id:
                            return room
                    return None
                except Exception:
                    return None

            def _get_available_exits():

                try:
                    dungeon = self._dg_state.get('generated_dungeon')
                    if not dungeon:
                        return[]
                    floor_idx = self._dg_state.get('current_floor', 0)
                    room_id = self._dg_state.get('current_room_id')
                    if floor_idx >=len(dungeon["floors"])or room_id is None:
                        return[]
                    floor = dungeon["floors"][floor_idx]
                    exits =[]
                    for conn in floor["connections"]:
                        if conn["from_room"]==room_id:
                            exits.append({"direction":conn["direction"], "to_room":conn["to_room"], "type":"connection"})
                        elif conn["to_room"]==room_id:
                            opposite = {"top":"bottom", "bottom":"top", "left":"right", "right":"left"}
                            exits.append({"direction":opposite.get(conn["direction"], conn["direction"]), "to_room":conn["from_room"], "type":"connection"})

                    current_room = _get_current_room()
                    if current_room and current_room.get("type")=="transport":

                        if current_room.get("is_entry_transport")and current_room.get("leads_to_floor"):
                            exits.append({"direction":"up", "to_floor":current_room["leads_to_floor"]-1, "type":"transport", "label":f"â†‘ Floor {current_room['leads_to_floor']}"})

                        if current_room.get("is_exit_transport")and current_room.get("leads_to_floor"):
                            exits.append({"direction":"down", "to_floor":current_room["leads_to_floor"]-1, "type":"transport", "label":f"â†“ Floor {current_room['leads_to_floor']}"})

                        if current_room.get("also_leads_to_floor"):
                            exits.append({"direction":"down", "to_floor":current_room["also_leads_to_floor"]-1, "type":"transport", "label":f"â†“ Floor {current_room['also_leads_to_floor']}"})

                    return exits
                except Exception:
                    return[]

            def _check_door_locked(direction):

                try:
                    room = _get_current_room()
                    if not room:
                        return False
                    doors_state = room.get("doors_state", {})
                    door_info = doors_state.get(direction, {})
                    return door_info.get("locked", False)and not door_info.get("picked", False)
                except Exception:
                    return False

            def _move_to_room(exit_info):

                try:

                    if self._dg_state.get('movement_locked', False):
                        return

                    direction = exit_info.get("direction")

                    if _check_door_locked(direction):
                        _play_dungeon_sound("locked", volume = 0.4)
                        self._dg_state['pending_door']= exit_info
                        _update_display()
                        return

                    if exit_info.get("type")!="transport":
                        current_room = _get_current_room()
                        if current_room:
                            doors_state = current_room.get("doors_state", {})
                            if direction in doors_state:
                                _play_dungeon_sound("door", volume = 0.3)
                            else:

                                _play_dungeon_sound("step", volume = 0.25)

                    if exit_info.get("type")=="transport":

                        current_room = _get_current_room()
                        transport_subtype = current_room.get("subtype", "stairs").lower()if current_room else "stairs"

                        self._dg_state['movement_locked']= True

                        if transport_subtype =="elevator":
                            _play_dungeon_sound("elevator", volume = 0.35)
                            unlock_delay = 2500
                        else:

                            _play_dungeon_sound("step", volume = 0.4)
                            unlock_delay = 800

                        dg.after(unlock_delay, lambda:self._dg_state.update({'movement_locked':False}))

                        next_floor = exit_info.get("to_floor", 0)
                        direction = exit_info.get("direction")
                        dungeon = self._dg_state.get('generated_dungeon')
                        current_floor = self._dg_state.get('current_floor', 0)
                        if dungeon and next_floor <len(dungeon["floors"]):
                            self._dg_state['current_floor']= next_floor

                            dest_room_id = None

                            if next_floor ==0:

                                for room in dungeon["floors"][next_floor]["rooms"]:
                                    if room.get("type")=="entrance":
                                        dest_room_id = room["room_id"]
                                        break
                            elif direction =="up":

                                for room in dungeon["floors"][next_floor]["rooms"]:
                                    if room.get("is_exit_transport")and room.get("leads_to_floor")==current_floor +1:
                                        dest_room_id = room["room_id"]
                                        break

                                    if room.get("also_leads_to_floor")==current_floor +1:
                                        dest_room_id = room["room_id"]
                                        break
                            else:

                                for room in dungeon["floors"][next_floor]["rooms"]:
                                    if room.get("is_entry_transport")and room.get("leads_to_floor")==current_floor +1:
                                        dest_room_id = room["room_id"]
                                        break

                            if dest_room_id is None:
                                dest_room_id = dungeon["floors"][next_floor]["rooms"][0]["room_id"]if dungeon["floors"][next_floor]["rooms"]else 0

                            self._dg_state['current_room_id']= dest_room_id
                    else:

                        self._dg_state['current_room_id']= exit_info.get("to_room")

                    room = _get_current_room()
                    if room:
                        room["visited"]= True

                    self._dg_state['pending_door']= None

                    _move_npcs_once()

                    _update_display()

                except Exception as e:
                    logging.exception("Failed to move to room")

            def _pick_door_success():

                try:
                    pending = self._dg_state.get('pending_door')
                    if not pending:
                        return
                    room = _get_current_room()
                    if room:
                        direction = pending.get("direction")

                        if direction in room.get("doors_state", {}):
                            room["doors_state"][direction]["picked"]= True

                        opposite = {"top":"bottom", "bottom":"top", "left":"right", "right":"left"}
                        dest_room_id = pending.get("to_room")
                        if dest_room_id is not None:
                            dungeon = self._dg_state.get('generated_dungeon')
                            floor_idx = self._dg_state.get('current_floor', 0)
                            if dungeon and floor_idx <len(dungeon["floors"]):
                                for dest_room in dungeon["floors"][floor_idx]["rooms"]:
                                    if dest_room.get("room_id")==dest_room_id:
                                        opp_dir = opposite.get(direction)
                                        if opp_dir and opp_dir in dest_room.get("doors_state", {}):
                                            dest_room["doors_state"][opp_dir]["picked"]= True
                                        break

                    _play_dungeon_sound("unlock", volume = 0.35)
                    self._dg_state['pending_door']= None
                    _move_to_room(pending)
                except Exception as e:
                    logging.exception("Failed to pick door")

            def _update_display():

                try:
                    dungeon = self._dg_state.get('generated_dungeon')
                    if not dungeon:
                        location_label.configure(text = "No dungeon generated")
                        room_info_label.configure(text = "Click 'Generate Dungeon' to create a new dungeon.")
                        door_status_label.configure(text = "")
                        pick_door_btn.configure(state = "disabled")
                        for w in nav_frame.winfo_children():
                            w.destroy()
                        if grid_canvas[0]:
                            grid_canvas[0].delete("all")
                        return

                    floor_idx = self._dg_state.get('current_floor', 0)
                    room = _get_current_room()

                    if not room:
                        location_label.configure(text = f"Floor {floor_idx +1} - No room")
                        room_info_label.configure(text = "")
                        return

                    location_label.configure(text = f"Floor {floor_idx +1} - {room.get('name', 'Unknown Room')}")

                    info_parts =[]
                    info_parts.append(f"Type: {room.get('type', 'unknown')}")
                    if room.get("visited"):
                        info_parts.append("(Visited)")
                    else:
                        info_parts.append("(New)")

                    enemies =[e for e in room.get("enemies", [])if e.get("alive", True)]
                    if enemies:
                        enemy_names =[e.get("name", "Unknown")for e in enemies]
                        info_parts.append(f"âš” Enemies({len(enemies)}): {', '.join(enemy_names)}")
                    else:
                        info_parts.append("Enemies: None")

                    friendlies =[f for f in room.get("friendlies", [])if f.get("alive", True)]
                    if friendlies:
                        friendly_names =[f.get("name", "Unknown")for f in friendlies]
                        info_parts.append(f"ðŸ›¡ Friendlies({len(friendlies)}): {', '.join(friendly_names)}")

                    pending_loot = room.get("pending_loot", [])
                    if pending_loot:
                        info_parts.append(f"ðŸ’€ Loot available from {len(pending_loot)} defeated enemy(s)")

                    loot_spawn = room.get("loot_spawn", [])
                    if loot_spawn:
                        info_parts.append(f"Loot: {len(loot_spawn)} spawn point(s)")

                    if room.get("type")=="transport":
                        transport_info =[]
                        if room.get("is_entry_transport")and room.get("leads_to_floor"):
                            transport_info.append(f"â†‘ Floor {room.get('leads_to_floor')}")
                        if room.get("is_exit_transport")and room.get("leads_to_floor"):
                            transport_info.append(f"â†“ Floor {room.get('leads_to_floor')}")
                        if room.get("also_leads_to_floor"):
                            transport_info.append(f"â†“ Floor {room.get('also_leads_to_floor')}")
                        if transport_info:
                            info_parts.append("Transport: "+", ".join(transport_info))
                        else:
                            info_parts.append(f"Transport to Floor {room.get('leads_to_floor', '?')}")

                    room_info_label.configure(text = "\n".join(info_parts))

                    _draw_grid()

                    for w in nav_frame.winfo_children():
                        w.destroy()

                    exits = _get_available_exits()
                    direction_labels = {"top":"â†‘ North(â†‘/W)", "bottom":"â†“ South(â†“/S)", "left":"â† West(â†/A)", "right":"â†’ East(â†’/D)", "up":"â¬† Ascend"}
                    key_hints = {"top":"â†‘", "bottom":"â†“", "left":"â†", "right":"â†’"}

                    if exits:

                        exits_text = "Exits: "
                        exit_parts =[]
                        for exit_info in exits:
                            direction = exit_info.get("direction")
                            is_locked = _check_door_locked(direction)
                            dir_label = direction_labels.get(direction, direction.title())
                            if is_locked:
                                dir_label +=" ðŸ”’"# type: ignore
                            exit_parts.append(dir_label)
                        exits_text +=" | ".join(exit_parts)
                        nav_label = customtkinter.CTkLabel(nav_frame, text = exits_text, font = customtkinter.CTkFont(size = 11))
                        nav_label.pack(side = 'left', padx = 4)

                    pending = self._dg_state.get('pending_door')
                    if pending:
                        direction = pending.get("direction")
                        door_status_label.configure(text = f"Door to {direction} is LOCKED! Pick the lock to proceed.")
                        pick_door_btn.configure(state = "normal", command = _pick_door_success)
                    else:
                        door_status_label.configure(text = "")
                        pick_door_btn.configure(state = "disabled")

                    if enemies:

                        kill_enemy_btn.configure(state = "normal", command = _kill_enemies_in_room)
                        collect_loot_btn.configure(state = "disabled")

                        for w in nav_frame.winfo_children():
                            if isinstance(w, customtkinter.CTkLabel):
                                w.configure(text = "âš” Movement blocked - enemies present!")
                    else:
                        kill_enemy_btn.configure(state = "disabled")

                        if pending_loot:
                            collect_loot_btn.configure(state = "normal", command = _collect_loot_from_room)
                        else:
                            collect_loot_btn.configure(state = "disabled")

                except Exception as e:
                    logging.exception("Failed to update dungeon display")

            def _handle_arrow_key(event):

                try:

                    key_to_direction = {
                    "Up":"top",
                    "Down":"bottom",
                    "Left":"left",
                    "Right":"right"
                    }

                    direction = key_to_direction.get(event.keysym)
                    if not direction:
                        return

                    room = _get_current_room()
                    if room:
                        enemies =[e for e in room.get("enemies", [])if e.get("alive", True)]
                        if enemies:
                            return

                    exits = _get_available_exits()
                    for exit_info in exits:
                        if exit_info.get("direction")==direction:
                            _move_to_room(exit_info)
                            return

                except Exception as e:
                    logging.debug(f"Arrow key handling error: {e}")

            def _handle_floor_transport(event):

                try:
                    room = _get_current_room()
                    if not room or room.get("type")!="transport":
                        return

                    enemies =[e for e in room.get("enemies", [])if e.get("alive", True)]
                    if enemies:
                        return

                    transport_direction = None
                    if event.keysym =="Up":
                        transport_direction = "up"
                    elif event.keysym =="Down":
                        transport_direction = "down"

                    if not transport_direction:
                        return

                    exits = _get_available_exits()
                    for exit_info in exits:
                        if exit_info.get("type")=="transport"and exit_info.get("direction")==transport_direction:
                            _move_to_room(exit_info)
                            return

                except Exception as e:
                    logging.debug(f"Floor transport handling error: {e}")

            dg.bind("<Up>", _handle_arrow_key)
            dg.bind("<Down>", _handle_arrow_key)
            dg.bind("<Left>", _handle_arrow_key)
            dg.bind("<Right>", _handle_arrow_key)

            dg.bind("<w>", lambda e:_handle_arrow_key(type('Event', (), {'keysym':'Up'})()))
            dg.bind("<s>", lambda e:_handle_arrow_key(type('Event', (), {'keysym':'Down'})()))
            dg.bind("<a>", lambda e:_handle_arrow_key(type('Event', (), {'keysym':'Left'})()))
            dg.bind("<d>", lambda e:_handle_arrow_key(type('Event', (), {'keysym':'Right'})()))
            dg.bind("<W>", lambda e:_handle_arrow_key(type('Event', (), {'keysym':'Up'})()))
            dg.bind("<S>", lambda e:_handle_arrow_key(type('Event', (), {'keysym':'Down'})()))
            dg.bind("<A>", lambda e:_handle_arrow_key(type('Event', (), {'keysym':'Left'})()))
            dg.bind("<D>", lambda e:_handle_arrow_key(type('Event', (), {'keysym':'Right'})()))

            dg.bind("<Shift-Up>", lambda e:_handle_floor_transport(type('Event', (), {'keysym':'Up'})()))
            dg.bind("<Shift-Down>", lambda e:_handle_floor_transport(type('Event', (), {'keysym':'Down'})()))
            dg.bind("<Shift-w>", lambda e:_handle_floor_transport(type('Event', (), {'keysym':'Up'})()))
            dg.bind("<Shift-s>", lambda e:_handle_floor_transport(type('Event', (), {'keysym':'Down'})()))
            dg.bind("<Shift-W>", lambda e:_handle_floor_transport(type('Event', (), {'keysym':'Up'})()))
            dg.bind("<Shift-S>", lambda e:_handle_floor_transport(type('Event', (), {'keysym':'Down'})()))

            def _save_dungeon():

                try:
                    dungeon = self._dg_state.get('generated_dungeon')
                    if not dungeon:
                        self._popup_show_info("Error", "No dungeon to save.", sound = "error")
                        return

                    dungeons_dir = os.path.join(saves_folder or "saves", "dungeons")
                    os.makedirs(dungeons_dir, exist_ok = True)

                    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                    filename = f"dungeon_{timestamp}.slddng"
                    filepath = os.path.join(dungeons_dir, filename)

                    save_data = {
                    "dungeon":dungeon,
                    "current_floor":self._dg_state.get('current_floor', 0),
                    "current_room_id":self._dg_state.get('current_room_id'),
                    "saved_at":datetime.now().isoformat()
                    }

                    with open(filepath, 'w', encoding = 'utf-8')as f:
                        json.dump(save_data, f, indent = 2)

                    self._popup_show_info("Dungeon Saved", f"Saved to: {filename}")
                    logging.info(f"Saved dungeon to {filepath}")

                except Exception as e:
                    logging.exception("Failed to save dungeon")
                    self._popup_show_info("Error", f"Failed to save: {e}", sound = "error")

            def _load_dungeon():

                try:
                    dungeons_dir = os.path.join(saves_folder or "saves", "dungeons")
                    if not os.path.isdir(dungeons_dir):
                        self._popup_show_info("Error", "No saved dungeons found.", sound = "error")
                        return

                    dungeon_files = sorted(glob.glob(os.path.join(dungeons_dir, "*.slddng")), reverse = True)
                    if not dungeon_files:
                        self._popup_show_info("Error", "No saved dungeons found.", sound = "error")
                        return

                    options =[os.path.basename(f)for f in dungeon_files[:10]]
                    selected = self._popup_select_option("Load Dungeon", "Select a dungeon to load:", options)
                    if not selected:
                        return

                    filepath = os.path.join(dungeons_dir, selected)
                    with open(filepath, 'r', encoding = 'utf-8')as f:
                        save_data = json.load(f)

                    self._dg_state['generated_dungeon']= save_data.get("dungeon")
                    self._dg_state['current_floor']= save_data.get("current_floor", 0)
                    self._dg_state['current_room_id']= save_data.get("current_room_id", 0)
                    self._dg_state['pending_door']= None

                    _update_display()
                    self._popup_show_info("Dungeon Loaded", f"Loaded: {selected}")
                    logging.info(f"Loaded dungeon from {filepath}")

                except Exception as e:
                    logging.exception("Failed to load dungeon")
                    self._popup_show_info("Error", f"Failed to load: {e}", sound = "error")

            action_frame = customtkinter.CTkFrame(frm)
            action_frame.pack(fill = 'x', pady = 8)

            generate_btn = customtkinter.CTkButton(action_frame, text = "Generate Dungeon", width = 140, command = _generate_dungeon)
            generate_btn.pack(side = 'left', padx = 4)

            save_btn = customtkinter.CTkButton(action_frame, text = "Save Layout", width = 100, command = _save_dungeon)
            save_btn.pack(side = 'left', padx = 4)

            load_btn = customtkinter.CTkButton(action_frame, text = "Load Layout", width = 100, command = _load_dungeon)
            load_btn.pack(side = 'left', padx = 4)

            def _toggle_continuous_generation():
                if continuous_gen_active[0]:

                    continuous_gen_active[0]= False
                    if continuous_gen_timer[0]:
                        try:
                            dg.after_cancel(continuous_gen_timer[0])
                        except Exception:
                            pass
                        continuous_gen_timer[0]= None
                    continuous_gen_btn.configure(text = "Start Continuous Gen", fg_color =("gray70", "gray30"))
                    logging.info("Continuous dungeon generation stopped")
                else:

                    continuous_gen_active[0]= True
                    continuous_gen_btn.configure(text = "Stop Continuous Gen", fg_color =("#D35B58", "#C77C78"))
                    logging.info("Continuous dungeon generation started")
                    _continuous_generate_cycle()

            def _continuous_generate_cycle():
                if not continuous_gen_active[0]:
                    return
                try:
                    if not dg.winfo_exists():
                        continuous_gen_active[0]= False
                        return
                    _generate_dungeon()

                    continuous_gen_timer[0]= dg.after(10000, _continuous_generate_cycle)# type: ignore
                except Exception as e:
                    logging.error(f"Continuous generation error: {e}")
                    continuous_gen_active[0]= False
                    try:
                        continuous_gen_btn.configure(text = "Start Continuous Gen", fg_color =("gray70", "gray30"))
                    except Exception:
                        pass

            if global_variables.get("devmode", {}).get("value", False):
                continuous_gen_btn = customtkinter.CTkButton(
                action_frame,
                text = "Start Continuous Gen",
                width = 140,
                command = _toggle_continuous_generation,
                fg_color =("gray70", "gray30")
                )
                continuous_gen_btn.pack(side = 'left', padx = 4)

            _update_display()

            btn_close = customtkinter.CTkButton(frm, text = "Close", command = _confirm_close)
            btn_close.pack(pady = 8)

            self._dg_window = dg
            try:
                dg.focus_force()
                dg.lift()
            except Exception:
                pass
        except Exception:
            logging.exception("Failed to open Dungeon Generator window")

    def _open_encounter_roll_tool(self):

        logging.info("Encounter Roll tool called")

        try:
            tbl_path = get_current_table_path()
            if not tbl_path or not os.path.exists(tbl_path):
                self._popup_show_info("Error", "No table file found.", sound = "error")
                return
            with open(tbl_path, 'r')as f:
                table_data = json.load(f)
        except Exception as e:
            logging.error(f"Failed to load table: {e}")
            self._popup_show_info("Error", f"Failed to load table: {e}", sound = "error")
            return

        dm_settings_path = os.path.join(saves_folder or "saves", "dm_settings.sldsv")
        enabled_enemies = {}

        if os.path.exists(dm_settings_path):
            try:
                with open(dm_settings_path, 'r')as f:
                    dm_settings = json.load(f)
                    enabled_enemies = dm_settings.get("enabled_enemies", {})
            except Exception as e:
                logging.warning(f"Failed to load DM settings: {e}")

        enemy_list = table_data.get("tables", {}).get("enemy_drops", [])

        available_enemies =[
        enemy for enemy in enemy_list
        if enabled_enemies.get(enemy.get("name"), True)
        ]

        if not available_enemies:
            self._popup_show_info("Error", "No enabled enemies in table.", sound = "error")
            return

        self._clear_window()
        self._play_ui_sound("whoosh1")

        main_frame = customtkinter.CTkFrame(self.root, fg_color = "transparent")
        main_frame.pack(fill = "both", expand = True, padx = 20, pady = 20)

        title_label = customtkinter.CTkLabel(
        main_frame,
        text = "Encounter Roll",
        font = customtkinter.CTkFont(size = 24, weight = "bold")
        )
        title_label.pack(pady = 20)

        info_frame = customtkinter.CTkFrame(main_frame)
        info_frame.pack(fill = "x", pady = 10)

        info_text = """Encounter Difficulty Ranges:
        1 = Miniboss
        2-5 = Hard
        6-10 = Medium
        11-14 = Easy
        15-20 = None/Friendly(50/50)"""

        customtkinter.CTkLabel(
        info_frame,
        text = info_text,
        font = customtkinter.CTkFont(size = 12),
        justify = "left"
        ).pack(padx = 20, pady = 10)

        content_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        content_frame.pack(fill = "both", expand = True, pady = 10)

        loot_list_frame = customtkinter.CTkScrollableFrame(content_frame, width = 400, height = 300)
        loot_list_frame.pack(side = "left", fill = "both", expand = True, padx =(0, 10))

        loot_list_label = customtkinter.CTkLabel(
        loot_list_frame,
        text = "Enemy Loot",
        font = customtkinter.CTkFont(size = 16, weight = "bold")
        )
        loot_list_label.pack(pady = 10)

        right_frame = customtkinter.CTkFrame(content_frame, fg_color = "transparent")
        right_frame.pack(side = "right", fill = "both", expand = True, padx =(10, 0))

        result_label = customtkinter.CTkLabel(
        right_frame,
        text = "",
        font = customtkinter.CTkFont(size = 14),
        wraplength = 400,
        justify = "left"
        )
        result_label.pack(pady = 20)

        encounter_state = {"spawned_enemies":[], "all_loot":[]}

        def clear_loot_list():
            for widget in loot_list_frame.winfo_children():
                if widget !=loot_list_label:
                    widget.destroy()
            encounter_state["spawned_enemies"]=[]
            encounter_state["all_loot"]=[]

        def add_enemy_to_list(enemy_name, difficulty, loot_items):
            enemy_frame = customtkinter.CTkFrame(loot_list_frame)
            enemy_frame.pack(fill = "x", pady = 5, padx = 5)

            header_frame = customtkinter.CTkFrame(enemy_frame, fg_color = "transparent")
            header_frame.pack(fill = "x", padx = 5, pady =(5, 2))

            enemy_header = customtkinter.CTkLabel(
            header_frame,
            text = f"â–¸ {enemy_name}({difficulty})",
            font = customtkinter.CTkFont(size = 13, weight = "bold"),
            anchor = "w"
            )
            enemy_header.pack(side = "left", fill = "x", expand = True)

            if loot_items:
                def save_this_enemy_loot(name = enemy_name, loot = loot_items):
                    self._save_enemy_loot_transfer(name, loot)

                save_btn = customtkinter.CTkButton(
                header_frame,
                text = "Save",
                width = 50,
                height = 24,
                font = customtkinter.CTkFont(size = 11),
                command = save_this_enemy_loot
                )
                save_btn.pack(side = "right", padx = 2)

            if loot_items:
                for item in loot_items:
                    item_name = item.get('name', 'Unknown Item')
                    qty = item.get('quantity', 1)
                    item_text = f" â€¢ {item_name}"
                    if qty >1:
                        item_text +=f" x{qty}"
                    item_label = customtkinter.CTkLabel(
                    enemy_frame,
                    text = item_text,
                    font = customtkinter.CTkFont(size = 11),
                    anchor = "w"
                    )
                    item_label.pack(fill = "x", padx = 10)
                encounter_state["all_loot"].extend(loot_items)
            else:
                no_loot_label = customtkinter.CTkLabel(
                enemy_frame,
                text = "(No items)",
                font = customtkinter.CTkFont(size = 11),
                text_color = "gray",
                anchor = "w"
                )
                no_loot_label.pack(fill = "x", padx = 10)

            encounter_state["spawned_enemies"].append({
            "name":enemy_name,
            "difficulty":difficulty,
            "loot":loot_items
            })

        def perform_roll():
            clear_loot_list()
            roll = random.randint(1, 20)

            if roll ==1:
                difficulty = "Miniboss"
            elif 2 <=roll <=5:
                difficulty = "Hard"
            elif 6 <=roll <=10:
                difficulty = "Medium"
            elif 11 <=roll <=14:
                difficulty = "Easy"
            else:
                is_friendly = random.choice([True, False])
                difficulty = "Friendly"if is_friendly else "None"

            result_text = f"Roll: {roll}\nDifficulty: {difficulty}\n\n"

            if difficulty =="None":
                result_text +="No encounter!"
                result_label.configure(text = result_text)
                return

            if difficulty =="Friendly":
                friendly_enemies =[e for e in available_enemies if e.get("difficulty", "").lower()=="friendly"]
                if not friendly_enemies:
                    friendly_enemies = available_enemies

                selected_enemy = random.choice(friendly_enemies)
                enemy_name = selected_enemy.get('name', 'Unknown')
                result_text +=f"Friendly encounter!\nEnemy: {enemy_name}\n\n"
                result_text +="Friendly enemies have no loot."
                result_label.configure(text = result_text)

                add_enemy_to_list(enemy_name, "Friendly", [])
                return

            matching_enemies =[e for e in available_enemies if e.get("difficulty", "").lower()==difficulty.lower()]

            if not matching_enemies:
                result_text +=f"No enemies found for difficulty: {difficulty}"
                result_label.configure(text = result_text)
                return

            selected_enemy = random.choice(matching_enemies)
            enemy_name = selected_enemy.get('name', 'Unknown')
            result_text +=f"Enemy: {enemy_name}\n\n"

            loot = self._generate_enemy_loot(selected_enemy, table_data)

            result_text +=f"Generated {len(loot)} item(s)"
            result_label.configure(text = result_text)

            add_enemy_to_list(enemy_name, difficulty, loot)

        def save_all_loot():
            if not encounter_state["all_loot"]:
                self._popup_show_info("Info", "No loot to save.", sound = "error")
                return
            enemy_names = ", ".join([e["name"]for e in encounter_state["spawned_enemies"]])
            self._save_enemy_loot_transfer(enemy_names, encounter_state["all_loot"])

        self._create_sound_button(
        right_frame,
        text = "Roll for Encounter",
        command = perform_roll,
        width = 300,
        height = 50,
        font = customtkinter.CTkFont(size = 16)
        ).pack(pady = 10)

        self._create_sound_button(
        right_frame,
        text = "Save All Loot as Transfer",
        command = save_all_loot,
        width = 300
        ).pack(pady = 10)

        back_button = self._create_sound_button(
        right_frame,
        text = "Back to DM Tools",
        command = lambda:[self._clear_window(), self._open_dm_tools()],
        width = 300,
        height = 50,
        font = customtkinter.CTkFont(size = 16)
        )
        back_button.pack(pady = 20)

    def _open_enemy_loot_tool(self):

        logging.info("Individual Enemy Loot tool called")

        try:
            tbl_path = get_current_table_path()
            if not tbl_path or not os.path.exists(tbl_path):
                self._popup_show_info("Error", "No table file found.", sound = "error")
                return
            with open(tbl_path, 'r')as f:
                table_data = json.load(f)
        except Exception as e:
            logging.error(f"Failed to load table: {e}")
            self._popup_show_info("Error", f"Failed to load table: {e}", sound = "error")
            return

        dm_settings_path = os.path.join(saves_folder or "saves", "dm_settings.sldsv")
        enabled_enemies = {}

        if os.path.exists(dm_settings_path):
            try:
                with open(dm_settings_path, 'r')as f:
                    dm_settings = json.load(f)
                    enabled_enemies = dm_settings.get("enabled_enemies", {})
            except Exception as e:
                logging.warning(f"Failed to load DM settings: {e}")

        enemy_list = table_data.get("tables", {}).get("enemy_drops", [])

        available_enemies =[
        enemy for enemy in enemy_list
        if enabled_enemies.get(enemy.get("name"), True)
        ]

        if not available_enemies:
            self._popup_show_info("Error", "No enabled enemies in table.", sound = "error")
            return

        self._clear_window()
        self._play_ui_sound("whoosh1")

        main_frame = customtkinter.CTkScrollableFrame(self.root, fg_color = "transparent")
        main_frame.pack(fill = "both", expand = True, padx = 20, pady = 20)

        title_label = customtkinter.CTkLabel(
        main_frame,
        text = "Individual Enemy Loot",
        font = customtkinter.CTkFont(size = 24, weight = "bold")
        )
        title_label.pack(pady = 20)

        customtkinter.CTkLabel(
        main_frame,
        text = "Select an enemy to generate loot:",
        font = customtkinter.CTkFont(size = 14)
        ).pack(pady = 10)

        for enemy in available_enemies:
            enemy_frame = customtkinter.CTkFrame(main_frame)
            enemy_frame.pack(fill = "x", pady = 5, padx = 20)

            enemy_info = f"{enemy.get('name', 'Unknown')} - {enemy.get('difficulty', 'Unknown')} Difficulty"

            customtkinter.CTkLabel(
            enemy_frame,
            text = enemy_info,
            font = customtkinter.CTkFont(size = 12)
            ).pack(side = "left", padx = 10, pady = 10)

            def generate_loot(e = enemy):
                self._show_enemy_loot_result(e, table_data)

            self._create_sound_button(
            enemy_frame,
            text = "Generate Loot",
            command = generate_loot,
            width = 150
            ).pack(side = "right", padx = 10, pady = 5)

        back_button = self._create_sound_button(
        main_frame,
        text = "Back to DM Tools",
        command = lambda:[self._clear_window(), self._open_dm_tools()],
        width = 300,
        height = 50,
        font = customtkinter.CTkFont(size = 16)
        )
        back_button.pack(pady = 20)

    def _show_enemy_loot_result(self, enemy, table_data):

        loot = self._generate_enemy_loot(enemy, table_data)

        dialog = customtkinter.CTkToplevel(self.root)
        dialog.title(f"Loot: {enemy.get('name', 'Unknown')}")
        dialog.transient(self.root)

        if global_variables.get("devmode", {}).get("value", False):
            self._center_popup_on_window(dialog, 700, 700)
        else:
            self._center_popup_on_window(dialog, 500, 600)
        dialog.grab_set()

        customtkinter.CTkLabel(
        dialog,
        text = f"Generated Loot for {enemy.get('name', 'Unknown')}",
        font = customtkinter.CTkFont(size = 16, weight = "bold")
        ).pack(pady = 10)

        scroll_frame = customtkinter.CTkScrollableFrame(dialog)
        scroll_frame.pack(fill = "both", expand = True, padx = 20, pady = 10)

        if global_variables.get("devmode", {}).get("value", False)and loot:
            debug_summary = loot[0].get("_loot_debug_summary", "")
            if debug_summary:
                debug_frame = customtkinter.CTkFrame(scroll_frame, fg_color = "#1a1a2e")
                debug_frame.pack(fill = "x", pady =(0, 15), padx = 5)

                customtkinter.CTkLabel(
                debug_frame,
                text = "ðŸ”§ DEBUG INFO",
                font = customtkinter.CTkFont(size = 12, weight = "bold"),
                text_color = "#00ff88"
                ).pack(anchor = "w", padx = 10, pady =(10, 5))

                debug_text = customtkinter.CTkTextbox(
                debug_frame,
                height = 250,
                font = customtkinter.CTkFont(family = "Consolas", size = 10),
                fg_color = "#0d0d1a",
                text_color = "#88ff88"
                )
                debug_text.pack(fill = "x", padx = 10, pady =(0, 10))
                debug_text.insert("1.0", debug_summary)
                debug_text.configure(state = "disabled")

        if not loot:
            customtkinter.CTkLabel(
            scroll_frame,
            text = "No loot generated",
            font = customtkinter.CTkFont(size = 12)
            ).pack(pady = 20)

            if global_variables.get("devmode", {}).get("value", False):
                customtkinter.CTkLabel(
                scroll_frame,
                text = "(Check logs for debug details)",
                font = customtkinter.CTkFont(size = 10),
                text_color = "gray"
                ).pack()
        else:
            customtkinter.CTkLabel(
            scroll_frame,
            text = "Generated Items:",
            font = customtkinter.CTkFont(size = 14, weight = "bold")
            ).pack(anchor = "w", padx = 10, pady =(10, 5))

            for item in loot:
                item_text = item.get('name', 'Unknown Item')
                if item.get("quantity", 1)>1:
                    item_text +=f" x{item['quantity']}"

                rarity = item.get('rarity', 'Common')
                rarity_colors = {
                'Common':'white',
                'Uncommon':'#00ff00',
                'Rare':'#0088ff',
                'Epic':'#aa00ff',
                'Legendary':'#ffaa00',
                'Special':'#ff0088'
                }
                text_color = rarity_colors.get(rarity, 'white')

                customtkinter.CTkLabel(
                scroll_frame,
                text = f"â€¢ {item_text}[{rarity}]",
                font = customtkinter.CTkFont(size = 12),
                text_color = text_color
                ).pack(anchor = "w", padx = 10, pady = 2)

        def save_loot():
            self._save_enemy_loot_transfer(enemy.get("name"), loot)
            dialog.destroy()

        self._create_sound_button(
        dialog,
        text = "Save as Enemy Loot Transfer",
        command = save_loot,
        width = 250
        ).pack(pady = 10)

        self._create_sound_button(
        dialog,
        text = "Close",
        command = dialog.destroy,
        fg_color = "#8B0000",
        width = 250
        ).pack(pady = 10)

    def _generate_enemy_loot(self, enemy, table_data):

        loot =[]
        debug_lines =[]

        if global_variables.get("devmode", {}).get("value", False):
            debug_lines.append(f"â•â•â• ENEMY LOOT GENERATION DEBUG â•â•â•")
            debug_lines.append(f"Enemy: {enemy.get('name', 'Unknown')}")
            debug_lines.append(f"Difficulty: {enemy.get('difficulty', 'Unknown')}")
            debug_lines.append(f"Total loot entries: {len(enemy.get('items', []))}")
            debug_lines.append("")

        rarity_weights = table_data.get("rarity_weights", {})

        for idx, loot_entry in enumerate(enemy.get("items", [])):

            entry_debug =[]
            if global_variables.get("devmode", {}).get("value", False):
                entry_debug.append(f"--- Entry #{idx +1} ---")
                entry_debug.append(f" Type: {loot_entry.get('type', 'Unknown')}")
                if loot_entry.get('type')=='table':
                    entry_debug.append(f" Table: {loot_entry.get('table', 'Unknown')}")
                elif loot_entry.get('type')=='id':
                    entry_debug.append(f" Item ID: {loot_entry.get('id', 'Unknown')}")
                entry_debug.append(f" Rarity filter: {loot_entry.get('rarity', 'Any')}")
                entry_debug.append(f" Guaranteed: {loot_entry.get('guaranteed', False)}")

            if loot_entry.get("guaranteed"):
                should_drop = True
                if global_variables.get("devmode", {}).get("value", False):
                    entry_debug.append(f" Drop result: âœ“ GUARANTEED")
            else:

                rarity = loot_entry.get("rarity", "Common")
                drop_chance = rarity_weights.get(rarity, 50)/100.0
                roll = random.random()
                should_drop = roll <drop_chance

                if global_variables.get("devmode", {}).get("value", False):
                    entry_debug.append(f" Drop chance for '{rarity}': {drop_chance *100:.1f}%")
                    entry_debug.append(f" Roll: {roll *100:.2f}%")
                    entry_debug.append(f" Drop result: {'âœ“ SUCCESS'if should_drop else 'âœ— FAILED'}")

            if should_drop:
                item = self._resolve_loot_entry(loot_entry, table_data)
                if item:

                    if isinstance(item, list):
                        for it in item:
                            if global_variables.get("devmode", {}).get("value", False):
                                entry_debug.append(f" â†’ Resolved: {it.get('name', 'Unknown')}({it.get('rarity', 'Unknown')})")

                                if it.get("_debug_info"):
                                    entry_debug.append(f"[Resolution details]\n{it.get('_debug_info')}")
                        loot.extend(item)
                    else:
                        if global_variables.get("devmode", {}).get("value", False):
                            entry_debug.append(f" â†’ Resolved: {self._format_item_name(item)}({item.get('rarity', 'Unknown')})")
                        loot.append(item)

            if global_variables.get("devmode", {}).get("value", False):
                debug_lines.extend(entry_debug)
                debug_lines.append("")

        special_chance = rarity_weights.get("Special Chance", 0)
        special_roll = random.random()*100

        if global_variables.get("devmode", {}).get("value", False):
            debug_lines.append(f"--- Special Item Roll ---")
            debug_lines.append(f" Special chance: {special_chance}%")
            debug_lines.append(f" Roll: {special_roll:.2f}")

        if special_roll <special_chance:
            special_table = table_data.get("tables", {}).get("special_items", [])
            if special_table:
                selected_special = random.choice(special_table)
                special_copy = selected_special.copy()
                special_copy["table_category"]= "special_items"
                loot.append(special_copy)

                if global_variables.get("devmode", {}).get("value", False):
                    debug_lines.append(f" â˜… SPECIAL ITEM TRIGGERED! Selected: {selected_special.get('name', 'Unknown')}")
            else:
                if global_variables.get("devmode", {}).get("value", False):
                    debug_lines.append(f" Special roll succeeded but no special_items table found")
        else:
            if global_variables.get("devmode", {}).get("value", False):
                debug_lines.append(f" No special item(needed < {special_chance})")

        if global_variables.get("devmode", {}).get("value", False):
            debug_lines.append("")
            debug_lines.append(f"â•â•â• FINAL RESULT: {len(loot)} item(s) â•â•â•")
            for it in loot:
                debug_lines.append(f" â€¢ {it.get('name', 'Unknown')}({it.get('rarity', 'Unknown')})")

            logging.debug("\n".join(debug_lines))

            if loot:
                loot[0]["_loot_debug_summary"]= "\n".join(debug_lines)

        return loot

    def _save_enemy_loot_transfer(self, enemy_name, loot_items):

        try:

            transfer_data = {
            "type":"enemyloot",
            "enemy_name":enemy_name,
            "items":loot_items,
            "timestamp":datetime.now().isoformat()
            }

            safe_name = enemy_name.replace(" ", "_").lower()
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"enemyloot_{safe_name}_{timestamp}.sldenlt"
            filepath = os.path.join("enemyloot", filename)

            os.makedirs("enemyloot", exist_ok = True)

            with open(filepath, 'wb')as f:
                pickled = pickle.dumps(transfer_data)
                encoded = base64.b85encode(pickled)
                f.write(encoded)

            logging.info(f"Saved enemy loot transfer: {filepath}")
            self._popup_show_info("Success", f"Enemy loot saved as:\n{filename}", sound = "success")

        except Exception as e:
            logging.error(f"Failed to save enemy loot transfer: {e}")
            self._popup_show_info("Error", f"Failed to save: {e}", sound = "error")

    def _save_enemy_loot_transfer_silent(self, enemy_name, loot_items):

        try:
            transfer_data = {
            "type":"enemyloot",
            "enemy_name":enemy_name,
            "items":loot_items,
            "timestamp":datetime.now().isoformat()
            }

            safe_name = enemy_name.replace(" ", "_").lower()
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S_%f")
            filename = f"enemyloot_{safe_name}_{timestamp}.sldenlt"
            filepath = os.path.join("enemyloot", filename)

            os.makedirs("enemyloot", exist_ok = True)

            with open(filepath, 'wb')as f:
                pickled = pickle.dumps(transfer_data)
                encoded = base64.b85encode(pickled)
                f.write(encoded)

            logging.info(f"Saved enemy loot transfer: {filepath}")
            return filename

        except Exception as e:
            logging.error(f"Failed to save enemy loot transfer: {e}")
            return None

    def _save_lootcrate_transfer_silent(self, crate_name, loot_items):

        try:
            transfer_data = {
            "type":"lootcrate",
            "crate_name":crate_name,
            "items":loot_items,
            "timestamp":datetime.now().isoformat()
            }

            safe_name = crate_name.replace(" ", "_").lower()
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S_%f")
            filename = f"lootcrate_{safe_name}_{timestamp}.sldlct"
            filepath = os.path.join("lootcrates", filename)

            os.makedirs("lootcrates", exist_ok = True)

            with open(filepath, 'wb')as f:
                pickled = pickle.dumps(transfer_data)
                encoded = base64.b85encode(pickled)
                f.write(encoded)

            logging.info(f"Saved lootcrate transfer: {filepath}")
            return filename

        except Exception as e:
            logging.error(f"Failed to save lootcrate transfer: {e}")
            return None

    def _generate_lootcrate_contents(self, lootcrate_def, table_data):

        try:
            loot =[]
            pulls_config = lootcrate_def.get("pulls", {"min":1, "max":3})
            num_pulls = random.randint(pulls_config.get("min", 1), pulls_config.get("max", 3))

            loot_table = lootcrate_def.get("loot_table", [])
            if not loot_table:
                return loot

            for _ in range(num_pulls):

                loot_entry = random.choice(loot_table)

                item = self._resolve_loot_entry(loot_entry, table_data)
                if item:
                    if isinstance(item, list):
                        loot.extend(item)
                    else:
                        loot.append(item)

            return loot

        except Exception as e:
            logging.error(f"Failed to generate lootcrate contents: {e}")
            return[]

    def _open_create_lootcrate_tool(self):
        logging.info("Create Loot Crate tool called")
        self._clear_window()

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew")

        title_label = customtkinter.CTkLabel(main_frame, text = "Create Lootcrate", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title_label.pack(pady = 20)

        create_scratch_btn = self._create_sound_button(main_frame, "Create from Scratch", self._open_create_lootcrate_from_scratch, width = 800, height = 60, font = customtkinter.CTkFont(size = 16))
        create_scratch_btn.pack(pady = 10, padx = 20)

        create_preset_btn = self._create_sound_button(main_frame, "Create from Preset", self._open_create_lootcrate_from_preset, width = 800, height = 60, font = customtkinter.CTkFont(size = 16))
        create_preset_btn.pack(pady = 10, padx = 20)

        back_button = self._create_sound_button(main_frame, "Back to DM Tools", lambda:[self._clear_window(), self._open_dm_tools()], width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        back_button.pack(pady = 20)

    def _open_create_lootcrate_from_preset(self):
        logging.info("Create Loot Crate from Preset called")
        self._clear_window()

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkScrollableFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew")

        title_label = customtkinter.CTkLabel(main_frame, text = "Create Lootcrate from Preset", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title_label.pack(pady = 20)

        try:
            tbl_path = get_current_table_path()
            if not tbl_path or not os.path.exists(tbl_path):
                self._popup_show_info("Error", "No table files found.", sound = "error")
                return
            with open(tbl_path, 'r')as f:
                table_data = json.load(f)
        except Exception as e:
            logging.error(f"Failed to load tables for loot crate creator: {e}")
            self._popup_show_info("Error", f"Failed to load tables: {e}", sound = "error")
            return

        def generate_crate_from_preset(crate):

            try:
                crate_copy = json.loads(json.dumps(crate))
                crate_copy.pop("_source_file", None)
                crate_copy.pop("_file_path", None)
                crate_copy["generated_at"]= datetime.now().isoformat()
                os.makedirs("lootcrates", exist_ok = True)
                filename = os.path.join(
                "lootcrates",
                f"lootcrate_{datetime.now().strftime('%Y%m%d_%H%M%S')}{global_variables['lootcrate_extension']}"
                )
                pickled_data = pickle.dumps(crate_copy)
                encoded_data = base64.b85encode(pickled_data).decode('utf-8')
                with open(filename, 'w')as f:
                    f.write(encoded_data)
                self._popup_show_info("Success", f"Generated loot crate '{crate.get('name', 'Loot Crate')}'.", sound = "success")
                logging.info(f"Generated loot crate file: {filename}")
            except Exception as e:
                logging.error(f"Failed to generate loot crate: {e}")
                self._popup_show_info("Error", f"Failed to generate loot crate: {e}", sound = "error")

        def render_preset(crate, parent_frame):

            row = customtkinter.CTkFrame(parent_frame)
            row.pack(fill = "x", padx = 5, pady = 4)
            row.grid_columnconfigure(0, weight = 1)

            name = crate.get("name", "Loot Crate")
            desc = crate.get("description", "")

            title = customtkinter.CTkLabel(row, text = name, font = customtkinter.CTkFont(size = 14, weight = "bold"), anchor = "w")
            title.grid(row = 0, column = 0, sticky = "w", padx = 4, pady =(2, 0))

            if desc:
                desc_label = customtkinter.CTkLabel(row, text = desc, font = customtkinter.CTkFont(size = 11), text_color = "gray", justify = "left", anchor = "w", wraplength = 600)
                desc_label.grid(row = 1, column = 0, sticky = "w", padx = 4, pady =(0, 2))

            preview = self._get_loot_crate_contents_preview(crate, table_data)
            if preview:
                preview_label = customtkinter.CTkLabel(row, text = preview, font = customtkinter.CTkFont(size = 10), text_color = "orange", justify = "left", anchor = "w", wraplength = 600)
                preview_label.grid(row = 2, column = 0, sticky = "w", padx = 4, pady =(0, 4))

            create_btn = self._create_sound_button(row, "Create", lambda c = crate:generate_crate_from_preset(c), width = 130, height = 35, font = customtkinter.CTkFont(size = 12))
            create_btn.grid(row = 0, column = 1, rowspan = 3, sticky = "e", padx = 10, pady = 6)

        presets_from_table = table_data.get("tables", {}).get("lootcrates", [])

        os.makedirs(os.path.join("lootcrates", "presets"), exist_ok = True)
        preset_files = glob.glob(os.path.join("lootcrates", "presets", f"*{global_variables['lootcrate_extension']}"))
        presets_from_folder =[]
        for pf in preset_files:
            try:
                with open(pf, 'r')as f:
                    encoded_data = f.read()
                pickled_data = base64.b85decode(encoded_data.encode('utf-8'))
                pdata = pickle.loads(pickled_data)
                pdata["_source_file"]= pf
                presets_from_folder.append(pdata)
            except Exception as e:
                logging.warning(f"Failed to load preset file {pf}: {e}")

        all_presets = presets_from_table +presets_from_folder
        if all_presets:
            for crate in all_presets:
                render_preset(crate, main_frame)
        else:
            no_presets_label = customtkinter.CTkLabel(main_frame, text = "No presets available.", font = customtkinter.CTkFont(size = 14), text_color = "gray")
            no_presets_label.pack(pady = 20)

        back_button = self._create_sound_button(main_frame, "Back", self._open_create_lootcrate_tool, width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        back_button.pack(pady = 20)

    def _open_create_lootcrate_from_scratch(self):
        logging.info("Create Loot Crate from Scratch called")
        self._clear_window()

        try:
            tbl_path = get_current_table_path()
            if not tbl_path or not os.path.exists(tbl_path):
                self._popup_show_info("Error", "No table files found.", sound = "error")
                return
            with open(tbl_path, 'r')as f:
                table_data = json.load(f)
        except Exception as e:
            logging.error(f"Failed to load tables for loot crate creator: {e}")
            self._popup_show_info("Error", f"Failed to load tables: {e}", sound = "error")
            return

        excluded_tables = {"lootcrates", "special_items", "enemy_drops"}
        all_items =[]
        for table_name, items in table_data.get("tables", {}).items():
            if table_name in excluded_tables:
                continue
            if not isinstance(items, list):
                continue
            for item in items:
                if not isinstance(item, dict)or item.get("id")is None:
                    continue
                item_copy = item.copy()
                item_copy["table_category"]= table_name
                all_items.append(item_copy)

        all_items.sort(key = lambda x:x.get("id", 999999))

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew", padx = 10, pady = 10)
        main_frame.grid_rowconfigure(2, weight = 1)
        main_frame.grid_columnconfigure(0, weight = 1)
        main_frame.grid_columnconfigure(1, weight = 0)

        title_label = customtkinter.CTkLabel(main_frame, text = "Create Lootcrate from Scratch", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title_label.grid(row = 0, column = 0, columnspan = 2, pady =(0, 10))

        meta_frame = customtkinter.CTkFrame(main_frame)
        meta_frame.grid(row = 1, column = 0, columnspan = 2, sticky = "ew", padx = 10, pady = 10)
        meta_frame.grid_columnconfigure(1, weight = 1)
        meta_frame.grid_columnconfigure(3, weight = 1)

        name_label = customtkinter.CTkLabel(meta_frame, text = "Name:")
        name_label.grid(row = 0, column = 0, padx = 5, pady = 5, sticky = "w")
        name_entry = customtkinter.CTkEntry(meta_frame, placeholder_text = "Loot Crate Name", width = 200)
        name_entry.grid(row = 0, column = 1, padx = 5, pady = 5, sticky = "w")

        desc_label = customtkinter.CTkLabel(meta_frame, text = "Description:")
        desc_label.grid(row = 0, column = 2, padx =(20, 5), pady = 5, sticky = "w")
        desc_entry = customtkinter.CTkEntry(meta_frame, placeholder_text = "Optional description", width = 300)
        desc_entry.grid(row = 0, column = 3, padx = 5, pady = 5, sticky = "ew")

        locked_var = customtkinter.BooleanVar(value = False)
        locked_check = customtkinter.CTkCheckBox(meta_frame, text = "Locked(requires lockpicking)", variable = locked_var)
        locked_check.grid(row = 1, column = 0, columnspan = 2, padx = 5, pady = 5, sticky = "w")

        pulls_label = customtkinter.CTkLabel(meta_frame, text = "Pulls:")
        pulls_label.grid(row = 1, column = 2, padx =(20, 5), pady = 5, sticky = "w")

        pulls_frame = customtkinter.CTkFrame(meta_frame, fg_color = "transparent")
        pulls_frame.grid(row = 1, column = 3, padx = 5, pady = 5, sticky = "w")

        pulls_min_entry = customtkinter.CTkEntry(pulls_frame, placeholder_text = "Min", width = 60)
        pulls_min_entry.pack(side = "left", padx = 2)
        pulls_min_entry.insert(0, "3")

        pulls_dash = customtkinter.CTkLabel(pulls_frame, text = "-")
        pulls_dash.pack(side = "left", padx = 2)

        pulls_max_entry = customtkinter.CTkEntry(pulls_frame, placeholder_text = "Max", width = 60)
        pulls_max_entry.pack(side = "left", padx = 2)
        pulls_max_entry.insert(0, "3")

        pulls_hint = customtkinter.CTkLabel(pulls_frame, text = "(same for fixed)", font = customtkinter.CTkFont(size = 10), text_color = "gray")
        pulls_hint.pack(side = "left", padx = 5)

        content_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        content_frame.grid(row = 2, column = 0, columnspan = 2, sticky = "nsew", pady = 10)
        content_frame.grid_rowconfigure(0, weight = 1)
        content_frame.grid_columnconfigure(0, weight = 1)
        content_frame.grid_columnconfigure(1, weight = 0)

        left_frame = customtkinter.CTkFrame(content_frame)
        left_frame.grid(row = 0, column = 0, sticky = "nsew", padx =(0, 5))
        left_frame.grid_rowconfigure(2, weight = 1)
        left_frame.grid_columnconfigure(0, weight = 1)

        search_frame = customtkinter.CTkFrame(left_frame, fg_color = "transparent")
        search_frame.grid(row = 0, column = 0, sticky = "ew", padx = 10, pady = 5)
        search_frame.grid_columnconfigure(1, weight = 1)

        search_label = customtkinter.CTkLabel(search_frame, text = "Search(ID or Name):", font = customtkinter.CTkFont(size = 12))
        search_label.grid(row = 0, column = 0, padx =(0, 10), sticky = "w")

        search_entry = customtkinter.CTkEntry(search_frame, placeholder_text = "Enter item ID or name...", width = 250)
        search_entry.grid(row = 0, column = 1, sticky = "ew", padx =(0, 10))

        ITEMS_PER_PAGE = 20
        current_page =[0]
        current_filtered =[all_items]
        search_timer =[None]

        info_label = customtkinter.CTkLabel(search_frame, text = f"Page 1 | {len(all_items)} items", font = customtkinter.CTkFont(size = 10), text_color = "gray")
        info_label.grid(row = 0, column = 2, padx = 5)

        table_filter_frame = customtkinter.CTkFrame(left_frame, fg_color = "transparent")
        table_filter_frame.grid(row = 1, column = 0, sticky = "ew", padx = 10, pady = 5)

        table_filter_label = customtkinter.CTkLabel(table_filter_frame, text = "Filter by table:", font = customtkinter.CTkFont(size = 11))
        table_filter_label.pack(side = "left", padx =(0, 5))

        table_names =["All"]+[t for t in table_data.get("tables", {}).keys()if t not in excluded_tables]
        table_filter_var = customtkinter.StringVar(value = "All")
        table_filter_menu = customtkinter.CTkOptionMenu(table_filter_frame, variable = table_filter_var, values = table_names, width = 150)
        table_filter_menu.pack(side = "left", padx = 5)

        scroll_frame = customtkinter.CTkScrollableFrame(left_frame, width = 550, height = 300)
        scroll_frame.grid(row = 2, column = 0, sticky = "nsew", padx = 5, pady = 5)
        scroll_frame.grid_columnconfigure(0, weight = 1)

        pagination_frame = customtkinter.CTkFrame(left_frame, fg_color = "transparent")
        pagination_frame.grid(row = 3, column = 0, pady = 5)

        right_frame = customtkinter.CTkFrame(content_frame)
        right_frame.grid(row = 0, column = 1, sticky = "nsew", padx =(5, 0))
        right_frame.grid_rowconfigure(1, weight = 1)

        loot_label = customtkinter.CTkLabel(right_frame, text = "Loot Table Entries", font = customtkinter.CTkFont(size = 14, weight = "bold"))
        loot_label.pack(pady = 10)

        loot_count_label = customtkinter.CTkLabel(right_frame, text = "0 entries", font = customtkinter.CTkFont(size = 11), text_color = "gray")
        loot_count_label.pack(pady = 2)

        loot_scroll = customtkinter.CTkScrollableFrame(right_frame, width = 320, height = 280)
        loot_scroll.pack(fill = "both", expand = True, padx = 5, pady = 5)

        loot_entries =[]

        def update_loot_display():
            for widget in loot_scroll.winfo_children():
                widget.destroy()

            loot_count_label.configure(text = f"{len(loot_entries)} entries")

            for idx, entry in enumerate(loot_entries):
                entry_frame = customtkinter.CTkFrame(loot_scroll)
                entry_frame.pack(fill = "x", pady = 2, padx = 2)

                entry_type = entry.get("type")
                if entry_type =="id":
                    item_id = entry.get("id")
                    item_name = entry.get("_display_name", f"ID: {item_id}")
                    rarity = entry.get("rarity", "")
                    rarity_text = f"({rarity})"if rarity else ""
                    text = f"ðŸ“¦ {item_name}{rarity_text}"
                elif entry_type =="table":
                    table_name = entry.get("table", "Unknown")
                    rarity = entry.get("rarity", "Any")
                    text = f"ðŸŽ² Random from '{table_name}'({rarity})"
                else:
                    text = f"? Unknown entry type"

                entry_label = customtkinter.CTkLabel(
                entry_frame,
                text = text,
                font = customtkinter.CTkFont(size = 11),
                anchor = "w",
                wraplength = 250
                )
                entry_label.pack(side = "left", fill = "x", expand = True, padx = 5, pady = 4)

                remove_btn = customtkinter.CTkButton(
                entry_frame,
                text = "X",
                width = 25,
                height = 25,
                font = customtkinter.CTkFont(size = 10),
                fg_color = "darkred",
                hover_color = "red",
                command = lambda i = idx:remove_entry(i)
                )
                remove_btn.pack(side = "right", padx = 2, pady = 2)

        def remove_entry(index):
            if 0 <=index <len(loot_entries):
                loot_entries.pop(index)
                update_loot_display()

        def show_add_item_popup(item):
            self._play_ui_sound("popup")
            popup = customtkinter.CTkToplevel(self.root)
            popup.title("Add Item to Loot Table")
            popup.transient(self.root)
            popup.grab_set()

            item_name = self._format_item_name(item)
            item_rarity = item.get("rarity", "Common")

            title_label = customtkinter.CTkLabel(popup, text = f"Add: {item_name}", font = customtkinter.CTkFont(size = 14, weight = "bold"))
            title_label.pack(pady =(15, 5))

            info_label = customtkinter.CTkLabel(popup, text = f"Item's inherent rarity: {item_rarity}", font = customtkinter.CTkFont(size = 11), text_color = "gray")
            info_label.pack(pady =(0, 10))

            rarity_weights = table_data.get("rarity_weights", {})
            non_rarity_keys = {"Luck Effect", "Special Chance"}
            rarity_options =[k for k in rarity_weights.keys()if k not in non_rarity_keys]

            total_weight = sum(rarity_weights.get(r, 1)for r in rarity_options)

            rarity_frame = customtkinter.CTkFrame(popup)
            rarity_frame.pack(fill = "x", padx = 20, pady = 10)

            rarity_label = customtkinter.CTkLabel(rarity_frame, text = "Select pull rarity(affects drop chance):", font = customtkinter.CTkFont(size = 12))
            rarity_label.pack(anchor = "w", padx = 10, pady = 5)

            selected_rarity = customtkinter.StringVar(value = item_rarity)

            for rarity in rarity_options:
                weight = rarity_weights.get(rarity, 1)
                percentage =(weight /total_weight *100)if total_weight >0 else 0

                radio_frame = customtkinter.CTkFrame(rarity_frame, fg_color = "transparent")
                radio_frame.pack(fill = "x", padx = 10, pady = 2)

                radio = customtkinter.CTkRadioButton(
                radio_frame,
                text = f"{rarity}",
                variable = selected_rarity,
                value = rarity,
                font = customtkinter.CTkFont(size = 12)
                )
                radio.pack(side = "left")

                pct_label = customtkinter.CTkLabel(
                radio_frame,
                text = f"({percentage:.1f}% chance)",
                font = customtkinter.CTkFont(size = 10),
                text_color = "orange"if rarity ==item_rarity else "gray"
                )
                pct_label.pack(side = "left", padx = 10)

                if rarity ==item_rarity:
                    default_label = customtkinter.CTkLabel(
                    radio_frame,
                    text = "â† default",
                    font = customtkinter.CTkFont(size = 10),
                    text_color = "green"
                    )
                    default_label.pack(side = "left")

            hint_label = customtkinter.CTkLabel(popup, text = "Higher rarity = lower weight = rarer drop", font = customtkinter.CTkFont(size = 10), text_color = "gray")
            hint_label.pack(pady = 5)

            button_frame = customtkinter.CTkFrame(popup, fg_color = "transparent")
            button_frame.pack(pady = 15)

            def confirm_add():
                self._play_ui_sound("click")
                entry = {
                "type":"id",
                "id":item.get("id"),
                "rarity":selected_rarity.get(),
                "_display_name":item.get("name", "Unknown")
                }
                loot_entries.append(entry)
                update_loot_display()
                popup.destroy()

            def cancel_add():
                self._play_ui_sound("click")
                popup.destroy()

            add_btn = customtkinter.CTkButton(button_frame, text = "Add Item", command = confirm_add, width = 120, height = 35)
            add_btn.pack(side = "left", padx = 10)

            cancel_btn = customtkinter.CTkButton(button_frame, text = "Cancel", command = cancel_add, width = 120, height = 35)
            cancel_btn.pack(side = "left", padx = 10)

            popup.update_idletasks()
            width = max(420, popup.winfo_reqwidth()+40)
            height = popup.winfo_reqheight()+20
            self._center_popup_on_window(popup, width, height)
            popup.deiconify()
            popup.lift()

        def add_item_entry(item):
            show_add_item_popup(item)

        def add_table_entry(table_name, rarity = "Common"):
            entry = {
            "type":"table",
            "table":table_name,
            "rarity":rarity
            }
            loot_entries.append(entry)
            update_loot_display()

        table_entry_frame = customtkinter.CTkFrame(right_frame)
        table_entry_frame.pack(fill = "x", padx = 5, pady = 5)

        table_entry_label = customtkinter.CTkLabel(table_entry_frame, text = "Add random table entry:", font = customtkinter.CTkFont(size = 11))
        table_entry_label.pack(anchor = "w", padx = 5, pady = 2)

        table_select_frame = customtkinter.CTkFrame(table_entry_frame, fg_color = "transparent")
        table_select_frame.pack(fill = "x", padx = 5, pady = 2)

        avail_tables =[t for t in table_data.get("tables", {}).keys()if t not in excluded_tables]
        table_select_var = customtkinter.StringVar(value = avail_tables[0]if avail_tables else "")
        table_select_menu = customtkinter.CTkOptionMenu(table_select_frame, variable = table_select_var, values = avail_tables, width = 140)
        table_select_menu.pack(side = "left", padx = 2)

        rarity_weights = table_data.get("rarity_weights", {})
        non_rarity_keys = {"Luck Effect", "Special Chance"}
        rarity_options =[k for k in rarity_weights.keys()if k not in non_rarity_keys]
        rarity_select_var = customtkinter.StringVar(value = rarity_options[0]if rarity_options else "Common")
        rarity_select_menu = customtkinter.CTkOptionMenu(table_select_frame, variable = rarity_select_var, values = rarity_options if rarity_options else["Common"], width = 100)
        rarity_select_menu.pack(side = "left", padx = 2)

        add_table_btn = customtkinter.CTkButton(
        table_select_frame,
        text = "+",
        width = 30,
        height = 28,
        command = lambda:add_table_entry(table_select_var.get(), rarity_select_var.get())
        )
        add_table_btn.pack(side = "left", padx = 2)

        clear_btn = customtkinter.CTkButton(
        right_frame,
        text = "Clear All Entries",
        width = 150,
        height = 30,
        fg_color = "darkred",
        hover_color = "red",
        command = lambda:[loot_entries.clear(), update_loot_display()]
        )
        clear_btn.pack(pady = 5)

        def create_item_widget(item):
            item_frame = customtkinter.CTkFrame(scroll_frame)
            item_frame.pack(fill = "x", pady = 2, padx = 3)
            item_frame.grid_columnconfigure(1, weight = 1)

            id_label = customtkinter.CTkLabel(
            item_frame,
            text = f"ID: {item.get('id', 'N/A')}",
            font = customtkinter.CTkFont(size = 11, weight = "bold"),
            width = 70,
            fg_color =("gray75", "gray25"),
            corner_radius = 4
            )
            id_label.grid(row = 0, column = 0, padx = 5, pady = 5, sticky = "w")

            details_frame = customtkinter.CTkFrame(item_frame, fg_color = "transparent")
            details_frame.grid(row = 0, column = 1, sticky = "ew", padx = 5, pady = 5)

            name_label = customtkinter.CTkLabel(
            details_frame,
            text = item.get("name", "Unknown"),
            font = customtkinter.CTkFont(size = 12, weight = "bold"),
            anchor = "w"
            )
            name_label.pack(anchor = "w")

            category_label = customtkinter.CTkLabel(
            details_frame,
            text = f"{item.get('table_category', 'N/A')} | {item.get('rarity', 'N/A')} | ${item.get('value', 0)}",
            font = customtkinter.CTkFont(size = 9),
            text_color = "gray",
            anchor = "w"
            )
            category_label.pack(anchor = "w")

            add_button = self._create_sound_button(
            item_frame,
            "Add",
            lambda it = item:add_item_entry(it),
            width = 60,
            height = 28,
            font = customtkinter.CTkFont(size = 10)
            )
            add_button.grid(row = 0, column = 2, padx = 5, pady = 5)

        def display_page(page_num):
            items = current_filtered[0]
            total_pages = max(1, (len(items)+ITEMS_PER_PAGE -1)//ITEMS_PER_PAGE)

            page_num = max(0, min(page_num, total_pages -1))
            current_page[0]= page_num

            for widget in scroll_frame.winfo_children():
                widget.destroy()

            if not items:
                no_results = customtkinter.CTkLabel(scroll_frame, text = "No items found.", font = customtkinter.CTkFont(size = 12), text_color = "gray")
                no_results.pack(pady = 20)
                info_label.configure(text = "No items found")
                update_pagination_controls(0, 0)
                return

            start_idx = page_num *ITEMS_PER_PAGE
            end_idx = min(start_idx +ITEMS_PER_PAGE, len(items))

            for i in range(start_idx, end_idx):
                create_item_widget(items[i])

            info_label.configure(text = f"Page {page_num +1}/{total_pages} | {len(items)} items")
            update_pagination_controls(page_num, total_pages)

            try:
                scroll_frame._parent_canvas.yview_moveto(0)
            except Exception:
                pass

        def update_pagination_controls(current, total):
            for widget in pagination_frame.winfo_children():
                widget.destroy()

            if total <=1:
                return

            first_btn = customtkinter.CTkButton(
            pagination_frame, text = "<<", width = 35, height = 28,
            command = lambda:display_page(0),
            state = "normal"if current >0 else "disabled"
            )
            first_btn.pack(side = "left", padx = 1)

            prev_btn = customtkinter.CTkButton(
            pagination_frame, text = "<", width = 35, height = 28,
            command = lambda:display_page(current -1),
            state = "normal"if current >0 else "disabled"
            )
            prev_btn.pack(side = "left", padx = 1)

            start_page = max(0, current -2)
            end_page = min(total, start_page +5)
            if end_page -start_page <5:
                start_page = max(0, end_page -5)

            for p in range(start_page, end_page):
                btn = customtkinter.CTkButton(
                pagination_frame,
                text = str(p +1),
                width = 30,
                height = 28,
                fg_color =("gray75", "gray25")if p ==current else None,
                command = lambda page = p:display_page(page)
                )
                btn.pack(side = "left", padx = 1)

            next_btn = customtkinter.CTkButton(
            pagination_frame, text = ">", width = 35, height = 28,
            command = lambda:display_page(current +1),
            state = "normal"if current <total -1 else "disabled"
            )
            next_btn.pack(side = "left", padx = 1)

            last_btn = customtkinter.CTkButton(
            pagination_frame, text = ">>", width = 35, height = 28,
            command = lambda:display_page(total -1),
            state = "normal"if current <total -1 else "disabled"
            )
            last_btn.pack(side = "left", padx = 1)

        def filter_items(*args):
            search_term = search_entry.get().lower().strip()
            table_filter = table_filter_var.get()

            filtered = all_items

            if table_filter !="All":
                filtered =[item for item in filtered if item.get("table_category")==table_filter]

            if search_term:
                filtered =[
                item for item in filtered
                if search_term in str(item.get("id", ""))or search_term in item.get("name", "").lower()
                ]

            current_filtered[0]= filtered
            current_page[0]= 0
            display_page(0)

        def on_search_change(*args):
            if search_timer[0]is not None:
                try:
                    self.root.after_cancel(search_timer[0])
                except Exception:
                    pass
            search_timer[0]= self.root.after(200, filter_items)# type: ignore

        search_entry.bind("<KeyRelease>", on_search_change)
        table_filter_var.trace_add("write", lambda *a:filter_items())

        display_page(0)

        def save_lootcrate(as_preset = False):
            try:
                crate_name = name_entry.get().strip()
                if not crate_name:
                    self._popup_show_info("Error", "Please enter a crate name.", sound = "error")
                    return

                if not loot_entries:
                    self._popup_show_info("Error", "Please add at least one loot entry.", sound = "error")
                    return

                crate_desc = desc_entry.get().strip()
                locked = locked_var.get()

                try:
                    pulls_min = int(pulls_min_entry.get()or 3)
                    pulls_max = int(pulls_max_entry.get()or 3)
                except ValueError:
                    self._popup_show_info("Error", "Pulls must be numbers.", sound = "error")
                    return

                if pulls_min ==pulls_max:
                    pulls = pulls_min
                else:
                    pulls = {"min":min(pulls_min, pulls_max), "max":max(pulls_min, pulls_max)}

                clean_loot_entries =[]
                for entry in loot_entries:
                    clean_entry = {k:v for k, v in entry.items()if not k.startswith("_")}
                    clean_loot_entries.append(clean_entry)

                crate_data = {
                "name":crate_name,
                "description":crate_desc,
                "locked":locked,
                "pulls":pulls,
                "loot_table":clean_loot_entries,
                "created_at":datetime.now().isoformat(),
                "dm_created":True
                }

                if as_preset:
                    os.makedirs(os.path.join("lootcrates", "presets"), exist_ok = True)
                    safe_name = "".join(c if c.isalnum()or c in " _-"else "_"for c in crate_name).strip()
                    filename = os.path.join(
                    "lootcrates", "presets",
                    f"{safe_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}{global_variables['lootcrate_extension']}"
                    )
                else:
                    os.makedirs("lootcrates", exist_ok = True)
                    filename = os.path.join(
                    "lootcrates",
                    f"lootcrate_{datetime.now().strftime('%Y%m%d_%H%M%S')}{global_variables['lootcrate_extension']}"
                    )

                pickled_data = pickle.dumps(crate_data)
                encoded_data = base64.b85encode(pickled_data).decode('utf-8')
                with open(filename, 'w')as f:
                    f.write(encoded_data)

                if as_preset:
                    self._popup_show_info("Success", f"Saved preset '{crate_name}' to presets folder.\nIt will now appear in 'Create from Preset'.", sound = "success")
                    logging.info(f"Saved preset loot crate to {filename}")
                else:
                    self._popup_show_info("Success", f"Generated loot crate '{crate_name}'.", sound = "success")
                    logging.info(f"Generated loot crate file: {filename}")

            except Exception as e:
                logging.error(f"Failed to save loot crate: {e}")
                self._popup_show_info("Error", f"Failed to save loot crate: {e}", sound = "error")

        button_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        button_frame.grid(row = 3, column = 0, columnspan = 2, pady = 10)

        save_crate_btn = self._create_sound_button(
        button_frame,
        "Save Lootcrate",
        lambda:save_lootcrate(as_preset = False),
        width = 180,
        height = 40,
        font = customtkinter.CTkFont(size = 14)
        )
        save_crate_btn.pack(side = "left", padx = 10)

        save_preset_btn = self._create_sound_button(
        button_frame,
        "Save as Preset",
        lambda:save_lootcrate(as_preset = True),
        width = 180,
        height = 40,
        font = customtkinter.CTkFont(size = 14)
        )
        save_preset_btn.pack(side = "left", padx = 10)

        back_btn = self._create_sound_button(
        button_frame,
        "Back",
        self._open_create_lootcrate_tool,
        width = 120,
        height = 40,
        font = customtkinter.CTkFont(size = 14)
        )
        back_btn.pack(side = "left", padx = 10)

    def _open_create_item_transfer_tool(self):
        logging.info("Create Item Transfer tool called")
        self._clear_window()

        try:
            tbl_path = get_current_table_path()
            if not tbl_path or not os.path.exists(tbl_path):
                self._popup_show_info("Error", "No table files found.", sound = "error")
                return
            with open(tbl_path, 'r')as f:
                table_data = json.load(f)
        except Exception as e:
            logging.error(f"Failed to load tables for item transfer: {e}")
            self._popup_show_info("Error", f"Failed to load tables: {e}", sound = "error")
            return

        all_items =[]
        for table_name, items in table_data.get("tables", {}).items():
            if not isinstance(items, list):
                continue
            for item in items:
                if not isinstance(item, dict)or item.get("id")is None:
                    continue
                item_copy = item.copy()
                item_copy["table_category"]= table_name
                all_items.append(item_copy)

        all_items.sort(key = lambda x:x.get("id", 999999))

        if not all_items:
            self._popup_show_info("Error", "No items found in table.", sound = "error")
            return

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew", padx = 20, pady = 20)
        main_frame.grid_rowconfigure(3, weight = 1)
        main_frame.grid_columnconfigure(0, weight = 1)
        main_frame.grid_columnconfigure(1, weight = 0)

        title_label = customtkinter.CTkLabel(main_frame, text = "Create Item Transfer", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title_label.grid(row = 0, column = 0, columnspan = 2, pady =(0, 10))

        top_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        top_frame.grid(row = 1, column = 0, columnspan = 2, sticky = "ew", pady = 10)
        top_frame.grid_columnconfigure(1, weight = 1)

        money_label = customtkinter.CTkLabel(top_frame, text = "Money Amount:")
        money_label.grid(row = 0, column = 0, padx =(0, 10), sticky = "w")
        money_entry = customtkinter.CTkEntry(top_frame, placeholder_text = "0", width = 120)
        money_entry.grid(row = 0, column = 1, sticky = "w", padx =(0, 30))

        search_label = customtkinter.CTkLabel(top_frame, text = "Search(ID or Name):", font = customtkinter.CTkFont(size = 13))
        search_label.grid(row = 0, column = 2, padx =(0, 10), sticky = "w")

        search_entry = customtkinter.CTkEntry(top_frame, placeholder_text = "Enter item ID or name...", width = 250)
        search_entry.grid(row = 0, column = 3, sticky = "ew", padx =(0, 10))

        ITEMS_PER_PAGE = 25
        current_page =[0]
        current_filtered =[all_items]
        search_timer =[None]
        selected_items =[]

        info_label = customtkinter.CTkLabel(top_frame, text = f"Page 1 | {len(all_items)} items total", font = customtkinter.CTkFont(size = 11), text_color = "gray")
        info_label.grid(row = 0, column = 4, padx = 10)

        content_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        content_frame.grid(row = 3, column = 0, columnspan = 2, sticky = "nsew", pady = 10)
        content_frame.grid_rowconfigure(0, weight = 1)
        content_frame.grid_columnconfigure(0, weight = 1)
        content_frame.grid_columnconfigure(1, weight = 0)

        scroll_frame = customtkinter.CTkScrollableFrame(content_frame, width = 600, height = 350)
        scroll_frame.grid(row = 0, column = 0, sticky = "nsew", padx =(0, 10))
        scroll_frame.grid_columnconfigure(0, weight = 1)

        selected_frame = customtkinter.CTkFrame(content_frame)
        selected_frame.grid(row = 0, column = 1, sticky = "nsew")

        selected_label = customtkinter.CTkLabel(selected_frame, text = "Selected Items", font = customtkinter.CTkFont(size = 14, weight = "bold"))
        selected_label.pack(pady = 10)

        selected_count_label = customtkinter.CTkLabel(selected_frame, text = "0 items selected", font = customtkinter.CTkFont(size = 11), text_color = "gray")
        selected_count_label.pack(pady = 5)

        selected_scroll = customtkinter.CTkScrollableFrame(selected_frame, width = 280, height = 300)
        selected_scroll.pack(fill = "both", expand = True, padx = 5, pady = 5)

        def update_selected_display():
            for widget in selected_scroll.winfo_children():
                widget.destroy()

            selected_count_label.configure(text = f"{len(selected_items)} item(s) selected")

            for idx, item in enumerate(selected_items):
                item_row = customtkinter.CTkFrame(selected_scroll)
                item_row.pack(fill = "x", pady = 2, padx = 2)

                item_label = customtkinter.CTkLabel(
                item_row,
                text = f"ID {item.get('id', '?')}: {self._format_item_name(item)[:25]}",
                font = customtkinter.CTkFont(size = 11),
                anchor = "w"
                )
                item_label.pack(side = "left", fill = "x", expand = True, padx = 5)

                remove_btn = customtkinter.CTkButton(
                item_row,
                text = "X",
                width = 25,
                height = 25,
                font = customtkinter.CTkFont(size = 10),
                fg_color = "darkred",
                hover_color = "red",
                command = lambda i = idx:remove_item(i)
                )
                remove_btn.pack(side = "right", padx = 2)

        def remove_item(index):
            if 0 <=index <len(selected_items):
                selected_items.pop(index)
                update_selected_display()
                display_page(current_page[0])

        def add_item_to_transfer(item):
            item_copy = item.copy()
            selected_items.append(item_copy)
            update_selected_display()
            display_page(current_page[0])

        def is_item_selected(item):
            item_id = item.get("id")
            for sel in selected_items:
                if sel.get("id")==item_id:
                    return True
            return False

        pagination_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        pagination_frame.grid(row = 4, column = 0, columnspan = 2, pady = 5)

        def create_item_widget(item):
            item_frame = customtkinter.CTkFrame(scroll_frame)
            item_frame.pack(fill = "x", pady = 3, padx = 5)
            item_frame.grid_columnconfigure(1, weight = 1)

            id_label = customtkinter.CTkLabel(
            item_frame,
            text = f"ID: {item.get('id', 'N/A')}",
            font = customtkinter.CTkFont(size = 12, weight = "bold"),
            width = 80,
            fg_color =("gray75", "gray25"),
            corner_radius = 6
            )
            id_label.grid(row = 0, column = 0, padx = 8, pady = 8, sticky = "w")

            details_frame = customtkinter.CTkFrame(item_frame, fg_color = "transparent")
            details_frame.grid(row = 0, column = 1, sticky = "ew", padx = 8, pady = 8)

            name_label = customtkinter.CTkLabel(
            details_frame,
            text = item.get("name", "Unknown"),
            font = customtkinter.CTkFont(size = 13, weight = "bold"),
            anchor = "w"
            )
            name_label.pack(anchor = "w")

            category_label = customtkinter.CTkLabel(
            details_frame,
            text = f"{item.get('table_category', 'N/A')} | {item.get('rarity', 'N/A')} | ${item.get('value', 0)}",
            font = customtkinter.CTkFont(size = 10),
            text_color = "gray",
            anchor = "w"
            )
            category_label.pack(anchor = "w")

            already_selected = is_item_selected(item)
            add_button = self._create_sound_button(
            item_frame,
            "Added"if already_selected else "Add",
            lambda it = item:add_item_to_transfer(it),
            width = 80,
            height = 30,
            font = customtkinter.CTkFont(size = 11)
            )
            if already_selected:
                add_button.configure(state = "disabled", fg_color = "gray")
            add_button.grid(row = 0, column = 2, padx = 8, pady = 8)

        def display_page(page_num):
            items = current_filtered[0]
            total_pages = max(1, (len(items)+ITEMS_PER_PAGE -1)//ITEMS_PER_PAGE)

            page_num = max(0, min(page_num, total_pages -1))
            current_page[0]= page_num

            for widget in scroll_frame.winfo_children():
                widget.destroy()

            if not items:
                no_results = customtkinter.CTkLabel(scroll_frame, text = "No items found.", font = customtkinter.CTkFont(size = 14), text_color = "gray")
                no_results.pack(pady = 20)
                info_label.configure(text = "No items found")
                update_pagination_controls(0, 0)
                return

            start_idx = page_num *ITEMS_PER_PAGE
            end_idx = min(start_idx +ITEMS_PER_PAGE, len(items))

            for i in range(start_idx, end_idx):
                create_item_widget(items[i])

            info_label.configure(text = f"Page {page_num +1} of {total_pages} | {len(items)} items total")

            update_pagination_controls(page_num, total_pages)

            try:
                scroll_frame._parent_canvas.yview_moveto(0)
            except Exception:
                pass

        def update_pagination_controls(current, total):
            for widget in pagination_frame.winfo_children():
                widget.destroy()

            if total <=1:
                return

            first_btn = customtkinter.CTkButton(
            pagination_frame, text = "<<", width = 40, height = 30,
            command = lambda:display_page(0),
            state = "normal"if current >0 else "disabled"
            )
            first_btn.pack(side = "left", padx = 2)

            prev_btn = customtkinter.CTkButton(
            pagination_frame, text = "<", width = 40, height = 30,
            command = lambda:display_page(current -1),
            state = "normal"if current >0 else "disabled"
            )
            prev_btn.pack(side = "left", padx = 2)

            start_page = max(0, current -3)
            end_page = min(total, start_page +7)
            if end_page -start_page <7:
                start_page = max(0, end_page -7)

            for p in range(start_page, end_page):
                btn = customtkinter.CTkButton(
                pagination_frame,
                text = str(p +1),
                width = 35,
                height = 30,
                fg_color =("gray75", "gray25")if p ==current else None,
                command = lambda page = p:display_page(page)
                )
                btn.pack(side = "left", padx = 1)

            next_btn = customtkinter.CTkButton(
            pagination_frame, text = ">", width = 40, height = 30,
            command = lambda:display_page(current +1),
            state = "normal"if current <total -1 else "disabled"
            )
            next_btn.pack(side = "left", padx = 2)

            last_btn = customtkinter.CTkButton(
            pagination_frame, text = ">>", width = 40, height = 30,
            command = lambda:display_page(total -1),
            state = "normal"if current <total -1 else "disabled"
            )
            last_btn.pack(side = "left", padx = 2)

        def filter_items(search_term):
            search_lower = search_term.lower().strip()

            if search_lower:
                filtered =[
                item for item in all_items
                if search_lower in str(item.get("id", ""))or search_lower in item.get("name", "").lower()
                ]
            else:
                filtered = all_items

            current_filtered[0]= filtered
            current_page[0]= 0
            display_page(0)

        def on_search_change(*args):
            if search_timer[0]is not None:
                try:
                    self.root.after_cancel(search_timer[0])
                except Exception:
                    pass

            search_timer[0]= self.root.after(200, lambda:filter_items(search_entry.get()))# type: ignore

        search_entry.bind("<KeyRelease>", on_search_change)

        display_page(0)

        def save_transfer():
            try:
                transfer_money = int(money_entry.get()or 0)
            except ValueError:
                self._popup_show_info("Error", "Money amount must be a number.", sound = "error")
                return
            try:
                if not selected_items and transfer_money ==0:
                    self._popup_show_info("Error", "Add money or select at least one item.", sound = "error")
                    return
                items_to_send =[]
                for item in selected_items:
                    itm = {k:v for k, v in item.items()if k !="table_category"}
                    itm = add_subslots_to_item(itm)
                    items_to_send.append(itm)
                transfer_data = {
                "money":transfer_money,
                "items":items_to_send,
                "timestamp":datetime.now().isoformat(),
                "from_character":"DM"
                }
                pickled_data = pickle.dumps(transfer_data)
                encoded_data = base64.b85encode(pickled_data).decode('utf-8')
                os.makedirs("transfers", exist_ok = True)
                filename = os.path.join("transfers", f"transfer_dm_{datetime.now().strftime('%Y%m%d_%H%M%S')}{global_variables['transfer_extension']}")
                with open(filename, 'w')as f:
                    f.write(encoded_data)
                self._popup_show_info("Success", f"Saved transfer with ${transfer_money} and {len(items_to_send)} items.", sound = "success")
                logging.info(f"Saved DM transfer to {filename}")
                self._open_dm_tools()
            except Exception as e:
                logging.error(f"Failed to save item transfer: {e}")
                self._popup_show_info("Error", f"Failed to save item transfer: {e}", sound = "error")

        def clear_selected():
            selected_items.clear()
            update_selected_display()
            display_page(current_page[0])

        button_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        button_frame.grid(row = 5, column = 0, columnspan = 2, pady = 10)

        clear_button = self._create_sound_button(button_frame, "Clear Selection", clear_selected, width = 150, height = 40, font = customtkinter.CTkFont(size = 14))
        clear_button.pack(side = "left", padx = 10)

        save_button = self._create_sound_button(button_frame, "Save Transfer", save_transfer, width = 200, height = 40, font = customtkinter.CTkFont(size = 14))
        save_button.pack(side = "left", padx = 10)

        back_button = self._create_sound_button(button_frame, "Back to DM Tools", lambda:[self._clear_window(), self._open_dm_tools()], width = 200, height = 40, font = customtkinter.CTkFont(size = 14))
        back_button.pack(side = "left", padx = 10)

    def _open_create_magazine_transfer_tool(self):

        logging.info("Create Loaded Magazine Transfer tool called")

        try:
            tbl_path = get_current_table_path()
            if not tbl_path or not os.path.exists(tbl_path):
                self._popup_show_info("Error", "No table file found.", sound = "error")
                return
            with open(tbl_path, 'r')as f:
                table_data = json.load(f)
        except Exception as e:
            logging.error(f"Failed to load table: {e}")
            self._popup_show_info("Error", f"Failed to load table: {e}", sound = "error")
            return

        magazines = table_data.get("tables", {}).get("magazines", [])

        if not magazines:
            self._popup_show_info("Error", "No magazines found in table.", sound = "error")
            return

        all_magazines = sorted(magazines, key = lambda x:x.get("name", "").lower())

        self._clear_window()
        self._play_ui_sound("whoosh1")

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew", padx = 20, pady = 20)
        main_frame.grid_rowconfigure(2, weight = 1)
        main_frame.grid_columnconfigure(0, weight = 1)

        title_label = customtkinter.CTkLabel(
        main_frame,
        text = "Create Loaded Magazine Transfer",
        font = customtkinter.CTkFont(size = 24, weight = "bold")
        )
        title_label.grid(row = 0, column = 0, pady =(0, 10))

        top_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        top_frame.grid(row = 1, column = 0, sticky = "ew", pady = 10)
        top_frame.grid_columnconfigure(1, weight = 1)

        search_label = customtkinter.CTkLabel(top_frame, text = "Search(Name or Caliber):", font = customtkinter.CTkFont(size = 13))
        search_label.grid(row = 0, column = 0, padx =(0, 10), sticky = "w")

        search_entry = customtkinter.CTkEntry(top_frame, placeholder_text = "Enter magazine name or caliber...", width = 300)
        search_entry.grid(row = 0, column = 1, sticky = "w", padx =(0, 20))

        ITEMS_PER_PAGE = 20
        current_page =[0]
        current_filtered =[all_magazines]
        search_timer =[None]

        info_label = customtkinter.CTkLabel(top_frame, text = f"Page 1 | {len(all_magazines)} magazines total", font = customtkinter.CTkFont(size = 11), text_color = "gray")
        info_label.grid(row = 0, column = 2, padx = 10)

        scroll_frame = customtkinter.CTkScrollableFrame(main_frame, height = 400)
        scroll_frame.grid(row = 2, column = 0, sticky = "nsew", pady = 10)
        scroll_frame.grid_columnconfigure(0, weight = 1)

        pagination_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        pagination_frame.grid(row = 3, column = 0, pady = 5)

        def create_mag_widget(mag):
            mag_frame = customtkinter.CTkFrame(scroll_frame)
            mag_frame.pack(fill = "x", pady = 3, padx = 5)
            mag_frame.grid_columnconfigure(1, weight = 1)

            mag_info = f"{mag.get('name', 'Unknown')}"
            mag_details = f"Caliber: {', '.join(mag.get('caliber', ['Unknown']))} | Capacity: {mag.get('capacity', 0)}"
            if mag.get("magazinesystem"):
                mag_details +=f" | System: {mag.get('magazinesystem')}"

            name_label = customtkinter.CTkLabel(
            mag_frame,
            text = mag_info,
            font = customtkinter.CTkFont(size = 13, weight = "bold"),
            anchor = "w"
            )
            name_label.grid(row = 0, column = 0, padx = 10, pady =(8, 2), sticky = "w")

            details_label = customtkinter.CTkLabel(
            mag_frame,
            text = mag_details,
            font = customtkinter.CTkFont(size = 11),
            text_color = "gray",
            anchor = "w"
            )
            details_label.grid(row = 1, column = 0, padx = 10, pady =(0, 8), sticky = "w")

            def create_mag_transfer(m = mag):
                self._create_loaded_magazine_dialog(m, table_data)

            create_btn = self._create_sound_button(
            mag_frame,
            text = "Create Transfer",
            command = create_mag_transfer,
            width = 140,
            height = 32
            )
            create_btn.grid(row = 0, column = 1, rowspan = 2, padx = 10, pady = 8, sticky = "e")

        def display_page(page_num):
            items = current_filtered[0]
            total_pages = max(1, (len(items)+ITEMS_PER_PAGE -1)//ITEMS_PER_PAGE)
            page_num = max(0, min(page_num, total_pages -1))
            current_page[0]= page_num

            for widget in scroll_frame.winfo_children():
                widget.destroy()

            if not items:
                no_results = customtkinter.CTkLabel(scroll_frame, text = "No magazines found.", font = customtkinter.CTkFont(size = 14), text_color = "gray")
                no_results.pack(pady = 20)
                info_label.configure(text = "No magazines found")
                update_pagination_controls(0, 0)
                return

            start_idx = page_num *ITEMS_PER_PAGE
            end_idx = min(start_idx +ITEMS_PER_PAGE, len(items))

            for i in range(start_idx, end_idx):
                create_mag_widget(items[i])

            info_label.configure(text = f"Page {page_num +1} of {total_pages} | {len(items)} magazines total")
            update_pagination_controls(page_num, total_pages)

            try:
                scroll_frame._parent_canvas.yview_moveto(0)
            except Exception:
                pass

        def update_pagination_controls(current, total):
            for widget in pagination_frame.winfo_children():
                widget.destroy()

            if total <=1:
                return

            first_btn = customtkinter.CTkButton(pagination_frame, text = "<<", width = 40, height = 30, command = lambda:display_page(0), state = "normal"if current >0 else "disabled")
            first_btn.pack(side = "left", padx = 2)

            prev_btn = customtkinter.CTkButton(pagination_frame, text = "<", width = 40, height = 30, command = lambda:display_page(current -1), state = "normal"if current >0 else "disabled")
            prev_btn.pack(side = "left", padx = 2)

            start_page = max(0, current -3)
            end_page = min(total, start_page +7)
            if end_page -start_page <7:
                start_page = max(0, end_page -7)

            for p in range(start_page, end_page):
                btn = customtkinter.CTkButton(pagination_frame, text = str(p +1), width = 35, height = 30, fg_color =("gray75", "gray25")if p ==current else None, command = lambda page = p:display_page(page))
                btn.pack(side = "left", padx = 1)

            next_btn = customtkinter.CTkButton(pagination_frame, text = ">", width = 40, height = 30, command = lambda:display_page(current +1), state = "normal"if current <total -1 else "disabled")
            next_btn.pack(side = "left", padx = 2)

            last_btn = customtkinter.CTkButton(pagination_frame, text = ">>", width = 40, height = 30, command = lambda:display_page(total -1), state = "normal"if current <total -1 else "disabled")
            last_btn.pack(side = "left", padx = 2)

        def filter_magazines(search_term):
            search_lower = search_term.lower().strip()

            if search_lower:
                filtered =[
                mag for mag in all_magazines
                if search_lower in mag.get("name", "").lower()
                or any(search_lower in cal.lower()for cal in mag.get("caliber", []))
                or search_lower in mag.get("magazinesystem", "").lower()
                ]
            else:
                filtered = all_magazines

            current_filtered[0]= filtered
            current_page[0]= 0
            display_page(0)

        def on_search_change(*args):
            if search_timer[0]is not None:
                try:
                    self.root.after_cancel(search_timer[0])
                except Exception:
                    pass
            search_timer[0]= self.root.after(200, lambda:filter_magazines(search_entry.get()))# type: ignore

        search_entry.bind("<KeyRelease>", on_search_change)

        display_page(0)

        back_button = self._create_sound_button(
        main_frame,
        text = "Back to DM Tools",
        command = lambda:[self._clear_window(), self._open_dm_tools()],
        width = 300,
        height = 50,
        font = customtkinter.CTkFont(size = 16)
        )
        back_button.grid(row = 4, column = 0, pady = 20)

    def _create_loaded_magazine_dialog(self, magazine, table_data):

        dialog = customtkinter.CTkToplevel(self.root)
        dialog.title(f"Create: {magazine.get('name', 'Magazine')}")
        dialog.transient(self.root)
        self._center_popup_on_window(dialog, 600, 700)
        try:
            dialog.wait_visibility()
            dialog.grab_set()
        except Exception as e:
            logging.warning("Dialog grab_set failed: %s", e)

        customtkinter.CTkLabel(
        dialog,
        text = f"Configure {magazine.get('name', 'Magazine')}",
        font = customtkinter.CTkFont(size = 16, weight = "bold")
        ).pack(pady = 10)

        quantity_frame = customtkinter.CTkFrame(dialog)
        quantity_frame.pack(fill = "x", padx = 20, pady = 10)

        customtkinter.CTkLabel(
        quantity_frame,
        text = "Number of magazines:",
        font = customtkinter.CTkFont(size = 12)
        ).pack(side = "left", padx = 10)

        quantity_var = customtkinter.StringVar(value = "1")
        quantity_entry = customtkinter.CTkEntry(quantity_frame, textvariable = quantity_var, width = 100)
        quantity_entry.pack(side = "right", padx = 10)

        customtkinter.CTkLabel(
        dialog,
        text = "Select ammunition type:",
        font = customtkinter.CTkFont(size = 14, weight = "bold")
        ).pack(pady = 10)

        mag_calibers = magazine.get("caliber", [])
        ammunition_table = table_data.get("tables", {}).get("ammunition", [])

        compatible_ammo =[
        ammo for ammo in ammunition_table
        if ammo.get("caliber")in mag_calibers
        ]

        if not compatible_ammo:
            customtkinter.CTkLabel(
            dialog,
            text = "No compatible ammunition found!",
            font = customtkinter.CTkFont(size = 12),
            text_color = "red"
            ).pack(pady = 20)

            self._create_sound_button(
            dialog,
            text = "Close",
            command = dialog.destroy,
            fg_color = "#8B0000"
            ).pack(pady = 10)
            return

        selected_ammo = customtkinter.StringVar(value = compatible_ammo[0].get("name", ""))
        selected_variant = customtkinter.StringVar(value = "")

        ammo_scroll = customtkinter.CTkScrollableFrame(dialog, height = 200)
        ammo_scroll.pack(fill = "x", padx = 20, pady = 10)

        for ammo in compatible_ammo:
            ammo_frame = customtkinter.CTkFrame(ammo_scroll)
            ammo_frame.pack(fill = "x", pady = 2)

            radio = customtkinter.CTkRadioButton(
            ammo_frame,
            text = ammo.get("name", "Unknown"),
            variable = selected_ammo,
            value = ammo.get("name", ""),
            font = customtkinter.CTkFont(size = 12)
            )
            radio.pack(anchor = "w", padx = 10, pady = 5)

            if ammo.get("variants"):
                variant_frame = customtkinter.CTkFrame(ammo_frame)
                variant_frame.pack(fill = "x", padx = 30)

                for variant in ammo["variants"]:
                    var_radio = customtkinter.CTkRadioButton(
                    variant_frame,
                    text = variant.get("name", "Unknown Variant"),
                    variable = selected_variant,
                    value = f"{ammo.get('name')}|{variant.get('name')}",
                    font = customtkinter.CTkFont(size = 11)
                    )
                    var_radio.pack(anchor = "w", padx = 10, pady = 2)

        fill_frame = customtkinter.CTkFrame(dialog)
        fill_frame.pack(fill = "x", padx = 20, pady = 10)

        customtkinter.CTkLabel(
        fill_frame,
        text = "Fill level(% of capacity):",
        font = customtkinter.CTkFont(size = 12)
        ).pack(side = "left", padx = 10)

        fill_var = customtkinter.StringVar(value = "100")
        fill_entry = customtkinter.CTkEntry(fill_frame, textvariable = fill_var, width = 100)
        fill_entry.pack(side = "right", padx = 10)

        def create_transfer():
            try:
                qty = int(quantity_var.get())
                fill_percent = int(fill_var.get())

                if qty <=0 or fill_percent <0 or fill_percent >100:
                    raise ValueError("Invalid quantity or fill percentage")

                ammo_obj = None
                for ammo in compatible_ammo:
                    if ammo.get("name")==selected_ammo.get():
                        ammo_obj = ammo
                        break

                if not ammo_obj:
                    raise ValueError("No ammunition selected")

                variant_info = None
                if selected_variant.get():
                    variant_parts = selected_variant.get().split("|")
                    if len(variant_parts)==2:
                        for var in ammo_obj.get("variants", []):
                            if var.get("name")==variant_parts[1]:
                                variant_info = var
                                break

                if not variant_info:
                    variants = ammo_obj.get("variants", [])
                    if variants:
                        variant_info = variants[0]

                magazines =[]
                capacity = magazine.get("capacity", 30)
                rounds_to_load = int(capacity *(fill_percent /100.0))

                for i in range(qty):
                    mag_copy = json.loads(json.dumps(magazine))
                    mag_copy["rounds"]=[]

                    if not mag_copy.get("magazinesystem"):
                        mag_copy["magazinesystem"]= magazine.get("magazinesystem", "Unknown")

                    for j in range(rounds_to_load):
                        caliber = ammo_obj.get("caliber", "Unknown")
                        if isinstance(caliber, list):
                            caliber = caliber[0]if caliber else "Unknown"

                        round_data = {
                        "caliber":caliber,
                        "name":f"{caliber} | {variant_info.get('name', 'FMJ')if variant_info else 'FMJ'}",
                        "variant":variant_info.get("name", "FMJ")if variant_info else "FMJ"
                        }

                        if variant_info:
                            if variant_info.get("type"):
                                round_data["type"]= variant_info.get("type")
                            if variant_info.get("pen"):
                                round_data["pen"]= variant_info.get("pen")
                            if variant_info.get("tip"):
                                round_data["tip"]= variant_info.get("tip")
                            if variant_info.get("modifiers"):
                                round_data["modifiers"]= variant_info.get("modifiers")

                        mag_copy["rounds"].append(round_data)

                    magazines.append(mag_copy)

                self._save_magazine_transfer(magazines)
                dialog.destroy()

            except ValueError as e:
                self._popup_show_info("Error", f"Invalid input: {e}", sound = "error")

        self._create_sound_button(
        dialog,
        text = "Create Transfer",
        command = create_transfer,
        width = 200
        ).pack(pady = 10)

        self._create_sound_button(
        dialog,
        text = "Cancel",
        command = dialog.destroy,
        fg_color = "#8B0000",
        width = 200
        ).pack(pady = 5)

    def _save_magazine_transfer(self, magazines):

        try:
            transfer_data = {
            "type":"magazines",
            "items":magazines,
            "timestamp":datetime.now().isoformat()
            }

            mag_name = magazines[0].get("name", "magazine").replace(" ", "_").lower()
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"mag_{mag_name}_{len(magazines)}x_{timestamp}.sldtrf"
            filepath = os.path.join("transfers", filename)

            os.makedirs("transfers", exist_ok = True)

            with open(filepath, 'wb')as f:
                pickled = pickle.dumps(transfer_data)
                encoded = base64.b85encode(pickled)
                f.write(encoded)

            logging.info(f"Saved magazine transfer: {filepath}")
            self._popup_show_info("Success", f"Magazine transfer saved as:\n{filename}", sound = "success")

        except Exception as e:
            logging.error(f"Failed to save magazine transfer: {e}")
            self._popup_show_info("Error", f"Failed to save: {e}", sound = "error")

    def _open_create_belt_transfer_tool(self):

        logging.info("Create Belt Transfer tool called")

        try:
            tbl_path = get_current_table_path()
            if not tbl_path or not os.path.exists(tbl_path):
                self._popup_show_info("Error", "No table file found.", sound = "error")
                return
            with open(tbl_path, 'r')as f:
                table_data = json.load(f)
        except Exception as e:
            logging.error(f"Failed to load table: {e}")
            self._popup_show_info("Error", f"Failed to load table: {e}", sound = "error")
            return

        magazines = table_data.get("tables", {}).get("magazines", [])
        belt_links =[mag for mag in magazines if mag.get("beltlink")]

        if not belt_links:
            self._popup_show_info("Error", "No belt links found in table.", sound = "error")
            return

        self._clear_window()
        self._play_ui_sound("whoosh1")

        main_frame = customtkinter.CTkScrollableFrame(self.root, fg_color = "transparent")
        main_frame.pack(fill = "both", expand = True, padx = 20, pady = 20)

        title_label = customtkinter.CTkLabel(
        main_frame,
        text = "Create Loaded Belt Transfer",
        font = customtkinter.CTkFont(size = 24, weight = "bold")
        )
        title_label.pack(pady = 20)

        customtkinter.CTkLabel(
        main_frame,
        text = "Select a belt link type to create:",
        font = customtkinter.CTkFont(size = 14)
        ).pack(pady = 10)

        for belt in belt_links:
            belt_frame = customtkinter.CTkFrame(main_frame)
            belt_frame.pack(fill = "x", pady = 5, padx = 20)

            belt_info = f"{belt.get('name', 'Unknown')}\n"
            belt_info +=f"Caliber: {', '.join(belt.get('caliber', ['Unknown']))}\n"
            belt_info +=f"Belt Link: {belt.get('beltlink')}"

            customtkinter.CTkLabel(
            belt_frame,
            text = belt_info,
            font = customtkinter.CTkFont(size = 12),
            justify = "left"
            ).pack(side = "left", padx = 10, pady = 10)

            def create_belt_transfer(b = belt):
                self._create_loaded_belt_dialog(b, table_data)

            self._create_sound_button(
            belt_frame,
            text = "Create Transfer",
            command = create_belt_transfer,
            width = 150
            ).pack(side = "right", padx = 10, pady = 5)

        back_button = self._create_sound_button(
        main_frame,
        text = "Back to DM Tools",
        command = lambda:[self._clear_window(), self._open_dm_tools()],
        width = 300,
        height = 50,
        font = customtkinter.CTkFont(size = 16)
        )
        back_button.pack(pady = 20)

    def _create_loaded_belt_dialog(self, belt_link, table_data):

        dialog = customtkinter.CTkToplevel(self.root)
        dialog.title(f"Create: {belt_link.get('name', 'Belt')}")
        dialog.transient(self.root)
        self._center_popup_on_window(dialog, 600, 700)
        dialog.grab_set()

        customtkinter.CTkLabel(
        dialog,
        text = f"Configure {belt_link.get('name', 'Belt')}",
        font = customtkinter.CTkFont(size = 16, weight = "bold")
        ).pack(pady = 10)

        count_frame = customtkinter.CTkFrame(dialog)
        count_frame.pack(fill = "x", padx = 20, pady = 10)

        customtkinter.CTkLabel(
        count_frame,
        text = "Number of rounds in belt:",
        font = customtkinter.CTkFont(size = 12)
        ).pack(side = "left", padx = 10)

        count_var = customtkinter.StringVar(value = "100")
        count_entry = customtkinter.CTkEntry(count_frame, textvariable = count_var, width = 100)
        count_entry.pack(side = "right", padx = 10)

        customtkinter.CTkLabel(
        dialog,
        text = "Select ammunition type:",
        font = customtkinter.CTkFont(size = 14, weight = "bold")
        ).pack(pady = 10)

        belt_calibers = belt_link.get("caliber", [])
        ammunition_table = table_data.get("tables", {}).get("ammunition", [])

        compatible_ammo =[
        ammo for ammo in ammunition_table
        if ammo.get("caliber")in belt_calibers
        ]

        if not compatible_ammo:
            customtkinter.CTkLabel(
            dialog,
            text = "No compatible ammunition found!",
            font = customtkinter.CTkFont(size = 12),
            text_color = "red"
            ).pack(pady = 20)

            self._create_sound_button(
            dialog,
            text = "Close",
            command = dialog.destroy,
            fg_color = "#8B0000"
            ).pack(pady = 10)
            return

        selected_ammo = customtkinter.StringVar(value = compatible_ammo[0].get("name", ""))
        selected_variant = customtkinter.StringVar(value = "")

        ammo_scroll = customtkinter.CTkScrollableFrame(dialog, height = 250)
        ammo_scroll.pack(fill = "x", padx = 20, pady = 10)

        for ammo in compatible_ammo:
            ammo_frame = customtkinter.CTkFrame(ammo_scroll)
            ammo_frame.pack(fill = "x", pady = 2)

            radio = customtkinter.CTkRadioButton(
            ammo_frame,
            text = ammo.get("name", "Unknown"),
            variable = selected_ammo,
            value = ammo.get("name", ""),
            font = customtkinter.CTkFont(size = 12)
            )
            radio.pack(anchor = "w", padx = 10, pady = 5)

            if ammo.get("variants"):
                variant_frame = customtkinter.CTkFrame(ammo_frame)
                variant_frame.pack(fill = "x", padx = 30)

                for variant in ammo["variants"]:
                    var_radio = customtkinter.CTkRadioButton(
                    variant_frame,
                    text = variant.get("name", "Unknown Variant"),
                    variable = selected_variant,
                    value = f"{ammo.get('name')}|{variant.get('name')}",
                    font = customtkinter.CTkFont(size = 11)
                    )
                    var_radio.pack(anchor = "w", padx = 10, pady = 2)

        def create_transfer():
            try:
                round_count = int(count_var.get())

                if round_count <=0:
                    raise ValueError("Invalid round count")

                ammo_obj = None
                for ammo in compatible_ammo:
                    if ammo.get("name")==selected_ammo.get():
                        ammo_obj = ammo
                        break

                if not ammo_obj:
                    raise ValueError("No ammunition selected")

                belt_copy = json.loads(json.dumps(belt_link))
                belt_copy["rounds"]=[]

                variant_info = None
                if selected_variant.get():
                    variant_parts = selected_variant.get().split("|")
                    if len(variant_parts)==2:
                        for var in ammo_obj.get("variants", []):
                            if var.get("name")==variant_parts[1]:
                                variant_info = var
                                break

                if not variant_info:
                    variants = ammo_obj.get("variants", [])
                    if variants:
                        variant_info = variants[0]

                for i in range(round_count):
                    caliber = ammo_obj.get("caliber")
                    if isinstance(caliber, list):
                        caliber = caliber[0]if caliber else "Unknown"

                    round_data = {
                    "caliber":caliber,
                    "name":f"{caliber} | {variant_info.get('name', 'FMJ')if variant_info else 'FMJ'}",
                    "variant":variant_info.get("name", "FMJ")if variant_info else "FMJ"
                    }

                    if variant_info:
                        if variant_info.get("type"):
                            round_data["type"]= variant_info.get("type")
                        if variant_info.get("pen"):
                            round_data["pen"]= variant_info.get("pen")
                        if variant_info.get("tip"):
                            round_data["tip"]= variant_info.get("tip")
                        if variant_info.get("modifiers"):
                            round_data["modifiers"]= variant_info.get("modifiers")

                    belt_copy["rounds"].append(round_data)

                self._save_belt_transfer(belt_copy, round_count)
                dialog.destroy()

            except ValueError as e:
                self._popup_show_info("Error", f"Invalid input: {e}", sound = "error")

        self._create_sound_button(
        dialog,
        text = "Create Transfer",
        command = create_transfer,
        width = 200
        ).pack(pady = 10)

        self._create_sound_button(
        dialog,
        text = "Cancel",
        command = dialog.destroy,
        fg_color = "#8B0000",
        width = 200
        ).pack(pady = 5)

    def _save_belt_transfer(self, belt, round_count):

        try:
            transfer_data = {
            "type":"belt",
            "items":[belt],
            "timestamp":datetime.now().isoformat()
            }

            belt_name = belt.get("beltlink", "belt").replace(" ", "_").lower()
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"belt_{belt_name}_{round_count}rds_{timestamp}.sldtrf"
            filepath = os.path.join("transfers", filename)

            os.makedirs("transfers", exist_ok = True)

            with open(filepath, 'wb')as f:
                pickled = pickle.dumps(transfer_data)
                encoded = base64.b85encode(pickled)
                f.write(encoded)

            logging.info(f"Saved belt transfer: {filepath}")
            self._popup_show_info("Success", f"Belt transfer saved as:\n{filename}", sound = "success")

        except Exception as e:
            logging.error(f"Failed to save belt transfer: {e}")
            self._popup_show_info("Error", f"Failed to save: {e}", sound = "error")

    def _open_modify_settings_tool(self):

        logging.info("Modify Settings tool called")

        try:
            tbl_path = get_current_table_path()
            if not tbl_path or not os.path.exists(tbl_path):
                self._popup_show_info("Error", "No table file found.", sound = "error")
                return
            with open(tbl_path, 'r')as f:
                table_data = json.load(f)
        except Exception as e:
            logging.error(f"Failed to load table: {e}")
            self._popup_show_info("Error", f"Failed to load table: {e}", sound = "error")
            return

        dm_settings_path = os.path.join(saves_folder or "saves", "dm_settings.sldsv")
        dm_settings = {"enabled_enemies":{}}

        if os.path.exists(dm_settings_path):
            try:
                with open(dm_settings_path, 'r')as f:
                    dm_settings = json.load(f)
                    if "enabled_enemies"not in dm_settings:
                        dm_settings["enabled_enemies"]= {}
            except Exception as e:
                logging.warning(f"Failed to load DM settings: {e}")

        enemy_list = table_data.get("tables", {}).get("enemy_drops", [])

        for enemy in enemy_list:
            enemy_name = enemy.get("name")
            if enemy_name and enemy_name not in dm_settings["enabled_enemies"]:
                dm_settings["enabled_enemies"][enemy_name]= True

        self._clear_window()
        self._play_ui_sound("whoosh1")

        main_frame = customtkinter.CTkScrollableFrame(self.root, fg_color = "transparent")
        main_frame.pack(fill = "both", expand = True, padx = 20, pady = 20)

        title_label = customtkinter.CTkLabel(
        main_frame,
        text = "DM Settings - Enemy Spawn Control",
        font = customtkinter.CTkFont(size = 24, weight = "bold")
        )
        title_label.pack(pady = 20)

        customtkinter.CTkLabel(
        main_frame,
        text = "Toggle enemies on/off for encounter rolls and loot generation:",
        font = customtkinter.CTkFont(size = 14)
        ).pack(pady = 10)

        enemy_vars = {}

        for enemy in enemy_list:
            enemy_name = enemy.get("name", "Unknown")
            enemy_frame = customtkinter.CTkFrame(main_frame)
            enemy_frame.pack(fill = "x", pady = 5, padx = 20)

            enemy_info = f"{enemy_name} - {enemy.get('difficulty', 'Unknown')} Difficulty"

            customtkinter.CTkLabel(
            enemy_frame,
            text = enemy_info,
            font = customtkinter.CTkFont(size = 12)
            ).pack(side = "left", padx = 10, pady = 10)

            var = customtkinter.BooleanVar(value = dm_settings["enabled_enemies"].get(enemy_name, True))
            enemy_vars[enemy_name]= var

            toggle = customtkinter.CTkSwitch(
            enemy_frame,
            text = "Enabled",
            variable = var,
            font = customtkinter.CTkFont(size = 12)
            )
            toggle.pack(side = "right", padx = 10, pady = 10)

        buttons_frame = customtkinter.CTkFrame(main_frame)
        buttons_frame.pack(fill = "x", pady = 20, padx = 20)

        def save_settings():

            try:

                for enemy_name, var in enemy_vars.items():
                    dm_settings["enabled_enemies"][enemy_name]= var.get()

                with open(dm_settings_path, 'w')as f:
                    json.dump(dm_settings, f, indent = 4)

                logging.info(f"DM settings saved to {dm_settings_path}")
                self._popup_show_info("Success", "DM settings saved successfully!", sound = "success")

            except Exception as e:
                logging.error(f"Failed to save DM settings: {e}")
                self._popup_show_info("Error", f"Failed to save settings: {e}", sound = "error")

        def enable_all():

            for var in enemy_vars.values():
                var.set(True)

        def disable_all():

            for var in enemy_vars.values():
                var.set(False)

        self._create_sound_button(
        buttons_frame,
        text = "Save Settings",
        command = save_settings,
        width = 200
        ).pack(side = "left", padx = 10)

        self._create_sound_button(
        buttons_frame,
        text = "Enable All",
        command = enable_all,
        width = 150,
        fg_color = "#006400"
        ).pack(side = "left", padx = 10)

        self._create_sound_button(
        buttons_frame,
        text = "Disable All",
        command = disable_all,
        width = 150,
        fg_color = "#8B0000"
        ).pack(side = "left", padx = 10)

        back_button = self._create_sound_button(
        main_frame,
        text = "Back to DM Tools",
        command = lambda:[self._clear_window(), self._open_dm_tools()],
        width = 300,
        height = 50,
        font = customtkinter.CTkFont(size = 16)
        )
        back_button.pack(pady = 20)

if __name__ =="__main__":
    try:
        _gil = os.environ.get('PYTHON_GIL', '1')
        if _gil !='0':
            try:
                import tkinter as _tk
                from tkinter import messagebox as _mb
                _root = _tk.Tk()
                _root.withdraw()
                _mb.showinfo("DOOM Tools", "Python GIL was detected as enabled.For best performance, please disable the GIL by setting the environment variable PYTHON_GIL=0 or using runwithoutgil.bat.Disabling the GIL will allow the program to run with more than one thread.")
                _root.destroy()
            except Exception:
                try:
                    print('Warning: running with GIL enabled.Running with GIL disabled may improve performance.')
                except Exception:
                    pass
    except Exception:
        pass

    try:
        show_table_selection_dialog()
    except Exception:
        logging.exception("Table selection dialog failed")

    app = App()
