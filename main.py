version = "1.0.7"

import os
import logging
import re
from datetime import datetime
import zipfile
import glob
import requests
import platform
import pygame
import customtkinter
import tkinter as _tk
import base64
import pickle
import json
import shutil
import subprocess
import psutil
import locale
import random
import math
import time
import secrets
import ctypes
import threading
import queue
import pyperclip
import sys
import inspect
import distro

pygame.init()

pygame.mixer.init(channels = 4096)

try:
    _orig_focus = getattr(_tk.Misc, 'focus', None)
    _orig_focus_set = getattr(_tk.Misc, 'focus_set', None)
    _orig_focus_force = getattr(_tk.Misc, 'focus_force', None)

    def _wrapped_focus(self, *a, **k):
        try:
            if getattr(self, 'winfo_exists', lambda:False)():
                if _orig_focus:
                    return _orig_focus(self, *a, **k)
        except Exception:
            pass

    def _wrapped_focus_set(self, *a, **k):
        try:
            self_obj = a[0]if a else None
        except Exception:
            self_obj = None
        try:
            widget = self_obj if self_obj is not None else None
            if widget is None:
                widget = getattr(k.get('self', None), 'winfo_exists', None)
        except Exception:
            widget = None
        try:

            obj = getattr(self_obj, '__self__', None)or self_obj
            if obj and getattr(obj, 'winfo_exists', lambda:False)():
                if _orig_focus_set:
                    return _orig_focus_set(obj, *a[1:], **k)if a else _orig_focus_set(obj, **k)
        except Exception:
            try:
                if getattr(self, 'winfo_exists', lambda:False)():
                    if _orig_focus_set:
                        return _orig_focus_set(self, *a, **k)
            except Exception:
                pass

    def _wrapped_focus_force(self, *a, **k):
        try:
            if getattr(self, 'winfo_exists', lambda:False)():
                if _orig_focus_force:
                    return _orig_focus_force(self, *a, **k)
        except Exception:
            pass

    try:
        if _orig_focus is not None:
            _tk.Misc.focus = _wrapped_focus
    except Exception:
        pass
    try:
        if _orig_focus_set is not None:
            _tk.Misc.focus_set = _wrapped_focus_set
    except Exception:
        pass
    try:
        if _orig_focus_force is not None:
            _tk.Misc.focus_force = _wrapped_focus_force
    except Exception:
        pass
except Exception:
    pass

class ColoredFormatter(logging.Formatter):
    COLORS = {
    'DEBUG':'\033[36m',
    'INFO':'\033[32m',
    'WARNING':'\033[33m',
    'ERROR':'\033[31m',
    'CRITICAL':'\033[35m',
    }
    RESET = '\033[0m'

    def format(self, record):
        orig_level = record.levelname
        color = self.COLORS.get(orig_level, '')

        formatted = super().format(record)

        if orig_level in('WARNING', 'ERROR', 'CRITICAL', 'DEBUG')and color:
            return f"{color}{formatted}{self.RESET}"

        if orig_level =='INFO'and color:
            try:
                return formatted.replace(orig_level, f"{color}{orig_level}{self.RESET}", 1)
            except Exception:
                return formatted
        return formatted

class StripAnsiFormatter(logging.Formatter):

    ANSI_RE = re.compile(r"\x1b\[[0-9;]*m")

    def format(self, record):

        formatted = super().format(record)
        return self.ANSI_RE.sub('', formatted)

os.makedirs("logs", exist_ok = True)
os.makedirs("logs/archive", exist_ok = True)

log_files = glob.glob("logs/*.log")
if len(log_files)>=50:
    archive_name = f"logs/archive/logs_archive_{datetime.now().strftime('%Y%m%d_%H%M%S')}.zip"
    with zipfile.ZipFile(archive_name, 'w', zipfile.ZIP_DEFLATED)as zipf:
        for log_file in log_files:
            zipf.write(log_file, os.path.basename(log_file))
            os.remove(log_file)

existing_logs = glob.glob("logs/log_*.log")
log_number = len(existing_logs)+1

log_filename = f"logs/log_{log_number}_{datetime.now().strftime('%A_%B_%d_%Y_%H_%M_%S_%f')[:-3]}.log"

file_formatter = logging.Formatter('%(asctime)s | %(levelname)s | %(message)s')
console_formatter = ColoredFormatter('%(asctime)s | %(levelname)s | %(message)s')

file_handler = logging.FileHandler(log_filename)
file_handler.setFormatter(StripAnsiFormatter('%(asctime)s | %(levelname)s | %(message)s'))

console_handler = logging.StreamHandler()
console_handler.setFormatter(console_formatter)

logging.basicConfig(
level = logging.INFO,
handlers =[file_handler, console_handler]
)

dev_log_counters = {
'DEBUG':0,
'INFO':0,
'WARNING':0,
'ERROR':0,
'CRITICAL':0,
}

class DevLogCounter(logging.Handler):

    def emit(self, record:logging.LogRecord)->None:
        try:
            lvl = record.levelname
            if lvl in dev_log_counters:
                dev_log_counters[lvl]+=1
        except Exception:
            pass

try:
    logging.getLogger().addHandler(DevLogCounter())
except Exception:
    pass

ANSI_COLORS = {
'black':'\033[30m',
'red':'\033[31m',
'green':'\033[32m',
'yellow':'\033[33m',
'blue':'\033[34m',
'magenta':'\033[35m',
'cyan':'\033[36m',
'white':'\033[37m',
}

def color_text(text:str, color:str |None)->str:
    if not color:
        return text
    prefix = ANSI_COLORS.get(color, '')
    if not prefix:
        return text
    return f"{prefix}{text}\033[0m"

def strip_ansi(text:str)->str:
    return StripAnsiFormatter.ANSI_RE.sub('', text)

def log_console_colored(logger:logging.Logger, level:int, msg:str, color:str |None = None):

    plain = strip_ansi(msg)
    for h in getattr(logger, 'handlers', []):
        try:

            if isinstance(h, logging.FileHandler):
                rec = logging.LogRecord(logger.name, level, pathname = '', lineno = 0, msg = plain, args =(), exc_info = None)
                try:
                    h.handle(rec)
                except Exception:

                    try:
                        h.emit(rec)
                    except Exception:
                        pass

            elif isinstance(h, logging.StreamHandler):
                rec = logging.LogRecord(logger.name, level, pathname = '', lineno = 0, msg = plain, args =(), exc_info = None)
                try:
                    formatted = h.format(rec)
                except Exception:
                    formatted = plain
                if color:
                    try:
                        formatted = formatted.replace(plain, color_text(plain, color), 1)
                    except Exception:
                        pass
                try:
                    stream = h.stream
                    stream.write(formatted +getattr(h, 'terminator', '\n'))
                    stream.flush()
                except Exception:
                    pass
            else:

                rec = logging.LogRecord(logger.name, level, pathname = '', lineno = 0, msg = plain, args =(), exc_info = None)
                try:
                    h.handle(rec)
                except Exception:
                    try:
                        h.emit(rec)
                    except Exception:
                        pass
        except Exception:
            pass

def log_with_colored_substring(logger:logging.Logger, level:int, plain_msg:str, substring:str, color:str):

    plain = strip_ansi(plain_msg)
    logger.log(level, plain, extra = {"suppress_console":True})

    colored_sub = color_text(substring, color)
    for h in getattr(logger, 'handlers', []):
        try:
            if isinstance(h, logging.StreamHandler)and not isinstance(h, logging.FileHandler):
                try:
                    rec = logging.LogRecord(logger.name, level, pathname = '', lineno = 0, msg = plain, args =(), exc_info = None)
                    formatted = h.format(rec)

                    formatted = formatted.replace(substring, colored_sub, 1)
                    stream = h.stream
                    stream.write(formatted +(getattr(h, 'terminator', '\n')))
                    stream.flush()
                except Exception:
                    pass
        except Exception:
            pass

class ConsoleFilter(logging.Filter):

    def filter(self, record:logging.LogRecord)->bool:
        return not getattr(record, 'suppress_console', False)

try:
    console_handler.addFilter(ConsoleFilter())
except Exception:
    pass
import warnings

logging.captureWarnings(True)
def handle_exception(exc_type, exc_value, exc_traceback):
    if issubclass(exc_type, KeyboardInterrupt):
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
        return
    logging.critical(
    "Uncaught exception",
    exc_info =(exc_type, exc_value, exc_traceback)
    )
import sys

sys.excepthook = handle_exception

def _thread_exception_handler(args):
    try:
        if issubclass(args.exc_type, KeyboardInterrupt):
            return
    except Exception:
        pass
    logging.critical("Uncaught thread exception", exc_info =(args.exc_type, args.exc_value, args.exc_traceback))

try:
    threading.excepthook = _thread_exception_handler
except Exception:

    pass

os.system('cls'if os.name =='nt'else 'clear')

logging.info(f"DOOM Tools, version {version}")
try:
    response = requests.get("https://uselessfacts.jsph.pl/random.json?language=en")
    response.raise_for_status()
    fact = response.json().get("text", "No fact retrieved")
    logging.info(f"{fact}")
except requests.RequestException as e:
    logging.warning(f"Failed to fetch random fact: {e}")

logging.info("Start system information dump")
logging.info(f"Platform: {platform.platform()}")
logging.info(f"Processor: {platform.processor()}")
logging.info(f"Python version: {platform.python_version()}")
distribution_info = "Unknown"
try:
    if os.name !='nt':
        import distro
        distribution_info = f"{distro.name()} {distro.version()}({distro.codename()})"
    else:
        distribution_info = platform.platform()
except ImportError:
    logging.info("distro module not installed; skipping Linux distribution info")
logging.info(f"Distribution: {distribution_info}")
try:
    try:
        locale.setlocale(locale.LC_ALL, '')
    except Exception as e:
        logging.debug(f"Failed to set locale from environment: {e}")
    loc = None
    try:
        loc = locale.getlocale()
    except Exception as e:
        logging.debug(f"locale.getlocale() failed: {e}")
    enc = None
    if hasattr(locale, "getencoding"):
        try:
            enc = locale.getencoding()
        except Exception as e:
            logging.debug(f"locale.getencoding() failed: {e}")
    if not enc:
        try:
            enc = locale.getpreferredencoding(False)
        except Exception as e:
            logging.debug(f"locale.getpreferredencoding() failed: {e}")
    logging.info(f"Locale: {loc}, encoding: {enc}")
except Exception as e:
    logging.warning(f"Failed to determine locale information: {e}")
logging.info(f"CPU count: {psutil.cpu_count(logical = True)}")
logging.info(f"Total RAM: {round(psutil.virtual_memory().total /(1024 **3), 2)} GB")
logging.info(f"Available RAM: {round(psutil.virtual_memory().available /(1024 **3), 2)} GB")
logging.info(f"Python executable: {sys.executable}")
logging.info(f"Current working directory: {os.getcwd()}")
logging.info("End system information dump")

global_variables = {
"devmode":{"value":False, "forced":False},
"dmmode":{"value":False, "forced":False},
"debugmode":{"value":False, "forced":False},
"current_table":None,
"ide":False,
"table_extension":".sldtbl",
"save_extension":".sldsv",
"lootcrate_extension":".sldlct",
"transfer_extension":".sldtrf",
"enemyloot_extension":".sldenlt",
}

try:
    tfiles = sorted(glob.glob(os.path.join(os.getcwd(), 'tables', f"*{global_variables.get('table_extension', '.sldtbl')}")))
    if tfiles:
        with open(tfiles[0], 'r', encoding = 'utf-8')as _tf:
            _td = json.load(_tf)
        globals()['table_data']= _td
        logging.info(f"Loaded global table_data from {os.path.basename(tfiles[0])}")
except Exception:

    pass

def show_error_dialog(title, message):

    try:
        if os.name =='nt':
            try:
                ctypes.windll.user32.MessageBoxW(0, str(message), str(title), 0x10)
                return
            except Exception:

                pass
    except Exception:
        pass

    try:
        if shutil.which('zenity'):
            subprocess.run(['zenity', '--error', '--title', str(title), '--text', str(message)])
            return
        if shutil.which('kdialog'):
            subprocess.run(['kdialog', '--title', str(title), '--error', str(message)])
            return
        if shutil.which('notify-send'):
            subprocess.run(['notify-send', str(title), str(message)])
            return
    except Exception:
        pass

    try:
        import tkinter as _tk
        from tkinter import messagebox as _mb
        _root = _tk.Tk()
        _root.withdraw()
        _mb.showerror(str(title), str(message))
        try:
            _root.destroy()
        except Exception:
            pass
        return
    except Exception:
        logging.error("Unable to display GUI error dialog: %s - %s", title, message)
        logging.info(f"Linux distribution: {distribution_info}")

possible_flags =["--dev", "--dm", "--debug", "--force", "-debug"]

for flag in possible_flags:
    if flag in sys.argv:
        if flag =="--dev":
            global_variables["devmode"]["value"]= True
            logging.info("Development mode activated via command-line flag.")
        elif flag =="--dm":
            global_variables["dmmode"]["value"]= True
            logging.info("DM mode activated via command-line flag.")
        elif flag in("--debug", "-debug"):
            global_variables["debugmode"]["value"]= True
            logging.info("Debug mode activated via command-line flag.")
        elif flag =="--force":
            for var in global_variables:
                if isinstance(global_variables[var], dict)and "forced"in global_variables[var]:
                                    global_variables[var]["forced"]= True
            logging.info("Force flag applied to all modes.")

if global_variables["debugmode"]["value"]:
    logging.getLogger().setLevel(logging.DEBUG)
    logging.info("Debug mode enabled.Logging level set to DEBUG.")
    logging.info("Starting debug tests")
    logging.debug("Debug level test")
    logging.info("Info level test")
    logging.warning("Warning level test")
    logging.error("Error level test")
    logging.critical("Critical level test")
    logging.info("Debug tests complete")

appearance_settings = {
"appearance_mode":"system",
"color_theme":"dark-blue",
"resolution":"1920x1080",
"fullscreen":False,
"borderless":False,
"units":"imperial",
"auto_set_units":False,
"sound_volume":100
}

folders =[
{"name":"logs", "ignore_gitignore":False},
{"name":"sounds", "ignore_gitignore":False},
{"name":"tables", "ignore_gitignore":True},
{"name":"transfers", "ignore_gitignore":False},
{"name":"lootcrates", "ignore_gitignore":False},
{"name":"enemyloot", "ignore_gitignore":False},
{"name":"themes", "ignore_gitignore":False}
]

themes_dir = "themes"
os.makedirs(themes_dir, exist_ok = True)

tmp_zip = None
extract_dir = None

try:
    if not any(os.scandir(themes_dir)):
        logging.info("Themes folder is empty.Downloading CTkThemesPack...")
        tmp_zip = "CTkThemesPack.zip"
        extract_dir = "CTkThemesPack_src"

        response = requests.get("https://github.com/a13xe/CTkThemesPack/archive/refs/heads/main.zip", timeout = 30)
        response.raise_for_status()
        with open(tmp_zip, "wb")as f:
            f.write(response.content)

        os.makedirs(extract_dir, exist_ok = True)
        with zipfile.ZipFile(tmp_zip, "r")as zip_ref:
            zip_ref.extractall(extract_dir)

        extracted_roots =[d for d in os.listdir(extract_dir)if os.path.isdir(os.path.join(extract_dir, d))]
        if extracted_roots:
            src_theme_dir = os.path.join(extract_dir, extracted_roots[0], "themes")
            if os.path.isdir(src_theme_dir):
                for entry in os.listdir(src_theme_dir):
                    src_path = os.path.join(src_theme_dir, entry)
                    dst_path = os.path.join(themes_dir, entry)
                    if os.path.isdir(src_path):
                        shutil.copytree(src_path, dst_path, dirs_exist_ok = True)
                    else:
                        shutil.copy2(src_path, dst_path)
                logging.info("Themes downloaded and installed successfully.")
            else:
                logging.warning("No 'themes' directory found in downloaded package.")
        else:
            logging.warning("Failed to locate extracted CTkThemesPack directory.")

except Exception as e:
    logging.error(f"Failed to populate themes: {e}")

ide_indicators =[
'PYCHARM_HOSTED',
'VSCODE_PID',
'SPYDER_KERNELS_NAMESPACE',
'PYDEVD_USE_FRAME_EVAL',
'TERM_PROGRAM',
'JUPYTER_RUNTIME_DIR',
'JPY_PARENT_PID',
'IPYTHONDIR',
'PYCHARM_MATPLOTLIB_INTERACTIVE',
'PYCHARM_DISPLAY_PORT',
'INTELLIJ_ENVIRONMENT_READER',
'IDEA_INITIAL_DIRECTORY',
'PYTHONIOENCODING',
'PYDEV_CONSOLE_ENCODING',
'VSCODE_CLI',
'VSCODE_GIT_ASKPASS_NODE',
'VSCODE_INJECTION'
]

dm_users =["bGlseQ==", "amFjemk=", "cGhvbmU=", "YWlkZW4="]

if any(indicator in os.environ for indicator in ide_indicators):
    if not global_variables["devmode"]["value"]and not global_variables["devmode"]["forced"]:
        global_variables["devmode"]["value"]= True
        logging.info("Development mode activated due to IDE environment detection.")
    elif global_variables["devmode"]["value"]:
        logging.info("IDE environment detected, but development mode is already set.")
    else:
        logging.info("IDE environment detected, but development mode is forced off.")
    logging.info(f"Trigger: {[key for key in os.environ if key in ide_indicators]}")
    global_variables["ide"]= True
    try:

        try:
            out = subprocess.check_output([sys.executable, '-m', 'pip', 'freeze'], text = True, stderr = subprocess.DEVNULL)
            with open('requirements.txt', 'w', encoding = 'utf-8')as _rq:
                _rq.write(out)
            logging.info('Updated requirements.txt from pip freeze(IDE mode)')
        except Exception:
            logging.exception('Failed to refresh requirements.txt in IDE mode')
    except Exception:
        pass
    for folder_entry in folders:
        folder = folder_entry["name"]
        ignore_gitignore = folder_entry.get("ignore_gitignore", False)

        if not os.path.exists(folder):
            os.makedirs(folder)
            logging.info(f"Created missing folder: {folder}")
        if ignore_gitignore:
            logging.info(f"Skipped.gitignore addition for '{folder}'(ignore_gitignore=True)")
            continue

        with open('.gitignore', 'a')as gitignore:
            existing_gitignore = set()
            try:
                with open('.gitignore', 'r')as read_gitignore:
                    existing_gitignore = set(line.strip()for line in read_gitignore)
            except FileNotFoundError:
                pass
            entry = f'/{folder}/'
            if entry not in existing_gitignore:
                gitignore.write(f'{entry}\n')
                logging.info(f"Added '{entry}' to.gitignore")
            else:
                logging.info(f"'{entry}' already exists in.gitignore")
    try:
        import subprocess
        result = subprocess.run([sys.executable, '-m', 'pip', 'freeze'], capture_output = True, text = True)
        current_packages = set(result.stdout.strip().split('\n'))

        existing_packages = set()
        try:
            with open('requirements.txt', 'r')as f:
                existing_packages = set(line.strip()for line in f if line.strip())
        except FileNotFoundError:
            pass
        all_packages = existing_packages |current_packages
        all_packages.discard('')
        with open('requirements.txt', 'w')as f:
            for package in sorted(all_packages):
                f.write(f'{package}\n')
        logging.info(f"Updated requirements.txt with {len(all_packages)} packages")
    except Exception as e:
        logging.warning(f"Failed to update requirements.txt: {e}")

saves_folder = "saves"

if not global_variables["devmode"]["value"]:
    logging.info("Running in production mode.")
    if os.name =='nt':
        base_ld = os.getenv('LOCALAPPDATA')or os.path.expanduser('~')
        saves_folder = os.path.join(base_ld, 'soli_dstate', 'DOOM-Tools', 'saves')
    else:
        saves_folder = os.path.expanduser('~/.local/share/soli_dstate/DOOM-Tools/saves')
else:
    logging.info("Running in development mode.")
    saves_folder = "saves"
    folders.append({"name":"saves", "ignore_gitignore":False})

for folder_entry in folders:
    folder = folder_entry["name"]
    if not os.path.exists(folder):
        os.makedirs(folder)
        logging.info(f"Created missing folder: {folder}")

os.makedirs(saves_folder or "saves", exist_ok = True)

try:
    appearance_settings_path = os.path.join(saves_folder, "appearance_settings.sldsv")
    if os.path.exists(appearance_settings_path):
        with open(appearance_settings_path, 'r')as f:
            loaded_settings = json.load(f)
        appearance_settings.update(loaded_settings)
        logging.info(f"Appearance settings loaded from {appearance_settings_path}")
except Exception as e:
    logging.warning(f"Failed to load appearance settings: {e}")

try:
    settings_path = os.path.join(saves_folder, "settings.sldsv")
    if os.path.exists(settings_path):
        with open(settings_path, 'r')as f:
            loaded_globals = json.load(f)

        for key, value in loaded_globals.items():
            if key in global_variables:
                if isinstance(global_variables[key], dict)and isinstance(value, dict):
                    global_variables[key].update(value)
                else:
                    global_variables[key]= value
            else:
                global_variables[key]= value
        logging.info(f"Global settings loaded from {settings_path}")
except Exception as e:
    logging.warning(f"Failed to load global settings: {e}")

def _sync_remote_table():
    try:
        table_dir = os.path.join(os.getcwd(), "tables")
        if not os.path.isdir(table_dir):
            logging.info("No tables directory present; skipping remote table sync")
            return

        local_tables = sorted(glob.glob(os.path.join("tables", f"*{global_variables.get('table_extension', '.sldtbl')}")))
        if not local_tables:
            logging.info("No local table files found; skipping remote table sync")
            return

        target_local = None
        cur_tbl = global_variables.get("current_table")
        if cur_tbl:
            for f in local_tables:
                if os.path.abspath(f).endswith(cur_tbl)or os.path.basename(f)==cur_tbl:
                    target_local = f
                    break

        if not target_local:
            target_local = local_tables[0]

        basename = os.path.basename(target_local)
        raw_base = "https://raw.githubusercontent.com/soli-dstate/DOOM-Tools/master/tables/"
        remote_url = raw_base +basename

        logging.info(f"Checking remote table for updates: {remote_url}")
        resp = requests.get(remote_url, timeout = 15)
        if resp.status_code !=200:
            logging.info(f"Remote table not found(status {resp.status_code}): {remote_url}")
            return

        remote_text = resp.text
        try:
            with open(target_local, 'r', encoding = 'utf-8')as f:
                local_text = f.read()
        except Exception as e:
            logging.warning(f"Failed to read local table {target_local}: {e}")
            local_text = None

        if local_text is None or local_text !=remote_text:
            if global_variables.get("devmode", {}).get("value", False):
                logging.info("Devmode enabled: remote table differs but will not replace local file")
                return

            name_root, _ = os.path.splitext(basename)
            backup_name = name_root +".backup"
            backup_path = os.path.join(table_dir, backup_name)
            try:
                if os.path.exists(target_local):
                    shutil.move(target_local, backup_path)
                    logging.info(f"Backed up local table {target_local} -> {backup_path}")

                with open(target_local, 'w', encoding = 'utf-8')as f:
                    f.write(remote_text)
                logging.info(f"Replaced local table with remote version: {target_local}")
            except Exception as e:
                logging.error(f"Failed to replace local table with remote version: {e}")
        else:
            logging.info("Local table matches remote; no update needed")
    except Exception as e:
        logging.error(f"Error during remote table sync: {e}")

if not global_variables.get("devmode", {}).get("value", False):
    logging.info("Remote table sync active, syncing...")
    _sync_remote_table()
    logging.info("Remote table sync complete.")
else:
    logging.info("Remote table sync active, skipped due to devmode.")

def suggest_magazine_for_weapon_static(weapon):

    try:
        name =(weapon.get('name')or '').strip()
    except Exception:
        name = ''
    try:
        calib_raw = weapon.get('caliber')
        if isinstance(calib_raw, (list, tuple))and calib_raw:
            calib = str(calib_raw[0])
        else:
            calib = str(calib_raw or '')
    except Exception:
        calib = ''

    results = {
    'weapon_name':name,
    'caliber':calib,
    'wiki_matches':[],
    'suggested_capacities':[],
    'suggested_mag_item':None,
    'next_id':0,
    'notes':[]
    }

    caliber_map = {
    '9x19':[15, 17, 30],
    '9mm':[15, 17, 30],
    '5.56x45':[30],
    '5.56':[30],
    '7.62x39':[30],
    '7.62x51':[20, 30],
    '7.62':[20, 30],
    '.45 acp':[7, 8, 10],
    '.45':[7, 8, 10],
    '.308':[10, 20, 30],
    '.30-06':[5, 10],
    '12 gauge':[1, 4, 5, 8],
    '40mm':[1]
    }

    def _norm(s):
        try:
            return re.sub(r"[^0-9a-zA-Z\.x\-\s]", '', str(s or '')).strip().lower()
        except Exception:
            return ''

    capacities_meta =[]
    try:
        session = requests.Session()
        session.headers.update({'User-Agent':'DOOM-Tools/1.0(https://example.local)'})
        wiki_candidates =[]

        def _safe_wiki_get(url, params = None, timeout = 8):
            try:
                r = session.get(url, params = params, timeout = timeout)
            except Exception as e:
                logging.warning("suggest_magazine_for_weapon_static: HTTP request failed(%s): %s", url, e)
                return None
            if r is None:
                return None
            text =(r.text or '').strip()
            if not text:
                logging.warning("suggest_magazine_for_weapon_static: Empty response from %s", url)
                return None
            try:
                return r.json()
            except ValueError:

                try:
                    logging.warning("suggest_magazine_for_weapon_static: Non-JSON response from %s: %s", url, text[:400].replace('\n', ' '))
                except Exception:
                    pass
                return None

        if name:
            url = 'https://en.wikipedia.org/w/api.php'
            params = {'action':'query', 'list':'search', 'srsearch':name, 'format':'json', 'srlimit':4}
            j = _safe_wiki_get(url, params = params)
            if j:
                for s in j.get('query', {}).get('search', [])or[]:
                    wiki_candidates.append(s.get('title'))
        if calib:
            url = 'https://en.wikipedia.org/w/api.php'
            params = {'action':'query', 'list':'search', 'srsearch':calib, 'format':'json', 'srlimit':4}
            j = _safe_wiki_get(url, params = params)
            if j:
                for s in j.get('query', {}).get('search', [])or[]:
                    if s.get('title')not in wiki_candidates:
                        wiki_candidates.append(s.get('title'))

        capacities_found =[]
        api = 'https://en.wikipedia.org/w/api.php'
        for title in wiki_candidates[:4]:
            try:
                params = {'action':'query', 'prop':'extracts', 'explaintext':1, 'titles':title, 'format':'json', 'exintro':1}
                j = _safe_wiki_get(api, params = params)
                text = ''
                if j:
                    pages = j.get('query', {}).get('pages', {})or {}
                    for p in pages.values():
                        text = p.get('extract')or ''
                        break

                try:
                    wt_params = {'action':'query', 'prop':'revisions', 'rvprop':'content', 'rvslots':'main', 'titles':title, 'format':'json'}
                    jwt = _safe_wiki_get(api, params = wt_params)
                    wikitext = ''
                    if jwt:
                        pages2 = jwt.get('query', {}).get('pages', {})or {}
                        for p2 in pages2.values():
                            revs = p2.get('revisions')or[]
                            if revs:

                                r0 = revs[0]
                                if isinstance(r0, dict):
                                    if 'slots'in r0 and isinstance(r0.get('slots'), dict):
                                        main_slot = r0.get('slots', {}).get('main', {})or {}
                                        wikitext = main_slot.get('*')or ''
                                    if not wikitext:
                                        wikitext = r0.get('*')or r0.get('content')or ''
                            break
                    if wikitext:

                        for m in re.finditer(r"\|\s*(feed(?:_system)?|feed_system|magazine|capacity|feeds?)\s*=\s*(.*?)(?=\n\s*\||\n\s*\}\})", wikitext, flags = re.IGNORECASE |re.DOTALL):
                            raw_block =(m.group(2)or '').strip()
                            if not raw_block:
                                continue

                            lines =[ln.strip()for ln in raw_block.splitlines()if ln.strip()]
                            for ln in lines:

                                ln2 = re.sub(r"^[\*\u2022\-\:\;\s]+", '', ln)
                                if not ln2:
                                    continue

                                nums = re.findall(r"(\d{1, 3})\s*(?:-round|rounds|round|rnd|rd|rds)\b", ln2, flags = re.IGNORECASE)

                                nums +=re.findall(r"(\d{1, 3})\s*\+\s*1", ln2)

                                if not nums and re.search(r"magazin|feed|capac|round", ln2, flags = re.IGNORECASE):
                                    nums = re.findall(r"(\d{1, 3})", ln2)

                                for n in nums:
                                    try:
                                        iv = int(n)
                                        if 1 <=iv <=200:

                                            try:
                                                if calib and calib.lower()in ln2.lower():
                                                    capacities_found.extend([iv, iv])
                                                else:
                                                    capacities_found.append(iv)
                                            except Exception:
                                                capacities_found.append(iv)
                                    except Exception:
                                        pass

                            if not capacities_found:
                                try:
                                    logging.debug("suggest_magazine_for_weapon_static: no numeric capacities parsed from infobox block for %s: %s", title, raw_block[:300].replace('\n', ' '))
                                except Exception:
                                    pass
                        if capacities_found:
                            try:
                                logging.info("suggest_magazine_for_weapon_static: infobox feed capacities for %s: %s", title, capacities_found)
                                results['notes'].append(f"infobox_feed_caps: {capacities_found}")
                            except Exception:
                                pass
                except Exception:
                    pass

                if not text:
                    try:
                        rest_url = f"https://en.wikipedia.org/api/rest_v1/page/summary/{requests.utils.requote_uri(title)}"
                        r2 = session.get(rest_url, timeout = 8)
                        if r2 and r2.status_code ==200:
                            try:
                                j2 = r2.json()
                                text =(j2.get('extract')or '')
                            except ValueError:
                                logging.warning("suggest_magazine_for_weapon_static: REST summary non-JSON for %s: %s", title, (r2.text or '')[:200])
                        else:
                            logging.warning("suggest_magazine_for_weapon_static: REST summary failed for %s: status %s", title, getattr(r2, 'status_code', None))
                    except Exception as e:
                        logging.warning("suggest_magazine_for_weapon_static: REST summary request failed for %s: %s", title, e)
                if not text:
                    continue
                results['wiki_matches'].append({'title':title, 'snippet':text[:600]})
                lower = text.lower()
                for m in re.finditer(r"magazine|capacity|standard|commonly|usually", lower):
                    start = max(0, m.start()-120)
                    end = min(len(lower), m.end()+120)
                    ctx = lower[start:end]
                    nums = re.findall(r"(\d{1, 3})\s*(?:-round|rounds|round|rnd|rd)", ctx)
                    for n in nums:
                        try:
                            capacities_meta.append((int(n), ctx))
                        except Exception:
                            pass
                nums2 = re.findall(r"(\d{1, 3})\s*-?\s*round(?:s)?", lower)
                for n in nums2:
                    try:
                        capacities_meta.append((int(n), lower))
                    except Exception:
                        pass
            except Exception:
                continue
    except Exception as e:
        results['notes'].append('Wikipedia lookup failed or timed out')
        logging.warning("suggest_magazine_for_weapon_static: Wikipedia lookup error for '%s' calib='%s': %s", name, calib, e)

    caps =[]

    if capacities_meta:
        try:
            raw_caps =[c for c, _ in capacities_meta]
            logging.debug("suggest_magazine_for_weapon_static: raw capacities_meta for '%s'(calib=%s): %s", name, calib, raw_caps)
        except Exception:
            raw_caps =[c for c, _ in capacities_meta]

        def _norm_for_match(s:str)->str:
            try:
                s2 = str(s or '').lower()
                s2 = s2.replace('\u00d7', 'x').replace('Ã—', 'x')
                s2 = re.sub(r"[^0-9a-zx]+", ' ', s2)
                return s2
            except Exception:
                return str(s or '').lower()

        calib_norm = _norm_for_match(calib)
        calib_freq = {}
        overall_freq = {}
        for iv, src in capacities_meta:
            overall_freq[iv]= overall_freq.get(iv, 0)+1
            try:
                if calib and calib_norm and calib_norm in _norm_for_match(src):
                    calib_freq[iv]= calib_freq.get(iv, 0)+1
            except Exception:
                pass

        if calib_freq:
            caps = sorted(calib_freq.keys(), key = lambda x:(-calib_freq[x], -overall_freq.get(x, 0), x))[:5]
        else:
            caps = sorted(overall_freq.keys(), key = lambda x:(-overall_freq[x], x))[:5]
        try:
            logging.info("suggest_magazine_for_weapon_static: Wikipedia capacities for '%s'(calib=%s): %s(raw=%s)", name, calib, caps, raw_caps)
            results['notes'].append(f"wikipedia_caps: {caps}")
        except Exception:
            pass

    if not caps and calib:
        ncal = _norm(calib)

        ncal_tokens = set(re.findall(r"\w+", ncal))
        for k, v in caliber_map.items():
            nk = _norm(k)
            k_tokens = set(re.findall(r"\w+", nk))

            if ncal_tokens &k_tokens:
                caps = v[:3]
                try:
                    logging.info("suggest_magazine_for_weapon_static: used caliber_map fallback for '%s'(calib=%s): %s(matched_key=%s)", name, calib, caps, k)
                    results['notes'].append(f"fallback_caliber_map: {caps}(matched {k})")
                except Exception:
                    pass
                break

    if not caps:
        caps =[10, 20, 30]
        try:
            logging.info("suggest_magazine_for_weapon_static: using default capacities for '%s'(calib=%s): %s", name, calib, caps)
            results['notes'].append('fallback_default_caps')
        except Exception:
            pass

    results['suggested_capacities']= caps

    try:
        table_files = glob.glob(os.path.join('tables', '*.sldtbl'))
        maxid = 0
        for tf in table_files:
            try:
                with open(tf, 'r', encoding = 'utf-8')as fh:
                    td = json.load(fh)
                for items in(td.get('tables')or {}).values():
                    if isinstance(items, list):
                        for it in items:
                            if isinstance(it, dict)and 'id'in it:
                                iid = it.get('id')
                                try:
                                    if iid is None:
                                        continue
                                    iv = int(iid)
                                    if iv >maxid:
                                        maxid = iv
                                except Exception:
                                    pass
            except Exception:
                continue
        next_id = maxid +1
    except Exception:
        next_id = 0

    results['next_id']= next_id

    try:
        cap0 = caps[0]if caps else 30
        mag_item = {'id':next_id, 'name':f"Synthetic Mag({cap0})", 'capacity':int(cap0), 'magazinetype':weapon.get('magazinetype')or 'detachable box', 'magazinesystem':weapon.get('magazinesystem')or weapon.get('magazinetype')or '', 'rounds':[]}
        round_name =(calib or 'Unknown')+' | FMJ'
        for i in range(int(cap0)):
            mag_item['rounds'].append({'name':round_name, 'caliber':calib or None, 'variant':'FMJ'})
        results['suggested_mag_item']= mag_item
    except Exception:
        results['notes'].append('Failed to build mag item')

    return results

def validate_table_ids():

    tables_dir = "tables"
    if not os.path.isdir(tables_dir):
        logging.warning(f"Tables directory '{tables_dir}' not found, skipping validation.")
        return

    table_files =[f for f in os.listdir(tables_dir)if f.endswith(".sldtbl")]
    if not table_files:
        logging.info("No table files found to validate.")
        return

    global_id_map = {}

    magazine_errors =[]
    magazine_errors_details =[]
    table_sequence_errors =[]
    table_sequence_details =[]
    ammo_errors =[]
    ammo_errors_details =[]

    referenced_slots = set()
    all_table_items =[]

    for table_file in sorted(table_files):
        table_path = os.path.join(tables_dir, table_file)
        try:
            with open(table_path, 'r', encoding = 'utf-8')as f:
                table_data = json.load(f)

            table_name = table_data.get("prettyname", table_file)
            tables = table_data.get("tables", {})

            try:
                magazine_items =[]
                if isinstance(tables, dict):
                    magazine_items = tables.get("magazines", [])or[]

                magazine_systems = set()
                for mag in magazine_items:
                    if isinstance(mag, dict):
                        ms = mag.get("magazinesystem")
                        if ms is None:
                            continue
                        if isinstance(ms, list):
                            for m in ms:
                                magazine_systems.add(str(m))
                        else:
                            magazine_systems.add(str(ms))

                for subtable_name_check, items_check in tables.items():
                    if not isinstance(items_check, list):
                        continue
                    for item_check in items_check:
                        if not isinstance(item_check, dict):
                            continue
                        if item_check.get("firearm")and str(item_check.get("magazinetype", "")).lower()=="detachable box":
                            f_ms = item_check.get("magazinesystem")
                            friendly = f"Table '{table_name}': Firearm '{item_check.get('name')}'(ID {item_check.get('id')})"

                            if item_check.get('has_magazine_in_pool')is False:
                                continue

                            if f_ms is None:
                                msg = f"{friendly} missing 'magazinesystem' field"
                                logging.error(msg)
                                magazine_errors.append(msg)
                                try:
                                    magazine_errors_details.append({'table':table_name, 'weapon':item_check, 'reason':'missing_magazinesystem', 'message':msg})
                                except Exception:
                                    pass
                                continue

                            needed =[f_ms]if not isinstance(f_ms, list)else f_ms

                            needed =[str(n)for n in needed]
                            compatible = any(n in magazine_systems for n in needed)
                            if not compatible:
                                msg = f"{friendly} has no magazines matching magazinesystem(s): {needed}"
                                magazine_errors.append(msg)
                                try:
                                    magazine_errors_details.append({'table':table_name, 'weapon':item_check, 'reason':'no_compatible_magazines', 'message':msg})
                                except Exception:
                                    pass
            except Exception as e:
                logging.warning(f"Failed to perform magazine compatibility check for '{table_file}': {e}")

            file_ids =[]

            for subtable_name, items in tables.items():
                if not isinstance(items, list):
                    continue
                for idx, item in enumerate(items):
                    if isinstance(item, dict)and "id"in item:
                        item_id = item["id"]
                        file_ids.append(item_id)

                        entry =(table_file, subtable_name, item.get("name")or f"index_{idx}")
                        global_id_map.setdefault(item_id, []).append(entry)

                    if isinstance(item, dict):
                        all_table_items.append((item, table_file, subtable_name))

                        try:
                            accs = item.get('accessories')or[]
                            if isinstance(accs, list):
                                for a in accs:
                                    if isinstance(a, dict)and a.get('slot'):
                                        referenced_slots.add(str(a.get('slot')).strip())
                        except Exception:
                            pass

                        try:
                            subs = item.get('subslots')or[]
                            if isinstance(subs, list):
                                for s in subs:
                                    if isinstance(s, dict)and s.get('slot'):
                                        referenced_slots.add(str(s.get('slot')).strip())
                        except Exception:
                            pass

            if not file_ids:
                logging.info(f"Table '{table_name}': No items with IDs found.")
                continue

            file_ids.sort()
            min_id = file_ids[0]
            max_id = file_ids[-1]
            next_id = max_id +1

            expected_ids = set(range(min_id, max_id +1))
            actual_ids = set(file_ids)
            if expected_ids ==actual_ids:
                plain = f"Table '{table_name}': IDs valid(sequential from {min_id} to {max_id}).Next ID: {next_id}"
                log_with_colored_substring(logging.getLogger(), logging.INFO, plain, str(next_id), 'blue')
            else:
                missing_ids = sorted(expected_ids -actual_ids)

                logging.error(f"Table '{table_name}': ID sequence broken(details collected for dialog).")

                try:
                    file_entries =[]
                    for iid in sorted(actual_ids):
                        locs = global_id_map.get(iid, [])
                        for f, sub, name in locs:
                            if f ==table_file:
                                file_entries.append((iid, sub, name))
                                break
                    suggested_lines =[]
                    new_id = min_id
                    for old_id, sub, name in file_entries:
                        if old_id !=new_id:
                            suggested_lines.append(f"Change ID {old_id}({sub}:{name}) -> {new_id}")
                        new_id +=1
                except Exception:
                    suggested_lines =["Unable to build suggested ID changes."]

                id_msg_lines =[
                f"Table: {table_name}",
                "ID sequence broken:",
                f" Missing IDs: {missing_ids}",
                f" Last ID: {max_id}",
                f" Next ID: {next_id}",
                ]
                if suggested_lines:
                    id_msg_lines.append("")
                    id_msg_lines.append("Suggested changes to fix IDs:")
                    id_msg_lines.extend([f" {l}"for l in suggested_lines])

                seq_msg = "\n".join(id_msg_lines)
                table_sequence_errors.append(seq_msg)
                try:
                    table_sequence_details.append({'table':table_name, 'missing_ids':missing_ids, 'last_id':max_id, 'next_id':next_id, 'suggested_changes':suggested_lines})
                except Exception:
                    table_sequence_details.append({'table':table_name, 'message':seq_msg})
                logging.error("Table '%s': ID sequence error detected(collected, continuing checks).", table_name)

        except Exception as e:
            logging.error(f"Failed to validate table '{table_file}': {e}")

    ammo_names_present = set()
    ammo_calibers_present = set()
    try:
        for item, tf, sub in all_table_items:
            try:
                if isinstance(sub, str)and sub.lower()in('ammunition', 'ammo'):
                    name = item.get('name')
                    if name:
                        ammo_names_present.add(str(name).strip().lower())
                    calib = item.get('caliber')
                    if calib:
                        ammo_calibers_present.add(str(calib).strip().lower())
            except Exception:
                continue
    except Exception:
        pass

    try:
        for item, tf, sub in all_table_items:
            try:
                if not isinstance(item, dict):
                    continue
                if item.get('firearm'):
                    name = item.get('name')or '<unnamed>'

                    calib = item.get('caliber')
                    if calib:
                        if str(calib).strip().lower()not in ammo_calibers_present:
                            msg = f"Firearm '{name}' in table '{tf}' references caliber '{calib}' but no ammunition with that caliber found."
                            ammo_errors.append(msg)
                            try:
                                ammo_errors_details.append({'table':tf, 'weapon':item, 'reason':'missing_ammo_caliber', 'caliber':calib})
                            except Exception:
                                pass

                    ammo_type = item.get('ammo_type')or item.get('ammunition')
                    if ammo_type:
                        if str(ammo_type).strip().lower()not in ammo_names_present:
                            msg = f"Firearm '{name}' in table '{tf}' references ammunition '{ammo_type}' but no matching ammunition entry found."
                            ammo_errors.append(msg)
                            try:
                                ammo_errors_details.append({'table':tf, 'weapon':item, 'reason':'missing_ammo_name', 'ammo':ammo_type})
                            except Exception:
                                pass
            except Exception:
                continue
    except Exception:
        pass

    duplicates = {i:locs for i, locs in global_id_map.items()if len(locs)>1}
    duplicate_errors =[]

    duplicate_suggestions =[]
    if duplicates:
        for dup_id, locations in duplicates.items():
            loc_str = "; ".join([f"{f}:{sub}:{name}"for f, sub, name in locations])
            msg = f"Duplicate ID detected: {dup_id} used in: {loc_str}"
            duplicate_errors.append(msg)
            try:

                max_id = max(global_id_map.keys())if global_id_map else dup_id
                for idx, (f, sub, name)in enumerate(locations):
                    if idx ==0:

                        continue
                    max_id +=1
                    duplicate_suggestions.append(f"Change ID {dup_id}({f}:{sub}:{name}) -> {max_id}")
            except Exception:
                duplicate_suggestions.append(f"Unable to suggest fixes for duplicate ID {dup_id}.")

    try:
        missing_slots =[]
        if referenced_slots:

            def item_matches_slot(item, slot_name):
                try:

                    if isinstance(item, (list, tuple))and item:
                        item = item[0]
                    if not isinstance(item, dict):
                        return False

                    for v in item.values():
                        if isinstance(v, str)and v.strip().lower()==slot_name.lower():
                            return True
                        if isinstance(v, (list, tuple)):
                            for e in v:
                                try:
                                    if isinstance(e, str)and e.strip().lower()==slot_name.lower():
                                        return True
                                except Exception:
                                    continue

                    if isinstance(item.get('slot'), str)and item.get('slot').strip().lower()==slot_name.lower():
                        return True
                except Exception:
                    pass
                return False

            for slot in sorted(referenced_slots):

                try:
                    if isinstance(slot, str)and slot.strip().lower()=='weapon_slot':
                        continue
                except Exception:
                    pass

                found = any(item_matches_slot(it, slot)for it in all_table_items)
                if not found:
                    missing_slots.append(slot)
        if missing_slots:
            for s in missing_slots:
                logging.warning(f"Referenced slot '{s}' has no items available in tables to populate it.")
    except Exception:
        pass

    all_errors = duplicate_errors +magazine_errors +table_sequence_errors
    if all_errors:

        for err in all_errors:
            logging.error(err)

        displayed = all_errors[:10]
        numbered =[f"{i +1}.{e}"for i, e in enumerate(displayed)]
        preview = "\n\n".join(numbered)
        more_count = len(all_errors)-len(displayed)
        if more_count >0:
            preview +=f"\n\n...and {more_count} more errors"

        try:
            if duplicate_suggestions:
                preview +="\n\nSuggested duplicate ID fixes:\n"
                preview +="\n".join([f" {s}"for s in duplicate_suggestions])
        except Exception:
            pass

        try:
            if magazine_errors_details:
                preview +="\n\nSuggested magazine entries for problematic firearms:\n"

                try:
                    max_existing = 0
                    for k in list(global_id_map.keys()):
                        try:
                            iv = int(k)
                            if iv >max_existing:
                                max_existing = iv
                        except Exception:
                            continue
                    next_sugg_id = max_existing +1
                except Exception:
                    next_sugg_id = 1

                for det in magazine_errors_details[:8]:
                    weapon = det.get('weapon')or {}
                    table = det.get('table')or '<unknown table>'
                    wname = weapon.get('name')or weapon.get('prettyname')or '<unnamed>'
                    try:
                        sug = suggest_magazine_for_weapon_static(weapon)
                        caps = sug.get('suggested_capacities')or[10]
                        wiki = sug.get('wiki_matches')or[]

                        ms = weapon.get('magazinesystem')or weapon.get('magazinetype')
                        req_count = 1
                        if isinstance(ms, list)and ms:
                            req_count = len(ms)

                        assigned =[]
                        for i in range(req_count):
                            cap = caps[i]if i <len(caps)else caps[0]
                            assigned_id = next_sugg_id
                            next_sugg_id +=1
                            assigned.append((assigned_id, cap))

                        entries_str = ", ".join([f"ID {aid}(cap {cap})"for aid, cap in assigned])
                        preview +=f"- {table}: {wname} -> suggested magazines: {entries_str}\n"

                        if wiki:
                            try:
                                first = wiki[0]
                                t = first.get('title')
                                try:
                                    link = f"https://en.wikipedia.org/wiki/{requests.utils.requote_uri(t.replace(' ', '_'))}"
                                except Exception:
                                    link = f"https://en.wikipedia.org/wiki/{t.replace(' ', '_')}"
                                preview +=f" Information derived from: {link}\n"
                            except Exception:
                                pass

                        preview +="\n"
                    except Exception:
                        preview +=f"- {table}: {wname} -> suggestion unavailable\n\n"
                if len(magazine_errors_details)>8:
                    preview +=f"...and {len(magazine_errors_details)-8} more magazine issues\n"
        except Exception:
            pass

        try:
            if table_sequence_details:
                preview +="\n\nID sequence issues detected in tables:\n"
                for det in table_sequence_details[:8]:
                    try:
                        preview +=f"- Table: {det.get('table')} Missing IDs: {det.get('missing_ids')} Last ID: {det.get('last_id')} Next ID: {det.get('next_id')}\n"
                        sug = det.get('suggested_changes')or[]
                        if sug:
                            preview +=" Suggested changes:\n"
                            for s in sug[:6]:
                                preview +=f" {s}\n"
                            if len(sug)>6:
                                preview +=f"...and {len(sug)-6} more suggested changes\n"
                    except Exception:
                        preview +="-(unable to render table sequence detail)\n"
                if len(table_sequence_details)>8:
                    preview +=f"...and {len(table_sequence_details)-8} more table sequence issues\n"
        except Exception:
            pass

        title = f"Table Validation Errors({len(all_errors)})"
        full_msg = f"Errors detected during table validation:\n\n{preview}\n\nSee logs for full details."
        show_error_dialog(title, full_msg)
        logging.critical("Aborting startup due to table validation errors.")
        raise SystemExit("Format for table tables is broken due to validation errors; aborting startup.Please fix/update the table(s).")

validate_table_ids()

currentsave = None

emptysave = {
"charactername":"",
"stats":{
"Aim":0,
"Strength":0,
"Agility":0,
"Intelligence":0,
"Charisma":0,
"Perception":0,
"Resistance":0,
"Stealth":0,
"Luck":0
},
"hands":{
"encumbrance_modifier":0.5,
"capacity":50,
"items":[]
},
"equipment":{
"head":None,
"face":None,
"torso":None,
"left wrist":None,
"right wrist":None,
"left hand":None,
"right hand":None,
"legs":None,
"feet":None,
"neck":None,
"chest":None,
"back":None,
"waist":None,
"waistband":None,
"left shoulder":None,
"right shoulder":None,
"left arm":None,
"right arm":None,
"left leg":None,
"right leg":None
},
"encumbrance":0,
"encumbered_threshold":50,
"encumbered":{"value":False, "level":0},
"storage":[],
"money":0
}

def populate_equipment_with_subslots(save_data):

    try:
        table_files = glob.glob(os.path.join("tables", "*.sldtbl"))
        if not table_files:
            return save_data

        with open(table_files[0], 'r')as f:
            table_data = json.load(f)

        equipment_items = table_data.get("tables", {}).get("equipment", [])
        equipment_map = {item.get("id"):item for item in equipment_items}

        for slot_name, equipped_item in save_data.get("equipment", {}).items():

            items_to_process =[]
            if isinstance(equipped_item, dict):
                items_to_process =[equipped_item]
            elif isinstance(equipped_item, list):
                items_to_process =[it for it in equipped_item if isinstance(it, dict)]

            for eq in items_to_process:
                try:
                    item_id = eq.get("id")
                    if item_id is not None and item_id in equipment_map:
                        table_item = equipment_map[item_id]
                        if "subslots"in table_item and "subslots"not in eq:
                            eq["subslots"]=[{
                            "name":subslot.get("name"),
                            "slot":subslot.get("slot"),
                            "current":None
                            }for subslot in table_item["subslots"]]
                            logging.debug(f"Added {len(eq['subslots'])} subslots to equipped item ID {item_id} in slot {slot_name}")

                            for sub in eq.get("subslots", []):
                                try:
                                    cur = sub.get("current")
                                    if isinstance(cur, dict):
                                        add_subslots_to_item(cur)
                                except Exception:
                                    pass

                            for acc in eq.get("accessories", [])or[]:
                                try:
                                    cur = acc.get("current")
                                    if isinstance(cur, dict):
                                        add_subslots_to_item(cur)
                                except Exception:
                                    pass

                            try:
                                eq.setdefault('accessories', [])
                                for sub in eq.get('subslots', [])or[]:
                                    try:
                                        s_slot = sub.get('slot')
                                        s_name = sub.get('name')or s_slot
                                        exists = False
                                        for a in eq.get('accessories', [])or[]:
                                            try:
                                                if a and isinstance(a, dict)and(a.get('slot')==s_slot or a.get('name')==s_name):
                                                    exists = True
                                                    break
                                            except Exception:
                                                pass
                                        if not exists:
                                            try:
                                                eq['accessories'].append({'name':s_name, 'slot':s_slot, 'current':sub.get('current'), 'attachment':True})
                                            except Exception:
                                                pass
                                    except Exception:
                                        pass
                            except Exception:
                                pass
                except Exception:
                    pass

        for item in save_data.get("storage", []):
            if isinstance(item, dict):
                add_subslots_to_item(item)
                for acc in item.get("accessories", [])or[]:
                    try:
                        cur = acc.get("current")
                        if isinstance(cur, dict):
                            _add_attachment_subslots_to_weapon(item, acc, cur)
                    except Exception:
                        pass

        if "hands"in save_data and "items"in save_data["hands"]:
            for item in save_data["hands"]["items"]:
                if isinstance(item, dict):
                    add_subslots_to_item(item)
                    for acc in item.get("accessories", [])or[]:
                        try:
                            cur = acc.get("current")
                            if isinstance(cur, dict):
                                _add_attachment_subslots_to_weapon(item, acc, cur)
                        except Exception:
                            pass

        for slot_name, equipped_item in save_data.get("equipment", {}).items():
            if equipped_item and isinstance(equipped_item, dict):
                for acc in equipped_item.get("accessories", [])or[]:
                    try:
                        cur = acc.get("current")
                        if isinstance(cur, dict):
                            add_subslots_to_item(cur)
                            _add_attachment_subslots_to_weapon(equipped_item, acc, cur)
                    except Exception:
                        pass

        for slot_name, equipped_item in save_data.get("equipment", {}).items():
            if equipped_item and isinstance(equipped_item, dict)and "items"in equipped_item:
                for item in equipped_item["items"]:
                    if isinstance(item, dict):
                        add_subslots_to_item(item)
                        for acc in item.get("accessories", [])or[]:
                            try:
                                cur = acc.get("current")
                                if isinstance(cur, dict):
                                    _add_attachment_subslots_to_weapon(item, acc, cur)
                            except Exception:
                                pass

    except Exception as e:
        logging.warning(f"Failed to populate equipment subslots: {e}")

    return save_data

def _add_attachment_subslots_to_weapon(weapon, parent_accessory, attachment):

    try:
        if not weapon or not isinstance(weapon, dict):
            return
        if not attachment or not isinstance(attachment, dict):
            return

        attachment_subslots = attachment.get('subslots', [])or[]
        if not attachment_subslots:
            return

        weapon.setdefault('accessories', [])
        parent_slot = parent_accessory.get('slot')
        attachment_name = attachment.get('name', 'Attachment')

        for sub in attachment_subslots:
            try:
                s_slot = sub.get('slot')
                s_name = sub.get('name')or s_slot
                display_name = f"{attachment_name} â†’ {s_name}"

                exists = False
                for a in weapon.get('accessories', [])or[]:
                    try:
                        if a and isinstance(a, dict):
                            if a.get('_is_attachment_subslot')and a.get('_parent_accessory_slot')==parent_slot and a.get('_subslot_slot')==s_slot:
                                exists = True
                                a['current']= sub.get('current')
                                a['name']= display_name
                                break
                    except Exception:
                        pass

                if not exists:
                    weapon['accessories'].append({
                    'name':display_name,
                    'slot':s_slot,
                    'current':sub.get('current'),
                    'attachment':True,
                    '_parent_accessory_slot':parent_slot,
                    '_subslot_slot':s_slot,
                    '_is_attachment_subslot':True
                    })
            except Exception:
                pass
    except Exception:
        pass

def add_subslots_to_item(item):

    try:
        return _add_subslots_to_item_recursive(item, seen = None)
    except Exception as e:
        logging.warning(f"Failed to add subslots to item: {e}")
        return item

def _add_subslots_to_item_recursive(item, seen = None):
    if not item or not isinstance(item, dict):
        return item

    if seen is None:
        seen = set()

    obj_id = id(item)
    if obj_id in seen:
        return item
    seen.add(obj_id)

    try:

        if "subslots"not in item:
            table_files = sorted(glob.glob(os.path.join("tables", f"*{global_variables.get('table_extension', '.sldtbl')}")))
            if table_files:
                item_id = item.get("id")
                if item_id is not None:
                    found = False
                    for tf in table_files:
                        try:
                            with open(tf, 'r', encoding = 'utf-8')as f:
                                table_data = json.load(f)
                        except Exception:
                            continue
                        tables = table_data.get("tables", {})
                        for tbl_items in tables.values():
                            if not isinstance(tbl_items, list):
                                continue
                            for it in tbl_items:
                                try:
                                    if isinstance(it, dict)and it.get("id")==item_id:
                                        table_item = it
                                        if "subslots"in table_item:

                                            resolved_subslots =[]
                                            for subslot in table_item["subslots"]:
                                                cur = subslot.get("current", None)
                                                resolved_cur = cur
                                                if cur is not None and(isinstance(cur, int)or(isinstance(cur, str)and str(cur).isdigit())):
                                                    try:
                                                        iid = int(cur)

                                                        for _tf in table_files:
                                                            try:
                                                                with open(_tf, 'r', encoding = 'utf-8')as _f:
                                                                    _td = json.load(_f)
                                                            except Exception:
                                                                continue
                                                            for arr in _td.get('tables', {}).values():
                                                                if isinstance(arr, list):
                                                                    for candidate in arr:
                                                                        if isinstance(candidate, dict)and candidate.get('id')==iid:
                                                                            resolved_cur = candidate.copy()
                                                                            break
                                                                    if isinstance(resolved_cur, dict):
                                                                        break
                                                            if isinstance(resolved_cur, dict):
                                                                break
                                                    except Exception:
                                                        resolved_cur = cur

                                                    resolved_subslots.append({
                                                    "name":subslot.get("name"),
                                                    "slot":subslot.get("slot"),
                                                    "current":None
                                                    })

                                            try:
                                                if isinstance(item, dict):
                                                    item.setdefault('accessories', [])
                                                    for sub in resolved_subslots:
                                                        try:
                                                            s_slot = sub.get('slot')
                                                            s_name = sub.get('name')or s_slot
                                                            found = False
                                                            for a in item.get('accessories', [])or[]:
                                                                try:
                                                                    if a and isinstance(a, dict)and(a.get('slot')==s_slot or a.get('name')==s_name):
                                                                        found = True
                                                                        break
                                                                except Exception:
                                                                    pass
                                                            if not found:
                                                                try:
                                                                    item['accessories'].append({'name':s_name, 'slot':s_slot, 'current':None, 'attachment':True})
                                                                except Exception:
                                                                    pass
                                                        except Exception:
                                                            pass
                                            except Exception:
                                                pass
                                            item["subslots"]= resolved_subslots
                                            logging.debug(f"Added {len(item['subslots'])} subslots to item ID {item_id}({item.get('name')})")
                                        found = True
                                        break
                                except Exception:
                                    continue
                            if found:
                                break
                        if found:
                            break
    except Exception:
        pass

    try:

        for sub in item.get("items", [])or[]:
            try:
                if isinstance(sub, dict):
                    _add_subslots_to_item_recursive(sub, seen)
            except Exception:
                pass

        for subslot in item.get("subslots", [])or[]:
            try:
                cur = subslot.get("current")
                if isinstance(cur, dict):
                    _add_subslots_to_item_recursive(cur, seen)
            except Exception:
                pass

        for acc in item.get("accessories", [])or[]:
            try:
                cur = acc.get("current")
                if isinstance(cur, dict):
                    _add_subslots_to_item_recursive(cur, seen)
            except Exception:
                pass
    except Exception:
        pass

    return item

def update_item_keys_from_table(save_data):

    try:
        table_files = sorted(glob.glob(os.path.join("tables", f"*{global_variables.get('table_extension', '.sldtbl')}")))
        if not table_files:
            logging.warning("No table files found for item key update")
            return save_data

        cur_tbl = global_variables.get("current_table")
        target_file = None
        if cur_tbl:
            for fpath in table_files:
                if os.path.abspath(fpath).endswith(cur_tbl)or os.path.basename(fpath)==cur_tbl:
                    target_file = fpath
                    break

        if not target_file:
            target_file = table_files[0]

        try:
            with open(target_file, 'r', encoding = 'utf-8')as f:
                table_data = json.load(f)
        except Exception as e:
            logging.error(f"Failed to load table file for item key update: {target_file}: {e}")
            return save_data

        all_items_map = {}
        for table_name, items in table_data.get("tables", {}).items():
            if isinstance(items, list):
                for item in items:
                    if isinstance(item, dict)and "id"in item:
                        all_items_map[item["id"]]= item

        variable_keys = {
        "quantity", "current", "items", "subslots", "uses_left", "hits_left",
        "battery_life", "loaded", "chambered", "rounds",
        "accessories", "attachment"
        }

        changed_any = False

        def update_item(item):
            nonlocal changed_any
            """Update a single item's keys from table"""
            if not isinstance(item, dict)or "id"not in item:
                return item

            item_id = item.get("id")
            if item_id not in all_items_map:
                return item

            table_item = all_items_map[item_id]

            preserved_data = {key:item[key]for key in variable_keys if key in item}

            synced_keys =[]
            for key, value in table_item.items():
                if key in variable_keys:
                    continue
                if isinstance(key, str)and key.startswith("_"):
                    continue

                local_val = item.get(key, None)
                try:
                    different = local_val !=value
                except Exception:
                    different = True

                if different:
                    item[key]= value
                    synced_keys.append(key)

            if synced_keys:
                logging.info(f"Updated item id={item_id} name={item.get('name', '<unknown>')} keys_synced={synced_keys}")
                changed_any = True

            for key, value in preserved_data.items():
                item[key]= value

            if "subslots"in item:
                for subslot in item["subslots"]:
                    if isinstance(subslot, dict)and subslot.get("current"):
                        update_item(subslot["current"])

            if "items"in item and isinstance(item["items"], list):
                for contained_item in item["items"]:
                    update_item(contained_item)

            return item

        for item in save_data.get("storage", []):
            update_item(item)

        if "hands"in save_data and "items"in save_data["hands"]:
            for item in save_data["hands"]["items"]:
                update_item(item)

        for slot_name, equipped_item in save_data.get("equipment", {}).items():
            if isinstance(equipped_item, dict):
                update_item(equipped_item)
            elif isinstance(equipped_item, list):
                for it in equipped_item:
                    if isinstance(it, dict):
                        update_item(it)

        if changed_any:
            logging.info(f"Item keys successfully synced from table {os.path.join('tables', os.path.basename(target_file))}")
        else:
            logging.info(f"Item keys updated from table data: no changes detected in {os.path.join('tables', os.path.basename(target_file))}")

    except Exception as e:
        logging.error(f"Failed to update item keys from table: {e}")

    return save_data

persistentdata = {
"last_loaded_save":None,
"save_uuids":{},
"lootcrate_uuids":{},
"transfer_uuids":{}
}

ATTACHMENTS_VERSION = 0

dm_users =[base64.b64decode(user).decode('utf-8').lower()for user in dm_users]

for user in dm_users:
    if user in os.getlogin().lower():
        if not global_variables["dmmode"]["value"]and not global_variables["dmmode"]["forced"]:
            global_variables["dmmode"]["value"]= True
            logging.info(f"DM user '{user}' detected.DM mode toggled on.")
        elif global_variables["dmmode"]["value"]:
            logging.info(f"DM user '{user}' detected.DM mode already active.")
        else:
            logging.info(f"DM user '{user}' detected.DM mode is forced off.")

        def _console_command_loop():
            try:
                log_console_colored(logging.getLogger(), logging.INFO, "Console command thread started.Type 'help' for commands.", 'cyan')
            except Exception:
                pass

            import ast

            ALLOWED_FUNCS = {
            'len':len, 'str':str, 'int':int, 'float':float, 'bool':bool,
            'sum':sum, 'min':min, 'max':max, 'sorted':sorted, 'repr':repr,
            'json':json
            }

            ALLOWED_NAMES = {
            'dm_users':dm_users,
            'global_variables':global_variables,
            }

            ALLOWED_NODE_TYPES =(
            ast.Expression, ast.Tuple, ast.List, ast.Dict, ast.Set,
            ast.Load, ast.Constant, ast.BinOp, ast.UnaryOp, ast.BoolOp,
            ast.Compare, ast.IfExp, ast.Subscript, ast.Slice, ast.Index,
            ast.Name, ast.Call, ast.Attribute, ast.ListComp, ast.DictComp,
            ast.comprehension
            )

            def _is_ast_safe(node):

                if not isinstance(node, ALLOWED_NODE_TYPES):
                    return False
                for child in ast.iter_child_nodes(node):
                    if isinstance(child, ast.Name):
                        if child.id in('True', 'False', 'None'):
                            continue
                        if child.id not in ALLOWED_NAMES and child.id not in ALLOWED_FUNCS:
                            return False
                    if isinstance(child, ast.Call):

                        func = child.func
                        if isinstance(func, ast.Name):
                            if func.id not in ALLOWED_FUNCS:
                                return False
                        elif isinstance(func, ast.Attribute):

                            value = func.value
                            if not(isinstance(value, ast.Name)and value.id in ALLOWED_FUNCS):
                                return False
                        else:
                            return False
                    if not _is_ast_safe(child):
                        return False
                return True

            def safe_eval(expr:str):
                try:
                    parsed = ast.parse(expr, mode = 'eval')
                except Exception as e:
                    raise ValueError(f"Invalid expression: {e}")
                if not _is_ast_safe(parsed):
                    raise ValueError("Expression contains disallowed operations or names")
                env = {}
                env.update(ALLOWED_FUNCS)
                env.update(ALLOWED_NAMES)
                return eval(compile(parsed, '<safe_eval>', 'eval'), {'__builtins__':{}}, env)

            while True:
                try:
                    try:

                        prompt = f"{os.getlogin()}:~ "
                        try:
                            import sys

                            sys.stdout.write('\n')
                            sys.stdout.flush()
                        except Exception:
                            pass
                        cmd = input(prompt)

                        try:
                            log_console_colored(logging.getLogger(), logging.INFO, f"CMD: {os.getlogin()}:~ {cmd}", 'magenta')
                        except Exception:
                            pass
                    except EOFError:
                        time.sleep(0.25)
                        continue
                    if not cmd:
                        continue
                    cmd = cmd.strip()
                    dev_ok = bool(global_variables.get('devmode', {}).get('value'))or bool(global_variables.get('devmode', {}).get('forced'))
                    if not dev_ok:
                        log_console_colored(logging.getLogger(), logging.WARNING, "Console commands are disabled(devmode off).", 'yellow')
                        continue

                    lower = cmd.lower()
                    if lower in('help', '?'):
                        out = "Commands: help, print dm users, print globals, print global <key>, exit, pause <secs>, eval <expr>"
                        log_console_colored(logging.getLogger(), logging.INFO, out, 'green')
                        continue

                    if lower in('print dm users', 'print dm_users', 'print dmusers'):
                        try:
                            log_console_colored(logging.getLogger(), logging.INFO, f"dm_users(decoded): {dm_users}", 'cyan')
                        except Exception:
                            logging.exception('Failed to print dm_users')
                        continue

                    if lower in('print globals', 'print global_variables'):
                        try:
                            safe = json.dumps(global_variables, indent = 2, default = str)
                            log_console_colored(logging.getLogger(), logging.INFO, safe, 'cyan')
                        except Exception:
                            logging.exception('Failed to print global_variables')
                        continue

                    if lower.startswith('print global '):
                        key = cmd[len('print global '):].strip()
                        try:
                            val = global_variables.get(key)
                            log_console_colored(logging.getLogger(), logging.INFO, f"global {key}: {val}", 'cyan')
                        except Exception:
                            logging.exception('Failed to print global %s', key)
                        continue

                    if lower in('exit', 'quit'):
                        try:
                            log_console_colored(logging.getLogger(), logging.INFO, 'Exit requested from console â€” attempting graceful shutdown', 'green')
                        except Exception:
                            pass
                        try:

                            app_obj = globals().get('app')
                            if app_obj and hasattr(app_obj, '_safe_exit'):
                                try:
                                    app_obj._safe_exit()
                                except Exception:
                                    logging.exception('App._safe_exit() raised an exception')

                                time.sleep(0.25)
                                if 'os'in globals():
                                    globals()['os']._exit(0)
                                else:
                                    import os as _os
                                    _os._exit(0)
                            else:

                                safe_fn = globals().get('safe_exit')or globals().get('_safe_exit')
                                if callable(safe_fn):
                                    try:
                                        safe_fn()
                                    except Exception:
                                        logging.exception('Module-level safe exit raised an exception')
                                    time.sleep(0.25)
                                    if 'os'in globals():
                                        globals()['os']._exit(0)
                                    else:
                                        import os as _os
                                        _os._exit(0)
                                else:

                                    if 'os'in globals():
                                        globals()['os']._exit(0)
                                    else:
                                        import os as _os
                                        _os._exit(0)
                        except Exception:
                            try:
                                import sys
                                sys.exit(0)
                            except Exception:
                                return

                    if lower.startswith('pause ')or lower.startswith('sleep '):
                        try:
                            parts = cmd.split()
                            secs = float(parts[1])if len(parts)>1 else 1.0
                            log_console_colored(logging.getLogger(), logging.INFO, f'Pausing for {secs} seconds', 'green')
                            time.sleep(max(0.0, secs))
                        except Exception:
                            log_console_colored(logging.getLogger(), logging.WARNING, 'Usage: pause <seconds>', 'yellow')
                        continue

                    if lower.startswith('eval '):
                        expr = cmd[len('eval '):].strip()
                        try:
                            res = safe_eval(expr)
                            log_console_colored(logging.getLogger(), logging.INFO, f"=> {repr(res)}", 'cyan')
                        except Exception as e:
                            log_console_colored(logging.getLogger(), logging.WARNING, f"Eval error: {e}", 'yellow')
                        continue

                    try:
                        res = safe_eval(cmd)
                        log_console_colored(logging.getLogger(), logging.INFO, f"=> {repr(res)}", 'cyan')
                        continue
                    except Exception:
                        pass

                    log_console_colored(logging.getLogger(), logging.WARNING, f"Unknown or disallowed command: {cmd}", 'yellow')

                except Exception:
                    try:
                        logging.exception('Console command loop error')
                    except Exception:
                        pass

        try:
            t = threading.Thread(target = _console_command_loop, daemon = True)
            t.start()
        except Exception:
            logging.exception('Failed to start console command thread')

def send_windows_notification(title:str, message:str):

    if os.name !='nt':
        return
    try:
        from winotify import Notification, audio
        global version
        toast = Notification(
        app_id = f"DOOM Tools {version}",
        title = title,
        msg = message,
        duration = "short"
        )
        toast.set_audio(audio.Default, loop = False)
        toast.show()
    except ImportError:
        try:
            ps_script = f'''
            [Windows.UI.Notifications.ToastNotificationManager, Windows.UI.Notifications, ContentType = WindowsRuntime]| Out-Null
            [Windows.Data.Xml.Dom.XmlDocument, Windows.Data.Xml.Dom.XmlDocument, ContentType = WindowsRuntime]| Out-Null
            $template = @"
            <toast>
                <visual>
                    <binding template="ToastText02">
                        <text id="1">{title}</text>
                        <text id="2">{message}</text>
                    </binding>
                </visual>
                <audio src="ms-winsoundevent:Notification.Default"/>
            </toast>
"@
            $xml = New-Object Windows.Data.Xml.Dom.XmlDocument
            $xml.LoadXml($template)
            $toast =[Windows.UI.Notifications.ToastNotification]::new($xml)
            [Windows.UI.Notifications.ToastNotificationManager]::CreateToastNotifier("DOOM-Tools").Show($toast)
            '''
            subprocess.run(['powershell', '-Command', ps_script], capture_output = True)
        except Exception:
            pass

class App:

    PLATFORM_DEFAULTS = {
    "M203":{"ammo_type":"40mm_grenade", "capacity":1, "reload_sound_folder":"m203"}
    }

    def _save_persistent_data(self):

        try:
            persistent_path = os.path.join(saves_folder or "saves", "persistent_data.sldsv")
            pickled_persistent = pickle.dumps(persistentdata)
            encoded_persistent = base64.b85encode(pickled_persistent).decode('utf-8')
            with open(persistent_path, 'w')as f:
                f.write(encoded_persistent)
            logging.info(f"Persistent data saved to {persistent_path}")
        except Exception as e:
            logging.error(f"Failed to save persistent data: {e}")
    def _safe_focus(self, widget):

        try:
            if widget and getattr(widget, 'winfo_exists', lambda:False)():
                try:
                    widget.focus()
                except Exception:
                    try:
                        widget.focus_set()
                    except Exception:
                        pass
        except Exception:
            pass
    def _write_save_to_path(self, path, data):
        try:
            if not path.endswith(global_variables.get("save_extension", ".sldsv")):
                path +=global_variables.get("save_extension", ".sldsv")

            filename = os.path.basename(path)
            excluded_from_backup = {"persistent_data.sldsv", "settings.sldsv", "appearance_settings.sldsv", "dm_settings.sldsv"}
            if filename not in excluded_from_backup and isinstance(data, dict):
                try:
                    char_name = data.get("charactername", "Unknown")
                    safe_char_name = "".join(c if c.isalnum()or c in " _-"else "_"for c in char_name).strip()
                    if not safe_char_name:
                        safe_char_name = "Unknown"

                    backup_folder = os.path.join(saves_folder or "saves", "backups", safe_char_name)
                    archive_folder = os.path.join(backup_folder, "archive")
                    os.makedirs(backup_folder, exist_ok = True)
                    os.makedirs(archive_folder, exist_ok = True)

                    backup_files = sorted(glob.glob(os.path.join(backup_folder, "*.sldsv")))
                    if len(backup_files)>=50:
                        archive_name = os.path.join(archive_folder, f"backups_archive_{datetime.now().strftime('%Y%m%d_%H%M%S')}.zip")
                        with zipfile.ZipFile(archive_name, 'w', zipfile.ZIP_DEFLATED)as zipf:
                            for backup_file in backup_files:
                                zipf.write(backup_file, os.path.basename(backup_file))
                                os.remove(backup_file)
                        logging.info(f"Archived {len(backup_files)} backups to {archive_name}")

                    backup_filename = f"backup_{datetime.now().strftime('%Y%m%d_%H%M%S_%f')}.sldsv"
                    backup_path = os.path.join(backup_folder, backup_filename)

                    if os.path.exists(path):
                        try:
                            import shutil
                            shutil.copy2(path, backup_path)
                            logging.info(f"Created backup at {backup_path}")
                        except Exception as backup_err:
                            logging.warning(f"Failed to create backup copy: {backup_err}")
                    else:
                        pickled_backup = pickle.dumps(data)
                        encoded_backup = base64.b85encode(pickled_backup).decode('utf-8')
                        with open(backup_path, 'w', encoding = 'utf-8')as bf:
                            bf.write(encoded_backup)
                        logging.info(f"Created backup at {backup_path}")
                except Exception as backup_err:
                    logging.warning(f"Failed to create backup: {backup_err}")

            pickled = pickle.dumps(data)
            encoded = base64.b85encode(pickled).decode('utf-8')
            with open(path, 'w', encoding = 'utf-8')as f:
                f.write(encoded)
            logging.info(f"Data written to {path}(pickled+base85)")
        except Exception as e:
            logging.error(f"Failed to write save to {path}: {e}")

    def _read_save_from_path(self, path):
        try:
            if not path.endswith(global_variables.get("save_extension", ".sldsv")):
                path +=global_variables.get("save_extension", ".sldsv")
            if not os.path.exists(path):
                logging.error(f"Save file '{path}' does not exist.")
                return None
            with open(path, 'r', encoding = 'utf-8')as f:
                text = f.read()

            try:
                pickled = base64.b85decode(text.encode('utf-8'))
                data = pickle.loads(pickled)
                if isinstance(data, dict):
                    logging.info(f"Loaded save from {path}(pickled+base85)")
                    return data
            except Exception:
                pass

            try:
                data = json.loads(text)
                if isinstance(data, dict):
                    logging.info(f"Loaded save from {path}(json)")
                    return data
            except Exception:
                pass
            logging.error(f"Failed to parse save file: {path}")
            return None
        except Exception as e:
            logging.error(f"Failed to read save from {path}: {e}")
    def _save_file(self, data):
        if currentsave is None:
            logging.error("No current save file to save data to.")
            return
        else:

            try:
                if isinstance(data, dict):
                    tbl = None

                    ct = global_variables.get('current_table')
                    if ct:
                        tbl = ct
                    else:

                        tfiles = sorted(glob.glob(os.path.join('tables', f"*{global_variables.get('table_extension', '.sldtbl')}")))
                        if tfiles:
                            tbl = os.path.basename(tfiles[0])
                    if tbl:
                        data.setdefault('_table', tbl)
            except Exception:
                pass

            if os.path.isabs(currentsave):
                save_path = currentsave
            else:
                save_path = os.path.join(saves_folder or "saves", currentsave or "")
            try:

                try:
                    if isinstance(data, dict):
                        if 'save_data'in globals():
                            outer = globals().get('save_data')
                            if isinstance(outer, dict)and outer is not data:
                                try:
                                    outer.clear()
                                    outer.update(data)
                                    globals()['save_data']= outer
                                except Exception:
                                    globals()['save_data']= data
                            else:
                                globals()['save_data']= data
                        else:
                            globals()['save_data']= data
                except Exception:
                    pass
                try:
                    setattr(self, '_current_save_data', data)
                except Exception:
                    pass

                self._write_save_to_path(save_path, data)
            except Exception as e:
                logging.error(f"Failed to save data to {currentsave}: {e}")
        self._save_persistent_data()
    def _load_file(self, save_filename):

        try:
            persistent_path = os.path.join(saves_folder or "saves", "persistent_data.sldsv")
            if os.path.exists(persistent_path):
                with open(persistent_path, 'r')as f:
                    encoded_persistent = f.read()
                pickled_persistent = base64.b85decode(encoded_persistent.encode('utf-8'))
                loaded_persistent = pickle.loads(pickled_persistent)
                if isinstance(loaded_persistent, dict):
                    persistentdata.update(loaded_persistent)
                    logging.info(f"Persistent data loaded from {persistent_path}")
                else:
                    logging.warning(f"Persistent data in {persistent_path} is not a dict; got {type(loaded_persistent)}")
            else:
                logging.info("No persistent data file found, using defaults")
        except Exception as e:
            logging.warning(f"Failed to load persistent data: {e}")

        if save_filename is None:
            return None

        if os.path.isabs(save_filename):
            save_path = save_filename
        else:
            save_path = os.path.join(saves_folder or "saves", save_filename)
        if not save_path.endswith('.sldsv'):
            save_path +='.sldsv'
        if not os.path.exists(save_path):
            logging.error(f"Save file '{save_path}' does not exist.")
            return None

        try:

            data = self._read_save_from_path(save_path)
            if data is None:
                logging.error(f"Failed to load data from {save_path}")
                return None
            if not isinstance(data, dict):
                logging.error(f"Loaded data from {save_path} is not a dict; got {type(data)}")
                return None
            logging.info(f"Data loaded from {save_path}")

            try:
                table_from_save = None
                if isinstance(data, dict):
                    table_from_save = data.get('_table')or data.get('table')

                if table_from_save:

                    matches = sorted(glob.glob(os.path.join('tables', f"*{global_variables.get('table_extension', '.sldtbl')}")))
                    found = None
                    for fpath in matches:
                        try:
                            b = os.path.basename(fpath)
                            name_no_ext = os.path.splitext(b)[0]
                            absf = os.path.abspath(fpath)

                            if(
                            b ==table_from_save
                            or name_no_ext ==table_from_save
                            or absf.endswith(table_from_save)
                            or absf.endswith(table_from_save +global_variables.get('table_extension', '.sldtbl'))
                            ):
                                found = fpath
                                break
                        except Exception:
                            continue
                    if not found:
                        logging.error(f"Save '{save_path}' requires table '{table_from_save}' which is not present locally.Load aborted.")
                        return None

                    try:
                        global_variables['current_table']= os.path.basename(found)
                        with open(found, 'r', encoding = 'utf-8')as tf:
                            globals()['table_data']= json.load(tf)
                        logging.info(f"Loaded table {os.path.basename(found)} from save metadata")
                    except Exception as e:
                        logging.error(f"Failed to load table file {found} specified by save: {e}")
                        return None
                else:

                    try:
                        cur_tbl = global_variables.get('current_table')
                        if not cur_tbl:
                            tfiles = sorted(glob.glob(os.path.join('tables', f"*{global_variables.get('table_extension', '.sldtbl')}")))
                            if tfiles:
                                cur_tbl = os.path.basename(tfiles[0])
                                global_variables['current_table']= cur_tbl
                                try:
                                    with open(tfiles[0], 'r', encoding = 'utf-8')as tf:
                                        globals()['table_data']= json.load(tf)
                                except Exception:
                                    pass

                        if isinstance(data, dict)and cur_tbl:
                            data.setdefault('_table', cur_tbl)
                    except Exception:
                        pass
            except Exception:
                logging.debug('Table metadata handling failed during load, continuing')
            if save_path.endswith('.sldsv'):
                parts = os.path.basename(save_path).rsplit('_', 1)
                if len(parts)==2:
                    uuid_part = parts[1].replace('.sldsv', '')
                    persistentdata["last_loaded_save"]= uuid_part
                    logging.info(f"Updated last_loaded_save to UUID: {uuid_part}")

            data = populate_equipment_with_subslots(data)

            data = update_item_keys_from_table(data)

            try:
                data = self._normalize_save_data(data)
                try:
                    data = self._sync_equipment_slots(data)
                except Exception:
                    logging.exception("Failed to sync equipment slots after normalization")
            except Exception as e:
                logging.warning(f"Failed to normalize save data: {e}")
            return data
        except Exception as e:
            logging.error(f"Failed to load data from '{save_path}': {e}")
            return None

    def _get_ammo_table_data(self):
        try:
            table_files = glob.glob(os.path.join("tables", "*.sldtbl"))
            if table_files:
                with open(table_files[0], 'r')as f:
                    table_data = json.load(f)
                return table_data.get("tables", {}).get("ammunition", [])
        except Exception:
            pass
        return[]

    def _ensure_round_variant(self, round_data, ammo_table = None):
        if not isinstance(round_data, dict):
            return round_data

        if round_data.get("variant")and round_data.get("variant")not in["Unknown", "unknown", None, ""]:
            return round_data

        if ammo_table is None:
            ammo_table = self._get_ammo_table_data()

        caliber = round_data.get("caliber")
        if not caliber:
            name = round_data.get("name", "")
            if " | "in name:
                parts = name.split(" | ", 1)
                caliber = parts[0]
                round_data["caliber"]= caliber

        if caliber:
            for ammo in ammo_table:
                ammo_cal = ammo.get("caliber")
                cal_match = False
                if isinstance(ammo_cal, list):
                    cal_match = caliber in ammo_cal
                else:
                    cal_match = ammo_cal ==caliber

                if cal_match:
                    variants = ammo.get("variants", [])
                    if variants:
                        first_variant = variants[0]
                        round_data["variant"]= first_variant.get("name", "FMJ")
                        if first_variant.get("type"):
                            round_data["type"]= first_variant.get("type")
                        if first_variant.get("pen"):
                            round_data["pen"]= first_variant.get("pen")
                        if first_variant.get("tip"):
                            round_data["tip"]= first_variant.get("tip")
                        if first_variant.get("modifiers"):
                            round_data["modifiers"]= first_variant.get("modifiers")
                        return round_data
                    break

        if not round_data.get("variant"):
            round_data["variant"]= "FMJ"

        return round_data

    def _normalize_save_data(self, data):

        ammo_table = self._get_ammo_table_data()

        def normalize_round(r):
            if isinstance(r, dict):
                return self._ensure_round_variant(r, ammo_table)
            if isinstance(r, str):
                parts = r.split(" | ", 1)
                if len(parts)==2:
                    caliber, variant = parts
                    return {"name":r, "caliber":caliber, "variant":variant}
                round_data = {"name":r}
                return self._ensure_round_variant(round_data, ammo_table)
            round_data = {"name":str(r)}
            return self._ensure_round_variant(round_data, ammo_table)

        def normalize_mag(mag):
            if not isinstance(mag, dict):
                return {"name":str(mag), "rounds":[]}
            if "rounds"in mag and isinstance(mag["rounds"], list):
                mag["rounds"]=[normalize_round(rr)for rr in mag["rounds"]]
            return mag

        for slot_name, item in(data.get("equipment")or {}).items():

            if isinstance(item, dict):
                items_iter =[item]
            elif isinstance(item, list):
                items_iter =[it for it in item if isinstance(it, dict)]
            else:
                items_iter =[]

            for it in items_iter:
                if it.get("loaded"):
                    it["loaded"]= normalize_mag(it["loaded"])

                if it.get("rounds")and isinstance(it.get("rounds"), list):
                    it["rounds"]=[normalize_round(rr)for rr in it.get("rounds", [])]

                if it.get("chambered")and isinstance(it.get("chambered"), str):
                    it["chambered"]= normalize_round(it.get("chambered"))

                if "subslots"in it and isinstance(it["subslots"], list):
                    for sub in it["subslots"]:
                        curr = sub.get("current")
                        if isinstance(curr, dict):
                            if curr.get("loaded"):
                                curr["loaded"]= normalize_mag(curr["loaded"])
                            if curr.get("rounds")and isinstance(curr.get("rounds"), list):
                                curr["rounds"]=[normalize_round(rr)for rr in curr.get("rounds", [])]
                            if curr.get("chambered")and isinstance(curr.get("chambered"), str):
                                curr["chambered"]= normalize_round(curr.get("chambered"))

        hands = data.get("hands")or {}
        if isinstance(hands, dict)and isinstance(hands.get("items"), list):
            new_items =[]
            for it in hands.get("items", []):
                if isinstance(it, dict):
                    if it.get("rounds")and isinstance(it.get("rounds"), list):
                        it["rounds"]=[normalize_round(rr)for rr in it.get("rounds", [])]
                    new_items.append(it)
                elif isinstance(it, str):
                    new_items.append({"name":it})
                else:
                    new_items.append({"name":str(it)})
            hands["items"]= new_items

        for slot_name, item in(data.get("equipment")or {}).items():

            items_iter =[]
            if isinstance(item, dict):
                items_iter =[item]
            elif isinstance(item, list):
                items_iter =[it for it in item if isinstance(it, dict)]

            for it in items_iter:
                if "items"in it and isinstance(it["items"], list):
                    new_items =[]
                    for subit in it["items"]:
                        if isinstance(subit, dict):
                            if subit.get("rounds")and isinstance(subit.get("rounds"), list):
                                subit["rounds"]=[normalize_round(rr)for rr in subit.get("rounds", [])]
                            new_items.append(subit)
                        elif isinstance(subit, str):
                            new_items.append({"name":subit})
                        else:
                            new_items.append({"name":str(subit)})
                    it["items"]= new_items

        storage = data.get("storage")or {}
        if isinstance(storage, dict):
            for k, v in storage.items():
                if isinstance(v, list):
                    new_items =[]
                    for it in v:
                        if isinstance(it, dict):
                            if it.get("rounds")and isinstance(it.get("rounds"), list):
                                it["rounds"]=[normalize_round(rr)for rr in it.get("rounds", [])]
                            new_items.append(it)
                        elif isinstance(it, str):
                            new_items.append({"name":it})
                        else:
                            new_items.append({"name":str(it)})
                    storage[k]= new_items

        return data
    def _sync_equipment_slots(self, data):

        try:
            if not isinstance(data, dict):
                return data

            equip = data.setdefault('equipment', {}) or {}
            empty_equip = emptysave.get('equipment', {}) if isinstance(emptysave, dict) else {}

            hands = data.setdefault('hands', {}) or {}
            hands_items = hands.setdefault('items', []) if isinstance(hands, dict) else []

            # Move any slots present in save but not in emptysave back to hands
            extra_slots = [k for k in list(equip.keys()) if k not in empty_equip]
            for slot in extra_slots:
                val = equip.pop(slot, None)
                if not val:
                    continue
                if isinstance(val, dict):
                    hands_items.append(val)
                elif isinstance(val, list):
                    for it in val:
                        if isinstance(it, dict):
                            hands_items.append(it)
                        else:
                            hands_items.append({'name': str(it)})
                else:
                    hands_items.append({'name': str(val)})

            # Ensure all slots from emptysave exist in the save (add missing as None)
            for slot in empty_equip.keys():
                if slot not in equip:
                    equip[slot] = None

            # Reorder equipment to match emptysave ordering
            new_equip = {}
            for slot in empty_equip.keys():
                new_equip[slot] = equip.get(slot)
            data['equipment'] = new_equip

            return data
        except Exception:
            logging.exception('Error while syncing equipment slots')
            return data
    def __init__(self):
        customtkinter.set_appearance_mode(appearance_settings["appearance_mode"])

        theme_name = appearance_settings["color_theme"]
        builtin_themes =["dark-blue", "blue", "green"]
        if theme_name not in builtin_themes:

            custom_theme_path = os.path.join(os.getcwd(), "themes", f"{theme_name}.json")
            if os.path.exists(custom_theme_path):
                customtkinter.set_default_color_theme(custom_theme_path)
            else:
                logging.warning(f"Custom theme '{custom_theme_path}' not found, falling back to dark-blue")
                appearance_settings["color_theme"]= "dark-blue"
                customtkinter.set_default_color_theme("dark-blue")
        else:
            customtkinter.set_default_color_theme(theme_name)
        self.root = customtkinter.CTk()
        self.root.title("DOOM Tools")
        self.root.geometry(appearance_settings["resolution"])
        self.root.resizable(False, False)

        try:
            self.root.protocol("WM_DELETE_WINDOW", self._on_window_close)
        except Exception:
            pass

        self.root.attributes('-fullscreen', appearance_settings.get("fullscreen", False))

        try:
            if appearance_settings.get("borderless")and not appearance_settings.get("fullscreen"):
                self.root.overrideredirect(True)
        except Exception:
            pass

        self._sound_cache = {}

        self._load_file(None)
        if persistentdata.get("last_loaded_save"):
            last_save_uuid = persistentdata["last_loaded_save"]
            last_save_name = persistentdata.get("save_uuids", {}).get(last_save_uuid)
            if not last_save_name:

                pattern = os.path.join(saves_folder or "saves", f"*_{last_save_uuid}.sldsv")
                matches = glob.glob(pattern)
                if matches:
                    last_save_name = os.path.basename(matches[0]).replace(f"_{last_save_uuid}.sldsv", "")
                    persistentdata["save_uuids"][last_save_uuid]= last_save_name
                    self._save_persistent_data()
                else:
                    logging.warning(f"Last save UUID {last_save_uuid} not found in save_uuids")
            if last_save_name:
                save_filename = f"{last_save_name}_{last_save_uuid}.sldsv"
                loaded_data = self._load_file(save_filename)
                if loaded_data:

                    try:
                        globals()['save_data']= loaded_data
                    except Exception:
                        pass
                    try:
                        self._current_save_data = loaded_data
                    except Exception:
                        pass
                    global currentsave
                    currentsave = save_filename.replace(".sldsv", "")
                    logging.info(f"Automatically loaded last save: {save_filename}")
                else:
                    logging.warning(f"Failed to load last save: {save_filename}")
        self._build_main_menu()

        try:
            if global_variables.get("devmode", {}).get("value"):
                try:
                    self._create_dev_toolbar()
                except Exception:
                    logging.exception("Failed to initialize dev toolbar")
        except Exception:
            pass
        self.root.mainloop()
    def _play_ui_sound(self, sound_filename):
        sound_path = os.path.join("sounds", "ui", sound_filename +".ogg")
        if os.path.exists(sound_path):
            try:
                sound = pygame.mixer.Sound(sound_path)
                sound.play()
                logging.debug(f"Played UI sound: {sound_filename}")
            except Exception as e:
                logging.warning(f"Failed to play sound '{sound_filename}': {e}")
    def _create_sound_button(self, parent, text, command, **kwargs):
        def safe_command():
            try:
                self._play_ui_sound("click")
                command()
            except Exception as e:
                logging.exception("Button command failed for '%s': %s", text, e)
        button = customtkinter.CTkButton(
        parent, text = text, command = safe_command, **kwargs
        )
        def on_hover(e):
            if button.cget("state")!="disabled":
                self._play_ui_sound("hover")
        button.bind("<Enter>", on_hover)
        return button
    def _safe_sound_play(self, directory, sound_filename, block = False):

        if os.path.isabs(sound_filename)or sound_filename.endswith((".wav", ".ogg")):
            sound_path = sound_filename
        else:
            sound_path = os.path.join("sounds", directory, sound_filename +".ogg")

        try:
            exists = os.path.exists(sound_path)
        except Exception:
            exists = False
        logging.debug(f"_safe_sound_play: resolved '{sound_filename}' -> '{sound_path}', exists={exists}, block={block}")

        if os.path.exists(sound_path):
            try:

                if not hasattr(self, "_sound_cache"):
                    self._sound_cache = {}
                cache = self._sound_cache
                sound = cache.get(sound_path)
                if sound is None:
                    try:
                        sound = pygame.mixer.Sound(sound_path)
                    except Exception as e:
                        logging.warning(f"Failed to load sound '{sound_path}': {e}")
                        return
                    cache[sound_path]= sound

                if not hasattr(self, '_muffled_sound_cache'):
                    try:
                        self._muffled_sound_cache = {}
                    except Exception:
                        self._muffled_sound_cache = {}

                try:
                    vol = 1.0

                    if getattr(self, '_flashbang_mute', False):
                        base = os.path.basename(sound_path).lower()

                        if('ring'in base)or('explosion'in base)or('flashbang'in base):
                            vol = 1.0
                        else:
                            vol = float(getattr(self, '_flashbang_volume', 0.0))

                    try:
                        if getattr(self, '_bang_muffle', False):
                            base = os.path.basename(sound_path).lower()
                            is_bang =('explosion'in base)or('flashbang'in base)or('bang'in base)
                            logging.debug(f"_safe_sound_play: bang_muffle active, filename='{base}', is_bang={is_bang}")
                            if is_bang:
                                muffled = None
                                try:
                                    mcache = getattr(self, '_muffled_sound_cache', {})
                                    muffled = mcache.get(sound_path)
                                except Exception:
                                    muffled = None

                                if muffled is None:
                                    try:
                                        import numpy as _np
                                        from numpy.fft import rfft, irfft, fftfreq
                                        snd_arr = None
                                        try:
                                            snd_arr = pygame.sndarray.array(sound)
                                        except Exception:
                                            snd_arr = None

                                        if snd_arr is None:
                                            muffled = None
                                        else:
                                            try:
                                                mixer_info = pygame.mixer.get_init()
                                                sr = int(mixer_info[0])if mixer_info and mixer_info[0]else 44100
                                            except Exception:
                                                sr = 44100

                                            orig_dtype = snd_arr.dtype
                                            snd_float = snd_arr.astype(_np.float32)
                                            if snd_float.ndim ==1:
                                                channels = 1
                                                channels_data =[snd_float]
                                            else:
                                                channels = snd_float.shape[1]
                                                channels_data =[snd_float[:, c]for c in range(channels)]

                                            processed =[]
                                            cutoff = float(getattr(self, '_bang_muffle_cutoff', 3000.0))
                                            for chdata in channels_data:
                                                n = chdata.size
                                                spec = rfft(chdata)
                                                freqs = fftfreq(n, 1.0 /sr)[:spec.size]
                                                spec[freqs >cutoff]= 0
                                                proc = irfft(spec)
                                                ir_len = int(0.03 *sr)
                                                if ir_len >1:
                                                    ir = _np.exp(-_np.linspace(0, 4, ir_len))
                                                    ir = ir /(ir.sum()+1e-9)
                                                    try:
                                                        proc = _np.convolve(proc, ir, mode = 'same')
                                                    except Exception:
                                                        pass
                                                processed.append(proc)

                                            if channels ==1:
                                                proc_arr = processed[0]
                                            else:
                                                proc_arr = _np.vstack(processed).T

                                            try:
                                                if _np.issubdtype(orig_dtype, _np.integer):
                                                    info = _np.iinfo(orig_dtype)
                                                    proc_arr = _np.clip(proc_arr, info.min, info.max)
                                                else:
                                                    proc_arr = _np.clip(proc_arr, -1.0, 1.0)
                                                proc_arr = proc_arr.astype(orig_dtype)
                                            except Exception:
                                                try:
                                                    proc_arr = proc_arr.astype(orig_dtype)
                                                except Exception:
                                                    pass

                                            try:
                                                muffled_sound = pygame.sndarray.make_sound(proc_arr)
                                                try:
                                                    self._muffled_sound_cache[sound_path]= muffled_sound
                                                except Exception:
                                                    pass
                                                muffled = muffled_sound
                                            except Exception:
                                                muffled = None
                                    except Exception:
                                        muffled = None

                                if muffled is not None:
                                    sound = muffled
                                    logging.debug(f"_safe_sound_play: using synthesized muffled sound for {sound_path}")
                                else:
                                    mv = float(getattr(self, '_bang_muffle_volume', 0.45))
                                    vol = min(vol, mv)
                                    logging.debug(f"_safe_sound_play: no synthesized muffled sound, capping vol to {vol}")
                    except Exception:
                        logging.exception('_safe_sound_play: error during muffle handling')
                        pass
                    final_vol = max(0.0, min(1.0, vol))
                    try:
                        sound.set_volume(final_vol)
                    except Exception:
                        logging.debug('_safe_sound_play: failed to set volume on sound object')
                    logging.debug(f"_safe_sound_play: final volume set to {final_vol} for '{sound_path}'(flashbang_mute={getattr(self, '_flashbang_mute', False)}, bang_muffle={getattr(self, '_bang_muffle', False)})")
                except Exception:
                    pass

                try:
                    ch = sound.play()
                    if ch is None:

                        ch = pygame.mixer.find_channel(True)
                        if ch:
                            ch.play(sound)
                            logging.debug(f"Played sound(forced channel) file: {sound_path}")
                        else:
                            logging.warning(f"No channel available to play sound: {sound_path}")
                    else:
                        logging.debug(f"Played sound file: {sound_path}")

                    if block:
                        try:
                            length = sound.get_length()
                        except Exception:
                            length = None
                        if length and length >0:
                            time.sleep(length)
                        else:

                            try:
                                if ch:
                                    while ch.get_busy():
                                        time.sleep(0.01)
                            except Exception:
                                pass
                except Exception as e:
                    logging.warning(f"Failed to play sound '{sound_path}': {e}")
            except Exception as e:
                logging.warning(f"Failed to play sound '{sound_path}': {e}")

    def _add_item_to_container(self, container_items, item_to_add, force_no_stack = False):

        if not isinstance(container_items, list):
            return False
        if not isinstance(item_to_add, dict):
            container_items.append(item_to_add)
            return False

        if force_no_stack or item_to_add.get("can_stack")==False:
            container_items.append(item_to_add)
            return False

        non_stackable_keys =["magazinesystem", "capacity", "firearm", "attachment", "subslots", "loaded", "chambered"]
        if any(k in item_to_add for k in non_stackable_keys):
            container_items.append(item_to_add)
            return False

        def items_match_for_stacking(existing, new_item):

            if existing.get("name")!=new_item.get("name"):
                return False
            if existing.get("id")!=new_item.get("id"):
                return False

            if existing.get("caliber")!=new_item.get("caliber"):
                return False

            if existing.get("variant")!=new_item.get("variant"):
                return False

            if existing.get("can_stack")==False:
                return False

            if any(k in existing for k in non_stackable_keys):
                return False
            return True

        for existing_item in container_items:
            if not isinstance(existing_item, dict):
                continue
            if items_match_for_stacking(existing_item, item_to_add):

                existing_qty = existing_item.get("quantity", 1)
                new_qty = item_to_add.get("quantity", 1)
                try:
                    existing_qty = int(existing_qty)if existing_qty else 1
                    new_qty = int(new_qty)if new_qty else 1
                except(ValueError, TypeError):
                    existing_qty = 1
                    new_qty = 1
                existing_item["quantity"]= existing_qty +new_qty
                return True

        container_items.append(item_to_add)
        return False

    def _add_rounds_to_container(self, container_items, rounds_list):

        if not isinstance(container_items, list)or not isinstance(rounds_list, list):
            return

        round_groups = {}
        for r in rounds_list:
            if not isinstance(r, dict):
                continue
            caliber = r.get("caliber", "Unknown")
            variant = r.get("variant", "Unknown")
            key =(str(caliber), str(variant))
            if key not in round_groups:
                round_groups[key]=[]
            round_groups[key].append(r)

        for(caliber, variant), group_rounds in round_groups.items():

            sample = group_rounds[0]if group_rounds else {}
            stack_item = {
            "name":sample.get("name", f"{caliber} | {variant}"),
            "caliber":caliber,
            "variant":variant,
            "quantity":len(group_rounds)
            }

            for k in["type", "pen", "modifiers", "tip", "rarity"]:
                if k in sample:
                    stack_item[k]= sample[k]

            self._add_item_to_container(container_items, stack_item)

    def _center_popup_on_window(self, popup, width = None, height = None):

        try:
            popup.update_idletasks()

            if width is None:
                width = popup.winfo_reqwidth()
            if height is None:
                height = popup.winfo_reqheight()

            root_x = self.root.winfo_x()
            root_y = self.root.winfo_y()
            root_width = self.root.winfo_width()
            root_height = self.root.winfo_height()

            x = root_x +(root_width //2)-(width //2)
            y = root_y +(root_height //2)-(height //2)

            screen_width = popup.winfo_screenwidth()
            screen_height = popup.winfo_screenheight()
            x = max(0, min(x, screen_width -width))
            y = max(0, min(y, screen_height -height))

            popup.geometry(f"{width}x{height}+{x}+{y}")
        except Exception:

            try:
                popup.geometry("+100+100")
            except Exception:
                pass

    def _popup_show_info(self, title, message, sound = "popup"):
        self._play_ui_sound(sound)

        try:
            theme = customtkinter.ThemeManager.theme
            toplevel_fg = theme.get("CTkToplevel", {}).get("fg_color")
            label_text_color = theme.get("CTkLabel", {}).get("text_color")
            button_fg = theme.get("CTkButton", {}).get("fg_color")
            button_text = theme.get("CTkButton", {}).get("text_color")
        except Exception:
            toplevel_fg = None
            label_text_color = None
            button_fg = None
            button_text = None

        if toplevel_fg:
            popup = customtkinter.CTkToplevel(self.root, fg_color = toplevel_fg)
        else:
            popup = customtkinter.CTkToplevel(self.root)
        popup.title(title)
        popup.transient(self.root)

        try:
            screen_w = self.root.winfo_screenwidth()
            wraplength = min(1000, max(300, screen_w -200))
        except Exception:
            wraplength = 400

        label_kwargs = {"text":message, "wraplength":wraplength, "font":customtkinter.CTkFont(size = 13)}
        if label_text_color:
            label_kwargs["text_color"]= label_text_color
        label = customtkinter.CTkLabel(popup, **label_kwargs)
        label.pack(pady = 30, padx = 20)

        def close_popup():
            self._play_ui_sound("click")
            popup.destroy()

        btn_kwargs = {"text":"OK", "command":close_popup, "width":120, "height":35}
        if button_fg:
            btn_kwargs["fg_color"]= button_fg
        if button_text:
            btn_kwargs["text_color"]= button_text
        ok_button = customtkinter.CTkButton(popup, **btn_kwargs)
        ok_button.pack(pady = 10)

        popup.update_idletasks()

        try:
            req_w = popup.winfo_reqwidth()
            req_h = popup.winfo_reqheight()
            screen_w = popup.winfo_screenwidth()
            screen_h = popup.winfo_screenheight()
            max_w = max(200, screen_w -100)
            max_h = max(150, screen_h -100)
            final_w = min(req_w, max_w)
            final_h = min(req_h, max_h)
            self._center_popup_on_window(popup, final_w, final_h)
        except Exception:
            try:
                popup.geometry("+100+100")
            except Exception:
                pass

        popup.deiconify()
        popup.grab_set()
        popup.lift()
        self._safe_focus(popup)

    def _popup_progress(self, title, message):

        self._play_ui_sound("popup")
        try:
            theme = customtkinter.ThemeManager.theme
            toplevel_fg = theme.get("CTkToplevel", {}).get("fg_color")
            label_text_color = theme.get("CTkLabel", {}).get("text_color")
        except Exception:
            toplevel_fg = None
            label_text_color = None

        if toplevel_fg:
            popup = customtkinter.CTkToplevel(self.root, fg_color = toplevel_fg)
        else:
            popup = customtkinter.CTkToplevel(self.root)
        popup.title(title)
        popup.geometry("450x120")
        popup.transient(self.root)

        label_kwargs = {"text":message, "wraplength":400, "font":customtkinter.CTkFont(size = 13)}
        if label_text_color:
            label_kwargs["text_color"]= label_text_color
        label = customtkinter.CTkLabel(popup, **label_kwargs)
        label.pack(pady = 20, padx = 20)

        def update(text):
            try:
                label.configure(text = text)
                popup.update_idletasks()
            except Exception:
                pass

        def close():
            try:
                self._play_ui_sound("click")
            except Exception:
                pass
            try:
                popup.destroy()
            except Exception:
                pass

        self._center_popup_on_window(popup, 450, 120)
        popup.deiconify()
        popup.lift()
        return {"update":update, "close":close, "popup":popup}

    def _popup_confirm(self, title, message, on_confirm):
        self._play_ui_sound("popup")
        popup = customtkinter.CTkToplevel(self.root)
        popup.title(title)
        popup.geometry("450x220")
        popup.transient(self.root)

        label = customtkinter.CTkLabel(popup, text = message, wraplength = 400, font = customtkinter.CTkFont(size = 13))
        label.pack(pady = 30, padx = 20)

        button_frame = customtkinter.CTkFrame(popup, fg_color = "transparent")
        button_frame.pack(pady = 10)

        def confirm():
            self._play_ui_sound("click")
            popup.destroy()

            try:
                on_confirm(True)
            except TypeError:
                on_confirm()

        def cancel():
            self._play_ui_sound("click")
            popup.destroy()

            try:
                on_confirm(False)
            except TypeError:
                pass

        yes_button = customtkinter.CTkButton(button_frame, text = "Yes", command = confirm, width = 120, height = 35)
        yes_button.pack(side = "left", padx = 10)
        no_button = customtkinter.CTkButton(button_frame, text = "No", command = cancel, width = 120, height = 35)
        no_button.pack(side = "left", padx = 10)

        self._center_popup_on_window(popup, 450, 220)
        popup.deiconify()
        popup.lift()

    def _popup_ask_integer(self, title, prompt, initial_value = 1, min_value = 1, max_value = 100, on_result = None):

        self._play_ui_sound("popup")
        popup = customtkinter.CTkToplevel(self.root)
        popup.title(title)
        popup.geometry("400x180")
        popup.transient(self.root)

        label = customtkinter.CTkLabel(popup, text = prompt, wraplength = 380, font = customtkinter.CTkFont(size = 13))
        label.pack(pady =(16, 8), padx = 16)

        input_frame = customtkinter.CTkFrame(popup, fg_color = "transparent")
        input_frame.pack(fill = "x", padx = 16, pady =(0, 8))

        try:
            iv = int(initial_value)
        except Exception:
            iv = min_value
        if iv <min_value:
            iv = min_value
        if iv >max_value:
            iv = max_value

        value_var = customtkinter.IntVar(value = iv)

        entry = customtkinter.CTkEntry(input_frame, width = 80, textvariable = value_var)
        entry.pack(side = "left", padx =(0, 10))

        slider = None
        if max_value >min_value:

            steps = max_value -min_value
            slider = customtkinter.CTkSlider(
            input_frame,
            from_ = min_value,
            to = max_value,
            number_of_steps = steps,
            variable = value_var,
            width = 200
            )
            slider.pack(side = "left", fill = "x", expand = True)

        min_label = customtkinter.CTkLabel(input_frame, text = f"({min_value}-{max_value})", font = customtkinter.CTkFont(size = 11), text_color = "gray")
        min_label.pack(side = "left", padx =(10, 0))

        result:dict = {"value":None}

        def validate_and_confirm():
            try:
                val = int(value_var.get())
                if val <min_value:
                    val = min_value
                elif val >max_value:
                    val = max_value
                result["value"]= val
                self._play_ui_sound("click")
                popup.destroy()
                if on_result:
                    on_result(val)
            except(ValueError, TypeError):
                self._popup_show_info("Invalid Input", "Please enter a valid number")

        def cancel():
            self._play_ui_sound("click")
            result["value"]= None
            popup.destroy()
            if on_result:
                on_result(None)

        button_frame = customtkinter.CTkFrame(popup, fg_color = "transparent")
        button_frame.pack(pady =(8, 12))

        ok_btn = customtkinter.CTkButton(button_frame, text = "OK", command = validate_and_confirm, width = 120, height = 34)
        ok_btn.pack(side = "left", padx = 8)

        cancel_btn = customtkinter.CTkButton(button_frame, text = "Cancel", command = cancel, width = 120, height = 34, fg_color = "#444444")
        cancel_btn.pack(side = "left", padx = 8)

        entry.bind("<Return>", lambda e:validate_and_confirm())
        popup.bind("<Escape>", lambda e:cancel())

        self._center_popup_on_window(popup, 400, 180)
        popup.deiconify()
        popup.lift()
        popup.grab_set()
        self._safe_focus(entry)

        if on_result is None:

            popup.wait_window()
            return result.get("value")

    def _popup_select_option(self, title, prompt, options):

        self._play_ui_sound("popup")
        popup = customtkinter.CTkToplevel(self.root)
        popup.title(title)
        popup.geometry("480x160")
        popup.transient(self.root)

        label = customtkinter.CTkLabel(popup, text = prompt, wraplength = 440, font = customtkinter.CTkFont(size = 13))
        label.pack(pady =(16, 8), padx = 16)

        sel_var = customtkinter.StringVar(value =(options[0]if options else ""))
        opt = customtkinter.CTkOptionMenu(popup, values = options, variable = sel_var)
        opt.pack(pady =(0, 12), padx = 16, fill = "x")

        result = {"value":None}

        def confirm():
            try:
                self._play_ui_sound("click")
            except Exception:
                pass
            result["value"]= sel_var.get()# type: ignore
            popup.destroy()

        def cancel():
            try:
                self._play_ui_sound("click")
            except Exception:
                pass
            result["value"]= None
            popup.destroy()

        button_frame = customtkinter.CTkFrame(popup, fg_color = "transparent")
        button_frame.pack(pady =(4, 12))
        ok_btn = customtkinter.CTkButton(button_frame, text = "OK", command = confirm, width = 120, height = 34)
        ok_btn.pack(side = "left", padx = 8)
        cancel_btn = customtkinter.CTkButton(button_frame, text = "Cancel", command = cancel, width = 120, height = 34)
        cancel_btn.pack(side = "left", padx = 8)

        self._center_popup_on_window(popup, 480, 160)
        popup.deiconify()
        popup.lift()

        popup.grab_set()
        popup.wait_window()
        return result.get("value")
    def _clear_window(self):
        for widget in self.root.winfo_children():
            try:

                if getattr(widget, "_is_dev_toolbar", False):
                    continue
            except Exception:
                pass
            try:
                widget.destroy()
            except Exception:
                pass
        logging.debug("Cleared window called")
    def _build_main_menu(self):
        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)
        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew")
        title_label = customtkinter.CTkLabel(main_frame, text = "DOOM Tools", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title_label.pack(pady = 20)
        version_label = customtkinter.CTkLabel(main_frame, text = f"Version: {version}", font = customtkinter.CTkFont(size = 16))
        version_label.pack()
        current_character = customtkinter.CTkLabel(main_frame, text = f"Current Character: {currentsave if currentsave else 'None'}", font = customtkinter.CTkFont(size = 14))
        current_character.pack(pady = 10)
        current_table = customtkinter.CTkLabel(main_frame, text = f"Current Data Table: {global_variables.get('current_table', 'Default')}", font = customtkinter.CTkFont(size = 14))
        current_table.pack(pady = 5)
        loot_button = self._create_sound_button(main_frame, "Looting", self._open_loot_tool, width = 500, height = 50, font = customtkinter.CTkFont(size = 16), state = "disabled"if currentsave is None else "normal")
        loot_button.pack(pady = 10)
        business_button = self._create_sound_button(main_frame, "Businesses", self._open_business_tool, width = 500, height = 50, font = customtkinter.CTkFont(size = 16), state = "disabled"if currentsave is None else "normal")
        business_button.pack(pady = 10)
        inventoryman_button = self._create_sound_button(main_frame, "Inventory Manager", self._open_inventory_manager_tool, width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        inventoryman_button.pack(pady = 10)
        combatmode_button = self._create_sound_button(main_frame, "Combat Mode", self._open_combat_mode_tool, width = 500, height = 50, font = customtkinter.CTkFont(size = 16), state = "disabled"if currentsave is None else "normal")
        combatmode_button.pack(pady = 10)
        exitb_button = self._create_sound_button(main_frame, "Exit", self._safe_exit, width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        exitb_button.pack(pady = 10)
        settings_button = self._create_sound_button(main_frame, "Settings", self._open_settings, width = 500, height = 50, font = customtkinter.CTkFont(size = 16), state = "normal")
        settings_button.pack(pady = 10)
        if global_variables["devmode"]["value"]:
            devtools_button = self._create_sound_button(main_frame, "Developer Tools", self._open_dev_tools, width = 500, height = 50, font = customtkinter.CTkFont(size = 16), state = "disabled"if currentsave is None else "normal")
            devtools_button.pack(pady = 10)
        else:
            devtools_button = customtkinter.CTkButton(main_frame, text = "Developer Tools", width = 500, height = 50, font = customtkinter.CTkFont(size = 16), state = "disabled")
            devtools_button.pack(pady = 10)
        if global_variables["dmmode"]["value"]:
            dmmode_button = self._create_sound_button(main_frame, "DM Tools", self._open_dm_tools, width = 500, height = 50, font = customtkinter.CTkFont(size = 16), state = "disabled"if currentsave is None else "normal")
            dmmode_button.pack(pady = 10)
        else:
            dmmode_button = customtkinter.CTkButton(main_frame, text = "DM Tools", width = 500, height = 50, font = customtkinter.CTkFont(size = 16), state = "disabled")
            dmmode_button.pack(pady = 10)
        if currentsave is None:
            currentsave_label = customtkinter.CTkLabel(main_frame, text = "No save loaded.Please load a save to enable tools.", font = customtkinter.CTkFont(size = 14), text_color = "red")
            currentsave_label.pack(pady = 20)

    def _create_dev_toolbar(self):
        try:

            if not getattr(self, "_dev_toolbar_frame", None):

                top = customtkinter.CTkToplevel()

                try:
                    top._is_dev_toolbar = True
                except Exception:
                    pass
                top.title("devtools")
                top.resizable(True, True)

                try:
                    top.configure(fg_color = "#1f1f1f")
                except Exception:
                    pass

                font_large = customtkinter.CTkFont(size = 16)
                content = customtkinter.CTkFrame(top, fg_color = "#1f1f1f")
                try:
                    content.pack(fill = "both", expand = True, padx = 8, pady = 8)
                except Exception:
                    content.grid(row = 0, column = 0, sticky = "nsew", padx = 8, pady = 8)

                cpu_row = customtkinter.CTkFrame(content, fg_color = "transparent")
                cpu_row.pack(anchor = "w")
                self._dev_cpu_text = customtkinter.CTkLabel(cpu_row, text = "CPU/MEM:", font = customtkinter.CTkFont(size = 13), anchor = "w")
                self._dev_cpu_text.pack(side = "left")
                self._dev_cpu_value = customtkinter.CTkLabel(cpu_row, text = "initializing", font = font_large, text_color = "cyan", anchor = "w")
                self._dev_cpu_value.pack(side = "left", padx =(6, 0))

                gpu_row = customtkinter.CTkFrame(content, fg_color = "transparent")
                gpu_row.pack(anchor = "w", pady =(2, 0))
                self._dev_gpu_text = customtkinter.CTkLabel(gpu_row, text = "GPU:", font = customtkinter.CTkFont(size = 13), anchor = "w")
                self._dev_gpu_text.pack(side = "left")
                self._dev_gpu_value = customtkinter.CTkLabel(gpu_row, text = "N/A", font = font_large, text_color = "cyan", anchor = "w")
                self._dev_gpu_value.pack(side = "left", padx =(6, 0))

                self._dev_thread_lbl = customtkinter.CTkLabel(content, text = "Threads: N/A", font = font_large, anchor = "w")
                self._dev_thread_lbl.pack(anchor = "w", pady =(4, 0))

                logs_row = customtkinter.CTkFrame(content, fg_color = "transparent")
                logs_row.pack(anchor = "w", pady =(6, 0))
                small_font = customtkinter.CTkFont(size = 14)

                def _make_counter(parent, text, color):
                    t = customtkinter.CTkLabel(parent, text = text, font = small_font)
                    v = customtkinter.CTkLabel(parent, text = "0", font = small_font, text_color = color)
                    container = customtkinter.CTkFrame(parent, fg_color = "transparent")
                    t.pack(in_ = container, side = "left")
                    v.pack(in_ = container, side = "left", padx =(4, 8))
                    container.pack(side = "left")
                    return t, v

                _, self._dev_log_info_lbl = _make_counter(logs_row, "INFO:", "green")
                _, self._dev_log_warn_lbl = _make_counter(logs_row, "WARN:", "yellow")
                _, self._dev_log_err_lbl = _make_counter(logs_row, "ERR:", "red")
                _, self._dev_log_dbg_lbl = _make_counter(logs_row, "DBG:", "cyan")
                _, self._dev_log_crit_lbl = _make_counter(logs_row, "CRIT:", "magenta")

                table_row = customtkinter.CTkFrame(content, fg_color = "transparent")
                table_row.pack(anchor = "w", pady =(6, 0))
                self._dev_tables_lbl = customtkinter.CTkLabel(table_row, text = "Tables: 0 Items: 0 IDs: 0 Dups: 0", font = small_font, anchor = "w")
                self._dev_tables_lbl.pack(side = "left")
                nid_text = customtkinter.CTkLabel(table_row, text = "Next ID:", font = small_font)
                nid_text.pack(side = "left", padx =(12, 2))
                self._dev_nextid_lbl = customtkinter.CTkLabel(table_row, text = "N/A", font = small_font, text_color = "#7EC8FF")
                self._dev_nextid_lbl.pack(side = "left")

                defs_frame = customtkinter.CTkScrollableFrame(content, height = 220)
                defs_frame.pack(fill = "both", expand = False, pady =(8, 0))
                defs_label_title = customtkinter.CTkLabel(defs_frame, text = "Loaded Definitions:", font = small_font, anchor = "w")
                defs_label_title.pack(anchor = "w", pady =(4, 2), padx = 4)
                self._dev_defs_lbl = customtkinter.CTkLabel(defs_frame, text = "(refreshing...)", font = customtkinter.CTkFont(size = 13), anchor = "w", justify = "left")
                self._dev_defs_lbl.pack(fill = "both", expand = True, padx = 4, pady =(0, 4))

                try:
                    inspect_btn = customtkinter.CTkButton(content, text = "Inspect Tables/Strings", command = self._open_dev_data_viewer, width = 240, height = 36, fg_color = "#2f2f2f")
                    inspect_btn.pack(anchor = "w", pady =(8, 0))
                except Exception:
                    pass

                try:
                    self._dev_logs_summary = customtkinter.CTkLabel(content, text = "", font = small_font, anchor = "w")
                    self._dev_logs_summary.pack(anchor = "w", pady =(4, 0))
                except Exception:
                    self._dev_logs_summary = None

                try:
                    try:
                        content.update_idletasks()
                    except Exception:
                        top.update_idletasks()

                    try:
                        req_w = content.winfo_reqwidth()+16
                        req_h = content.winfo_reqheight()+16
                    except Exception:
                        req_w = top.winfo_reqwidth()
                        req_h = top.winfo_reqheight()
                    req_w = max(req_w, 320)
                    req_h = max(req_h, 240)
                    try:
                        top.minsize(req_w, req_h)
                        top.geometry(f"{req_w}x{req_h}")
                    except Exception:
                        pass
                except Exception:
                    pass

                self._dev_toolbar_frame = top

                try:
                    import GPUtil
                    self._gputil = GPUtil
                except Exception:
                    self._gputil = None

                try:
                    self._dev_proc = psutil.Process()
                except Exception:
                    self._dev_proc = None

                try:
                    self._dev_queue = queue.Queue(maxsize = 1)
                except Exception:
                    self._dev_queue = None
                try:
                    self._dev_worker_running = True
                except Exception:
                    self._dev_worker_running = False

                try:
                    def _on_dev_close():
                        try:
                            self._dev_worker_running = False
                        except Exception:
                            pass
                        try:
                            if getattr(top, 'destroy', None):
                                top.destroy()
                        except Exception:
                            pass
                        try:
                            self._dev_toolbar_frame = None
                        except Exception:
                            pass
                    top.protocol("WM_DELETE_WINDOW", _on_dev_close)
                except Exception:
                    pass

                try:
                    if getattr(self, '_dev_worker_thread', None)is None:
                        self._dev_worker_thread = threading.Thread(target = self._dev_toolbar_worker, name = 'DevToolbarWorker', daemon = True)
                        self._dev_worker_thread.start()
                except Exception:
                    pass

                try:
                    self._update_dev_toolbar()
                except Exception:
                    pass
        except Exception:
            logging.exception("Failed to create dev toolbar")

    def _open_dev_data_viewer(self):
        try:
            top = customtkinter.CTkToplevel()
            top.title("Dev Data Explorer")
            top.transient(self.root)
            self._center_popup_on_window(top, 1000, 600)
            try:
                top.configure(fg_color = "#1f1f1f")
            except Exception:
                pass

            left = customtkinter.CTkFrame(top, width = 300)
            left.pack(side = "left", fill = "y", padx = 6, pady = 6)
            right = customtkinter.CTkFrame(top)
            right.pack(side = "right", fill = "both", expand = True, padx = 6, pady = 6)

            lbl = customtkinter.CTkLabel(left, text = "In-memory data:", anchor = "w")
            lbl.pack(anchor = "w", pady =(4, 2))

            listbox_frame = customtkinter.CTkFrame(left, fg_color = "transparent")
            listbox_frame.pack(fill = "both", expand = True)

            lb = _tk.Listbox(listbox_frame, width = 48, exportselection = False)
            sb = _tk.Scrollbar(listbox_frame, command = lb.yview)
            lb.config(yscrollcommand = sb.set)
            lb.pack(side = "left", fill = "both", expand = True)
            sb.pack(side = "right", fill = "y")

            tbl_map =[]
            try:
                if globals().get('table_data')is not None:
                    lb.insert(_tk.END, "global_table_data")
                    tbl_map.append(("global_table_data", globals().get('table_data')))
            except Exception:
                pass
            try:
                if globals().get('all_table_items')is not None:
                    lb.insert(_tk.END, "all_table_items")
                    tbl_map.append(("all_table_items", globals().get('all_table_items')))
            except Exception:
                pass

            try:
                extras =[
                ("currentsave", globals().get('currentsave')),
                ("save_data", globals().get('save_data')),
                ("self._current_save_data", getattr(self, '_current_save_data', None)),
                ("global_variables", globals().get('global_variables')),
                ("appearance_settings", globals().get('appearance_settings')),
                ("folders", globals().get('folders')),
                ]
                for name, val in extras:
                    try:
                        if val is not None:
                            lb.insert(_tk.END, name)
                            tbl_map.append((name, val))
                    except Exception:
                        pass
            except Exception:
                pass
            try:
                cur = global_variables.get('current_table')
                if cur:
                    lb.insert(_tk.END, f"current_table: {cur}")

                    tbl_map.append((f"current_table: {cur}", globals().get('table_data')))
            except Exception:
                pass

            top_row = customtkinter.CTkFrame(right, fg_color = "transparent")
            top_row.pack(fill = "x")

            sub_lbl = customtkinter.CTkLabel(top_row, text = "Subtable:")
            sub_lbl.pack(side = "left", padx =(4, 8))

            sub_var = customtkinter.StringVar(value = "(none)")
            sub_menu = customtkinter.CTkOptionMenu(top_row, values =["(none)"], variable = sub_var, width = 240)
            sub_menu.pack(side = "left")

            def _show_content_from_selection():
                try:
                    sel = lb.curselection()
                    if not sel:
                        return
                    idx = sel[0]
                    name, obj = tbl_map[idx]

                    data = None
                    if isinstance(obj, str)and os.path.isfile(obj):
                        try:
                            with open(obj, 'r', encoding = 'utf-8')as f:
                                data = json.load(f)
                        except Exception as e:
                            txt.delete('1.0', _tk.END)
                            txt.insert(_tk.END, f"Failed to load file: {e}")
                            return
                    else:
                        data = obj

                    choice = sub_var.get()

                    if isinstance(data, dict):
                        if name =='global_table_data'or name.startswith('current_table'):

                            content = data.get('tables', data)

                            if choice and choice !='(none)':
                                content = content.get(choice, {})
                        else:
                            if choice and choice !="(none)":
                                content = data.get('tables', {}).get(choice, data.get(choice, {}))
                            else:
                                content = data
                    else:
                        content = data

                    txt.delete('1.0', _tk.END)
                    try:
                        txt.insert(_tk.END, json.dumps(content, indent = 2, ensure_ascii = False, default = str))
                    except Exception:
                        txt.insert(_tk.END, str(content))
                except Exception as e:
                    txt.delete('1.0', _tk.END)
                    txt.insert(_tk.END, f"Failed to load: {e}")

            view_btn = customtkinter.CTkButton(top_row, text = "Refresh / Show", command = lambda:(_populate_submenu(), _show_content_from_selection()), width = 140)
            view_btn.pack(side = "left", padx = 8)

            def _open_strings_window():
                try:
                    found =[]
                    def _collect(o):
                        try:
                            if isinstance(o, str):

                                try:
                                    ext = str(global_variables.get('table_extension', '.sldtbl')).lower()
                                except Exception:
                                    ext = '.sldtbl'
                                low = o.lower()
                                if ext and ext in low:
                                    return
                                if re.search(r"\.sldtbl\b", low):
                                    return
                                found.append(o)
                            elif isinstance(o, dict):
                                for v in o.values():
                                    _collect(v)
                            elif isinstance(o, list)or isinstance(o, tuple):
                                for v in o:
                                    _collect(v)
                        except Exception:
                            pass

                    for name, obj in tbl_map:
                        _collect(obj)

                    uniq =[]
                    seen = set()
                    for s in found:
                        if s and s not in seen:
                            seen.add(s)
                            uniq.append(s)

                    sw = customtkinter.CTkToplevel()
                    sw.title('Strings Explorer')
                    sw.geometry('700x500')
                    lf = customtkinter.CTkFrame(sw)
                    lf.pack(fill = 'both', expand = True, padx = 6, pady = 6)
                    lbox = _tk.Listbox(lf)
                    lbox.pack(side = 'left', fill = 'y')
                    scr = _tk.Scrollbar(lf, command = lbox.yview)
                    scr.pack(side = 'left', fill = 'y')
                    lbox.config(yscrollcommand = scr.set)
                    txtw = _tk.Text(sw)
                    txtw.pack(side = 'right', fill = 'both', expand = True)
                    for s in uniq:
                        try:
                            lbox.insert(_tk.END, s[:120])
                        except Exception:
                            lbox.insert(_tk.END, str(s))

                    def _on_string_select(evt = None):
                        try:
                            sel = lbox.curselection()
                            if not sel:
                                return
                            idx = sel[0]
                            s = uniq[idx]
                            txtw.delete('1.0', _tk.END)
                            txtw.insert(_tk.END, s)
                        except Exception:
                            pass

                    lbox.bind('<<ListboxSelect>>', _on_string_select)
                except Exception:
                    logging.exception('Failed opening strings window')

            strings_btn = customtkinter.CTkButton(top_row, text = "Show Strings", command = _open_strings_window, width = 140)
            strings_btn.pack(side = "right", padx = 8)

            txt = _tk.Text(right)
            txt.pack(fill = "both", expand = True)

            def _populate_submenu():
                try:
                    sel = lb.curselection()
                    if not sel:
                        sub_menu.configure(values =["(none)"], variable = sub_var)
                        return
                    idx = sel[0]
                    _, path = tbl_map[idx]

                    data = None
                    if isinstance(path, str)and os.path.isfile(path):
                        try:
                            with open(path, 'r', encoding = 'utf-8')as f:
                                data = json.load(f)
                        except Exception:
                            data = None
                    else:
                        data = path
                    keys =[]
                    if isinstance(data, dict):

                        if 'tables'in data and isinstance(data['tables'], dict):
                            keys = sorted(list(data['tables'].keys()))
                        else:
                            keys = sorted(list(data.keys()))
                    if not keys:
                        keys =["(none)"]
                    sub_menu.configure(values =["(none)"]+keys)
                except Exception:
                    sub_menu.configure(values =["(none)"])

            lb.bind('<<ListboxSelect>>', lambda evt:(_populate_submenu(), _show_content_from_selection()))

            try:
                if tbl_map:
                    lb.selection_set(0)
                    _populate_submenu()
                    _show_content_from_selection()
            except Exception:
                pass

        except Exception:
            logging.exception('Failed opening Dev Data Explorer')

    def _dev_toolbar_worker(self):

        try:
            while getattr(self, '_dev_worker_running', False):
                snap = {}
                try:
                    snap['sys_cpu']= psutil.cpu_percent(interval = None)
                except Exception:
                    snap['sys_cpu']= 0.0
                try:
                    proc = getattr(self, "_dev_proc", None)or psutil.Process()
                    snap['app_cpu']= proc.cpu_percent(interval = None)
                except Exception:
                    snap['app_cpu']= 0.0
                try:
                    vm = psutil.virtual_memory()
                    snap['sys_mem_pct']= vm.percent
                    snap['sys_total_mb']= int(vm.total /(1024 *1024))
                except Exception:
                    snap['sys_mem_pct']= 0.0
                    snap['sys_total_mb']= 0
                try:
                    app_rss = proc.memory_info().rss if proc else 0
                    snap['app_rss_mb']= int(app_rss /(1024 *1024))
                except Exception:
                    snap['app_rss_mb']= 0
                try:
                    snap['app_mem_pct']= round((snap.get('app_rss_mb', 0)/snap.get('sys_total_mb', 1))*100, 1)if snap.get('sys_total_mb')else 0.0
                except Exception:
                    snap['app_mem_pct']= 0.0
                try:
                    snap['threads']= proc.num_threads()if proc else threading.active_count()
                except Exception:
                    snap['threads']= threading.active_count()

                try:
                    gput = getattr(self, "_gputil", None)
                    got = False
                    gpu_str = "N/A"
                    if gput:
                        try:
                            gpus = gput.getGPUs()
                            if gpus:
                                g = gpus[0]
                                gpu_str = f"GPU {g.id}: {int(g.load *100)}% {int(g.memoryUsed)}/{int(g.memoryTotal)}MB"
                                got = True
                        except Exception:
                            got = False
                    if not got:
                        try:
                            if shutil.which("nvidia-smi"):
                                out = subprocess.check_output([
                                "nvidia-smi",
                                "--query-gpu=utilization.gpu, memory.used, memory.total",
                                "--format=csv, noheader, nounits"
                                ], text = True, stderr = subprocess.DEVNULL)
                                line = out.strip().splitlines()[0]
                                parts =[p.strip()for p in line.split(', ')]
                                if len(parts)>=3:
                                    util, used, total = parts[0], parts[1], parts[2]
                                    gpu_str = f"GPU 0: {util}% {used}/{total}MB"
                        except Exception:
                            pass
                    snap['gpu_str']= gpu_str
                except Exception:
                    snap['gpu_str']= 'N/A'

                try:
                    snap['info_ct']= dev_log_counters.get('INFO', 0)
                    snap['warn_ct']= dev_log_counters.get('WARNING', 0)
                    snap['err_ct']= dev_log_counters.get('ERROR', 0)
                    snap['dbg_ct']= dev_log_counters.get('DEBUG', 0)
                    snap['crt_ct']= dev_log_counters.get('CRITICAL', 0)
                except Exception:
                    snap['info_ct']= snap['warn_ct']= snap['err_ct']= snap['dbg_ct']= snap['crt_ct']= 0

                try:
                    table_files = glob.glob(os.path.join('tables', '*.sldtbl'))
                    snap['tbl_count']= len(table_files)
                    total_items = 0
                    id_map = {}
                    for tf in table_files:
                        try:
                            with open(tf, 'r', encoding = 'utf-8')as fh:
                                td = json.load(fh)
                            tables = td.get('tables', {})
                            for sub, items in tables.items():
                                if isinstance(items, list):
                                    for it in items:
                                        total_items +=1
                                        if isinstance(it, dict)and 'id'in it:
                                            iid = it.get('id')
                                            id_map[iid]= id_map.get(iid, 0)+1
                        except Exception:
                            continue
                    snap['total_items']= total_items
                    snap['duplicate_ids']= sum(1 for k, v in id_map.items()if v >1)
                    snap['total_ids']= len(id_map)
                    snap['id_map']= id_map
                except Exception:
                    snap['tbl_count']= snap['total_items']= snap['duplicate_ids']= snap['total_ids']= 0
                    snap['id_map']= {}

                try:
                    ths = threading.enumerate()
                    snap['thread_names']=[t.name for t in ths][:8]
                except Exception:
                    snap['thread_names']=[]

                try:
                    defs_list =[]
                    repo_root = os.path.abspath(os.getcwd())
                    main_mod = sys.modules.get('__main__')
                    if main_mod:
                        for n, o in inspect.getmembers(main_mod):
                            try:
                                if inspect.isfunction(o):
                                    defs_list.append(f"fn: {n}")
                                elif inspect.isclass(o):
                                    defs_list.append(f"class: {n}")
                            except Exception:
                                continue
                    for mname, mod in list(sys.modules.items()):
                        try:
                            mf = getattr(mod, '__file__', None)
                            if not mf:
                                continue
                            mf_abs = os.path.abspath(mf)
                            if not mf_abs.startswith(repo_root):
                                continue
                            for n, o in inspect.getmembers(mod):
                                try:
                                    if inspect.isfunction(o):
                                        defs_list.append(f"{mname}.fn:{n}")
                                    elif inspect.isclass(o):
                                        defs_list.append(f"{mname}.class:{n}")
                                except Exception:
                                    continue
                        except Exception:
                            continue
                    defs_list = sorted(set(defs_list))[:400]
                    snap['defs_text']= "\n".join(defs_list)if defs_list else '(no definitions found)'
                except Exception:
                    snap['defs_text']= '(error collecting definitions)'

                try:
                    q = getattr(self, '_dev_queue', None)
                    if q is not None:
                        try:

                            while not q.empty():
                                try:
                                    q.get_nowait()
                                except Exception:
                                    break
                            q.put_nowait(snap)
                        except Exception:
                            pass
                except Exception:
                    pass

                try:
                    time.sleep(1.0)
                except Exception:
                    break
        except Exception:
            logging.exception('Dev toolbar worker crashed')

    def _update_dev_toolbar(self):
        try:

            try:
                if global_variables.get("devmode", {}).get("value")and not getattr(self, "_dev_toolbar_frame", None):
                    try:
                        self._create_dev_toolbar()
                    except Exception:
                        pass
                elif getattr(self, "_dev_toolbar_frame", None):
                    try:
                        if not getattr(self._dev_toolbar_frame, 'winfo_exists', lambda:True)():

                            self._create_dev_toolbar()
                    except Exception:
                        pass
            except Exception:
                pass

            snap = None
            try:
                if getattr(self, '_dev_queue', None):
                    try:
                        snap = self._dev_queue.get_nowait()
                    except Exception:
                        snap = None
            except Exception:
                snap = None

            if snap:

                sys_cpu = snap.get('sys_cpu', 0.0)
                app_cpu = snap.get('app_cpu', 0.0)
                sys_mem_pct = snap.get('sys_mem_pct', 0.0)
                sys_total_mb = snap.get('sys_total_mb', 0)
                app_rss_mb = snap.get('app_rss_mb', 0)
                app_mem_pct = snap.get('app_mem_pct', 0.0)
                threads = snap.get('threads', 0)
                gpu_str = snap.get('gpu_str', 'N/A')
                info_ct = snap.get('info_ct', 0)
                warn_ct = snap.get('warn_ct', 0)
                err_ct = snap.get('err_ct', 0)
                dbg_ct = snap.get('dbg_ct', 0)
                crt_ct = snap.get('crt_ct', 0)
                tbl_count = snap.get('tbl_count', 0)
                total_items = snap.get('total_items', 0)
                duplicate_ids = snap.get('duplicate_ids', 0)
                total_ids = snap.get('total_ids', 0)
                thread_names = snap.get('thread_names', [])
                defs_text = snap.get('defs_text', '(no definitions found)')
                id_map = snap.get('id_map', {})
            else:

                try:
                    sys_cpu = psutil.cpu_percent(interval = None)
                except Exception:
                    sys_cpu = 0.0
                try:
                    proc = getattr(self, "_dev_proc", None)or psutil.Process()
                    app_cpu = proc.cpu_percent(interval = None)
                except Exception:
                    app_cpu = 0.0
                try:
                    vm = psutil.virtual_memory()
                    sys_mem_pct = vm.percent
                    sys_total_mb = int(vm.total /(1024 *1024))
                except Exception:
                    vm = None
                    sys_mem_pct = 0.0
                    sys_total_mb = 0
                try:
                    app_rss = proc.memory_info().rss if proc else 0
                    app_rss_mb = int(app_rss /(1024 *1024))
                except Exception:
                    app_rss_mb = 0
                try:
                    app_mem_pct = round((app_rss_mb /sys_total_mb)*100, 1)if sys_total_mb else 0.0
                except Exception:
                    app_mem_pct = 0.0
                try:
                    threads = proc.num_threads()if proc else threading.active_count()
                except Exception:
                    threads = threading.active_count()
                gpu_str = "N/A"
                try:
                    gput = getattr(self, "_gputil", None)
                    got = False
                    if gput:
                        try:
                            gpus = gput.getGPUs()
                            if gpus:
                                g = gpus[0]
                                gpu_str = f"GPU {g.id}: {int(g.load *100)}% {int(g.memoryUsed)}/{int(g.memoryTotal)}MB"
                                got = True
                        except Exception:
                            got = False
                    if not got:
                        try:
                            if shutil.which("nvidia-smi"):
                                out = subprocess.check_output([
                                "nvidia-smi",
                                "--query-gpu=utilization.gpu, memory.used, memory.total",
                                "--format=csv, noheader, nounits"
                                ], text = True, stderr = subprocess.DEVNULL)
                                line = out.strip().splitlines()[0]
                                parts =[p.strip()for p in line.split(', ')]
                                if len(parts)>=3:
                                    util, used, total = parts[0], parts[1], parts[2]
                                    gpu_str = f"GPU 0: {util}% {used}/{total}MB"
                                    got = True
                        except Exception:
                            pass
                except Exception:
                    gpu_str = "N/A"
                try:
                    info_ct = dev_log_counters.get('INFO', 0)
                    warn_ct = dev_log_counters.get('WARNING', 0)
                    err_ct = dev_log_counters.get('ERROR', 0)
                    dbg_ct = dev_log_counters.get('DEBUG', 0)
                    crt_ct = dev_log_counters.get('CRITICAL', 0)
                except Exception:
                    info_ct = warn_ct = err_ct = dbg_ct = crt_ct = 0
                try:
                    table_files = glob.glob(os.path.join('tables', '*.sldtbl'))
                    tbl_count = len(table_files)
                    total_items = 0
                    id_map = {}
                    for tf in table_files:
                        try:
                            with open(tf, 'r', encoding = 'utf-8')as fh:
                                td = json.load(fh)
                            tables = td.get('tables', {})
                            for sub, items in tables.items():
                                if isinstance(items, list):
                                    for it in items:
                                        total_items +=1
                                        if isinstance(it, dict)and 'id'in it:
                                            iid = it.get('id')
                                            id_map[iid]= id_map.get(iid, 0)+1
                        except Exception:
                            continue
                    duplicate_ids = sum(1 for k, v in id_map.items()if v >1)
                    total_ids = len(id_map)
                except Exception:
                    tbl_count = total_items = duplicate_ids = total_ids = 0
                try:
                    ths = threading.enumerate()
                    thread_names =[t.name for t in ths][:8]
                except Exception:
                    thread_names =[]
                try:

                    defs_list =[]
                    main_mod = sys.modules.get('__main__')
                    if main_mod:
                        for n, o in inspect.getmembers(main_mod):
                            try:
                                if inspect.isfunction(o):
                                    defs_list.append(f"fn: {n}")
                                elif inspect.isclass(o):
                                    defs_list.append(f"class: {n}")
                            except Exception:
                                continue
                    defs_list = sorted(set(defs_list))[:400]
                    defs_text = "\n".join(defs_list)if defs_list else "(no definitions found)"
                except Exception:
                    defs_text = "(error collecting definitions)"

            try:

                if getattr(self, "_dev_cpu_value", None):

                    try:
                        if sys_total_mb >=1024:
                            sys_gb = math.ceil(sys_total_mb /1024)
                            sys_mem_repr = f"{sys_total_mb}MB({sys_gb}GB) {int(sys_mem_pct)}%"
                        else:
                            sys_mem_repr = f"{sys_total_mb}MB {int(sys_mem_pct)}%"
                    except Exception:
                        sys_mem_repr = f"{int(sys_mem_pct)}%"

                    try:
                        if app_rss_mb >=1024:
                            app_gb = math.ceil(app_rss_mb /1024)
                            app_mem_repr = f"{app_rss_mb}MB({app_gb}GB) {app_mem_pct}%"
                        else:
                            app_mem_repr = f"{app_rss_mb}MB {app_mem_pct}%"
                    except Exception:
                        app_mem_repr = f"{app_rss_mb}MB"

                    self._dev_cpu_value.configure(text = f"SYS CPU: {int(sys_cpu)}% APP CPU: {int(app_cpu)}% SYS MEM: {sys_mem_repr} APP MEM: {app_mem_repr}")
            except Exception:
                pass
            try:

                if getattr(self, "_dev_gpu_value", None):
                    self._dev_gpu_value.configure(text = f"{gpu_str}")
            except Exception:
                pass
            try:

                if getattr(self, "_dev_thread_lbl", None):
                    self._dev_thread_lbl.configure(text = f"Threads: {threads} Names: {', '.join(thread_names)if thread_names else 'N/A'}")
            except Exception:
                pass
            try:

                if getattr(self, "_dev_log_info_lbl", None):
                    self._dev_log_info_lbl.configure(text = f"{info_ct}")
                if getattr(self, "_dev_log_warn_lbl", None):
                    self._dev_log_warn_lbl.configure(text = f"{warn_ct}")
                if getattr(self, "_dev_log_err_lbl", None):
                    self._dev_log_err_lbl.configure(text = f"{err_ct}")
                if getattr(self, "_dev_log_dbg_lbl", None):
                    self._dev_log_dbg_lbl.configure(text = f"{dbg_ct}")
                if getattr(self, "_dev_log_crit_lbl", None):
                    self._dev_log_crit_lbl.configure(text = f"{crt_ct}")

                if getattr(self, "_dev_logs_summary", None):
                    try:
                        self._dev_logs_summary.configure(text = f"INFO:{info_ct} WARN:{warn_ct} ERR:{err_ct} DBG:{dbg_ct} CRIT:{crt_ct}")
                    except Exception:
                        pass
            except Exception:
                pass
            try:

                if getattr(self, "_dev_tables_lbl", None):
                    self._dev_tables_lbl.configure(text = f"Tables: {tbl_count} Items: {total_items} IDs: {total_ids} Duplicate IDs: {duplicate_ids}")
                if getattr(self, "_dev_nextid_lbl", None):
                    try:
                        next_id_val =(max(id_map.keys())+1)if id_map else 0
                    except Exception:
                        next_id_val = 0
                    self._dev_nextid_lbl.configure(text = f"{next_id_val}")

                if getattr(self, "_dev_defs_lbl", None):
                    try:
                        self._dev_defs_lbl.configure(text = defs_text)
                    except Exception:
                        pass
            except Exception:
                pass
        except Exception:
            logging.exception("Failed to update dev toolbar stats")
        finally:
            try:

                if getattr(self, "_dev_toolbar_frame", None):
                    try:
                        self._dev_toolbar_frame.after(1000, self._update_dev_toolbar)
                    except Exception:

                        try:
                            self.root.after(1000, self._update_dev_toolbar)
                        except Exception:
                            pass
                else:
                    try:
                        self.root.after(1000, self._update_dev_toolbar)
                    except Exception:
                        pass
            except Exception:
                pass
    def _open_loot_tool(self):
        logging.info("Looting definition called")
        self._clear_window()

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew")

        title_label = customtkinter.CTkLabel(main_frame, text = "Looting", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title_label.pack(pady = 20)

        try:
            table_files = glob.glob(os.path.join("tables", "*.sldtbl"))
            if not table_files:
                self._popup_show_info("Error", "No table files found.", sound = "error")
                return

            with open(table_files[0], 'r')as f:
                table_data = json.load(f)

            lootcrates = table_data.get("lootcrates", [])

            crate_files = glob.glob(os.path.join("lootcrates", f"*{global_variables['lootcrate_extension']}"))
            for crate_file in crate_files:
                try:
                    with open(crate_file, 'r')as cf:
                        encoded_data = cf.read()
                    pickled_data = base64.b85decode(encoded_data.encode('utf-8'))
                    crate_data = pickle.loads(pickled_data)
                    crate_data["_file_path"]= crate_file
                    lootcrates.append(crate_data)
                    logging.info(f"Loaded custom loot crate: {crate_data.get('name', os.path.basename(crate_file))}")
                except Exception as e:
                    logging.warning(f"Failed to load loot crate file {crate_file}: {e}")

            enemyloots =[]
            enemyloot_files = glob.glob(os.path.join("enemyloot", "*.sldenlt"))
            for el_file in enemyloot_files:
                try:
                    with open(el_file, 'rb')as ef:
                        encoded_data = ef.read()
                    pickled_data = base64.b85decode(encoded_data)
                    el_data = pickle.loads(pickled_data)
                    el_data["_file_path"]= el_file
                    enemyloots.append(el_data)
                    logging.info(f"Loaded enemy loot: {el_data.get('enemy_name', os.path.basename(el_file))}")
                except Exception as e:
                    logging.warning(f"Failed to load enemy loot file {el_file}: {e}")

            if not lootcrates and not enemyloots:
                error_label = customtkinter.CTkLabel(main_frame, text = "No loot crates or enemy loot available.", font = customtkinter.CTkFont(size = 14), text_color = "orange")
                error_label.pack(pady = 20)
                back_button = self._create_sound_button(main_frame, "Back", lambda:[self._clear_window(), self._build_main_menu()], width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
                back_button.pack(pady = 20)
                return

            scroll_frame = customtkinter.CTkScrollableFrame(main_frame)
            scroll_frame.pack(fill = "both", expand = True, padx = 20, pady = 20)

            def loot_crate(crate, crate_file_path = None):

                try:

                    if crate.get("locked", False):
                        logging.info(f"Crate '{crate.get('name')}' is locked but lockpicking not implemented yet")
                        self._popup_show_info("Locked", "This crate is locked.Lockpicking not implemented yet.", sound = "error")
                        return

                    save_path = os.path.join(saves_folder or "", (currentsave or "")+".sldsv")
                    save_data = self._load_file((currentsave or "")+".sldsv")
                    if save_data is None:
                        raise RuntimeError("Failed to load current save for add_item")

                    if crate.get("generated_items"):

                        available_items = crate.get("generated_items", [])
                        logging.info(f"Using {len(available_items)} pre-generated items from crate '{crate.get('name')}'")
                    else:

                        loot_table = crate.get("loot_table", [])
                        pulls = crate.get("pulls", 3)
                        if isinstance(pulls, dict):
                            num_pulls = random.randint(pulls.get("min", 1), pulls.get("max", 3))
                        else:
                            num_pulls = int(pulls)

                        rarity_weights = table_data.get("rarity_weights", {})

                        luck_stat = save_data.get("stats", {}).get("luck", 0)if save_data else 0
                        luck_effect = rarity_weights.get("Luck Effect", 1.5)

                        available_items =[]
                        for _ in range(num_pulls):

                            weighted_entries =[]
                            for entry in loot_table:
                                entry_rarity = entry.get("rarity", "Common")
                                base_weight = rarity_weights.get(entry_rarity, 1)

                                if luck_stat >0:
                                    weight = base_weight *(1 +(luck_stat *luck_effect /100))
                                else:
                                    weight = base_weight

                                weight = max(1, int(weight))
                                weighted_entries.extend([entry]*weight)

                            if weighted_entries:
                                selected_entry = random.choice(weighted_entries)
                                items_to_add = self._resolve_loot_entry(selected_entry, table_data, save_data)
                                for item in items_to_add:
                                    item_copy = {k:v for k, v in item.items()if k !="table_category"}
                                    item_copy = add_subslots_to_item(item_copy)
                                    available_items.append(item_copy)

                        if crate_file_path and available_items:
                            updated_crate = crate.copy()
                            updated_crate["generated_items"]= available_items
                            updated_crate.pop("loot_table", None)
                            try:
                                pickled_crate = pickle.dumps(updated_crate)
                                encoded_crate = base64.b85encode(pickled_crate).decode('utf-8')
                                with open(crate_file_path, 'w')as cf:
                                    cf.write(encoded_crate)
                                logging.info(f"Saved {len(available_items)} generated items to crate file: {crate_file_path}")

                                crate["generated_items"]= available_items
                                crate.pop("loot_table", None)
                            except Exception as e:
                                logging.error(f"Failed to save generated items to crate file: {e}")

                    self._open_loot_selection_menu(crate, available_items, save_data, save_path, crate_file_path, table_data)

                except Exception as e:
                    logging.error(f"Failed to open loot crate: {e}")
                    self._popup_show_info("Error", f"Failed to open loot crate: {e}", sound = "error")

            if lootcrates:
                crate_section_label = customtkinter.CTkLabel(
                scroll_frame,
                text = "Loot Crates",
                font = customtkinter.CTkFont(size = 18, weight = "bold")
                )
                crate_section_label.pack(pady =(10, 10), anchor = "w", padx = 10)

            for crate in lootcrates:
                crate_frame = customtkinter.CTkFrame(scroll_frame)
                crate_frame.pack(fill = "x", pady = 10, padx = 10)
                crate_frame.grid_columnconfigure(1, weight = 1)

                header_frame = customtkinter.CTkFrame(crate_frame, fg_color = "transparent")
                header_frame.grid(row = 0, column = 0, columnspan = 2, sticky = "ew", pady =(0, 10))
                header_frame.grid_columnconfigure(0, weight = 1)

                name_label = customtkinter.CTkLabel(
                header_frame,
                text = crate.get("name", "Unknown Crate"),
                font = customtkinter.CTkFont(size = 14, weight = "bold"),
                anchor = "w"
                )
                name_label.grid(row = 0, column = 0, sticky = "w")

                rarity_label = customtkinter.CTkLabel(
                header_frame,
                text = f"Rarity: {crate.get('rarity', 'N/A')}",
                font = customtkinter.CTkFont(size = 11),
                text_color = "gray",
                anchor = "e"
                )
                rarity_label.grid(row = 0, column = 1, sticky = "e", padx =(10, 0))

                if "description"in crate and crate["description"]:
                    desc_label = customtkinter.CTkLabel(
                    crate_frame,
                    text = crate["description"],
                    font = customtkinter.CTkFont(size = 11),
                    text_color = "gray",
                    wraplength = 400,
                    justify = "left",
                    anchor = "w"
                    )
                    desc_label.grid(row = 1, column = 0, columnspan = 2, sticky = "ew", pady =(0, 10), padx = 10)

                contents_text = self._get_loot_crate_contents_preview(crate, table_data)
                if contents_text:
                    contents_label = customtkinter.CTkLabel(
                    crate_frame,
                    text = contents_text,
                    font = customtkinter.CTkFont(size = 10),
                    text_color = "orange",
                    wraplength = 400,
                    justify = "left",
                    anchor = "w"
                    )
                    contents_label.grid(row = 2, column = 0, columnspan = 2, sticky = "ew", pady =(0, 10), padx = 10)

                crate_file = crate.get("_file_path")
                loot_button = self._create_sound_button(
                crate_frame,
                "Loot Crate",
                lambda c = crate, f = crate_file:loot_crate(c, f),
                width = 150,
                height = 40,
                font = customtkinter.CTkFont(size = 12)
                )
                loot_button.grid(row = 3, column = 0, columnspan = 2, sticky = "ew", padx = 10, pady = 10)

            if enemyloots:
                enemy_section_label = customtkinter.CTkLabel(
                scroll_frame,
                text = "Enemy Loot",
                font = customtkinter.CTkFont(size = 18, weight = "bold")
                )
                enemy_section_label.pack(pady =(20, 10), anchor = "w", padx = 10)

                def loot_enemy(el_data, el_file_path = None):
                    try:
                        save_path = os.path.join(saves_folder or "", (currentsave or "")+".sldsv")
                        save_data = self._load_file((currentsave or "")+".sldsv")
                        if save_data is None:
                            raise RuntimeError("Failed to load current save for enemy loot")

                        available_items =[]
                        for item in el_data.get("items", []):
                            if isinstance(item, dict):
                                item_copy = {k:v for k, v in item.items()if k !="table_category"}
                                item_copy = add_subslots_to_item(item_copy)
                                available_items.append(item_copy)

                        pseudo_crate = {
                        "name":f"Enemy Loot: {el_data.get('enemy_name', 'Unknown')}",
                        "description":f"Loot from {el_data.get('enemy_name', 'Unknown')} - {el_data.get('timestamp', 'Unknown time')}"
                        }
                        self._open_loot_selection_menu(pseudo_crate, available_items, save_data, save_path, el_file_path, table_data)

                    except Exception as e:
                        logging.error(f"Failed to open enemy loot: {e}")
                        self._popup_show_info("Error", f"Failed to open enemy loot: {e}", sound = "error")

                for el in enemyloots:
                    el_frame = customtkinter.CTkFrame(scroll_frame)
                    el_frame.pack(fill = "x", pady = 10, padx = 10)
                    el_frame.grid_columnconfigure(1, weight = 1)

                    enemy_name = el.get("enemy_name", "Unknown Enemy")
                    timestamp = el.get("timestamp", "")
                    items_list = el.get("items", [])
                    item_count = len(items_list)

                    header_frame = customtkinter.CTkFrame(el_frame, fg_color = "transparent")
                    header_frame.grid(row = 0, column = 0, columnspan = 2, sticky = "ew", pady =(0, 5))
                    header_frame.grid_columnconfigure(0, weight = 1)

                    name_label = customtkinter.CTkLabel(
                    header_frame,
                    text = f"Loot from: {enemy_name}",
                    font = customtkinter.CTkFont(size = 14, weight = "bold"),
                    anchor = "w"
                    )
                    name_label.grid(row = 0, column = 0, sticky = "w")

                    items_label = customtkinter.CTkLabel(
                    header_frame,
                    text = f"{item_count} item(s)",
                    font = customtkinter.CTkFont(size = 11),
                    text_color = "gray",
                    anchor = "e"
                    )
                    items_label.grid(row = 0, column = 1, sticky = "e", padx =(10, 0))

                    if timestamp:
                        try:
                            from datetime import datetime as dt
                            ts_parsed = dt.fromisoformat(timestamp)
                            ts_display = ts_parsed.strftime("%Y-%m-%d %H:%M")
                        except Exception:
                            ts_display = timestamp
                        ts_label = customtkinter.CTkLabel(
                        el_frame,
                        text = f"Generated: {ts_display}",
                        font = customtkinter.CTkFont(size = 10),
                        text_color = "gray",
                        anchor = "w"
                        )
                        ts_label.grid(row = 1, column = 0, columnspan = 2, sticky = "w", padx = 10)

                    if items_list:
                        preview_items = items_list[:3]
                        preview_names =[it.get("name", "Unknown")if isinstance(it, dict)else "Unknown"for it in preview_items]
                        preview_text = ", ".join(preview_names)
                        if len(items_list)>3:
                            preview_text +=f", ...(+{len(items_list)-3} more)"
                        preview_label = customtkinter.CTkLabel(
                        el_frame,
                        text = preview_text,
                        font = customtkinter.CTkFont(size = 10),
                        text_color = "orange",
                        anchor = "w",
                        wraplength = 400
                        )
                        preview_label.grid(row = 2, column = 0, columnspan = 2, sticky = "w", padx = 10, pady =(5, 0))

                    el_file = el.get("_file_path")
                    loot_btn = self._create_sound_button(
                    el_frame,
                    "Loot",
                    lambda e = el, f = el_file:loot_enemy(e, f),
                    width = 150,
                    height = 40,
                    font = customtkinter.CTkFont(size = 12)
                    )
                    loot_btn.grid(row = 3, column = 0, columnspan = 2, sticky = "ew", padx = 10, pady = 10)

            back_button = self._create_sound_button(main_frame, "Back to Main Menu", lambda:[self._clear_window(), self._build_main_menu()], width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
            back_button.pack(pady = 20)

        except Exception as e:
            logging.error(f"Failed to load loot tool: {e}")
            self._popup_show_info("Error", f"Failed to load loot tool: {e}", sound = "error")

    def _resolve_loot_entry(self, entry, table_data, save_data = None):

        items =[]
        debug_info =[]
        try:
            if entry.get("type")=="table":

                table_name = entry.get("table")
                entry_rarity = entry.get("rarity", "Common")
                table = table_data.get("tables", {}).get(table_name, [])

                luck_stat = 0
                if save_data:
                    luck_stat = save_data.get("stats", {}).get("luck", 0)

                rarity_weights = table_data.get("rarity_weights", {})
                special_chance = rarity_weights.get("Special Chance", 0)
                luck_effect = rarity_weights.get("Luck Effect", 1.5)

                if global_variables.get("devmode", {}).get("value", False):
                    debug_info.append(f"[DEBUG]Resolving table entry: {table_name}")
                    debug_info.append(f" Entry rarity(selection weight): {entry_rarity}")
                    debug_info.append(f" Luck stat: {luck_stat}")
                    debug_info.append(f" Luck effect multiplier: {luck_effect}")
                    debug_info.append(f" Special chance: {special_chance}%")
                    debug_info.append(f" Available items in table: {len(table)}")

                special_roll = random.random()*100
                if global_variables.get("devmode", {}).get("value", False):
                    debug_info.append(f" Special roll: {special_roll:.2f}(needs < {special_chance} for special)")

                if special_roll <special_chance:

                    special_table = table_data.get("tables", {}).get("special_items", [])
                    if special_table:
                        selected_item = random.choice(special_table)
                        item_copy = selected_item.copy()
                        item_copy["table_category"]= "special_items"
                        if global_variables.get("devmode", {}).get("value", False):
                            debug_info.append(f" â˜… SPECIAL ITEM TRIGGERED! Selected: {selected_item.get('name', 'Unknown')}")
                            item_copy["_debug_info"]= "\n".join(debug_info)
                        items.append(item_copy)
                        return self._apply_random_quantity(items, table_data)

                weighted_pool =[]
                rarity_counts = {}
                for item in table:
                    item_rarity = item.get("rarity", "Common")
                    weight = rarity_weights.get(item_rarity, 1)

                    if luck_stat >0:
                        weight = weight *(1 +(luck_stat *luck_effect /100))

                    count = max(1, int(weight))
                    weighted_pool.extend([item]*count)
                    rarity_counts[item_rarity]= rarity_counts.get(item_rarity, 0)+count

                if global_variables.get("devmode", {}).get("value", False):
                    debug_info.append(f" Weighted pool breakdown:")
                    for rarity, count in sorted(rarity_counts.items(), key = lambda x:-x[1]):
                        base_w = rarity_weights.get(rarity, 1)
                        pct =(count /len(weighted_pool)*100)if weighted_pool else 0
                        debug_info.append(f" {rarity}: {count} entries({pct:.1f}%)[base weight: {base_w}]")
                    debug_info.append(f" Total pool size: {len(weighted_pool)}")

                if weighted_pool:
                    selected_item = random.choice(weighted_pool)
                    item_copy = selected_item.copy()
                    item_copy["table_category"]= table_name
                    if global_variables.get("devmode", {}).get("value", False):
                        debug_info.append(f" â†’ Selected: {selected_item.get('name', 'Unknown')}({selected_item.get('rarity', 'Unknown')})")
                        item_copy["_debug_info"]= "\n".join(debug_info)
                    items.append(item_copy)

            elif isinstance(entry.get("type"), list)and "table"in entry.get("type")and "id"in entry.get("type"):

                table_name = entry.get("table")
                item_id = entry.get("id")
                requested_rarity = entry.get("rarity")
                multi_type = entry.get("multi_type", "or")
                spawn_magazine = entry.get("spawn_magazine", False)
                magazines_to_spawn = entry.get("magazines_to_spawn", 1)
                loading_type = entry.get("loading", "full")

                if global_variables.get("devmode", {}).get("value", False):
                    debug_info.append(f"[DEBUG]Resolving table+id entry: table={table_name}, id={item_id}")
                    if requested_rarity:
                        debug_info.append(f" Requested rarity: {requested_rarity}")
                    if spawn_magazine:
                        debug_info.append(f" Spawn magazines: {spawn_magazine}, count: {magazines_to_spawn}, loading: {loading_type}")

                def spawn_magazines_for_item_tableid(firearm_item, table_data, debug_info):
                    spawned_mags =[]
                    mag_system = firearm_item.get("magazinesystem")
                    caliber = firearm_item.get("caliber")

                    if not mag_system:
                        if global_variables.get("devmode", {}).get("value", False):
                            debug_info.append(f" âš  No magazinesystem found for {firearm_item.get('name', 'Unknown')}")
                        return spawned_mags

                    if isinstance(caliber, str):
                        caliber =[caliber]

                    magazines_table = table_data.get("tables", {}).get("magazines", [])
                    compatible_mags =[]
                    for mag in magazines_table:
                        if mag.get("magazinesystem")==mag_system:
                            mag_caliber = mag.get("caliber")
                            if isinstance(mag_caliber, str):
                                mag_caliber =[mag_caliber]

                            if caliber and mag_caliber and any(c in mag_caliber for c in caliber):
                                compatible_mags.append(mag)

                    if not compatible_mags:
                        if global_variables.get("devmode", {}).get("value", False):
                            debug_info.append(f" âš  No compatible magazines found for {mag_system}")
                        return spawned_mags

                    if isinstance(magazines_to_spawn, dict):
                        num_mags = random.randint(magazines_to_spawn.get("min", 1), magazines_to_spawn.get("max", 1))
                    else:
                        num_mags = int(magazines_to_spawn)

                    if global_variables.get("devmode", {}).get("value", False):
                        debug_info.append(f" Spawning {num_mags} magazine(s) for {firearm_item.get('name', 'Unknown')}")

                    ammo_table = table_data.get("tables", {}).get("ammunition", [])
                    ammo_def = None
                    first_variant = None
                    for ammo in ammo_table:
                        ammo_caliber = ammo.get("caliber")
                        if isinstance(ammo_caliber, str):
                            ammo_caliber =[ammo_caliber]
                        if caliber and ammo_caliber and any(c in ammo_caliber for c in caliber):
                            ammo_def = ammo
                            variants = ammo.get("variants", [])
                            if variants:
                                first_variant = variants[0]
                            break

                    for i in range(num_mags):
                        mag_template = random.choice(compatible_mags)
                        mag_copy = json.loads(json.dumps(mag_template))
                        mag_copy["table_category"]= "magazines"
                        mag_copy["rounds"]=[]

                        capacity = mag_copy.get("capacity", 30)

                        if loading_type =="full":
                            rounds_to_load = capacity
                        elif loading_type =="random":
                            if random.random()<0.5:
                                rounds_to_load = capacity
                            else:
                                rounds_to_load = random.randint(1, capacity)
                        else:
                            rounds_to_load = capacity

                        if ammo_def and first_variant:
                            for _ in range(rounds_to_load):
                                round_data = {
                                "name":ammo_def.get("name"),
                                "caliber":caliber[0]if caliber else ammo_def.get("caliber"),
                                "variant":first_variant.get("name"),
                                "type":first_variant.get("type"),
                                "pen":first_variant.get("pen"),
                                "modifiers":first_variant.get("modifiers"),
                                "tip":first_variant.get("tip")
                                }
                                mag_copy["rounds"].append(round_data)

                        if global_variables.get("devmode", {}).get("value", False):
                            debug_info.append(f" â†’ Spawned {mag_copy.get('name')} with {len(mag_copy['rounds'])}/{capacity} rounds({first_variant.get('name')if first_variant else 'unknown variant'})")

                        spawned_mags.append(mag_copy)

                    return spawned_mags

                table = table_data.get("tables", {}).get(table_name, [])

                if isinstance(item_id, list):

                    matching_items =[]
                    for single_id in item_id:
                        for item in table:
                            if item.get("id")==single_id:
                                if not requested_rarity or item.get("rarity")==requested_rarity:
                                    matching_items.append(item)
                                    if global_variables.get("devmode", {}).get("value", False):
                                        debug_info.append(f" Found ID {single_id} in '{table_name}': {item.get('name', 'Unknown')}")
                                break

                    if matching_items:
                        if multi_type =="or":

                            chosen_item = random.choice(matching_items)
                            item_copy = chosen_item.copy()
                            item_copy["table_category"]= table_name
                            if global_variables.get("devmode", {}).get("value", False):
                                debug_info.append(f" â†’ OR logic: randomly selected '{chosen_item.get('name', 'Unknown')}'")
                                item_copy["_debug_info"]= "\n".join(debug_info)
                            items.append(item_copy)

                            if spawn_magazine and item_copy.get("firearm"):
                                spawned_mags = spawn_magazines_for_item_tableid(item_copy, table_data, debug_info)
                                items.extend(spawned_mags)
                        elif multi_type =="and":

                            if global_variables.get("devmode", {}).get("value", False):
                                debug_info.append(f" â†’ AND logic: giving all {len(matching_items)} items")
                            for idx, matched_item in enumerate(matching_items):
                                item_copy = matched_item.copy()
                                item_copy["table_category"]= table_name
                                if global_variables.get("devmode", {}).get("value", False)and idx ==0:
                                    item_copy["_debug_info"]= "\n".join(debug_info)
                                items.append(item_copy)

                                if spawn_magazine and item_copy.get("firearm"):
                                    spawned_mags = spawn_magazines_for_item_tableid(item_copy, table_data, debug_info)
                                    items.extend(spawned_mags)
                else:

                    for item in table:
                        if item.get("id")==item_id:
                            if not requested_rarity or item.get("rarity")==requested_rarity:
                                item_copy = item.copy()
                                item_copy["table_category"]= table_name
                                if global_variables.get("devmode", {}).get("value", False):
                                    debug_info.append(f" Found ID {item_id} in '{table_name}': {item.get('name', 'Unknown')}")
                                    item_copy["_debug_info"]= "\n".join(debug_info)
                                items.append(item_copy)

                                if spawn_magazine and item_copy.get("firearm"):
                                    spawned_mags = spawn_magazines_for_item_tableid(item_copy, table_data, debug_info)
                                    items.extend(spawned_mags)
                            break

                return self._apply_random_quantity(items, table_data)

            elif entry.get("type")=="id":

                item_id = entry.get("id")
                multi_type = entry.get("multi_type", "or")
                spawn_magazine = entry.get("spawn_magazine", False)
                magazines_to_spawn = entry.get("magazines_to_spawn", 1)
                loading_type = entry.get("loading", "full")

                if global_variables.get("devmode", {}).get("value", False):
                    if isinstance(item_id, list):
                        debug_info.append(f"[DEBUG]Resolving multi-ID entry: {item_id}")
                        debug_info.append(f" Multi-type: {multi_type}({'pick one'if multi_type =='or'else 'give all'})")
                    else:
                        debug_info.append(f"[DEBUG]Resolving ID entry: {item_id}")
                    if spawn_magazine:
                        debug_info.append(f" Spawn magazines: {spawn_magazine}, count: {magazines_to_spawn}, loading: {loading_type}")

                def spawn_magazines_for_item(firearm_item, table_data, debug_info):
                    spawned_mags =[]
                    mag_system = firearm_item.get("magazinesystem")
                    caliber = firearm_item.get("caliber")

                    if not mag_system:
                        if global_variables.get("devmode", {}).get("value", False):
                            debug_info.append(f" âš  No magazinesystem found for {firearm_item.get('name', 'Unknown')}")
                        return spawned_mags

                    if isinstance(caliber, str):
                        caliber =[caliber]

                    magazines_table = table_data.get("tables", {}).get("magazines", [])
                    compatible_mags =[]
                    for mag in magazines_table:
                        if mag.get("magazinesystem")==mag_system:
                            mag_caliber = mag.get("caliber")
                            if isinstance(mag_caliber, str):
                                mag_caliber =[mag_caliber]

                            if caliber and mag_caliber and any(c in mag_caliber for c in caliber):
                                compatible_mags.append(mag)

                    if not compatible_mags:
                        if global_variables.get("devmode", {}).get("value", False):
                            debug_info.append(f" âš  No compatible magazines found for {mag_system}")
                        return spawned_mags

                    if isinstance(magazines_to_spawn, dict):
                        num_mags = random.randint(magazines_to_spawn.get("min", 1), magazines_to_spawn.get("max", 1))
                    else:
                        num_mags = int(magazines_to_spawn)

                    if global_variables.get("devmode", {}).get("value", False):
                        debug_info.append(f" Spawning {num_mags} magazine(s) for {firearm_item.get('name', 'Unknown')}")

                    ammo_table = table_data.get("tables", {}).get("ammunition", [])
                    ammo_def = None
                    first_variant = None
                    for ammo in ammo_table:
                        ammo_caliber = ammo.get("caliber")
                        if isinstance(ammo_caliber, str):
                            ammo_caliber =[ammo_caliber]
                        if caliber and ammo_caliber and any(c in ammo_caliber for c in caliber):
                            ammo_def = ammo

                            variants = ammo.get("variants", [])
                            if variants:
                                first_variant = variants[0]
                            break

                    for i in range(num_mags):

                        mag_template = random.choice(compatible_mags)
                        mag_copy = json.loads(json.dumps(mag_template))
                        mag_copy["table_category"]= "magazines"
                        mag_copy["rounds"]=[]

                        capacity = mag_copy.get("capacity", 30)

                        if loading_type =="full":
                            rounds_to_load = capacity
                        elif loading_type =="random":

                            if random.random()<0.5:
                                rounds_to_load = capacity
                            else:
                                rounds_to_load = random.randint(1, capacity)
                        else:
                            rounds_to_load = capacity

                        if ammo_def and first_variant:
                            for _ in range(rounds_to_load):
                                round_data = {
                                "name":ammo_def.get("name"),
                                "caliber":caliber[0]if caliber else ammo_def.get("caliber"),
                                "variant":first_variant.get("name"),
                                "type":first_variant.get("type"),
                                "pen":first_variant.get("pen"),
                                "modifiers":first_variant.get("modifiers"),
                                "tip":first_variant.get("tip")
                                }
                                mag_copy["rounds"].append(round_data)

                        if global_variables.get("devmode", {}).get("value", False):
                            debug_info.append(f" â†’ Spawned {mag_copy.get('name')} with {len(mag_copy['rounds'])}/{capacity} rounds({first_variant.get('name')if first_variant else 'unknown variant'})")

                        spawned_mags.append(mag_copy)

                    return spawned_mags

                if isinstance(item_id, list):

                    matching_items =[]
                    for single_id in item_id:
                        for table_name, table_items in table_data.get("tables", {}).items():
                            for item in table_items:
                                if item.get("id")==single_id:
                                    matching_items.append((item, table_name))
                                    if global_variables.get("devmode", {}).get("value", False):
                                        debug_info.append(f" Found ID {single_id} in '{table_name}': {item.get('name', 'Unknown')}")
                                    break

                    if matching_items:
                        if multi_type =="or":

                            chosen_item, chosen_table = random.choice(matching_items)
                            item_copy = chosen_item.copy()
                            item_copy["table_category"]= chosen_table
                            if global_variables.get("devmode", {}).get("value", False):
                                debug_info.append(f" â†’ OR logic: randomly selected '{chosen_item.get('name', 'Unknown')}'")
                                item_copy["_debug_info"]= "\n".join(debug_info)
                            items.append(item_copy)

                            if spawn_magazine and item_copy.get("firearm"):
                                spawned_mags = spawn_magazines_for_item(item_copy, table_data, debug_info)
                                items.extend(spawned_mags)
                        elif multi_type =="and":

                            if global_variables.get("devmode", {}).get("value", False):
                                debug_info.append(f" â†’ AND logic: giving all {len(matching_items)} items")
                            for idx, (matched_item, matched_table)in enumerate(matching_items):
                                item_copy = matched_item.copy()
                                item_copy["table_category"]= matched_table
                                if global_variables.get("devmode", {}).get("value", False)and idx ==0:
                                    item_copy["_debug_info"]= "\n".join(debug_info)
                                items.append(item_copy)

                                if spawn_magazine and item_copy.get("firearm"):
                                    spawned_mags = spawn_magazines_for_item(item_copy, table_data, debug_info)
                                    items.extend(spawned_mags)
                    return self._apply_random_quantity(items, table_data)
                else:

                    for table_name, table_items in table_data.get("tables", {}).items():
                        for item in table_items:
                            if item.get("id")==item_id:
                                item_copy = item.copy()
                                item_copy["table_category"]= table_name
                                if global_variables.get("devmode", {}).get("value", False):
                                    debug_info.append(f" Found in table '{table_name}': {item.get('name', 'Unknown')}")
                                    item_copy["_debug_info"]= "\n".join(debug_info)
                                items.append(item_copy)

                                if spawn_magazine and item_copy.get("firearm"):
                                    spawned_mags = spawn_magazines_for_item(item_copy, table_data, debug_info)
                                    items.extend(spawned_mags)
                                return self._apply_random_quantity(items, table_data)
        except Exception as e:
            logging.error(f"Failed to resolve loot entry {entry}: {e}")

        return self._apply_random_quantity(items, table_data)

    def _apply_random_quantity(self, items, table_data = None):

        for item in items:
            if not isinstance(item, dict):
                continue

            rq = item.get("random_quantity")
            if rq and isinstance(rq, dict):
                min_qty = rq.get("min", 1)
                max_qty = rq.get("max", 1)
                try:
                    actual_qty = random.randint(int(min_qty), int(max_qty))
                except(ValueError, TypeError):
                    actual_qty = 1
                item["quantity"]= actual_qty
                del item["random_quantity"]
                logging.debug(f"Applied random_quantity to {item.get('name', 'Unknown')}: {actual_qty}(range {min_qty}-{max_qty})")

            if table_data and item.get("capacity")and item.get("magazinesystem")and not item.get("firearm"):

                if not item.get("rounds"):
                    item["rounds"]=[]
                if len(item.get("rounds", []))==0:
                    caliber = item.get("caliber")
                    if isinstance(caliber, str):
                        caliber =[caliber]

                    capacity = item.get("capacity", 30)

                    rounds_to_load = random.randint(max(1, capacity //4), capacity)

                    ammo_table = table_data.get("tables", {}).get("ammunition", [])
                    ammo_def = None
                    first_variant = None
                    for ammo in ammo_table:
                        ammo_caliber = ammo.get("caliber")
                        if isinstance(ammo_caliber, str):
                            ammo_caliber =[ammo_caliber]
                        if caliber and ammo_caliber and any(c in ammo_caliber for c in caliber):
                            ammo_def = ammo
                            variants = ammo.get("variants", [])
                            if variants:
                                first_variant = variants[0]
                            break

                    if ammo_def and first_variant:
                        for _ in range(rounds_to_load):
                            round_data = {
                            "name":ammo_def.get("name"),
                            "caliber":caliber[0]if caliber else ammo_def.get("caliber"),
                            "variant":first_variant.get("name"),
                            "type":first_variant.get("type"),
                            "pen":first_variant.get("pen"),
                            "modifiers":first_variant.get("modifiers"),
                            "tip":first_variant.get("tip")
                            }
                            item["rounds"].append(round_data)
                        logging.debug(f"Loaded magazine {item.get('name', 'Unknown')} with {rounds_to_load}/{capacity} rounds")

            if table_data and item.get("firearm")and item.get("magazinesystem")and not item.get("loaded"):

                if random.random()<0.4:
                    mag_system = item.get("magazinesystem")
                    caliber = item.get("caliber")
                    if isinstance(caliber, str):
                        caliber =[caliber]

                    magazines_table = table_data.get("tables", {}).get("magazines", [])
                    compatible_mags =[]
                    for mag in magazines_table:
                        if mag.get("magazinesystem")==mag_system:
                            mag_caliber = mag.get("caliber")
                            if isinstance(mag_caliber, str):
                                mag_caliber =[mag_caliber]
                            if caliber and mag_caliber and any(c in mag_caliber for c in caliber):
                                compatible_mags.append(mag)

                    if compatible_mags:
                        mag_template = random.choice(compatible_mags)
                        mag_copy = json.loads(json.dumps(mag_template))
                        mag_copy["table_category"]= "magazines"
                        mag_copy["rounds"]=[]

                        capacity = mag_copy.get("capacity", 30)

                        rounds_to_load = random.randint(max(1, capacity //4), capacity)

                        ammo_table = table_data.get("tables", {}).get("ammunition", [])
                        ammo_def = None
                        first_variant = None
                        for ammo in ammo_table:
                            ammo_caliber = ammo.get("caliber")
                            if isinstance(ammo_caliber, str):
                                ammo_caliber =[ammo_caliber]
                            if caliber and ammo_caliber and any(c in ammo_caliber for c in caliber):
                                ammo_def = ammo
                                variants = ammo.get("variants", [])
                                if variants:
                                    first_variant = variants[0]
                                break

                        if ammo_def and first_variant:
                            for _ in range(rounds_to_load):
                                round_data = {
                                "name":ammo_def.get("name"),
                                "caliber":caliber[0]if caliber else ammo_def.get("caliber"),
                                "variant":first_variant.get("name"),
                                "type":first_variant.get("type"),
                                "pen":first_variant.get("pen"),
                                "modifiers":first_variant.get("modifiers"),
                                "tip":first_variant.get("tip")
                                }
                                mag_copy["rounds"].append(round_data)

                        item["loaded"]= mag_copy
                        logging.debug(f"Loaded firearm {item.get('name', 'Unknown')} with {mag_copy.get('name')}({rounds_to_load}/{capacity} rounds)")

        return items

    def _get_loot_crate_contents_preview(self, crate, table_data):

        info_lines =[]
        try:

            locked_status = "Locked"if crate.get("locked", False)else "Unlocked"
            pulls = crate.get("pulls", 3)
            if isinstance(pulls, dict):
                pulls_text = f"{pulls.get('min')}-{pulls.get('max')}"
            else:
                pulls_text = str(pulls)
            info_lines.append(f"{locked_status} | Pulls: {pulls_text}")

            num_entries = len(crate.get("loot_table", []))
            info_lines.append(f"Loot entries: {num_entries}")
        except Exception as e:
            logging.error(f"Failed to generate loot preview: {e}")

        if info_lines:
            return "\n".join(info_lines)
        return ""

    def _open_loot_selection_menu(self, crate, available_items, save_data, save_path, crate_file_path, table_data):

        self._clear_window()

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew")

        title_label = customtkinter.CTkLabel(
        main_frame,
        text = f"Loot: {crate.get('name', 'Unknown Crate')}",
        font = customtkinter.CTkFont(size = 20, weight = "bold")
        )
        title_label.pack(pady = 20)

        def get_loot_containers():
            containers =[]
            equipment = save_data.get("equipment", {})

            containers.append({"name":"Hands", "location":"hands"})

            for slot, item in equipment.items():

                if item and isinstance(item, dict):
                    if "capacity"in item and "items"in item:
                        containers.append({
                        "name":f"{item.get('name', 'Container')}({slot})",
                        "location":f"equipment.{slot}"
                        })

                    if "subslots"in item:
                        for subslot_idx, subslot_data in enumerate(item["subslots"]):
                            subslot_item = subslot_data.get("current")
                            if subslot_item and isinstance(subslot_item, dict):
                                if "capacity"in subslot_item and "items"in subslot_item:
                                    subslot_name = subslot_data.get("name", f"Subslot {subslot_idx}")
                                    containers.append({
                                    "name":f"{subslot_item.get('name', 'Container')}({slot} â†’ {subslot_name})",
                                    "location":f"equipment.{slot}.subslot.{subslot_idx}"
                                    })

                elif isinstance(item, list):
                    for idx, subitem in enumerate(item):
                        try:
                            if subitem and isinstance(subitem, dict)and "capacity"in subitem and "items"in subitem:
                                containers.append({
                                "name":f"{subitem.get('name', 'Container')}({slot}#{idx})",
                                "location":f"equipment.{slot}.list.{idx}"
                                })

                            if subitem and isinstance(subitem, dict)and "subslots"in subitem:
                                for subslot_idx, subslot_data in enumerate(subitem.get("subslots", [])):
                                    subslot_item = subslot_data.get("current")
                                    if subslot_item and isinstance(subslot_item, dict):
                                        if "capacity"in subslot_item and "items"in subslot_item:
                                            subslot_name = subslot_data.get("name", f"Subslot {subslot_idx}")
                                            containers.append({
                                            "name":f"{subslot_item.get('name', 'Container')}({slot}#{idx} â†’ {subslot_name})",
                                            "location":f"equipment.{slot}.list.{idx}.subslot.{subslot_idx}"
                                            })
                        except Exception:
                            pass

            return containers

        loot_containers = get_loot_containers()
        container_names =[c["name"]for c in loot_containers]

        def get_container_items_local(location):
            if location =="hands":
                return save_data["hands"].get("items", [])
            elif location.startswith("equipment."):
                parts = location.split(".")
                slot = parts[1]
                item = save_data["equipment"].get(slot)
                if item is None:
                    return[]
                if len(parts)>2 and parts[2]=="subslot":
                    subslot_idx = int(parts[3])
                    if isinstance(item, dict)and "subslots"in item and subslot_idx <len(item["subslots"]):
                        subslot_item = item["subslots"][subslot_idx].get("current")
                        if subslot_item and isinstance(subslot_item, dict):
                            return subslot_item.get("items", [])
                if len(parts)>2 and parts[2]=="list":
                    list_idx = int(parts[3])
                    if isinstance(item, list)and 0 <=list_idx <len(item):
                        subitem = item[list_idx]
                        if len(parts)>4 and parts[4]=="subslot":
                            subslot_idx = int(parts[5])
                            if "subslots"in subitem and subslot_idx <len(subitem["subslots"]):
                                subslot_item = subitem["subslots"][subslot_idx].get("current")
                                if subslot_item and isinstance(subslot_item, dict):
                                    return subslot_item.get("items", [])
                        return subitem.get("items", [])if isinstance(subitem, dict)else[]
                if isinstance(item, dict):
                    return item.get("items", [])
            return[]

        def set_container_items_local(location, items):
            if location =="hands":
                save_data["hands"]["items"]= items
            elif location.startswith("equipment."):
                parts = location.split(".")
                slot = parts[1]
                if slot in save_data["equipment"]and save_data["equipment"][slot]:
                    item = save_data["equipment"][slot]
                    if len(parts)>2 and parts[2]=="subslot":
                        subslot_idx = int(parts[3])
                        if isinstance(item, dict)and "subslots"in item and subslot_idx <len(item["subslots"]):
                            subslot_item = item["subslots"][subslot_idx].get("current")
                            if subslot_item and isinstance(subslot_item, dict):
                                subslot_item["items"]= items
                    elif len(parts)>2 and parts[2]=="list":
                        list_idx = int(parts[3])
                        if isinstance(item, list)and 0 <=list_idx <len(item):
                            subitem = item[list_idx]
                            if len(parts)>4 and parts[4]=="subslot":
                                subslot_idx = int(parts[5])
                                if "subslots"in subitem and subslot_idx <len(subitem["subslots"]):
                                    subslot_item = subitem["subslots"][subslot_idx].get("current")
                                    if subslot_item and isinstance(subslot_item, dict):
                                        subslot_item["items"]= items
                            else:
                                if isinstance(subitem, dict):
                                    subitem["items"]= items
                    else:
                        if isinstance(item, dict):
                            item["items"]= items

        def get_container_capacity_local(location):
            if location =="hands":
                base_capacity = save_data.get("hands", {}).get("capacity", 50)
                strength = save_data.get("stats", {}).get("Strength", 0)

                return base_capacity *(1 +strength *0.1)
            if location.startswith("equipment."):
                parts = location.split(".")
                slot = parts[1]
                equip = save_data.get("equipment", {}).get(slot)
                if equip:
                    if len(parts)>2 and parts[2]=="subslot":
                        subslot_idx = int(parts[3])
                        if isinstance(equip, dict)and "subslots"in equip and subslot_idx <len(equip["subslots"]):
                            subslot_item = equip["subslots"][subslot_idx].get("current")
                            if subslot_item and isinstance(subslot_item, dict):
                                return subslot_item.get("capacity")
                            return None
                    if len(parts)>2 and parts[2]=="list":
                        list_idx = int(parts[3])
                        if isinstance(equip, list)and 0 <=list_idx <len(equip):
                            subitem = equip[list_idx]
                            if len(parts)>4 and parts[4]=="subslot":
                                subslot_idx = int(parts[5])
                                if "subslots"in subitem and subslot_idx <len(subitem["subslots"]):
                                    subslot_item = subitem["subslots"][subslot_idx].get("current")
                                    if subslot_item and isinstance(subslot_item, dict):
                                        return subslot_item.get("capacity")
                                return None
                            return subitem.get("capacity")if isinstance(subitem, dict)else None
                    return equip.get("capacity")if isinstance(equip, dict)else None
            return None

        container_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        container_frame.pack(fill = "x", padx = 20, pady =(0, 10))

        customtkinter.CTkLabel(
        container_frame,
        text = "Put items into:",
        font = customtkinter.CTkFont(size = 12)
        ).pack(side = "left", padx =(0, 10))

        container_selector = customtkinter.CTkOptionMenu(
        container_frame,
        values = container_names if container_names else["Hands"],
        width = 350,
        font = customtkinter.CTkFont(size = 12)
        )
        container_selector.pack(side = "left")
        container_selector.set(container_names[0]if container_names else "Hands")

        scroll_frame = customtkinter.CTkScrollableFrame(main_frame)
        scroll_frame.pack(fill = "both", expand = True, padx = 20, pady = 20)

        if global_variables.get("devmode", {}).get("value", False)and available_items:

            all_debug =[]
            for item in available_items:
                if item.get("_debug_info"):
                    all_debug.append(item.get("_debug_info"))
                    all_debug.append("")

            if all_debug:
                debug_frame = customtkinter.CTkFrame(scroll_frame, fg_color = "#1a1a2e")
                debug_frame.pack(fill = "x", pady =(0, 15), padx = 5)

                customtkinter.CTkLabel(
                debug_frame,
                text = "ðŸ”§ LOOT RESOLUTION DEBUG",
                font = customtkinter.CTkFont(size = 12, weight = "bold"),
                text_color = "#00ff88"
                ).pack(anchor = "w", padx = 10, pady =(10, 5))

                debug_text = customtkinter.CTkTextbox(
                debug_frame,
                height = 200,
                font = customtkinter.CTkFont(family = "Consolas", size = 10),
                fg_color = "#0d0d1a",
                text_color = "#88ff88"
                )
                debug_text.pack(fill = "x", padx = 10, pady =(0, 10))
                debug_text.insert("1.0", "\n".join(all_debug))
                debug_text.configure(state = "disabled")

        selected_items_checkboxes = {}

        def update_weight_display():

            selected_weight = 0.0
            for idx, checkbox in selected_items_checkboxes.items():
                if checkbox.get():
                    item = available_items[idx]
                    qty = item.get("quantity", 1)
                    weight = item.get("weight", 0)*qty
                    selected_weight +=weight

            current_encumbrance = self._calculate_encumbrance_status(save_data)

            new_encumbrance = current_encumbrance["encumbrance"]+selected_weight
            new_total_weight = current_encumbrance["total_weight"]+selected_weight

            threshold = current_encumbrance.get("threshold", save_data.get("encumbered_threshold", 50))

            weight_text = f"Selected Weight: {self._format_weight(selected_weight)}\n"
            weight_text +=f"New Total: {self._format_weight(new_total_weight)}\n"
            weight_text +=f"Encumbrance: {self._format_weight(new_encumbrance)} / {self._format_weight(threshold)}"

            if new_encumbrance >threshold:
                weight_text +=" âš ï¸ ENCUMBERED"
                weight_label.configure(text_color = "red")
            else:
                weight_label.configure(text_color = "white")

            weight_label.configure(text = weight_text)

        for i, item in enumerate(available_items):
            item_frame = customtkinter.CTkFrame(scroll_frame)
            item_frame.pack(fill = "x", pady = 10, padx = 10)
            item_frame.grid_columnconfigure(0, weight = 1)

            checkbox = customtkinter.CTkCheckBox(
            item_frame,
            text = "",
            command = update_weight_display
            )
            checkbox.grid(row = 0, column = 0, sticky = "w", padx =(0, 10))
            checkbox.select()
            selected_items_checkboxes[i]= checkbox

            item_info_text = f"{item.get('name', 'Unknown')} - {self._format_weight(item.get('weight', 0))}"
            if item.get("quantity", 1)>1:
                item_info_text +=f" x{item.get('quantity')}"
            if item.get("value"):
                item_info_text +=f"[${item.get('value')}]"

            item_label = customtkinter.CTkLabel(
            item_frame,
            text = item_info_text,
            font = customtkinter.CTkFont(size = 12),
            anchor = "w"
            )
            item_label.grid(row = 0, column = 1, sticky = "ew", padx = 10)

            if item.get("description"):
                desc_label = customtkinter.CTkLabel(
                item_frame,
                text = item.get("description"),
                font = customtkinter.CTkFont(size = 10),
                text_color = "gray",
                wraplength = 600,
                justify = "left",
                anchor = "w"
                )
                desc_label.grid(row = 1, column = 0, columnspan = 2, sticky = "ew", padx = 10, pady =(5, 0))

        weight_frame = customtkinter.CTkFrame(main_frame)
        weight_frame.pack(fill = "x", padx = 20, pady = 10)

        weight_label = customtkinter.CTkLabel(
        weight_frame,
        text = "",
        font = customtkinter.CTkFont(size = 12),
        justify = "left",
        anchor = "w"
        )
        weight_label.pack(fill = "x", padx = 10, pady = 10)

        button_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        button_frame.pack(fill = "x", padx = 20, pady = 20)
        button_frame.grid_columnconfigure((0, 1), weight = 1)

        def take_selected():

            try:

                selected_container_name = container_selector.get()
                selected_container = next((c for c in loot_containers if c["name"]==selected_container_name), None)

                if not selected_container:

                    selected_container = {"name":"Hands", "location":"hands"}

                target_location = selected_container["location"]

                items_to_take =[]
                remaining_items =[]

                for idx, checkbox in selected_items_checkboxes.items():
                    if checkbox.get():
                        items_to_take.append(available_items[idx])
                    else:
                        remaining_items.append(available_items[idx])

                if not items_to_take:
                    self._popup_show_info("Info", "No items selected.", sound = "popup")
                    return

                capacity = get_container_capacity_local(target_location)
                if capacity is not None:
                    current_items = get_container_items_local(target_location)
                    current_weight = sum(
                    it.get("weight", 0)*it.get("quantity", 1)
                    for it in current_items if isinstance(it, dict)
                    )
                    items_weight = sum(
                    it.get("weight", 0)*it.get("quantity", 1)
                    for it in items_to_take if isinstance(it, dict)
                    )
                    if current_weight +items_weight >capacity:
                        self._popup_show_info(
                        "Capacity Exceeded",
                        f"Selected items({self._format_weight(items_weight)}) would exceed container capacity.\n"
                        f"Current: {self._format_weight(current_weight)} / {self._format_weight(capacity)}",
                        sound = "error"
                        )
                        return

                current_items = get_container_items_local(target_location)
                current_items.extend(items_to_take)
                set_container_items_local(target_location, current_items)

                try:
                    self._write_save_to_path(save_path, save_data)
                except Exception as e:
                    logging.error(f"Failed to write updated save: {e}")

                if crate_file_path and os.path.exists(crate_file_path):
                    if remaining_items:

                        updated_crate = crate.copy()
                        updated_crate["generated_items"]= remaining_items
                        updated_crate.pop("loot_table", None)

                        pickled_crate = pickle.dumps(updated_crate)
                        encoded_crate = base64.b85encode(pickled_crate).decode('utf-8')
                        with open(crate_file_path, 'w')as cf:
                            cf.write(encoded_crate)
                        logging.info(f"Updated crate file with {len(remaining_items)} remaining items: {crate_file_path}")
                    else:

                        os.remove(crate_file_path)
                        logging.info(f"Deleted empty loot crate file: {crate_file_path}")

                item_summary = ", ".join([f"{item.get('name', 'Unknown')}"for item in items_to_take])
                logging.info(f"Looted crate '{crate.get('name')}' into {selected_container_name}: {item_summary}")
                self._popup_show_info("Success", f"Took {len(items_to_take)} item(s) into {selected_container_name}:\n{item_summary}", sound = "success")
                self._open_loot_tool()
            except Exception as e:
                logging.error(f"Failed to take items: {e}")
                self._popup_show_info("Error", f"Failed to take items: {e}", sound = "error")

        def take_none():

            self._open_loot_tool()

        take_button = self._create_sound_button(
        button_frame,
        "Take Selected Items",
        take_selected,
        width = 250,
        height = 50,
        font = customtkinter.CTkFont(size = 14)
        )
        take_button.grid(row = 0, column = 0, padx =(0, 10))

        cancel_button = self._create_sound_button(
        button_frame,
        "Leave Crate",
        take_none,
        width = 250,
        height = 50,
        font = customtkinter.CTkFont(size = 14)
        )
        cancel_button.grid(row = 0, column = 1, padx =(10, 0))

        update_weight_display()

    def _open_business_tool(self):
        logging.info("Business definition called")
        self._popup_show_info("Businesses", "Businesses are under development.")
    def _open_inventory_manager_tool(self):
        logging.info("Inventory Manager definition called")
        self._clear_window()

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew")

        title_label = customtkinter.CTkLabel(main_frame, text = "Inventory Manager", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title_label.pack(pady = 20)

        character_management_button = self._create_sound_button(main_frame, "Character Management", lambda:[self._clear_window(), self._open_character_management()], width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        character_management_button.pack(pady = 20)
        inventory_management_button = self._create_sound_button(main_frame, "Inventory Management", lambda:[self._clear_window(), self._open_inventory_management()], width = 500, height = 50, font = customtkinter.CTkFont(size = 16), state = "disabled"if currentsave is None else "normal")
        inventory_management_button.pack(pady = 20)
        item_equip_button = self._create_sound_button(main_frame, "Item Equipping", lambda:[self._clear_window(), self._open_item_equipping()], width = 500, height = 50, font = customtkinter.CTkFont(size = 16), state = "disabled"if currentsave is None else "normal")
        item_equip_button.pack(pady = 20)
        back_button = self._create_sound_button(main_frame, "Back to Main Menu", lambda:[self._clear_window(), self._build_main_menu()], width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        back_button.pack(pady = 20)

        if currentsave is None:
            warning_label = customtkinter.CTkLabel(main_frame, text = "Load or create a character to access inventory features.", font = customtkinter.CTkFont(size = 14), text_color = "orange")
            warning_label.pack(pady = 10)
    def _open_character_management(self):
        logging.info("Character Management definition called")
        create_new_character_button = self._create_sound_button(self.root, "Create New Character", lambda:[self._clear_window(), self._create_new_character()], width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        create_new_character_button.pack(pady = 20)
        load_existing_character_button = self._create_sound_button(
        self.root,
        "Load Existing Character",
        lambda:[self._clear_window(), self._load_existing_character()],
        width = 500,
        height = 50,
        font = customtkinter.CTkFont(size = 16),
        state = "disabled"if not os.listdir(saves_folder)or all(
        f in["persistent_data.sldsv", "settings.sldsv", "appearance_settings.sldsv", "dm_settings.sldsv"]or f.endswith(".sldsv.sldsv")or f =="backups"
        for f in os.listdir(saves_folder)
        )else "normal"
        )
        load_existing_character_button.pack(pady = 20)

        view_stats_button = self._create_sound_button(
        self.root,
        "View Loaded Character Stats",
        self._view_character_stats,
        width = 500,
        height = 50,
        font = customtkinter.CTkFont(size = 16),
        state = "disabled"if currentsave is None else "normal"
        )
        view_stats_button.pack(pady = 20)

        return_button = self._create_sound_button(self.root, "Return to Inventory Manager", lambda:[self._clear_window(), self._open_inventory_manager_tool()], width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        return_button.pack(pady = 20)

    def _view_character_stats(self):
        logging.info("View Character Stats called")

        if currentsave is None:
            self._popup_show_info("Error", "No character loaded.", sound = "error")
            return

        save_filename =(currentsave or "")+".sldsv"
        save_data = self._load_file(save_filename)

        if save_data is None:
            self._popup_show_info("Error", "Failed to load character data.", sound = "error")
            return

        encumbrance_info = self._calculate_encumbrance_status(save_data)

        self._clear_window()

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew", padx = 20, pady = 20)
        main_frame.grid_rowconfigure(1, weight = 1)
        main_frame.grid_columnconfigure(0, weight = 1)

        title = customtkinter.CTkLabel(main_frame, text = f"Character: {save_data.get('charactername', 'Unknown')}", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title.grid(row = 0, column = 0, pady =(0, 20))

        scroll = customtkinter.CTkScrollableFrame(main_frame, width = 800, height = 500)
        scroll.grid(row = 1, column = 0, sticky = "nsew", padx = 10, pady = 10)
        scroll.grid_columnconfigure(0, weight = 1)

        stats_label = customtkinter.CTkLabel(scroll, text = "Base Stats", font = customtkinter.CTkFont(size = 16, weight = "bold"))
        stats_label.pack(pady =(10, 15), anchor = "w", padx = 20)

        stats = save_data.get("stats", {})
        for stat_name, stat_value in stats.items():

            display_value = stat_value
            agility_penalty_text = ""

            if stat_name =="Agility"and encumbrance_info["encumbrance_level"]>0:
                display_value = stat_value -encumbrance_info["encumbrance_level"]
                agility_penalty_text = f"(Base: {stat_value}, Penalty: -{encumbrance_info['encumbrance_level']})"

            stat_frame = customtkinter.CTkFrame(scroll, fg_color = "transparent")
            stat_frame.pack(fill = "x", pady = 5, padx = 30)

            stat_label = customtkinter.CTkLabel(
            stat_frame,
            text = f"{stat_name}: {display_value:+d}{agility_penalty_text}",
            font = customtkinter.CTkFont(size = 12),
            anchor = "w"
            )
            stat_label.pack(fill = "x")

        enc_label = customtkinter.CTkLabel(scroll, text = "Encumbrance Status", font = customtkinter.CTkFont(size = 16, weight = "bold"))
        enc_label.pack(pady =(20, 15), anchor = "w", padx = 20)

        enc_items =[
        ("Total Weight", self._format_weight(encumbrance_info["total_weight"])),
        ("Encumbrance", self._format_weight(encumbrance_info['encumbrance'])),
        ("Encumbrance Threshold", self._format_weight(encumbrance_info['threshold'])),
        ("Encumbrance Level", f"{encumbrance_info['encumbrance_level']}"),
        ("Status", "Encumbered"if encumbrance_info["is_encumbered"]else "Not Encumbered")
        ]

        for label_text, value_text in enc_items:
            enc_frame = customtkinter.CTkFrame(scroll, fg_color = "transparent")
            enc_frame.pack(fill = "x", pady = 3, padx = 30)

            label = customtkinter.CTkLabel(
            enc_frame,
            text = f"{label_text}: {value_text}",
            font = customtkinter.CTkFont(size = 12),
            anchor = "w"
            )
            label.pack(fill = "x")

        tracked = save_data.get('tracked_stats', {})or {}
        try:
            if isinstance(tracked, dict):
                track_label = customtkinter.CTkLabel(scroll, text = "Tracked Activity", font = customtkinter.CTkFont(size = 16, weight = "bold"))
                track_label.pack(pady =(20, 15), anchor = "w", padx = 20)

                ta_items =[
                ("Rounds Fired(total)", tracked.get('rounds_fired_total', 0)),
                ("Magazines Reloaded(total)", tracked.get('mags_reloaded_total', 0)),
                ("Bullets Loaded(total)", tracked.get('bullets_loaded_total', 0)),
                ("D20 Rolls(total)", tracked.get('d20_rolls_total', 0)),
                ("D20 Ones(1)", tracked.get('d20_ones', 0)),
                ("D20 Twenties(20)", tracked.get('d20_twenties', 0))
                ]

                for label_text, value_text in ta_items:
                    tf = customtkinter.CTkFrame(scroll, fg_color = "transparent")
                    tf.pack(fill = "x", pady = 3, padx = 30)
                    lbl = customtkinter.CTkLabel(tf, text = f"{label_text}: {value_text}", font = customtkinter.CTkFont(size = 12), anchor = "w")
                    lbl.pack(fill = "x")

                bh = tracked.get('bullets_loaded_history', [])or[]
                if isinstance(bh, list)and bh:
                    hist_label = customtkinter.CTkLabel(scroll, text = "Recent Bullets Loaded", font = customtkinter.CTkFont(size = 14, weight = "bold"))
                    hist_label.pack(pady =(12, 6), anchor = "w", padx = 20)
                    for rec in bh[-5:]:
                        try:
                            wid = rec.get('weapon_id')
                            cnt = rec.get('count')
                            t = rec.get('time')
                            txt = f"{wid}: {cnt} @ {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(t))if t else 'unknown'}"
                        except Exception:
                            txt = str(rec)
                        rf = customtkinter.CTkFrame(scroll, fg_color = "transparent")
                        rf.pack(fill = "x", pady = 2, padx = 40)
                        rlbl = customtkinter.CTkLabel(rf, text = txt, font = customtkinter.CTkFont(size = 11), anchor = "w")
                        rlbl.pack(fill = "x")
        except Exception:
            logging.exception('Failed rendering tracked_stats in character view')

        other_label = customtkinter.CTkLabel(scroll, text = "Other Info", font = customtkinter.CTkFont(size = 16, weight = "bold"))
        other_label.pack(pady =(20, 15), anchor = "w", padx = 20)

        other_items =[
        ("Money", f"${save_data.get('money', 0)}"),
        ("Equipment Slots", f"{len([s for s in save_data.get('equipment', {}).values()if s is not None])}/{len(save_data.get('equipment', {}))}"),
        ("Storage Items", f"{len(save_data.get('storage', []))}")
        ]

        for label_text, value_text in other_items:
            other_frame = customtkinter.CTkFrame(scroll, fg_color = "transparent")
            other_frame.pack(fill = "x", pady = 3, padx = 30)

            label = customtkinter.CTkLabel(
            other_frame,
            text = f"{label_text}: {value_text}",
            font = customtkinter.CTkFont(size = 12),
            anchor = "w"
            )
            label.pack(fill = "x")

        button_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        button_frame.grid(row = 2, column = 0, pady = 10)
        button_frame.grid_columnconfigure((0, 1), weight = 1)

        def save_character():
            try:
                self._save_file(save_data)
                self._popup_show_info("Success", "Character saved successfully!", sound = "success")
            except Exception as e:
                logging.error(f"Failed to save character: {e}")
                self._popup_show_info("Error", f"Failed to save: {e}", sound = "error")

        save_button = self._create_sound_button(
        button_frame,
        "Save",
        save_character,
        width = 200,
        height = 40
        )
        save_button.grid(row = 0, column = 0, padx =(0, 10))

        back_button = self._create_sound_button(
        button_frame,
        "Back",
        lambda:[self._clear_window(), self._open_character_management()],
        width = 200,
        height = 40
        )
        back_button.grid(row = 0, column = 1, padx =(10, 0))
    def _create_new_character(self):
        import uuid
        import json
        stat_clamp = 20
        slot_disable_points = 6
        try:
            table_files = glob.glob(os.path.join("tables", "*.sldtbl"))
            if table_files:
                with open(table_files[0], 'r')as f:
                    table_data = json.load(f)
                    stat_clamp = table_data.get("additional_settings", {}).get("stat_clamp", 20)
                    slot_disable_points = table_data.get("additional_settings", {}).get("slot_disable_points", 1)
                    logging.info(f"Loaded stat_clamp from table: {stat_clamp}")
                    logging.info(f"Loaded slot_disable_points from table: {slot_disable_points}")
        except Exception as e:
            logging.warning(f"Failed to load table settings, using default clamp: {e}")
        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        scrollable_frame = customtkinter.CTkScrollableFrame(self.root, width = 650, height = 700)
        scrollable_frame.grid(row = 0, column = 0, sticky = "nsew", padx = 20, pady = 20)
        scrollable_frame.grid_columnconfigure(0, weight = 1)

        title = customtkinter.CTkLabel(scrollable_frame, text = "Create New Character", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title.grid(row = 0, column = 0, pady =(0, 20))
        name_label = customtkinter.CTkLabel(scrollable_frame, text = "Character Name:", font = customtkinter.CTkFont(size = 14))
        name_label.grid(row = 1, column = 0, sticky = "w", pady = 5)
        name_entry = customtkinter.CTkEntry(scrollable_frame, placeholder_text = "Enter character name")
        name_entry.grid(row = 2, column = 0, sticky = "ew", pady =(0, 15), padx = 10)
        stats_frame = customtkinter.CTkFrame(scrollable_frame)
        stats_frame.grid(row = 3, column = 0, sticky = "ew", pady = 10, padx = 10)
        stats_frame.grid_columnconfigure((1, 2, 3), weight = 1)
        stats_label = customtkinter.CTkLabel(stats_frame, text = "Initial Stats(Sum must be â‰¤ 0)", font = customtkinter.CTkFont(size = 14, weight = "bold"))
        stats_label.grid(row = 0, column = 0, columnspan = 4, pady =(0, 15))
        stat_names = list(emptysave["stats"].keys())
        stat_sliders = {}
        stat_value_labels = {}
        for i, stat in enumerate(stat_names):
            stat_label = customtkinter.CTkLabel(stats_frame, text = f"{stat}:", font = customtkinter.CTkFont(size = 12), width = 100)
            stat_label.grid(row = i +1, column = 0, sticky = "w", padx =(0, 10), pady = 8)
            value_label = customtkinter.CTkLabel(stats_frame, text = "0", font = customtkinter.CTkFont(size = 12, weight = "bold"), width = 30)
            value_label.grid(row = i +1, column = 1, sticky = "e", padx =(0, 10), pady = 8)
            stat_value_labels[stat]= value_label
            def make_slider_callback(stat_name, value_lbl):
                def on_slider_change(val):
                    value_lbl.configure(text = str(int(float(val))))
                return on_slider_change
            if stat =="Luck":
                stat_min, stat_max = -4, 4
                stat_steps = 8
            else:
                stat_min, stat_max = -20, stat_clamp
                stat_steps = 40 +stat_clamp
            slider = customtkinter.CTkSlider(
            stats_frame,
            from_ = stat_min,
            to = stat_max,
            number_of_steps = stat_steps,
            command = make_slider_callback(stat, value_label)
            )
            slider.set(0)
            slider.grid(row = i +1, column = 2, sticky = "ew", padx = 10, pady = 8)
            stat_sliders[stat]= slider
            range_label = customtkinter.CTkLabel(stats_frame, text = f"[{stat_min}, +{stat_max}]", font = customtkinter.CTkFont(size = 10), text_color = "gray")
            range_label.grid(row = i +1, column = 3, sticky = "w", padx =(10, 0), pady = 8)

        equipment_frame = customtkinter.CTkFrame(scrollable_frame)
        equipment_frame.grid(row = 4, column = 0, sticky = "ew", pady = 10, padx = 10)
        equipment_frame.grid_columnconfigure((0, 1, 2), weight = 1)

        equipment_label = customtkinter.CTkLabel(equipment_frame, text = f"Equipment Slots(Disable for -{slot_disable_points} point{'s'if slot_disable_points !=1 else ''} each)", font = customtkinter.CTkFont(size = 14, weight = "bold"))
        equipment_label.grid(row = 0, column = 0, columnspan = 3, pady =(0, 15))

        equipment_slots = list(emptysave["equipment"].keys())
        slot_checkboxes = {}

        for i, slot in enumerate(equipment_slots):
            row =(i //3)+1
            col = i %3

            checkbox = customtkinter.CTkCheckBox(
            equipment_frame,
            text = slot.title(),
            font = customtkinter.CTkFont(size = 11)
            )
            checkbox.select()
            checkbox.grid(row = row, column = col, sticky = "w", padx = 10, pady = 5)
            slot_checkboxes[slot]= checkbox

        sum_frame = customtkinter.CTkFrame(scrollable_frame)
        sum_frame.grid(row = 5, column = 0, sticky = "ew", pady = 15, padx = 10)
        sum_frame.grid_columnconfigure(1, weight = 1)
        sum_label = customtkinter.CTkLabel(sum_frame, text = "Total Points:", font = customtkinter.CTkFont(size = 12, weight = "bold"))
        sum_label.grid(row = 0, column = 0, sticky = "w", padx =(0, 10))
        sum_value_label = customtkinter.CTkLabel(sum_frame, text = "0", font = customtkinter.CTkFont(size = 12, weight = "bold"))
        sum_value_label.grid(row = 0, column = 1, sticky = "w")

        def update_sum(*args):
            stat_total = sum(int(float(stat_sliders[stat].get()))for stat in stat_names)
            disabled_slots = sum(1 for slot, checkbox in slot_checkboxes.items()if not checkbox.get())
            bonus_points = disabled_slots *slot_disable_points *-1
            total = stat_total +bonus_points

            sum_value_label.configure(text = f"{stat_total} + {bonus_points} = {total}")
            if total >0:
                sum_value_label.configure(text_color = "red")
                create_button.configure(state = "disabled")
            else:
                sum_value_label.configure(text_color = "white")
                create_button.configure(state = "normal")

        for stat in stat_names:
            stat_sliders[stat].configure(command = lambda val, s = stat:[
            stat_value_labels[s].configure(text = str(int(float(stat_sliders[s].get())))),
            update_sum()
            ])

        for slot in equipment_slots:
            slot_checkboxes[slot].configure(command = update_sum)

        button_frame = customtkinter.CTkFrame(scrollable_frame, fg_color = "transparent")
        button_frame.grid(row = 6, column = 0, sticky = "ew", pady =(20, 0), padx = 10)
        button_frame.grid_columnconfigure((0, 1), weight = 1)

        def perform_character_creation():
            char_name = name_entry.get().strip()
            stat_total = sum(int(float(stat_sliders[stat].get()))for stat in stat_names)
            disabled_slots = sum(1 for slot, checkbox in slot_checkboxes.items()if not checkbox.get())
            bonus_points = disabled_slots *slot_disable_points *-1
            total = stat_total +bonus_points

            try:
                new_save = emptysave.copy()
                new_save["charactername"]= char_name
                for stat in stat_names:
                    new_save["stats"][stat]= int(float(stat_sliders[stat].get()))

                for slot, checkbox in slot_checkboxes.items():
                    if not checkbox.get():
                        del new_save["equipment"][slot]
                char_uuid = str(uuid.uuid4())
                save_basename = f"{char_name}_{char_uuid}"
                save_filename = os.path.join(saves_folder or "saves", save_basename +".sldsv")

                self._write_save_to_path(save_filename, new_save)
                persistentdata["save_uuids"][char_uuid]= char_name
                persistentdata["last_loaded_save"]= char_uuid

                try:
                    global currentsave
                    currentsave = save_basename
                except Exception:
                    pass
                self._save_persistent_data()
                logging.info(f"Character '{char_name}' created successfully with UUID: {char_uuid}")
                self._popup_show_info("Success", f"Character '{char_name}' created successfully!", sound = "success")
                self._clear_window()
                self._open_character_management()
            except Exception as e:
                logging.error(f"Failed to create character: {e}")
                self._popup_show_info("Error", f"Failed to create character: {e}", sound = "error")

        def create_character():
            char_name = name_entry.get().strip()
            if not char_name:
                self._popup_show_info("Error", "Please enter a character name.", sound = "error")
                return

            stat_total = sum(int(float(stat_sliders[stat].get()))for stat in stat_names)
            disabled_slots = sum(1 for slot, checkbox in slot_checkboxes.items()if not checkbox.get())
            bonus_points = disabled_slots *slot_disable_points *-1
            total = stat_total +bonus_points

            if total <0:
                self._popup_confirm(
                "Negative Balance Warning",
                f"Your point balance is {total}(negative).This means you have unspent points.\n\nAre you sure you want to continue?",
                perform_character_creation
                )
            else:
                perform_character_creation()

        def go_back():
            self._clear_window()
            self._open_character_management()

        create_button = self._create_sound_button(button_frame, "Create Character", create_character, width = 200, height = 50, font = customtkinter.CTkFont(size = 14))
        create_button.grid(row = 0, column = 0, padx =(0, 10))
        back_button = self._create_sound_button(
        button_frame,
        "Cancel",
        lambda:self._popup_confirm(
        "Cancel Character Creation",
        "Are you sure you want to cancel? Unsaved changes will be lost.",
        go_back
        ),
        width = 200,
        height = 50,
        font = customtkinter.CTkFont(size = 14)
        )
        back_button.grid(row = 0, column = 1, padx =(10, 0))
    def _load_existing_character(self):
        import json
        import os

        logging.info("Load Existing Character definition called")

        save_files =[]
        try:
            for filename in os.listdir(saves_folder):
                if filename.endswith(".sldsv.sldsv"):
                    continue
                if filename.endswith(".sldsv")and filename not in["persistent_data.sldsv", "settings.sldsv", "appearance_settings.sldsv", "dm_settings.sldsv"]:
                    save_path = os.path.join(saves_folder or "saves", filename)
                    try:
                        save_data = self._read_save_from_path(save_path)
                        if save_data is None:
                            char_name = "Unknown"
                        else:
                            char_name = save_data.get("charactername", "Unknown")

                            uuid_part = filename.replace(".sldsv", "").split("_")[-1]
                            save_files.append({
                            "filename":filename,
                            "character_name":char_name,
                            "uuid":uuid_part,
                            "data":save_data
                            })
                    except Exception as e:
                        logging.warning(f"Failed to load save file {filename}: {e}")
        except Exception as e:
            logging.error(f"Failed to read saves folder: {e}")
            self._popup_show_info("Error", f"Failed to read saves folder: {e}", sound = "error")
            return

        if not save_files:
            self._popup_show_info("No Saves Found", "No character save files found.", sound = "error")
            return

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew", padx = 20, pady = 20)
        main_frame.grid_rowconfigure(1, weight = 1)
        main_frame.grid_columnconfigure(0, weight = 1)

        title = customtkinter.CTkLabel(main_frame, text = "Load Existing Character", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title.grid(row = 0, column = 0, pady =(0, 20))

        scroll_frame = customtkinter.CTkScrollableFrame(main_frame, width = 700, height = 400)
        scroll_frame.grid(row = 1, column = 0, sticky = "nsew", pady =(0, 20))
        scroll_frame.grid_columnconfigure(0, weight = 1)

        def load_character(save_info):
            global currentsave
            try:
                currentsave = save_info["filename"].replace(".sldsv", "")
                persistentdata["save_uuids"].setdefault(save_info["uuid"], save_info["character_name"])
                persistentdata["last_loaded_save"]= save_info["uuid"]
                self._save_persistent_data()
                logging.info(f"Loaded character '{save_info['character_name']}' with UUID: {save_info['uuid']}")
                self._popup_show_info("Success", f"Character '{save_info['character_name']}' loaded successfully!", sound = "success")
                self._clear_window()
                self._build_main_menu()
            except Exception as e:
                logging.error(f"Failed to load character: {e}")
                self._popup_show_info("Error", f"Failed to load character: {e}", sound = "error")

        for i, save_info in enumerate(save_files):
            char_frame = customtkinter.CTkFrame(scroll_frame)
            char_frame.grid(row = i, column = 0, sticky = "ew", pady = 5, padx = 10)
            char_frame.grid_columnconfigure(0, weight = 1)

            name_label = customtkinter.CTkLabel(
            char_frame,
            text = save_info["character_name"],
            font = customtkinter.CTkFont(size = 18, weight = "bold"),
            anchor = "w"
            )
            name_label.grid(row = 0, column = 0, sticky = "w", padx = 15, pady =(10, 5))

            stats = save_info["data"].get("stats", {})
            stats_text = " | ".join([f"{stat}: {value:+d}"for stat, value in stats.items()])
            stats_label = customtkinter.CTkLabel(
            char_frame,
            text = stats_text,
            font = customtkinter.CTkFont(size = 11),
            text_color = "gray",
            anchor = "w"
            )
            stats_label.grid(row = 1, column = 0, sticky = "w", padx = 15, pady =(0, 5))

            equipment_count = len(save_info["data"].get("equipment", {}))
            equipment_label = customtkinter.CTkLabel(
            char_frame,
            text = f"Equipment Slots: {equipment_count}",
            font = customtkinter.CTkFont(size = 11),
            text_color = "gray",
            anchor = "w"
            )
            equipment_label.grid(row = 2, column = 0, sticky = "w", padx = 15, pady =(0, 10))

            file_name = save_info["filename"]
            file_name_label = customtkinter.CTkLabel(
            char_frame,
            text = f"Filename: {file_name}",
            font = customtkinter.CTkFont(size = 11),
            text_color = "gray",
            anchor = "w"
            )
            file_name_label.grid(row = 3, column = 0, sticky = "w", padx = 15, pady =(0, 10))

            load_button = self._create_sound_button(
            char_frame,
            "Load Character",
            lambda s = save_info:load_character(s),
            width = 150,
            height = 35,
            font = customtkinter.CTkFont(size = 13)
            )
            load_button.grid(row = 0, column = 1, rowspan = 3, padx = 15, pady = 10)

        button_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        button_frame.grid(row = 2, column = 0, pady =(10, 0))

        load_backup_button = self._create_sound_button(
        button_frame,
        "Load from Backup",
        lambda:self._open_load_from_backup(),
        width = 200,
        height = 50,
        font = customtkinter.CTkFont(size = 14),
        fg_color = "#4a5568"
        )
        load_backup_button.pack(side = "left", padx = 10)

        back_button = self._create_sound_button(
        button_frame,
        "Back to Character Management",
        lambda:[self._clear_window(), self._open_character_management()],
        width = 300,
        height = 50,
        font = customtkinter.CTkFont(size = 14)
        )
        back_button.pack(side = "left", padx = 10)

    def _open_load_from_backup(self):

        logging.info("Load from Backup definition called")

        self._clear_window()
        self._play_ui_sound("whoosh1")

        backup_base = os.path.join(saves_folder or "saves", "backups")

        character_folders =[]
        if os.path.exists(backup_base):
            for folder_name in os.listdir(backup_base):
                folder_path = os.path.join(backup_base, folder_name)
                if os.path.isdir(folder_path)and folder_name !="archive":
                    backup_files = glob.glob(os.path.join(folder_path, "*.sldsv"))
                    if backup_files:
                        character_folders.append({
                        "name":folder_name,
                        "path":folder_path,
                        "backup_count":len(backup_files)
                        })

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew", padx = 20, pady = 20)
        main_frame.grid_rowconfigure(1, weight = 1)
        main_frame.grid_columnconfigure(0, weight = 1)

        title = customtkinter.CTkLabel(main_frame, text = "Load from Backup", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title.grid(row = 0, column = 0, pady =(0, 20))

        if not character_folders:
            no_backups = customtkinter.CTkLabel(
            main_frame,
            text = "No backups found.\nBackups are created automatically when saving characters.",
            font = customtkinter.CTkFont(size = 14),
            text_color = "gray"
            )
            no_backups.grid(row = 1, column = 0, pady = 20)
        else:
            scroll_frame = customtkinter.CTkScrollableFrame(main_frame, width = 700, height = 400)
            scroll_frame.grid(row = 1, column = 0, sticky = "nsew", pady =(0, 20))
            scroll_frame.grid_columnconfigure(0, weight = 1)

            for i, char_folder in enumerate(character_folders):
                folder_frame = customtkinter.CTkFrame(scroll_frame)
                folder_frame.grid(row = i, column = 0, sticky = "ew", pady = 5, padx = 10)
                folder_frame.grid_columnconfigure(0, weight = 1)

                name_label = customtkinter.CTkLabel(
                folder_frame,
                text = char_folder["name"],
                font = customtkinter.CTkFont(size = 18, weight = "bold"),
                anchor = "w"
                )
                name_label.grid(row = 0, column = 0, sticky = "w", padx = 15, pady =(10, 5))

                count_label = customtkinter.CTkLabel(
                folder_frame,
                text = f"{char_folder['backup_count']} backup(s) available",
                font = customtkinter.CTkFont(size = 11),
                text_color = "gray",
                anchor = "w"
                )
                count_label.grid(row = 1, column = 0, sticky = "w", padx = 15, pady =(0, 10))

                browse_button = self._create_sound_button(
                folder_frame,
                "Browse Backups",
                lambda cf = char_folder:self._browse_character_backups(cf),
                width = 150,
                height = 35,
                font = customtkinter.CTkFont(size = 13)
                )
                browse_button.grid(row = 0, column = 1, rowspan = 2, padx = 15, pady = 10)

        back_button = self._create_sound_button(
        main_frame,
        "Back to Load Character",
        lambda:[self._clear_window(), self._load_existing_character()],
        width = 300,
        height = 50,
        font = customtkinter.CTkFont(size = 14)
        )
        back_button.grid(row = 2, column = 0, pady =(10, 0))

    def _browse_character_backups(self, char_folder):

        logging.info(f"Browsing backups for: {char_folder['name']}")

        self._clear_window()
        self._play_ui_sound("whoosh1")

        backup_files =[]
        for backup_path in glob.glob(os.path.join(char_folder["path"], "*.sldsv")):
            try:
                filename = os.path.basename(backup_path)
                mtime = os.path.getmtime(backup_path)
                mtime_str = datetime.fromtimestamp(mtime).strftime("%Y-%m-%d %H:%M:%S")

                timestamp_part = filename.replace("backup_", "").replace(".sldsv", "")
                try:
                    if "_"in timestamp_part:
                        parts = timestamp_part.split("_")
                        if len(parts)>=2:
                            date_str = f"{parts[0][:4]}-{parts[0][4:6]}-{parts[0][6:8]}"
                            time_str = f"{parts[1][:2]}:{parts[1][2:4]}:{parts[1][4:6]}"
                            display_time = f"{date_str} {time_str}"
                        else:
                            display_time = mtime_str
                    else:
                        display_time = mtime_str
                except Exception:
                    display_time = mtime_str

                backup_files.append({
                "path":backup_path,
                "filename":filename,
                "mtime":mtime,
                "display_time":display_time
                })
            except Exception as e:
                logging.warning(f"Failed to read backup file info: {e}")

        backup_files.sort(key = lambda x:x["mtime"], reverse = True)

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew", padx = 20, pady = 20)
        main_frame.grid_rowconfigure(1, weight = 1)
        main_frame.grid_columnconfigure(0, weight = 1)

        title = customtkinter.CTkLabel(
        main_frame,
        text = f"Backups: {char_folder['name']}",
        font = customtkinter.CTkFont(size = 24, weight = "bold")
        )
        title.grid(row = 0, column = 0, pady =(0, 20))

        scroll_frame = customtkinter.CTkScrollableFrame(main_frame, width = 700, height = 400)
        scroll_frame.grid(row = 1, column = 0, sticky = "nsew", pady =(0, 20))
        scroll_frame.grid_columnconfigure(0, weight = 1)

        def load_backup(backup_info):
            try:
                backup_data = self._read_save_from_path(backup_info["path"])
                if backup_data is None:
                    self._popup_show_info("Error", "Failed to read backup file.", sound = "error")
                    return

                def confirm_load():
                    global currentsave
                    try:
                        char_name = backup_data.get("charactername", "Unknown")
                        uuid_val = backup_data.get("uuid")
                        if not uuid_val:
                            import uuid
                            uuid_val = str(uuid.uuid4())
                            backup_data["uuid"]= uuid_val

                        save_filename = f"{char_name}_{uuid_val}"
                        save_path = os.path.join(saves_folder or "saves", f"{save_filename}.sldsv")

                        self._write_save_to_path(save_path, backup_data)

                        currentsave = save_filename
                        persistentdata["save_uuids"].setdefault(uuid_val, char_name)
                        persistentdata["last_loaded_save"]= uuid_val
                        self._save_persistent_data()

                        logging.info(f"Restored backup for '{char_name}' from {backup_info['filename']}")
                        self._popup_show_info("Success", f"Backup restored for '{char_name}'!\nBackup time: {backup_info['display_time']}", sound = "success")
                        self._clear_window()
                        self._build_main_menu()
                    except Exception as e:
                        logging.error(f"Failed to restore backup: {e}")
                        self._popup_show_info("Error", f"Failed to restore backup: {e}", sound = "error")

                self._popup_confirm(
                "Restore Backup",
                f"This will restore the backup from:\n{backup_info['display_time']}\n\nThis will overwrite the current save for this character.\nContinue?",
                confirm_load
                )
            except Exception as e:
                logging.error(f"Failed to load backup: {e}")
                self._popup_show_info("Error", f"Failed to load backup: {e}", sound = "error")

        for i, backup_info in enumerate(backup_files):
            is_latest =(i ==0)
            backup_frame = customtkinter.CTkFrame(
            scroll_frame,
            fg_color =("#2d5a2d", "#1a3d1a")if is_latest else None,
            border_width = 2 if is_latest else 0,
            border_color = "#4ade80"if is_latest else None
            )
            backup_frame.grid(row = i, column = 0, sticky = "ew", pady = 3, padx = 10)
            backup_frame.grid_columnconfigure(0, weight = 1)

            time_text = backup_info["display_time"]
            if is_latest:
                time_text = f"â˜† {time_text}(Latest)"

            time_label = customtkinter.CTkLabel(
            backup_frame,
            text = time_text,
            font = customtkinter.CTkFont(size = 14, weight = "bold"),
            text_color = "#4ade80"if is_latest else None,
            anchor = "w"
            )
            time_label.grid(row = 0, column = 0, sticky = "w", padx = 15, pady =(8, 2))

            file_label = customtkinter.CTkLabel(
            backup_frame,
            text = backup_info["filename"],
            font = customtkinter.CTkFont(size = 10),
            text_color = "#86efac"if is_latest else "gray",
            anchor = "w"
            )
            file_label.grid(row = 1, column = 0, sticky = "w", padx = 15, pady =(0, 8))

            load_btn = self._create_sound_button(
            backup_frame,
            "Restore",
            lambda bi = backup_info:load_backup(bi),
            width = 100,
            height = 30,
            font = customtkinter.CTkFont(size = 12)
            )
            load_btn.grid(row = 0, column = 1, rowspan = 2, padx = 15, pady = 5)

        back_button = self._create_sound_button(
        main_frame,
        "Back to Backup List",
        lambda:self._open_load_from_backup(),
        width = 300,
        height = 50,
        font = customtkinter.CTkFont(size = 14)
        )
        back_button.grid(row = 2, column = 0, pady =(10, 0))

    def _open_inventory_management(self):
        logging.info("Inventory Management definition called")

        self._clear_window()

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew", padx = 20, pady = 20)
        main_frame.grid_columnconfigure(0, weight = 1)

        title = customtkinter.CTkLabel(main_frame, text = "Inventory Management", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title.pack(pady =(0, 20))

        container_management_button = self._create_sound_button(
        main_frame,
        "Manage Containers & Transfer Items",
        lambda:[self._clear_window(), self._manage_containers()],
        width = 500,
        height = 50,
        font = customtkinter.CTkFont(size = 16)
        )
        container_management_button.pack(pady = 10)

        player_transfer_button = self._create_sound_button(
        main_frame,
        "Transfer to Another Player(Export/Import)",
        lambda:[self._clear_window(), self._transfer_player()],
        width = 500,
        height = 50,
        font = customtkinter.CTkFont(size = 16)
        )
        player_transfer_button.pack(pady = 10)

        back_button = self._create_sound_button(
        main_frame,
        "Back to Inventory Manager",
        lambda:[self._clear_window(), self._open_inventory_manager_tool()],
        width = 500,
        height = 50,
        font = customtkinter.CTkFont(size = 16)
        )
        back_button.pack(pady = 10)

    def _format_weight(self, weight_kg):

        if appearance_settings["units"]=="imperial":
            weight_lb = weight_kg *2.20462
            return f"{weight_lb:.2f} lb"
        elif appearance_settings["units"]=="cheese":
            cheese_wheels = weight_kg /40.0
            if cheese_wheels ==1.0:
                return "1 cheese wheel"
            elif cheese_wheels ==int(cheese_wheels):
                return f"{int(cheese_wheels)} cheese wheels"
            else:
                return f"{cheese_wheels:.2f} cheese wheels"
        else:
            return f"{weight_kg:.2f} kg"

    def _consume_item(self, item, location, save_data, on_complete = None):

        import threading

        if not item or not isinstance(item, dict):
            self._popup_show_info("Error", "Invalid item.", sound = "error")
            return

        if not item.get("consumable"):
            self._popup_show_info("Error", "This item is not consumable.", sound = "error")
            return

        table_items_map = {}
        try:
            table_files = sorted(glob.glob(os.path.join("tables", f"*{global_variables.get('table_extension', '.sldtbl')}")))
            cur_tbl = global_variables.get("current_table")
            target_file = None
            if cur_tbl:
                for fpath in table_files:
                    if os.path.abspath(fpath).endswith(cur_tbl)or os.path.basename(fpath)==cur_tbl:
                        target_file = fpath
                        break
            if not target_file and table_files:
                target_file = table_files[0]
            if target_file:
                with open(target_file, 'r', encoding = 'utf-8')as f:
                    table_data = json.load(f)
                for table_name, items_list in table_data.get("tables", {}).items():
                    if isinstance(items_list, list):
                        for tbl_item in items_list:
                            if isinstance(tbl_item, dict)and "id"in tbl_item:
                                table_items_map[tbl_item["id"]]= tbl_item
        except Exception as e:
            logging.warning(f"Failed to load table for weight calculation: {e}")

        if item.get("disinfectant_required"):

            disinfectant_found = None
            disinfectant_location = None
            disinfectant_idx = -1

            for idx, inv_item in enumerate(save_data.get("hands", {}).get("items", [])):
                if isinstance(inv_item, dict)and inv_item.get("id")==257:
                    disinfectant_found = inv_item
                    disinfectant_location = "hands"
                    disinfectant_idx = idx
                    break

            if not disinfectant_found:
                for slot_name, eq_item in save_data.get("equipment", {}).items():
                    if isinstance(eq_item, dict)and eq_item.get("items"):
                        for idx, inv_item in enumerate(eq_item.get("items", [])):
                            if isinstance(inv_item, dict)and inv_item.get("id")==257:
                                disinfectant_found = inv_item
                                disinfectant_location = f"equipment.{slot_name}"
                                disinfectant_idx = idx
                                break
                    if disinfectant_found:
                        break

            if not disinfectant_found:
                self._popup_show_info("Disinfectant Required",
                f"You need isopropyl alcohol(disinfectant) to use {item.get('name', 'this item')}.",
                sound = "error")
                return

            disinfectant_sounds = disinfectant_found.get("consumable_sounds", [])

            if disinfectant_found.get("used_up"):
                uses = disinfectant_found.get("uses_left", 1)
                if uses >1:
                    disinfectant_found["uses_left"]= uses -1

                    dis_id = disinfectant_found.get("id")
                    if dis_id is not None and dis_id in table_items_map:
                        dis_table = table_items_map[dis_id]
                        dis_orig_uses = dis_table.get("uses_left", 1)
                        dis_orig_weight = dis_table.get("weight", 0)
                        if dis_orig_uses >0 and dis_orig_weight >0:
                            disinfectant_found["weight"]= dis_orig_weight *(uses -1)/dis_orig_uses
                else:

                    if disinfectant_location =="hands"and isinstance(disinfectant_idx, int):
                        items_list = save_data.get("hands", {}).get("items", [])
                        if disinfectant_idx >=0 and disinfectant_idx <len(items_list):
                            items_list.pop(disinfectant_idx)
                    elif disinfectant_location and disinfectant_location.startswith("equipment.")and isinstance(disinfectant_idx, int):
                        slot = disinfectant_location.split(".")[1]
                        eq_item = save_data.get("equipment", {}).get(slot)
                        if eq_item and isinstance(eq_item, dict):
                            items_list = eq_item.get("items", [])
                            if disinfectant_idx >=0 and disinfectant_idx <len(items_list):
                                items_list.pop(disinfectant_idx)

        def find_item_in_location(loc, target_item):

            if loc =="hands":
                items_list = save_data.get("hands", {}).get("items", [])
                for idx, it in enumerate(items_list):
                    if it is target_item:
                        return items_list, idx
            elif loc.startswith("equipment."):
                parts = loc.split(".")
                slot = parts[1]
                eq = save_data.get("equipment", {}).get(slot)
                if eq and isinstance(eq, dict):

                    if len(parts)>=5 and parts[2]=="subslots":
                        try:
                            subslot_idx = int(parts[3])
                            subslots = eq.get("subslots", [])
                            if subslot_idx <len(subslots):
                                subslot = subslots[subslot_idx]
                                curr = subslot.get("current")if isinstance(subslot, dict)else None
                                if curr and isinstance(curr, dict):

                                    if curr is target_item:

                                        return subslot, "current"

                                    items_list = curr.get("items", [])
                                    for idx, it in enumerate(items_list):
                                        if it is target_item:
                                            return items_list, idx
                        except(ValueError, IndexError):
                            pass
                    else:

                        items_list = eq.get("items", [])
                        for idx, it in enumerate(items_list):
                            if it is target_item:
                                return items_list, idx
            return None, -1

        def play_sounds_and_finish():

            sounds = item.get("consumable_sounds", [])

            if item.get("lighting_device_required"):

                lighting_device = None
                for inv_item in save_data.get("hands", {}).get("items", []):
                    if isinstance(inv_item, dict)and inv_item.get("lighting_device"):
                        lighting_device = inv_item
                        break
                if not lighting_device:
                    for slot_name, eq_item in save_data.get("equipment", {}).items():
                        if isinstance(eq_item, dict)and eq_item.get("items"):
                            for inv_item in eq_item.get("items", []):
                                if isinstance(inv_item, dict)and inv_item.get("lighting_device"):
                                    lighting_device = inv_item
                                    break
                        if lighting_device:
                            break

                if not lighting_device:
                    self._popup_show_info("Lighting Device Required",
                    f"You need a lighter or matches to use {item.get('name', 'this item')}.",
                    sound = "error")
                    return

                new_sounds =[]
                for s in sounds:
                    if s =="lightingdevice":
                        ld_sounds = lighting_device.get("consumable_sounds", [])
                        new_sounds.extend(ld_sounds)
                    else:
                        new_sounds.append(s)
                sounds = new_sounds

                if lighting_device.get("used_up"):
                    uses = lighting_device.get("uses_left", 1)
                    if uses >1:
                        lighting_device["uses_left"]= uses -1

                        ld_id = lighting_device.get("id")
                        if ld_id is not None and ld_id in table_items_map:
                            ld_table = table_items_map[ld_id]
                            ld_orig_uses = ld_table.get("uses_left", 1)
                            ld_orig_weight = ld_table.get("weight", 0)
                            if ld_orig_uses >0 and ld_orig_weight >0:
                                lighting_device["weight"]= ld_orig_weight *(uses -1)/ld_orig_uses
                    else:

                        for idx, inv_item in enumerate(save_data.get("hands", {}).get("items", [])):
                            if inv_item is lighting_device:
                                save_data["hands"]["items"].pop(idx)
                                break
                        else:
                            for slot_name, eq_item in save_data.get("equipment", {}).items():
                                if isinstance(eq_item, dict)and eq_item.get("items"):
                                    for idx, inv_item in enumerate(eq_item.get("items", [])):
                                        if inv_item is lighting_device:
                                            eq_item["items"].pop(idx)
                                            break

            if item.get("disinfectant_required")and disinfectant_found:
                for snd in disinfectant_sounds:
                    self._safe_sound_play("misc/consumable", snd.replace(".ogg", ""), block = True)

            for snd in sounds:
                if snd and snd !="lightingdevice":
                    self._safe_sound_play("misc/consumable", snd.replace(".ogg", ""), block = True)

            if item.get("used_up"):
                uses = item.get("uses_left", 1)
                if uses >1:
                    item["uses_left"]= uses -1

                    item_id = item.get("id")
                    if item_id is not None and item_id in table_items_map:
                        table_item = table_items_map[item_id]
                        original_uses = table_item.get("uses_left", 1)
                        original_weight = table_item.get("weight", 0)
                        if original_uses >0 and original_weight >0:
                            new_weight = original_weight *(uses -1)/original_uses
                            item["weight"]= new_weight
                            logging.info(f"Consumed {item.get('name')}, {uses -1} uses remaining, weight now {new_weight:.4f}")
                        else:
                            logging.info(f"Consumed {item.get('name')}, {uses -1} uses remaining")
                    else:
                        logging.info(f"Consumed {item.get('name')}, {uses -1} uses remaining")
                else:

                    items_list_or_subslot, idx = find_item_in_location(location, item)
                    if items_list_or_subslot is not None:
                        if idx =="current":

                            items_list_or_subslot["current"]= None
                            logging.info(f"Consumed and removed {item.get('name')} from subslot")
                        elif isinstance(idx, int)and idx >=0:
                            items_list_or_subslot.pop(idx)
                            logging.info(f"Consumed and removed {item.get('name')}")
            else:
                logging.info(f"Used {item.get('name')}(reusable)")

            self._save_file(save_data)

            if on_complete:
                self.root.after(0, on_complete)

        thread = threading.Thread(target = play_sounds_and_finish, daemon = True)
        thread.start()

    def _use_stratagem(self, item, location, save_data, on_complete = None):

        import threading

        if not item or not isinstance(item, dict):
            self._popup_show_info("Error", "Invalid item.", sound = "error")
            return

        if not item.get("stratagem"):
            self._popup_show_info("Error", "This item is not a stratagem.", sound = "error")
            return

        num_rounds = item.get("rounds", 1)

        rounds_data =[]
        for r in range(1, num_rounds +1):
            seq = item.get(f"round_{r}", [])
            if seq:
                rounds_data.append(seq)

        if not rounds_data:
            self._popup_show_info("Error", "No stratagem sequences defined.", sound = "error")
            return

        dir_to_arrow = {
        "up":"â†‘",
        "down":"â†“",
        "left":"â†",
        "right":"â†’"
        }

        arrow_to_dir = {
        "Up":"up",
        "Down":"down",
        "Left":"left",
        "Right":"right"
        }

        strat_window = customtkinter.CTkToplevel(self.root)
        strat_window.title(f"Stratagem: {item.get('name', 'Unknown')}")
        strat_window.transient(self.root)
        self._center_popup_on_window(strat_window, 600, 400)
        strat_window.grab_set()
        strat_window.focus_force()

        state = {
        "current_round":0,
        "current_index":0,
        "music_channel":None,
        "is_complete":False
        }

        main_frame = customtkinter.CTkFrame(strat_window)
        main_frame.pack(fill = "both", expand = True, padx = 20, pady = 20)

        title_label = customtkinter.CTkLabel(
        main_frame,
        text = "Starting Stratagem Sequence",
        font = customtkinter.CTkFont(size = 24, weight = "bold")
        )
        title_label.pack(pady = 20)

        round_label = customtkinter.CTkLabel(
        main_frame,
        text = "",
        font = customtkinter.CTkFont(size = 16)
        )
        round_label.pack(pady = 10)

        arrows_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        arrows_frame.pack(pady = 30)

        arrow_labels =[]

        def play_sound_blocking(sound_name):

            sound_path = os.path.join("sounds", "misc", "stratagem", f"{sound_name}.ogg")
            if os.path.exists(sound_path):
                try:
                    sound = pygame.mixer.Sound(sound_path)
                    sound.play()
                    time.sleep(sound.get_length())
                except Exception as e:
                    logging.warning(f"Failed to play stratagem sound {sound_name}: {e}")

        def play_sound(sound_name):

            sound_path = os.path.join("sounds", "misc", "stratagem", f"{sound_name}.ogg")
            if os.path.exists(sound_path):
                try:
                    sound = pygame.mixer.Sound(sound_path)
                    sound.play()
                except Exception as e:
                    logging.warning(f"Failed to play stratagem sound {sound_name}: {e}")

        def start_music():

            sound_path = os.path.join("sounds", "misc", "stratagem", "game_music.ogg")
            if os.path.exists(sound_path):
                try:
                    sound = pygame.mixer.Sound(sound_path)
                    state["music_channel"]= sound.play(loops = -1)
                except Exception as e:
                    logging.warning(f"Failed to start stratagem music: {e}")

        def stop_music():

            if state["music_channel"]:
                try:
                    state["music_channel"].stop()
                except Exception:
                    pass

        def display_round(round_idx):

            nonlocal arrow_labels

            for lbl in arrow_labels:
                lbl.destroy()
            arrow_labels =[]

            if round_idx >=len(rounds_data):
                return

            sequence = rounds_data[round_idx]
            round_label.configure(text = f"Round {round_idx +1} of {len(rounds_data)}")

            for i, direction in enumerate(sequence):
                arrow = dir_to_arrow.get(direction.lower(), "?")
                lbl = customtkinter.CTkLabel(
                arrows_frame,
                text = arrow,
                font = customtkinter.CTkFont(size = 48, weight = "bold"),
                text_color = "gray"
                )
                lbl.pack(side = "left", padx = 10)
                arrow_labels.append(lbl)

            if arrow_labels:
                arrow_labels[0].configure(text_color = "#3B8ED0")

        def update_arrow_colors():

            sequence = rounds_data[state["current_round"]]
            for i, lbl in enumerate(arrow_labels):
                if i <state["current_index"]:
                    lbl.configure(text_color = "gray")
                elif i ==state["current_index"]:
                    lbl.configure(text_color = "#3B8ED0")
                else:
                    lbl.configure(text_color = "white")

        def show_error():

            for lbl in arrow_labels:
                lbl.configure(text_color = "red")
            play_sound("button_press_error")

            def reset_after_error():
                state["current_index"]= 0
                update_arrow_colors()

            strat_window.after(500, reset_after_error)

        def show_success():

            for lbl in arrow_labels:
                lbl.configure(text_color = "green")

        def on_sequence_complete():

            show_success()

            def after_success():
                play_sound_blocking("sequence_success")
                play_sound_blocking("round_over")

                state["current_round"]+=1
                state["current_index"]= 0

                if state["current_round"]>=len(rounds_data):

                    on_game_complete()
                else:

                    strat_window.after(0, lambda:display_round(state["current_round"]))

            threading.Thread(target = after_success, daemon = True).start()

        def on_game_complete():

            state["is_complete"]= True
            stop_music()

            def finish_game():
                play_sound_blocking("game_over")

                def find_and_remove():
                    if location =="hands":
                        items_list = save_data.get("hands", {}).get("items", [])
                        for idx, it in enumerate(items_list):
                            if it is item:
                                items_list.pop(idx)
                                break
                    elif location.startswith("equipment."):
                        parts = location.split(".")
                        slot = parts[1]
                        eq = save_data.get("equipment", {}).get(slot)
                        if eq and isinstance(eq, dict):
                            items_list = eq.get("items", [])
                            for idx, it in enumerate(items_list):
                                if it is item:
                                    items_list.pop(idx)
                                    break

                find_and_remove()
                self._save_file(save_data)
                logging.info(f"Stratagem {item.get('name')} completed and consumed")

                def close_and_callback():
                    strat_window.destroy()
                    if on_complete:
                        on_complete()

                strat_window.after(0, close_and_callback)

            threading.Thread(target = finish_game, daemon = True).start()

        def on_key_press(event):

            if state["is_complete"]:
                return

            if state["current_round"]>=len(rounds_data):
                return

            key_dir = arrow_to_dir.get(event.keysym)
            if not key_dir:
                return

            sequence = rounds_data[state["current_round"]]
            expected = sequence[state["current_index"]].lower()

            if key_dir ==expected:

                play_sound("button_press")
                state["current_index"]+=1

                if state["current_index"]>=len(sequence):

                    on_sequence_complete()
                else:
                    update_arrow_colors()
            else:

                show_error()

        def start_game():

            title_label.configure(text = item.get("name", "Stratagem"))
            start_music()
            display_round(0)
            update_arrow_colors()
            strat_window.bind("<Key>", on_key_press)

        def intro_sequence():

            play_sound_blocking("round_start_coin")
            strat_window.after(0, start_game)

        def on_window_close():

            stop_music()
            strat_window.destroy()

        strat_window.protocol("WM_DELETE_WINDOW", on_window_close)

        threading.Thread(target = intro_sequence, daemon = True).start()

    def _calculate_encumbrance_status(self, save_data):

        def compute_item_weight(itm, include_contained = True):

            if not itm or not isinstance(itm, dict):
                return 0.0
            qty = itm.get("quantity", 1)
            weight = itm.get("weight", 0)*qty

            if include_contained:
                for contained in itm.get("items", []):
                    weight +=compute_item_weight(contained, include_contained = True)

            if "subslots"in itm:
                for ss in itm.get("subslots", []):
                    current = ss.get("current")
                    weight +=compute_item_weight(current, include_contained = True)
            return weight

        def compute_encumbrance_contribution(itm, is_equipped = False):

            if not itm or not isinstance(itm, dict):
                return 0.0

            qty = itm.get("quantity", 1)
            base_weight = itm.get("weight", 0)*qty

            reduction = itm.get("encumbrance_reduction", 1.0)if is_equipped else 1.0
            if reduction <=0:
                reduction = 1.0

            encumbrance = base_weight

            contained_weight = 0.0
            for contained in itm.get("items", []):
                contained_weight +=compute_item_weight(contained, include_contained = True)

            if is_equipped and reduction >0:

                encumbrance +=contained_weight /reduction
            else:

                encumbrance +=contained_weight

            if "subslots"in itm:
                for ss in itm.get("subslots", []):
                    current = ss.get("current")
                    encumbrance +=compute_encumbrance_contribution(current, is_equipped = is_equipped)

            return encumbrance

        total_weight = 0.0
        total_encumbrance = 0.0

        for item in save_data.get("hands", {}).get("items", []):
            item_weight = compute_item_weight(item, include_contained = True)
            total_weight +=item_weight
            total_encumbrance +=item_weight

        for slot, item in save_data.get("equipment", {}).items():
            if item and isinstance(item, dict):
                item_weight = compute_item_weight(item, include_contained = True)
                total_weight +=item_weight

                total_encumbrance +=compute_encumbrance_contribution(item, is_equipped = True)

        encumbrance = max(total_encumbrance, 0.0)

        strength = save_data.get("stats", {}).get("Strength", 0)

        stat_clamp = 4
        try:
            import glob, json, os
            table_files = glob.glob(os.path.join("tables", "*.sldtbl"))
            if table_files:
                with open(table_files[0], 'r')as tf:
                    td = json.load(tf)
                    sc = td.get("additional_settings", {}).get("stat_clamp")
                    if isinstance(sc, (int, float)):
                        stat_clamp = int(sc)
        except Exception:
            pass

        stat_min = -20
        stat_max = stat_clamp

        m_clamped = max(stat_min, min(strength, stat_max))

        span = float(stat_max -stat_min)
        if span <=0:
            span = 24.0

        threshold = 15.0 +85.0 *(m_clamped -stat_min)/span

        threshold = max(15.0, min(100.0, threshold))

        encumbrance_level = 0
        if encumbrance >threshold:
            overflow_percent =(encumbrance -threshold)/threshold
            encumbrance_level = int(overflow_percent *10)

        return {
        "total_weight":total_weight,
        "total_reduction":0.0,
        "encumbrance":encumbrance,
        "threshold":threshold,
        "encumbrance_level":encumbrance_level,
        "is_encumbered":encumbrance_level >0
        }

    def _transfer_player(self):
        import json
        import base64
        import pickle
        from datetime import datetime

        if currentsave is None:
            self._popup_show_info("Error", "No character loaded.", sound = "error")
            return

        self._clear_window()

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.pack(fill = "both", expand = True, padx = 20, pady = 20)

        title = customtkinter.CTkLabel(main_frame, text = "Player Transfer", font = customtkinter.CTkFont(size = 20, weight = "bold"))
        title.pack(pady =(0, 20))

        export_frame = customtkinter.CTkFrame(main_frame)
        export_frame.pack(fill = "x", pady = 10, padx = 10)

        export_label = customtkinter.CTkLabel(export_frame, text = "Export Items/Money", font = customtkinter.CTkFont(size = 16, weight = "bold"))
        export_label.pack(pady = 10)

        money_frame = customtkinter.CTkFrame(export_frame, fg_color = "transparent")
        money_frame.pack(pady = 5)

        money_label = customtkinter.CTkLabel(money_frame, text = "Money Amount:")
        money_label.pack(side = "left", padx = 5)

        money_entry = customtkinter.CTkEntry(money_frame, placeholder_text = "0", width = 150)
        money_entry.pack(side = "left", padx = 5)

        items_label = customtkinter.CTkLabel(export_frame, text = "Select items to export from storage:", font = customtkinter.CTkFont(size = 13))
        items_label.pack(pady =(10, 5))

        items_scroll = customtkinter.CTkScrollableFrame(export_frame, width = 700, height = 200)
        items_scroll.pack(pady = 5, padx = 10)

        selected_items =[]

        def refresh_export_items():
            for widget in items_scroll.winfo_children():
                widget.destroy()
            selected_items.clear()

            save_path = os.path.join(saves_folder or "", (currentsave or "")+".sldsv")
            try:
                save_data = self._load_file((currentsave or "")+".sldsv")
                if save_data is None:
                    raise RuntimeError("Failed to load current save for export")

                storage_items = save_data.get("storage", [])

                if not storage_items:
                    empty_label = customtkinter.CTkLabel(items_scroll, text = "No items in storage", text_color = "gray")
                    empty_label.pack(pady = 20)
                    return

                for idx, item in enumerate(storage_items):
                    item_frame = customtkinter.CTkFrame(items_scroll)
                    item_frame.pack(fill = "x", pady = 2, padx = 5)

                    var = customtkinter.BooleanVar(value = False)

                    def on_check(index = idx, var_ref = var):
                        if var_ref.get():
                            if index not in selected_items:
                                selected_items.append(index)
                        else:
                            if index in selected_items:
                                selected_items.remove(index)

                    checkbox = customtkinter.CTkCheckBox(
                    item_frame,
                    text = f"{item.get('name', 'Unknown')} x{item.get('quantity', 1)}",
                    variable = var,
                    command = on_check
                    )
                    checkbox.pack(side = "left", padx = 10, pady = 5)
            except Exception as e:
                logging.error(f"Failed to load items: {e}")

        refresh_export_items()

        def create_export():
            try:
                save_path = os.path.join(saves_folder or "", (currentsave or "")+".sldsv")
                save_data = self._load_file((currentsave or "")+".sldsv")
                if save_data is None:
                    raise RuntimeError("Failed to load current save for export")

                money_amount = int(money_entry.get()or 0)

                if money_amount >save_data.get("money", 0):
                    self._popup_show_info("Error", "Not enough money!", sound = "error")
                    return

                storage_items = save_data.get("storage", [])
                items_to_export =[storage_items[i]for i in sorted(selected_items)if i <len(storage_items)]

                transfer_data = {
                "money":money_amount,
                "items":items_to_export,
                "timestamp":datetime.now().isoformat(),
                "from_character":save_data.get("charactername", "Unknown")
                }

                save_data["money"]= save_data.get("money", 0)-money_amount

                for idx in sorted(selected_items, reverse = True):
                    if idx <len(storage_items):
                        storage_items.pop(idx)

                save_data["storage"]= storage_items

                self._save_file(save_data)

                pickled_data = pickle.dumps(transfer_data)
                encoded_data = base64.b85encode(pickled_data).decode('utf-8')

                transfer_filename = f"transfers/transfer_{datetime.now().strftime('%Y%m%d_%H%M%S')}.sldtrf"
                with open(transfer_filename, 'w')as f:
                    f.write(encoded_data)

                self._popup_show_info("Success", f"Exported {len(items_to_export)} items and ${money_amount}!", sound = "success")
                logging.info(f"Created transfer file: {transfer_filename}")
                refresh_export_items()
            except Exception as e:
                logging.error(f"Export failed: {e}")
                self._popup_show_info("Error", f"Export failed: {e}", sound = "error")

        export_button = self._create_sound_button(export_frame, "Create Transfer File", create_export, width = 200, height = 40)
        export_button.pack(pady = 10)

        import_frame = customtkinter.CTkFrame(main_frame)
        import_frame.pack(fill = "x", pady = 10, padx = 10)

        import_label = customtkinter.CTkLabel(import_frame, text = "Import Transfer File", font = customtkinter.CTkFont(size = 16, weight = "bold"))
        import_label.pack(pady = 10)

        def list_transfers():
            try:
                transfer_files = glob.glob("transfers/*.sldtrf")
                if not transfer_files:
                    self._popup_show_info("Info", "No transfer files found.", sound = "popup")
                    return

                select_window = customtkinter.CTkToplevel(self.root)
                select_window.title("Select Transfer File")
                select_window.transient(self.root)
                self._center_popup_on_window(select_window, 500, 400)

                scroll_frame = customtkinter.CTkScrollableFrame(select_window, width = 450, height = 300)
                scroll_frame.pack(pady = 10, padx = 10, fill = "both", expand = True)

                def import_transfer(filepath):
                    try:
                        with open(filepath, 'r')as f:
                            encoded_data = f.read()

                        pickled_data = base64.b85decode(encoded_data.encode('utf-8'))
                        transfer_data = pickle.loads(pickled_data)

                        save_data = self._load_file((currentsave or "")+".sldsv")
                        if save_data is None:
                            raise RuntimeError("Failed to load current save for import")
                        save_data["money"]= save_data.get("money", 0)+transfer_data.get("money", 0)
                        for item in transfer_data.get("items", []):
                            save_data["storage"].append(item)
                        self._save_file(save_data)

                        os.remove(filepath)

                        select_window.destroy()
                        self._popup_show_info("Success", f"Received ${transfer_data.get('money', 0)} and {len(transfer_data.get('items', []))} items!", sound = "success")
                    except Exception as e:
                        logging.error(f"Import failed: {e}")
                        self._popup_show_info("Error", f"Import failed: {e}", sound = "error")

                for i, filepath in enumerate(transfer_files):
                    try:
                        with open(filepath, 'r')as f:
                            encoded_data = f.read()
                        pickled_data = base64.b85decode(encoded_data.encode('utf-8'))
                        transfer_data = pickle.loads(pickled_data)

                        file_frame = customtkinter.CTkFrame(scroll_frame)
                        file_frame.pack(fill = "x", pady = 5, padx = 5)

                        info_label = customtkinter.CTkLabel(
                        file_frame,
                        text = f"From: {transfer_data.get('from_character', 'Unknown')}\nMoney: ${transfer_data.get('money', 0)} | Items: {len(transfer_data.get('items', []))}",
                        anchor = "w"
                        )
                        info_label.pack(side = "left", padx = 10, pady = 5)

                        import_btn = self._create_sound_button(
                        file_frame,
                        "Import",
                        lambda f = filepath:import_transfer(f),
                        width = 100,
                        height = 35
                        )
                        import_btn.pack(side = "right", padx = 10, pady = 5)
                    except Exception as e:
                        logging.warning(f"Failed to read transfer file {filepath}: {e}")

                select_window.update_idletasks()
                select_window.deiconify()
                select_window.grab_set()
            except Exception as e:
                logging.error(f"Failed to list transfers: {e}")
                self._popup_show_info("Error", f"Failed to list transfers: {e}", sound = "error")

        import_button = self._create_sound_button(import_frame, "Browse Transfer Files", list_transfers, width = 200, height = 40)
        import_button.pack(pady = 10)

        back_button = self._create_sound_button(main_frame, "Back", lambda:[self._clear_window(), self._open_inventory_management()], width = 200, height = 40)
        back_button.pack(pady = 20)

    def _manage_containers(self):
        logging.info("Container Management definition called")

        if currentsave is None:
            self._popup_show_info("Error", "No character loaded.", sound = "error")
            return

        self._clear_window()

        save_filename =(currentsave or "")+".sldsv"
        save_data = self._load_file(save_filename)

        if save_data is None:
            logging.error(f"Failed to load save file {save_filename}")
            self._popup_show_info("Error", f"Failed to load character data", sound = "error")
            return

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew", padx = 20, pady = 20)
        main_frame.grid_rowconfigure(1, weight = 1)
        main_frame.grid_columnconfigure(0, weight = 1)

        title = customtkinter.CTkLabel(main_frame, text = "Manage Containers & Transfer Items", font = customtkinter.CTkFont(size = 20, weight = "bold"))
        title.grid(row = 0, column = 0, pady =(0, 10))

        tabview = customtkinter.CTkTabview(main_frame, width = 1000, height = 600)
        tabview.grid(row = 1, column = 0, sticky = "nsew", pady = 10)

        tabview.add("View Inventory")
        tabview.add("Transfer Items")

        view_tab = tabview.tab("View Inventory")
        view_tab.grid_rowconfigure(1, weight = 1)
        view_tab.grid_columnconfigure(0, weight = 1)

        enc_info_frame = customtkinter.CTkFrame(view_tab, fg_color =("gray90", "gray20"))
        enc_info_frame.grid(row = 0, column = 0, sticky = "ew", padx = 10, pady = 10)
        enc_info_frame.grid_columnconfigure(0, weight = 1)

        enc_info_label = customtkinter.CTkLabel(enc_info_frame, font = customtkinter.CTkFont(size = 12), anchor = "w")
        enc_info_label.grid(row = 0, column = 0, sticky = "ew", padx = 15, pady = 10)

        def refresh_enc_info():
            encumbrance_info = self._calculate_encumbrance_status(save_data)
            enc_info_label.configure(
            text =(
            f"Total Weight: {self._format_weight(encumbrance_info['total_weight'])} | "
            f"Encumbrance: {self._format_weight(encumbrance_info['encumbrance'])} / {self._format_weight(encumbrance_info['threshold'])} | "
            f"Encumbrance level: {encumbrance_info['encumbrance_level']} | "
            f"Status: {'ENCUMBERED'if encumbrance_info['is_encumbered']else 'OK'}"
            )
            )

        tabview.configure(command = lambda value = None:refresh_enc_info())

        def get_containers():
            containers =[]
            equipment = save_data.get("equipment", {})

            def _slot_blocked_by_subslots(slot_name):
                try:
                    slot_name_l = str(slot_name).lower()if slot_name is not None else ''
                    for other_slot, other_item in equipment.items():
                        if not other_item:
                            continue
                        items_to_check =[]
                        if isinstance(other_item, dict):
                            items_to_check =[other_item]
                        elif isinstance(other_item, list):
                            items_to_check =[it for it in other_item if isinstance(it, dict)]

                        for oi in items_to_check:

                            for subslot_data in oi.get('subslots', [])or[]:
                                try:
                                    conflicts = subslot_data.get('conflicts_with')

                                    if isinstance(conflicts, dict):
                                        if conflicts.get('type')=='main'and str(conflicts.get('slot')).lower()==slot_name_l:
                                            return True
                                    elif isinstance(conflicts, (list, tuple)):
                                        for conflict_slot in conflicts:
                                            if str(conflict_slot).lower()==slot_name_l:
                                                return True
                                except Exception:
                                    pass

                            for acc in oi.get('accessories', [])or[]:
                                try:
                                    curacc = acc.get('current')
                                    if not isinstance(curacc, dict):
                                        continue
                                    for subslot_data in curacc.get('subslots', [])or[]:
                                        try:
                                            conflicts = subslot_data.get('conflicts_with')
                                            cur = subslot_data.get('current')
                                            if not cur:
                                                continue
                                            if isinstance(conflicts, dict):
                                                if conflicts.get('type')=='main'and str(conflicts.get('slot')).lower()==slot_name_l:
                                                    return True
                                            elif isinstance(conflicts, (list, tuple)):
                                                for conflict_slot in conflicts:
                                                    if str(conflict_slot).lower()==slot_name_l:
                                                        return True
                                        except Exception:
                                            pass
                                except Exception:
                                    pass
                    return False
                except Exception:
                    return False

            def _get_conflict_sources(slot_name):
                sources =[]
                try:
                    slot_name_l = str(slot_name).lower()if slot_name is not None else ''
                    for other_slot, other_item in equipment.items():
                        if not other_item:
                            continue
                        items_to_check =[]
                        if isinstance(other_item, dict):
                            items_to_check =[other_item]
                        elif isinstance(other_item, list):
                            items_to_check =[it for it in other_item if isinstance(it, dict)]

                        for oi in items_to_check:
                            for subslot_data in oi.get('subslots', [])or[]:
                                try:
                                    conflicts = subslot_data.get('conflicts_with')
                                    cur = subslot_data.get('current')
                                    if not cur:
                                        continue

                                    targets =[]
                                    if isinstance(conflicts, dict):
                                        if conflicts.get('type')=='main'and conflicts.get('slot'):
                                            targets =[conflicts.get('slot')]
                                    elif isinstance(conflicts, (list, tuple)):
                                        targets =[str(c)for c in conflicts]
                                    elif conflicts:
                                        targets =[str(conflicts)]

                                    targets_l =[str(t).lower()for t in targets]
                                    if slot_name_l in targets_l:
                                        subname = subslot_data.get('name')or subslot_data.get('slot')or 'subslot'
                                        sources.append(f"{other_slot}.{subname}")
                                except Exception:
                                    pass

                            for acc in oi.get('accessories', [])or[]:
                                try:
                                    curacc = acc.get('current')
                                    if not isinstance(curacc, dict):
                                        continue
                                    for subslot_data in curacc.get('subslots', [])or[]:
                                        try:
                                            conflicts = subslot_data.get('conflicts_with')

                                            targets =[]
                                            if isinstance(conflicts, dict):
                                                if conflicts.get('type')=='main'and conflicts.get('slot'):
                                                    targets =[conflicts.get('slot')]
                                            elif isinstance(conflicts, (list, tuple)):
                                                targets =[str(c)for c in conflicts]
                                            elif conflicts:
                                                targets =[str(conflicts)]

                                            targets_l =[str(t).lower()for t in targets]
                                            if slot_name_l in targets_l:
                                                subname = subslot_data.get('name')or subslot_data.get('slot')or 'subslot'
                                                sources.append(f"{other_slot}.{subname}")
                                        except Exception:
                                            pass
                                except Exception:
                                    pass
                except Exception:
                    pass

                seen = set()
                out =[]
                for s in sources:
                    if s not in seen:
                        seen.add(s)
                        out.append(s)
                return out

            def _get_conflicting_item_names(slot_name):
                names =[]
                try:
                    slot_name_l = str(slot_name).lower()if slot_name is not None else ''
                    for other_slot, other_item in equipment.items():
                        if not other_item:
                            continue
                        items_to_check =[]
                        if isinstance(other_item, dict):
                            items_to_check =[other_item]
                        elif isinstance(other_item, list):
                            items_to_check =[it for it in other_item if isinstance(it, dict)]

                        for oi in items_to_check:
                            for subslot_data in oi.get('subslots', [])or[]:
                                try:
                                    conflicts = subslot_data.get('conflicts_with')

                                    targets =[]
                                    if isinstance(conflicts, dict):
                                        if conflicts.get('type')=='main'and conflicts.get('slot'):
                                            targets =[conflicts.get('slot')]
                                    elif isinstance(conflicts, (list, tuple)):
                                        targets =[str(c)for c in conflicts]
                                    elif conflicts:
                                        targets =[str(conflicts)]
                                    targets_l =[t.lower()for t in targets]
                                    if slot_name_l in targets_l:

                                        nm = None
                                        try:
                                            if isinstance(oi, dict):
                                                nm = oi.get('name')or oi.get('id')
                                        except Exception:
                                            nm = None
                                        if not nm:
                                            cur = subslot_data.get('current')
                                            if isinstance(cur, dict):
                                                nm = cur.get('name')or cur.get('id')
                                        if not nm:
                                            nm = other_slot
                                        if nm:
                                            names.append(str(nm))
                                except Exception:
                                    pass

                            for acc in oi.get('accessories', [])or[]:
                                try:

                                    curacc = acc.get('current')if isinstance(acc, dict)else None
                                    acc_subslots =[]
                                    if isinstance(curacc, dict):
                                        acc_subslots.extend(curacc.get('subslots', [])or[])
                                    if isinstance(acc, dict):
                                        acc_subslots.extend(acc.get('subslots', [])or[])

                                    for subslot_data in acc_subslots:
                                        try:
                                            conflicts = subslot_data.get('conflicts_with')
                                            targets =[]
                                            if isinstance(conflicts, dict):
                                                if conflicts.get('type')=='main'and conflicts.get('slot'):
                                                    targets =[conflicts.get('slot')]
                                            elif isinstance(conflicts, (list, tuple)):
                                                targets =[str(c)for c in conflicts]
                                            elif conflicts:
                                                targets =[str(conflicts)]
                                            targets_l =[t.lower()for t in targets]
                                            if slot_name_l in targets_l:

                                                nm = None
                                                try:
                                                    if isinstance(curacc, dict):
                                                        nm = curacc.get('name')or curacc.get('id')
                                                except Exception:
                                                    nm = None
                                                if not nm:
                                                    try:
                                                        if isinstance(acc, dict):
                                                            nm = acc.get('name')or acc.get('id')
                                                    except Exception:
                                                        nm = None
                                                if not nm:
                                                    try:
                                                        if isinstance(oi, dict):
                                                            nm = oi.get('name')or oi.get('id')
                                                    except Exception:
                                                        nm = None
                                                if not nm:
                                                    nm = other_slot
                                                if nm:
                                                    names.append(str(nm))
                                        except Exception:
                                            pass
                                except Exception:
                                    pass
                except Exception:
                    pass

                seen = set();out =[]
                for n in names:
                    if n not in seen:
                        seen.add(n);out.append(n)
                return out

            def _find_any_item_with_conflict(slot_name):

                try:
                    slot_name_l = str(slot_name).lower()if slot_name is not None else ''
                    def check_item(it):
                        if not isinstance(it, dict):
                            return None

                        for ss in it.get('subslots', [])or[]:
                            try:
                                conflicts = ss.get('conflicts_with')
                                targets =[]
                                if isinstance(conflicts, dict):
                                    if conflicts.get('type')=='main'and conflicts.get('slot'):
                                        targets =[conflicts.get('slot')]
                                elif isinstance(conflicts, (list, tuple)):
                                    targets =[str(c)for c in conflicts]
                                elif conflicts:
                                    targets =[str(conflicts)]
                                if any(slot_name_l ==t.lower()for t in targets):
                                    return it.get('name')or it.get('id')
                            except Exception:
                                pass

                        for acc in it.get('accessories', [])or[]:
                            try:

                                for src in(acc, acc.get('current')):
                                    if not isinstance(src, dict):
                                        continue
                                    for ss in src.get('subslots', [])or[]:
                                        try:
                                            conflicts = ss.get('conflicts_with')
                                            targets =[]
                                            if isinstance(conflicts, dict):
                                                if conflicts.get('type')=='main'and conflicts.get('slot'):
                                                    targets =[conflicts.get('slot')]
                                            elif isinstance(conflicts, (list, tuple)):
                                                targets =[str(c)for c in conflicts]
                                            elif conflicts:
                                                targets =[str(conflicts)]
                                            if any(slot_name_l ==t.lower()for t in targets):

                                                return(src.get('name')or src.get('id')or it.get('name')or it.get('id'))
                                        except Exception:
                                            pass
                            except Exception:
                                pass
                        return None

                    for s, it in equipment.items():
                        if isinstance(it, dict):
                            nm = check_item(it)
                            if nm:
                                return str(nm)
                        elif isinstance(it, list):
                            for sub in it:
                                nm = check_item(sub)
                                if nm:
                                    return str(nm)

                    for it in save_data.get('storage', [])or[]:
                        nm = check_item(it)
                        if nm:
                            return str(nm)

                    for it in(save_data.get('hands')or {}).get('items', [])or[]:
                        nm = check_item(it)
                        if nm:
                            return str(nm)

                except Exception:
                    pass
                return None

            containers.append({"name":"Hands", "location":"hands"})
            containers.append({"name":"Storage", "location":"storage"})

            for slot, item in equipment.items():

                if item and isinstance(item, dict):
                    if "capacity"in item and "items"in item:
                        containers.append({
                        "name":f"{item.get('name', 'Container')}({slot})",
                        "location":f"equipment.{slot}"
                        })

                    if "subslots"in item:
                        for subslot_idx, subslot_data in enumerate(item["subslots"]):
                            subslot_item = subslot_data.get("current")
                            if subslot_item and isinstance(subslot_item, dict):
                                if "capacity"in subslot_item and "items"in subslot_item:
                                    subslot_name = subslot_data.get("name", f"Subslot {subslot_idx}")
                                    containers.append({
                                    "name":f"{subslot_item.get('name', 'Container')}({slot} â†’ {subslot_name})",
                                    "location":f"equipment.{slot}.subslot.{subslot_idx}"
                                    })

                elif isinstance(item, list):
                    for idx, subitem in enumerate(item):
                        try:
                            if subitem and isinstance(subitem, dict)and "capacity"in subitem and "items"in subitem:
                                containers.append({
                                "name":f"{subitem.get('name', 'Container')}({slot}#{idx})",
                                "location":f"equipment.{slot}.list.{idx}"
                                })

                            if subitem and isinstance(subitem, dict)and "subslots"in subitem:
                                for subslot_idx, subslot_data in enumerate(subitem.get("subslots", [])):
                                    subslot_item = subslot_data.get("current")
                                    if subslot_item and isinstance(subslot_item, dict):
                                        if "capacity"in subslot_item and "items"in subslot_item:
                                            subslot_name = subslot_data.get("name", f"Subslot {subslot_idx}")
                                            containers.append({
                                            "name":f"{subslot_item.get('name', 'Container')}({slot}#{idx} â†’ {subslot_name})",
                                            "location":f"equipment.{slot}.list.{idx}.subslot.{subslot_idx}"
                                            })
                        except Exception:
                            pass

            return containers

        containers = get_containers()

        def get_container_items(location):

            if location =="storage":
                return save_data.get("storage", [])
            elif location =="hands":
                return save_data["hands"].get("items", [])
            elif location.startswith("equipment."):
                parts = location.split(".")
                slot = parts[1]
                item = save_data["equipment"].get(slot)
                if item is None:
                    return[]

                if len(parts)>2 and parts[2]=="subslot":
                    subslot_idx = int(parts[3])
                    if isinstance(item, dict)and "subslots"in item and subslot_idx <len(item["subslots"]):
                        subslot_item = item["subslots"][subslot_idx].get("current")
                        if subslot_item and isinstance(subslot_item, dict):
                            return subslot_item.get("items", [])

                if len(parts)>2 and parts[2]=="list":
                    list_idx = int(parts[3])
                    if isinstance(item, list)and 0 <=list_idx <len(item):
                        subitem = item[list_idx]
                        if len(parts)>4 and parts[4]=="subslot":
                            subslot_idx = int(parts[5])
                            if "subslots"in subitem and subslot_idx <len(subitem["subslots"]):
                                subslot_item = subitem["subslots"][subslot_idx].get("current")
                                if subslot_item and isinstance(subslot_item, dict):
                                    return subslot_item.get("items", [])
                        return subitem.get("items", [])if isinstance(subitem, dict)else[]

                if isinstance(item, dict):
                    return item.get("items", [])
            return[]

        def set_container_items(location, items):

            if location =="storage":
                save_data["storage"]= items
            elif location =="hands":
                save_data["hands"]["items"]= items
            elif location.startswith("equipment."):
                parts = location.split(".")
                slot = parts[1]
                if slot in save_data["equipment"]and save_data["equipment"][slot]:
                    item = save_data["equipment"][slot]

                    if len(parts)>2 and parts[2]=="subslot":
                        subslot_idx = int(parts[3])
                        if isinstance(item, dict)and "subslots"in item and subslot_idx <len(item["subslots"]):
                            subslot_item = item["subslots"][subslot_idx].get("current")
                            if subslot_item and isinstance(subslot_item, dict):
                                subslot_item["items"]= items

                    elif len(parts)>2 and parts[2]=="list":
                        list_idx = int(parts[3])
                        if isinstance(item, list)and 0 <=list_idx <len(item):
                            subitem = item[list_idx]
                            if len(parts)>4 and parts[4]=="subslot":
                                subslot_idx = int(parts[5])
                                if "subslots"in subitem and subslot_idx <len(subitem["subslots"]):
                                    subslot_item = subitem["subslots"][subslot_idx].get("current")
                                    if subslot_item and isinstance(subslot_item, dict):
                                        subslot_item["items"]= items
                            else:
                                if isinstance(subitem, dict):
                                    subitem["items"]= items
                    else:
                        if isinstance(item, dict):
                            item["items"]= items

        def get_container_weight(location):

            items = get_container_items(location)
            return sum(i.get("weight", 0)*i.get("quantity", 1)for i in items if isinstance(i, dict))

        def get_container_capacity(location):

            if location =="hands":
                base_capacity = save_data.get("hands", {}).get("capacity", 50)
                strength = save_data.get("stats", {}).get("Strength", 0)

                return base_capacity *(1 +strength *0.1)
            if location.startswith("equipment."):
                parts = location.split(".")
                slot = parts[1]
                equip = save_data.get("equipment", {}).get(slot)
                if equip:

                    if len(parts)>2 and parts[2]=="subslot":
                        subslot_idx = int(parts[3])
                        if isinstance(equip, dict)and "subslots"in equip and subslot_idx <len(equip["subslots"]):
                            subslot_item = equip["subslots"][subslot_idx].get("current")
                            if subslot_item and isinstance(subslot_item, dict):
                                return subslot_item.get("capacity")
                            return None

                    if len(parts)>2 and parts[2]=="list":
                        list_idx = int(parts[3])
                        if isinstance(equip, list)and 0 <=list_idx <len(equip):
                            subitem = equip[list_idx]
                            if len(parts)>4 and parts[4]=="subslot":
                                subslot_idx = int(parts[5])
                                if "subslots"in subitem and subslot_idx <len(subitem["subslots"]):
                                    subslot_item = subitem["subslots"][subslot_idx].get("current")
                                    if subslot_item and isinstance(subslot_item, dict):
                                        return subslot_item.get("capacity")
                                return None
                            return subitem.get("capacity")if isinstance(subitem, dict)else None
                    return equip.get("capacity")if isinstance(equip, dict)else None

            return None

        def rebuild_container_labels():

            labels =[]
            for c in containers:

                total_weight = get_container_weight(c["location"])

                try:
                    capacity = get_container_capacity(c.get("location"))
                except Exception:
                    capacity = None
                capacity_text = self._format_weight(capacity)if capacity is not None else "âˆž"
                c["label"]= f"{c['name']}({self._format_weight(total_weight)}/{capacity_text})"
                labels.append(c["label"])
            return labels

        labels = rebuild_container_labels()

        refresh_enc_info()

        view_tab = tabview.tab("View Inventory")
        view_tab.grid_rowconfigure(2, weight = 1)
        view_tab.grid_columnconfigure(0, weight = 1)

        view_frame = customtkinter.CTkFrame(view_tab)
        view_frame.grid(row = 0, column = 0, rowspan = 3, sticky = "nsew", padx = 10, pady = 10)
        view_frame.grid_rowconfigure(2, weight = 1)
        view_frame.grid_columnconfigure(0, weight = 1)

        top_view_frame = customtkinter.CTkFrame(view_frame, fg_color = "transparent")
        top_view_frame.grid(row = 0, column = 0, sticky = "ew", pady =(0, 10))
        top_view_frame.grid_columnconfigure(2, weight = 1)

        container_selector = customtkinter.CTkOptionMenu(
        top_view_frame,
        values = labels,
        width = 300,
        font = customtkinter.CTkFont(size = 14)
        )
        container_selector.grid(row = 0, column = 0, padx =(0, 20))
        container_selector.set(labels[0]if labels else "")

        view_search_label = customtkinter.CTkLabel(top_view_frame, text = "Search:", font = customtkinter.CTkFont(size = 12))
        view_search_label.grid(row = 0, column = 1, padx =(0, 5))

        view_search_entry = customtkinter.CTkEntry(top_view_frame, placeholder_text = "Filter items...", width = 200)
        view_search_entry.grid(row = 0, column = 2, sticky = "w")

        view_info_label = customtkinter.CTkLabel(top_view_frame, text = "", font = customtkinter.CTkFont(size = 11), text_color = "gray")
        view_info_label.grid(row = 0, column = 3, padx = 10)

        view_scroll = customtkinter.CTkScrollableFrame(view_frame, width = 900, height = 380)
        view_scroll.grid(row = 2, column = 0, sticky = "nsew", padx = 10, pady = 10)

        view_pagination_frame = customtkinter.CTkFrame(view_frame, fg_color = "transparent")
        view_pagination_frame.grid(row = 3, column = 0, pady = 5)

        ITEMS_PER_PAGE_VIEW = 20
        view_current_page =[0]
        view_current_filtered =[[]]
        view_search_timer =[None]
        view_all_items =[[]]

        def refresh_view():
            current_label = container_selector.get()
            new_labels = rebuild_container_labels()
            container_selector.configure(values = new_labels)
            if current_label in new_labels:
                container_selector.set(current_label)
            elif new_labels:
                container_selector.set(new_labels[0])
            refresh_enc_info()

            selected_label = container_selector.get()
            selected_container = next((c for c in containers if c.get("label")==selected_label), None)

            if not selected_container:
                view_all_items[0]=[]
                view_current_filtered[0]=[]
                view_current_page[0]= 0
                display_view_page(0)
                return

            location = selected_container["location"]
            items = get_container_items(location)
            view_all_items[0]= items if items else[]
            view_search_entry.delete(0, "end")
            view_current_filtered[0]= view_all_items[0]
            view_current_page[0]= 0
            display_view_page(0)

        def show_item_details(item_data):
            detail_window = customtkinter.CTkToplevel(self.root)
            detail_window.title("Item Details")
            detail_window.transient(self.root)
            self._center_popup_on_window(detail_window, 500, 600)

            scroll = customtkinter.CTkScrollableFrame(detail_window, width = 450, height = 550)
            scroll.pack(pady = 10, padx = 10, fill = "both", expand = True)

            title = customtkinter.CTkLabel(scroll, text = item_data.get("name", "Unknown"), font = customtkinter.CTkFont(size = 18, weight = "bold"))
            title.pack(pady =(10, 20))

            for key, value in item_data.items():
                if key =="name":
                    continue

                prop_frame = customtkinter.CTkFrame(scroll, fg_color = "transparent")
                prop_frame.pack(fill = "x", pady = 2, padx = 10)

                key_label = customtkinter.CTkLabel(
                prop_frame,
                text = f"{key.replace('_', ' ').title()}:",
                font = customtkinter.CTkFont(size = 12, weight = "bold"),
                anchor = "w",
                width = 150
                )
                key_label.pack(side = "left", padx = 5)

                if isinstance(value, (list, dict)):
                    value_text = json.dumps(value, indent = 2)
                else:
                    value_text = str(value)

                value_label = customtkinter.CTkLabel(
                prop_frame,
                text = value_text,
                font = customtkinter.CTkFont(size = 11),
                anchor = "w",
                wraplength = 250
                )
                value_label.pack(side = "left", padx = 5, fill = "x", expand = True)

            close_button = self._create_sound_button(scroll, "Close", detail_window.destroy, width = 120, height = 35)
            close_button.pack(pady = 20)

            detail_window.update_idletasks()
            detail_window.deiconify()
            detail_window.grab_set()

        def create_item_view_widget(item):
            selected_label = container_selector.get()
            selected_container = next((c for c in containers if c.get("label")==selected_label), None)
            location = selected_container["location"]if selected_container else ""

            item_frame = customtkinter.CTkFrame(view_scroll)
            item_frame.pack(fill = "x", pady = 5, padx = 10)
            item_frame.grid_columnconfigure(0, weight = 1)

            item_name = item.get("name", "Unknown")
            item_qty = item.get("quantity", 1)
            item_weight = item.get("weight", 0)*item_qty
            item_value = item.get("value", 0)

            display_text = f"{item_name} x{item_qty}"
            if item.get("consumable"):
                if item.get("uses_left"):
                    display_text +=f"({item.get('uses_left')} uses left)"
                elif item.get("used_up"):
                    display_text +="(1 use left)"
                else:
                    display_text +="(âˆž uses)"

            name_label = customtkinter.CTkLabel(
            item_frame,
            text = display_text,
            font = customtkinter.CTkFont(size = 14, weight = "bold"),
            anchor = "w"
            )
            name_label.grid(row = 0, column = 0, sticky = "w", padx = 15, pady =(10, 2))

            item_info_label = customtkinter.CTkLabel(
            item_frame,
            text = f"Weight: {self._format_weight(item_weight)} | Value: ${item_value}",
            font = customtkinter.CTkFont(size = 11),
            text_color = "gray",
            anchor = "w"
            )
            item_info_label.grid(row = 1, column = 0, sticky = "w", padx = 15, pady =(0, 10))

            button_col = 1
            details_button = self._create_sound_button(
            item_frame,
            "View Details",
            lambda it = item:show_item_details(it),
            width = 120,
            height = 35,
            font = customtkinter.CTkFont(size = 12)
            )
            details_button.grid(row = 0, column = button_col, rowspan = 2, padx = 15, pady = 10)

            if item.get("consumable"):
                button_col +=1
                consume_button = self._create_sound_button(
                item_frame,
                "Consume",
                lambda it = item, loc = location:self._consume_item(it, loc, save_data, on_complete = refresh_view),
                width = 100,
                height = 35,
                font = customtkinter.CTkFont(size = 12)
                )
                consume_button.grid(row = 0, column = button_col, rowspan = 2, padx =(0, 15), pady = 10)

            if item.get("stratagem"):
                button_col +=1
                stratagem_button = self._create_sound_button(
                item_frame,
                "Use Stratagem",
                lambda it = item, loc = location:self._use_stratagem(it, loc, save_data, on_complete = refresh_view),
                width = 120,
                height = 35,
                font = customtkinter.CTkFont(size = 12)
                )
                stratagem_button.grid(row = 0, column = button_col, rowspan = 2, padx =(0, 15), pady = 10)

        def display_view_page(page_num):
            items = view_current_filtered[0]
            total_pages = max(1, (len(items)+ITEMS_PER_PAGE_VIEW -1)//ITEMS_PER_PAGE_VIEW)
            page_num = max(0, min(page_num, total_pages -1))
            view_current_page[0]= page_num

            for widget in view_scroll.winfo_children():
                widget.destroy()

            if not items:
                empty_label = customtkinter.CTkLabel(view_scroll, text = "Container is empty", font = customtkinter.CTkFont(size = 14), text_color = "gray")
                empty_label.pack(pady = 30)
                view_info_label.configure(text = "No items")
                update_view_pagination(0, 0)
                return

            start_idx = page_num *ITEMS_PER_PAGE_VIEW
            end_idx = min(start_idx +ITEMS_PER_PAGE_VIEW, len(items))

            for i in range(start_idx, end_idx):
                create_item_view_widget(items[i])

            view_info_label.configure(text = f"Page {page_num +1}/{total_pages} | {len(items)} items")
            update_view_pagination(page_num, total_pages)

            try:
                view_scroll._parent_canvas.yview_moveto(0)
            except Exception:
                pass

        def update_view_pagination(current, total):
            for widget in view_pagination_frame.winfo_children():
                widget.destroy()

            if total <=1:
                return

            first_btn = customtkinter.CTkButton(view_pagination_frame, text = "<<", width = 40, height = 30, command = lambda:display_view_page(0), state = "normal"if current >0 else "disabled")
            first_btn.pack(side = "left", padx = 2)

            prev_btn = customtkinter.CTkButton(view_pagination_frame, text = "<", width = 40, height = 30, command = lambda:display_view_page(current -1), state = "normal"if current >0 else "disabled")
            prev_btn.pack(side = "left", padx = 2)

            start_page = max(0, current -3)
            end_page = min(total, start_page +7)
            if end_page -start_page <7:
                start_page = max(0, end_page -7)

            for p in range(start_page, end_page):
                btn = customtkinter.CTkButton(view_pagination_frame, text = str(p +1), width = 35, height = 30, fg_color =("gray75", "gray25")if p ==current else None, command = lambda page = p:display_view_page(page))
                btn.pack(side = "left", padx = 1)

            next_btn = customtkinter.CTkButton(view_pagination_frame, text = ">", width = 40, height = 30, command = lambda:display_view_page(current +1), state = "normal"if current <total -1 else "disabled")
            next_btn.pack(side = "left", padx = 2)

            last_btn = customtkinter.CTkButton(view_pagination_frame, text = ">>", width = 40, height = 30, command = lambda:display_view_page(total -1), state = "normal"if current <total -1 else "disabled")
            last_btn.pack(side = "left", padx = 2)

        def filter_view_items(search_term):
            search_lower = search_term.lower().strip()

            if search_lower:
                filtered =[
                item for item in view_all_items[0]
                if search_lower in item.get("name", "").lower()
                ]
            else:
                filtered = view_all_items[0]

            view_current_filtered[0]= filtered
            view_current_page[0]= 0
            display_view_page(0)

        def on_view_search_change(*args):
            if view_search_timer[0]is not None:
                try:
                    self.root.after_cancel(view_search_timer[0])
                except Exception:
                    pass
            view_search_timer[0]= self.root.after(200, lambda:filter_view_items(view_search_entry.get()))# type: ignore

        view_search_entry.bind("<KeyRelease>", on_view_search_change)
        container_selector.configure(command = lambda _:refresh_view())
        refresh_view()

        transfer_tab = tabview.tab("Transfer Items")
        transfer_tab.grid_rowconfigure(1, weight = 1)
        transfer_tab.grid_columnconfigure((0, 1), weight = 1)

        info_label = customtkinter.CTkLabel(transfer_tab, text = "Select source and destination containers to move items:", font = customtkinter.CTkFont(size = 13))
        info_label.grid(row = 0, column = 0, columnspan = 2, pady = 10)

        container_frame = customtkinter.CTkFrame(transfer_tab)
        container_frame.grid(row = 1, column = 0, columnspan = 2, sticky = "nsew", pady = 10)
        container_frame.grid_rowconfigure(0, weight = 1)
        container_frame.grid_columnconfigure((0, 1), weight = 1)

        source_frame = customtkinter.CTkFrame(container_frame)
        source_frame.grid(row = 0, column = 0, sticky = "nsew", padx =(0, 10))
        source_frame.grid_rowconfigure(3, weight = 1)
        source_frame.grid_columnconfigure(0, weight = 1)

        source_label = customtkinter.CTkLabel(source_frame, text = "Source Container", font = customtkinter.CTkFont(size = 16, weight = "bold"))
        source_label.grid(row = 0, column = 0, pady = 10)

        source_selector = customtkinter.CTkOptionMenu(source_frame, values =[c["name"]for c in containers], width = 300)
        source_selector.grid(row = 1, column = 0, pady = 5)
        source_selector.set(containers[1]["name"]if len(containers)>1 else containers[0]["name"])

        source_search_frame = customtkinter.CTkFrame(source_frame, fg_color = "transparent")
        source_search_frame.grid(row = 2, column = 0, sticky = "ew", padx = 10, pady = 5)
        source_search_frame.grid_columnconfigure(1, weight = 1)

        customtkinter.CTkLabel(source_search_frame, text = "Search:", font = customtkinter.CTkFont(size = 11)).grid(row = 0, column = 0, padx =(0, 5))
        source_search_entry = customtkinter.CTkEntry(source_search_frame, placeholder_text = "Filter...", width = 150)
        source_search_entry.grid(row = 0, column = 1, sticky = "w")
        source_info_label = customtkinter.CTkLabel(source_search_frame, text = "", font = customtkinter.CTkFont(size = 10), text_color = "gray")
        source_info_label.grid(row = 0, column = 2, padx = 10)

        source_scroll = customtkinter.CTkScrollableFrame(source_frame, width = 350, height = 320)
        source_scroll.grid(row = 3, column = 0, sticky = "nsew", padx = 10, pady =(5, 5))

        source_pagination_frame = customtkinter.CTkFrame(source_frame, fg_color = "transparent")
        source_pagination_frame.grid(row = 4, column = 0, pady = 5)

        dest_frame = customtkinter.CTkFrame(container_frame)
        dest_frame.grid(row = 0, column = 1, sticky = "nsew", padx =(10, 0))
        dest_frame.grid_rowconfigure(3, weight = 1)
        dest_frame.grid_columnconfigure(0, weight = 1)

        dest_label = customtkinter.CTkLabel(dest_frame, text = "Destination Container", font = customtkinter.CTkFont(size = 16, weight = "bold"))
        dest_label.grid(row = 0, column = 0, pady = 10)

        dest_selector = customtkinter.CTkOptionMenu(dest_frame, values =[c["name"]for c in containers], width = 300)
        dest_selector.grid(row = 1, column = 0, pady = 5)
        dest_selector.set(containers[0]["name"])

        dest_search_frame = customtkinter.CTkFrame(dest_frame, fg_color = "transparent")
        dest_search_frame.grid(row = 2, column = 0, sticky = "ew", padx = 10, pady = 5)
        dest_search_frame.grid_columnconfigure(1, weight = 1)

        customtkinter.CTkLabel(dest_search_frame, text = "Search:", font = customtkinter.CTkFont(size = 11)).grid(row = 0, column = 0, padx =(0, 5))
        dest_search_entry = customtkinter.CTkEntry(dest_search_frame, placeholder_text = "Filter...", width = 150)
        dest_search_entry.grid(row = 0, column = 1, sticky = "w")
        dest_info_label = customtkinter.CTkLabel(dest_search_frame, text = "", font = customtkinter.CTkFont(size = 10), text_color = "gray")
        dest_info_label.grid(row = 0, column = 2, padx = 10)

        dest_scroll = customtkinter.CTkScrollableFrame(dest_frame, width = 350, height = 320)
        dest_scroll.grid(row = 3, column = 0, sticky = "nsew", padx = 10, pady =(5, 5))

        dest_pagination_frame = customtkinter.CTkFrame(dest_frame, fg_color = "transparent")
        dest_pagination_frame.grid(row = 4, column = 0, pady = 5)

        TRANSFER_ITEMS_PER_PAGE = 15
        source_page =[0]
        source_all_items =[[]]
        source_filtered =[[]]
        source_search_timer =[None]
        dest_page =[0]
        dest_all_items =[[]]
        dest_filtered =[[]]
        dest_search_timer =[None]
        source_location_ref =[""]
        dest_location_ref =[""]

        def update_source_pagination(current, total):
            for widget in source_pagination_frame.winfo_children():
                widget.destroy()
            if total <=1:
                return
            prev_btn = customtkinter.CTkButton(source_pagination_frame, text = "<", width = 30, height = 25, command = lambda:display_source_page(current -1), state = "normal"if current >0 else "disabled")
            prev_btn.pack(side = "left", padx = 2)
            for p in range(max(0, current -2), min(total, current +3)):
                btn = customtkinter.CTkButton(source_pagination_frame, text = str(p +1), width = 28, height = 25, fg_color =("gray75", "gray25")if p ==current else None, command = lambda page = p:display_source_page(page))
                btn.pack(side = "left", padx = 1)
            next_btn = customtkinter.CTkButton(source_pagination_frame, text = ">", width = 30, height = 25, command = lambda:display_source_page(current +1), state = "normal"if current <total -1 else "disabled")
            next_btn.pack(side = "left", padx = 2)

        def update_dest_pagination(current, total):
            for widget in dest_pagination_frame.winfo_children():
                widget.destroy()
            if total <=1:
                return
            prev_btn = customtkinter.CTkButton(dest_pagination_frame, text = "<", width = 30, height = 25, command = lambda:display_dest_page(current -1), state = "normal"if current >0 else "disabled")
            prev_btn.pack(side = "left", padx = 2)
            for p in range(max(0, current -2), min(total, current +3)):
                btn = customtkinter.CTkButton(dest_pagination_frame, text = str(p +1), width = 28, height = 25, fg_color =("gray75", "gray25")if p ==current else None, command = lambda page = p:display_dest_page(page))
                btn.pack(side = "left", padx = 1)
            next_btn = customtkinter.CTkButton(dest_pagination_frame, text = ">", width = 30, height = 25, command = lambda:display_dest_page(current +1), state = "normal"if current <total -1 else "disabled")
            next_btn.pack(side = "left", padx = 2)

        def display_source_page(page_num):
            items = source_filtered[0]
            total_pages = max(1, (len(items)+TRANSFER_ITEMS_PER_PAGE -1)//TRANSFER_ITEMS_PER_PAGE)
            page_num = max(0, min(page_num, total_pages -1))
            source_page[0]= page_num

            for widget in source_scroll.winfo_children():
                widget.destroy()

            if not items:
                empty_label = customtkinter.CTkLabel(source_scroll, text = "Container is empty", text_color = "gray")
                empty_label.pack(pady = 20)
                source_info_label.configure(text = "0 items")
                update_source_pagination(0, 0)
                return

            start_idx = page_num *TRANSFER_ITEMS_PER_PAGE
            end_idx = min(start_idx +TRANSFER_ITEMS_PER_PAGE, len(items))

            for i in range(start_idx, end_idx):
                item_data = items[i]
                original_idx = item_data["_original_idx"]
                item = item_data["item"]

                item_frame = customtkinter.CTkFrame(source_scroll)
                item_frame.pack(fill = "x", pady = 2)

                item_name = item.get("name", "Unknown")
                item_weight = item.get("weight", 0)*item.get("quantity", 1)

                item_label = customtkinter.CTkLabel(
                item_frame,
                text = f"{item_name} x{item.get('quantity', 1)}({self._format_weight(item_weight)})",
                anchor = "w"
                )
                item_label.pack(side = "left", padx = 10, pady = 5)

                move_button = self._create_sound_button(
                item_frame,
                "Move â†’",
                lambda idx = original_idx:move_item(idx, source_location_ref[0], dest_location_ref[0]),
                width = 80,
                height = 30
                )
                move_button.pack(side = "right", padx = 10, pady = 5)

            source_info_label.configure(text = f"Pg {page_num +1}/{total_pages}({len(items)})")
            update_source_pagination(page_num, total_pages)

        def display_dest_page(page_num):
            items = dest_filtered[0]
            total_pages = max(1, (len(items)+TRANSFER_ITEMS_PER_PAGE -1)//TRANSFER_ITEMS_PER_PAGE)
            page_num = max(0, min(page_num, total_pages -1))
            dest_page[0]= page_num

            for widget in dest_scroll.winfo_children():
                widget.destroy()

            if not items:
                empty_label = customtkinter.CTkLabel(dest_scroll, text = "Container is empty", text_color = "gray")
                empty_label.pack(pady = 20)
                dest_info_label.configure(text = "0 items")
                update_dest_pagination(0, 0)
                return

            start_idx = page_num *TRANSFER_ITEMS_PER_PAGE
            end_idx = min(start_idx +TRANSFER_ITEMS_PER_PAGE, len(items))

            for i in range(start_idx, end_idx):
                item_data = items[i]
                item = item_data["item"]

                item_frame = customtkinter.CTkFrame(dest_scroll)
                item_frame.pack(fill = "x", pady = 2)

                item_name = item.get("name", "Unknown")
                item_weight = item.get("weight", 0)*item.get("quantity", 1)

                item_label = customtkinter.CTkLabel(
                item_frame,
                text = f"{item_name} x{item.get('quantity', 1)}({self._format_weight(item_weight)})",
                anchor = "w"
                )
                item_label.pack(side = "left", padx = 10, pady = 5)

            dest_info_label.configure(text = f"Pg {page_num +1}/{total_pages}({len(items)})")
            update_dest_pagination(page_num, total_pages)

        def filter_source_items(search_term):
            search_lower = search_term.lower().strip()
            if search_lower:
                filtered =[item for item in source_all_items[0]if search_lower in item["item"].get("name", "").lower()]
            else:
                filtered = source_all_items[0]
            source_filtered[0]= filtered
            source_page[0]= 0
            display_source_page(0)

        def filter_dest_items(search_term):
            search_lower = search_term.lower().strip()
            if search_lower:
                filtered =[item for item in dest_all_items[0]if search_lower in item["item"].get("name", "").lower()]
            else:
                filtered = dest_all_items[0]
            dest_filtered[0]= filtered
            dest_page[0]= 0
            display_dest_page(0)

        def on_source_search_change(*args):
            if source_search_timer[0]is not None:
                try:
                    self.root.after_cancel(source_search_timer[0])
                except Exception:
                    pass
            source_search_timer[0]= self.root.after(200, lambda:filter_source_items(source_search_entry.get()))# type: ignore

        def on_dest_search_change(*args):
            if dest_search_timer[0]is not None:
                try:
                    self.root.after_cancel(dest_search_timer[0])
                except Exception:
                    pass
            dest_search_timer[0]= self.root.after(200, lambda:filter_dest_items(dest_search_entry.get()))# type: ignore

        source_search_entry.bind("<KeyRelease>", on_source_search_change)
        dest_search_entry.bind("<KeyRelease>", on_dest_search_change)

        def refresh_containers():
            source_name = source_selector.get()
            dest_name = dest_selector.get()

            if source_name ==dest_name:
                source_selector.set(dest_name)
                dest_selector.set(source_name)
                source_name = source_selector.get()
                dest_name = dest_selector.get()
                if source_name ==dest_name:
                    for c in containers:
                        if c["name"]!=source_name:
                            dest_selector.set(c["name"])
                            dest_name = c["name"]
                            break

            source_container = next((c for c in containers if c["name"]==source_name), None)
            dest_container = next((c for c in containers if c["name"]==dest_name), None)

            if not source_container or not dest_container:
                return

            source_location_ref[0]= source_container["location"]
            dest_location_ref[0]= dest_container["location"]
            source_items = get_container_items(source_location_ref[0])
            dest_items = get_container_items(dest_location_ref[0])

            source_all_items[0]=[{"item":item, "_original_idx":i}for i, item in enumerate(source_items)if isinstance(item, dict)]
            dest_all_items[0]=[{"item":item, "_original_idx":i}for i, item in enumerate(dest_items)if isinstance(item, dict)]

            source_search_entry.delete(0, "end")
            dest_search_entry.delete(0, "end")
            source_filtered[0]= source_all_items[0]
            dest_filtered[0]= dest_all_items[0]
            source_page[0]= 0
            dest_page[0]= 0
            display_source_page(0)
            display_dest_page(0)

        def move_item(item_idx, source_location, dest_location):
            try:
                source_items = get_container_items(source_location)
                dest_items = get_container_items(dest_location)

                if item_idx >=len(source_items):
                    return

                item = source_items[item_idx]

                if not isinstance(item, dict):
                    item = {"name":str(item), "weight":0, "quantity":1}
                item_weight = item.get("weight", 0)*item.get("quantity", 1)

                dest_capacity = get_container_capacity(dest_location)
                if dest_capacity is not None:
                    current_dest_weight = sum(i.get("weight", 0)*i.get("quantity", 1)for i in dest_items)
                    if current_dest_weight +item_weight >dest_capacity:
                        self._popup_show_info("Error", "Not enough capacity in destination!", sound = "error")
                        return

                source_items.pop(item_idx)
                item = add_subslots_to_item(item)
                dest_items.append(item)

                set_container_items(source_location, source_items)
                set_container_items(dest_location, dest_items)

                encumbrance_info = self._calculate_encumbrance_status(save_data)
                save_data["encumbrance"]= encumbrance_info["total_weight"]

                self._save_file(save_data)

                refresh_containers()
                refresh_enc_info()
                self._play_ui_sound("success")
            except Exception as e:
                logging.error(f"Move failed: {e}")
                self._popup_show_info("Error", f"Move failed: {e}", sound = "error")

        source_selector.configure(command = lambda _:refresh_containers())
        dest_selector.configure(command = lambda _:refresh_containers())

        refresh_containers()

        back_button = self._create_sound_button(
        main_frame,
        "Back",
        lambda:[self._clear_window(), self._open_inventory_management()],
        width = 200,
        height = 40
        )
        back_button.grid(row = 2, column = 0, pady = 10)

    def _open_item_equipping(self):

        logging.info("Item Equipping definition called")

        if currentsave is None:
            self._popup_show_info("Error", "No character loaded.", sound = "error")
            return

        self._clear_window()

        save_filename =(currentsave or "")+".sldsv"
        save_data = self._load_file(save_filename)

        if save_data is None:
            logging.error(f"Failed to load save file {save_filename}")
            self._popup_show_info("Error", f"Failed to load character data", sound = "error")
            return

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.pack(fill = "both", expand = True, padx = 20, pady = 20)

        title = customtkinter.CTkLabel(main_frame, text = "Item Equipping", font = customtkinter.CTkFont(size = 20, weight = "bold"))
        title.pack(pady =(0, 20))

        content_frame = customtkinter.CTkFrame(main_frame)
        content_frame.pack(fill = "both", expand = True)
        content_frame.grid_rowconfigure(0, weight = 1)
        content_frame.grid_columnconfigure((0, 1), weight = 1)

        slots_frame = customtkinter.CTkFrame(content_frame)
        slots_frame.grid(row = 0, column = 0, sticky = "nsew", padx =(0, 10))
        slots_frame.grid_rowconfigure(1, weight = 1)

        slots_frame.grid_columnconfigure(0, weight = 1)

        slots_label = customtkinter.CTkLabel(slots_frame, text = "Equipment Slots", font = customtkinter.CTkFont(size = 16, weight = "bold"))
        slots_label.grid(row = 0, column = 0, pady = 10)

        slots_scroll = customtkinter.CTkScrollableFrame(slots_frame, height = 600)
        slots_scroll.grid(row = 1, column = 0, sticky = "nsew", padx = 10, pady =(0, 10))

        items_frame = customtkinter.CTkFrame(content_frame)
        items_frame.grid(row = 0, column = 1, sticky = "nsew", padx =(10, 0))
        items_frame.grid_rowconfigure(1, weight = 1)

        items_frame.grid_columnconfigure(0, weight = 1)

        items_label = customtkinter.CTkLabel(items_frame, text = "Available Items(Storage & Hands)", font = customtkinter.CTkFont(size = 16, weight = "bold"))
        items_label.grid(row = 0, column = 0, pady = 10)

        items_scroll = customtkinter.CTkScrollableFrame(items_frame, height = 600)
        items_scroll.grid(row = 1, column = 0, sticky = "nsew", padx = 10, pady =(0, 10))

        def refresh_display():

            for widget in slots_scroll.winfo_children():
                widget.destroy()
            for widget in items_scroll.winfo_children():
                widget.destroy()

            equipment = save_data.get("equipment", {})

            def _slot_blocked_by_subslots(slot_name):
                try:
                    slot_name_l = str(slot_name).lower()if slot_name is not None else ''
                    for other_slot, other_item in equipment.items():
                        if not other_item:
                            continue
                        items_to_check =[]
                        if isinstance(other_item, dict):
                            items_to_check =[other_item]
                        elif isinstance(other_item, list):
                            items_to_check =[it for it in other_item if isinstance(it, dict)]

                        for oi in items_to_check:

                            for subslot_data in oi.get('subslots', [])or[]:
                                try:
                                    conflicts = subslot_data.get('conflicts_with')
                                    cur = subslot_data.get('current')
                                    if not cur:
                                        continue
                                    if isinstance(conflicts, dict):
                                        if conflicts.get('type')=='main'and str(conflicts.get('slot')).lower()==slot_name_l:
                                            return True
                                    elif isinstance(conflicts, (list, tuple)):
                                        for conflict_slot in conflicts:
                                            if str(conflict_slot).lower()==slot_name_l:
                                                return True
                                except Exception:
                                    pass

                            for acc in oi.get('accessories', [])or[]:
                                try:
                                    curacc = acc.get('current')
                                    if not isinstance(curacc, dict):
                                        continue
                                    for subslot_data in curacc.get('subslots', [])or[]:
                                        try:
                                            conflicts = subslot_data.get('conflicts_with')
                                            cur = subslot_data.get('current')
                                            if not cur:
                                                continue
                                            if isinstance(conflicts, dict):
                                                if conflicts.get('type')=='main'and str(conflicts.get('slot')).lower()==slot_name_l:
                                                    return True
                                            elif isinstance(conflicts, (list, tuple)):
                                                for conflict_slot in conflicts:
                                                    if str(conflict_slot).lower()==slot_name_l:
                                                        return True
                                        except Exception:
                                            pass
                                except Exception:
                                    pass
                    return False
                except Exception:
                    return False

            for slot, item in equipment.items():
                slot_frame = customtkinter.CTkFrame(slots_scroll)
                slot_frame.pack(fill = "x", pady = 5, padx = 5)

                slot_label = customtkinter.CTkLabel(
                slot_frame,
                text = f"{slot.title()}:",
                font = customtkinter.CTkFont(size = 12, weight = "bold"),
                anchor = "w"
                )
                slot_label.pack(side = "top", anchor = "w", padx = 10, pady =(5, 0))

                if item:

                    if isinstance(item, list):
                        counts = {}
                        for it in item:
                            try:
                                if isinstance(it, dict):
                                    name = it.get('name', 'Unknown')
                                else:
                                    name = str(it)
                            except Exception:
                                name = 'Unknown'
                            counts[name]= counts.get(name, 0)+1

                        if len(counts)==1:
                            name, cnt = next(iter(counts.items()))
                            display_text = f" {name} x{cnt}"
                        else:

                            parts =[f"{n} x{c}"for n, c in counts.items()]
                            display_text = "(MIXED - NOT ALLOWED) "+", ".join(parts)

                            item_label = customtkinter.CTkLabel(
                            slot_frame,
                            text = display_text,
                            anchor = "w",
                            text_color = "#FF4444"
                            )
                            item_label.pack(side = "top", anchor = "w", padx = 10)

                            continue
                    else:
                        item_name = item.get("name", "Unknown")if isinstance(item, dict)else str(item)
                        display_text = f" {item_name}"

                    item_label = customtkinter.CTkLabel(
                    slot_frame,
                    text = display_text,
                    anchor = "w",
                    text_color = "lightblue"
                    )
                    item_label.pack(side = "top", anchor = "w", padx = 10)

                    unequip_button = self._create_sound_button(
                    slot_frame,
                    "Unequip",
                    lambda s = slot:unequip_item(s),
                    width = 80,
                    height = 30
                    )
                    unequip_button.pack(side = "right", padx = 10, pady = 5)

                    if isinstance(item, dict)and "subslots"in item:
                        for subslot_data in item["subslots"]:
                            subslot_name = subslot_data.get("name", "Unknown Subslot")
                            subslot_type = subslot_data.get("slot", "unknown")
                            current_item = subslot_data.get("current")

                            subslot_frame = customtkinter.CTkFrame(slots_scroll)
                            subslot_frame.pack(fill = "x", pady = 2, padx = 5)

                            subslot_label = customtkinter.CTkLabel(
                            subslot_frame,
                            text = f" â†³ {subslot_name}:",
                            font = customtkinter.CTkFont(size = 11),
                            anchor = "w",
                            text_color = "#FFA500"
                            )
                            subslot_label.pack(side = "top", anchor = "w", padx = 20, pady =(5, 0))

                            if current_item:
                                subitem_name = current_item.get("name", "Unknown")if isinstance(current_item, dict)else str(current_item)

                                is_container = isinstance(current_item, dict)and current_item.get("container", False)
                                if is_container:
                                    total_weight = sum(i.get("weight", 0)*i.get("quantity", 1)for i in current_item.get("items", []))
                                    capacity = current_item.get("capacity", 0)
                                    subitem_text = f" {subitem_name}[{self._format_weight(total_weight)}/{self._format_weight(capacity)}]"
                                else:
                                    subitem_text = f" {subitem_name}"

                                subitem_label = customtkinter.CTkLabel(
                                subslot_frame,
                                text = subitem_text,
                                anchor = "w",
                                text_color = "lightgreen"
                                )
                                subitem_label.pack(side = "top", anchor = "w", padx = 20)

                                button_container = customtkinter.CTkFrame(subslot_frame, fg_color = "transparent")
                                button_container.pack(side = "right", padx = 10, pady = 5)

                                unequip_sub_button = self._create_sound_button(
                                button_container,
                                "Unequip",
                                lambda s = slot, ss = subslot_data:unequip_from_subslot(s, ss),
                                width = 80,
                                height = 25
                                )
                                unequip_sub_button.pack(side = "left", padx = 2)

                                if is_container:
                                    view_button = self._create_sound_button(
                                    button_container,
                                    "View",
                                    lambda ci = current_item:view_container_contents(ci),
                                    width = 60,
                                    height = 25
                                    )
                                    view_button.pack(side = "left", padx = 2)
                            else:
                                try:
                                    conflicts = subslot_data.get('conflicts_with')
                                except Exception:
                                    conflicts = None

                                if conflicts:
                                    try:
                                        if isinstance(conflicts, dict):
                                            conf_slots =[conflicts.get('slot')]if conflicts.get('slot')else[]
                                        elif isinstance(conflicts, (list, tuple)):
                                            conf_slots =[str(c)for c in conflicts]
                                        else:
                                            conf_slots =[str(conflicts)]
                                        conf_slots =[c for c in conf_slots if c]
                                        conf_text = ', '.join(conf_slots)if conf_slots else 'unknown'
                                    except Exception:
                                        conf_text = 'unknown'
                                    empty_text = f"Conflicts with: {conf_text}"
                                    text_color = "#FF4444"
                                else:
                                    empty_text = f"(empty - accepts: {subslot_type})"
                                    text_color = "gray"

                                empty_sub_label = customtkinter.CTkLabel(
                                subslot_frame,
                                text = empty_text,
                                anchor = "w",
                                text_color = text_color,
                                font = customtkinter.CTkFont(size = 10)
                                )
                                empty_sub_label.pack(side = "top", anchor = "w", padx = 20, pady =(0, 5))
                else:

                    try:
                        conflict_sources = _get_conflict_sources(slot)
                    except Exception:
                        conflict_sources =[]

                    try:
                        conflict_item = _find_any_item_with_conflict(slot)
                    except Exception:
                        conflict_item = None

                    if conflict_item:
                        empty_text = f"Conflicts with: {conflict_item}"
                        text_color = "#FF4444"
                    elif conflict_sources:

                        parents =[]
                        for s in conflict_sources:
                            try:
                                parent = s.split('.', 1)[0]if '.'in s else s
                            except Exception:
                                parent = s
                            parents.append(parent)

                        seen = set()
                        uniq_parents =[]
                        for p in parents:
                            if p not in seen:
                                seen.add(p)
                                uniq_parents.append(p)
                        conf_text = ', '.join(uniq_parents)
                        empty_text = f"Conflicts with: {conf_text}"
                        text_color = "#FF4444"
                    else:
                        empty_text = "(empty)"
                        text_color = "gray"

                    empty_label = customtkinter.CTkLabel(
                    slot_frame,
                    text = empty_text,
                    anchor = "w",
                    text_color = text_color
                    )
                    empty_label.pack(side = "top", anchor = "w", padx = 10, pady =(0, 5))

                    def open_equip_candidates(target_slot):

                        candidates =[]

                        for hi, hit in enumerate(save_data.get("hands", {}).get("items", [])):
                            if not isinstance(hit, dict):
                                continue
                            if hit.get("equippable"):
                                slot_field = hit.get("slot")
                                slots = slot_field if isinstance(slot_field, list)else[slot_field]
                                if target_slot in slots:
                                    candidates.append(("hands", hi, hit))

                        equipment = save_data.get("equipment", {})
                        for eq_slot, eq_item in equipment.items():
                            if not eq_item or not isinstance(eq_item, dict):
                                continue

                            if "items"in eq_item and isinstance(eq_item.get("items"), list):
                                for ci, citem in enumerate(eq_item["items"]):
                                    if not isinstance(citem, dict):
                                        continue
                                    if citem.get("equippable"):
                                        slot_field = citem.get("slot")
                                        slots = slot_field if isinstance(slot_field, list)else[slot_field]
                                        if target_slot in slots:
                                            candidates.append((f"equipment.{eq_slot}.items", ci, citem))

                            for ss_idx, subslot_data in enumerate(eq_item.get("subslots", [])or[]):
                                subslot_item = subslot_data.get("current")
                                if subslot_item and isinstance(subslot_item, dict)and "items"in subslot_item:
                                    for ci, citem in enumerate(subslot_item["items"]):
                                        if not isinstance(citem, dict):
                                            continue
                                        if citem.get("equippable"):
                                            slot_field = citem.get("slot")
                                            slots = slot_field if isinstance(slot_field, list)else[slot_field]
                                            if target_slot in slots:
                                                candidates.append((f"equipment.{eq_slot}.subslot.{ss_idx}.items", ci, citem))

                        if not candidates:
                            self._popup_show_info("Equip", f"No equippable items for slot: {target_slot}")
                            return

                        popup = customtkinter.CTkToplevel(self.root)
                        popup.title(f"Equip to {target_slot}")
                        popup.transient(self.root)
                        self._center_popup_on_window(popup, 420, 300)
                        list_frame = customtkinter.CTkScrollableFrame(popup, fg_color = "transparent")
                        list_frame.pack(fill = "both", expand = True, padx = 10, pady = 10)

                        sel_var = customtkinter.StringVar(value = "0")
                        for idx, (loc, iidx, itm)in enumerate(candidates):
                            name = itm.get("name", "Unknown")
                            lab = customtkinter.CTkLabel(list_frame, text = f"{name} - {loc}")
                            lab.pack(anchor = "w", pady = 4)
                            rb = customtkinter.CTkRadioButton(list_frame, text = "", variable = sel_var, value = str(idx))
                            rb.pack(anchor = "e")

                        def do_equip():
                            sel = int(sel_var.get())
                            loc, iidx, itm = candidates[sel]
                            popup.destroy()
                            equip_item(loc, iidx, itm)

                        btn_frame = customtkinter.CTkFrame(popup, fg_color = "transparent")
                        btn_frame.pack(fill = "x", padx = 10, pady = 8)
                        customtkinter.CTkButton(btn_frame, text = "Equip Selected", command = do_equip, width = 140).pack(side = "left", padx = 6)
                        customtkinter.CTkButton(btn_frame, text = "Cancel", command = popup.destroy, width = 120).pack(side = "right", padx = 6)

                    equip_slot_btn = self._create_sound_button(
                    slot_frame,
                    "Equip",
                    lambda s = slot:open_equip_candidates(s),
                    width = 80,
                    height = 30,
                    state = "disabled"if _slot_blocked_by_subslots(slot)else "normal"
                    )
                    equip_slot_btn.pack(side = "right", padx = 10, pady = 5)

            all_items =[]

            for i, item in enumerate(save_data["hands"].get("items", [])):
                if isinstance(item, dict):
                    is_equippable = item.get("equippable", False)
                    is_firearm = item.get("firearm", False)
                    is_melee = item.get("melee", False)
                    if is_equippable or is_firearm or is_melee:
                        all_items.append(("hands", i, item))

            equipment = save_data.get("equipment", {})
            for eq_slot, eq_item in equipment.items():
                if not eq_item or not isinstance(eq_item, dict):
                    continue

                if "items"in eq_item and isinstance(eq_item.get("items"), list):
                    for ci, citem in enumerate(eq_item["items"]):
                        if not isinstance(citem, dict):
                            continue
                        is_equippable = citem.get("equippable", False)
                        is_firearm = citem.get("firearm", False)
                        is_melee = citem.get("melee", False)
                        if is_equippable or is_firearm or is_melee:
                            all_items.append((f"equipment.{eq_slot}.items", ci, citem))

                for ss_idx, subslot_data in enumerate(eq_item.get("subslots", [])or[]):
                    subslot_item = subslot_data.get("current")
                    if subslot_item and isinstance(subslot_item, dict)and "items"in subslot_item:
                        for ci, citem in enumerate(subslot_item["items"]):
                            if not isinstance(citem, dict):
                                continue
                            is_equippable = citem.get("equippable", False)
                            is_firearm = citem.get("firearm", False)
                            is_melee = citem.get("melee", False)
                            if is_equippable or is_firearm or is_melee:
                                all_items.append((f"equipment.{eq_slot}.subslot.{ss_idx}.items", ci, citem))

            for location, idx, item in all_items:
                item_frame = customtkinter.CTkFrame(items_scroll)
                item_frame.pack(fill = "x", pady = 2, padx = 5)

                item_name = item.get("name", "Unknown")

                if item.get("equippable"):
                    slots = item.get("slot", [])
                    if not isinstance(slots, list):
                        slots =[slots]
                    slots_text = f"Slots: {', '.join(str(s)for s in slots)}"
                elif item.get("firearm")or item.get("melee"):

                    if item.get("firearm"):
                        weapon_type = item.get("subtype", "unknown")
                    else:
                        weapon_type = item.get("type", "unknown")

                    if weapon_type =="pistol":
                        slots_text = "Slots: holster/sling subslots or waistband"
                    else:
                        slots_text = f"Slots: holster/sling subslots(type: {weapon_type})"
                else:
                    slots_text = "Slots: unknown"

                item_label = customtkinter.CTkLabel(
                item_frame,
                text = f"{item_name}\n {slots_text}",
                anchor = "w",
                font = customtkinter.CTkFont(size = 11)
                )
                item_label.pack(side = "left", padx = 10, pady = 5)

                equip_button = self._create_sound_button(
                item_frame,
                "Equip",
                lambda loc = location, i = idx, itm = item:equip_item(loc, i, itm),
                width = 80,
                height = 30
                )
                equip_button.pack(side = "right", padx = 10, pady = 5)

            if not all_items:
                empty_label = customtkinter.CTkLabel(items_scroll, text = "No equippable items available", text_color = "gray")
                empty_label.pack(pady = 20)

        def equip_item(location, item_idx, item):
            try:
                equipment = save_data.get("equipment", {})

                choices =[]

                def add_choice(label, slot = None, parent_slot = None, subslot = None):
                    choices.append({"label":label, "slot":slot, "parent_slot":parent_slot, "subslot":subslot})

                is_weapon = item.get("firearm", False)or item.get("melee", False)

                if is_weapon:
                    weapon_subtype = item.get("subtype", "unknown")
                    weapon_melee_type = item.get("type")if item.get("melee")else None

                    def _slot_blocked_by_subslots(slot_name):
                        try:
                            slot_name_l = str(slot_name).lower()if slot_name is not None else ''
                            for other_slot, other_item in equipment.items():
                                if not other_item or not isinstance(other_item, dict):
                                    continue

                                for subslot_data in other_item.get('subslots', [])or[]:
                                    try:
                                        conflicts = subslot_data.get('conflicts_with')
                                        cur = subslot_data.get('current')
                                        if not cur:
                                            continue
                                        if isinstance(conflicts, dict):
                                            if conflicts.get('type')=='main'and str(conflicts.get('slot')).lower()==slot_name_l:
                                                return True
                                        elif isinstance(conflicts, (list, tuple)):
                                            for conflict_slot in conflicts:
                                                if str(conflict_slot).lower()==slot_name_l:
                                                    return True
                                    except Exception:
                                        pass

                                for acc in other_item.get('accessories', [])or[]:
                                    try:
                                        curacc = acc.get('current')
                                        if not isinstance(curacc, dict):
                                            continue
                                        for subslot_data in curacc.get('subslots', [])or[]:
                                            try:
                                                conflicts = subslot_data.get('conflicts_with')
                                                cur = subslot_data.get('current')
                                                if not cur:
                                                    continue
                                                if isinstance(conflicts, dict):
                                                    if conflicts.get('type')=='main'and str(conflicts.get('slot')).lower()==slot_name_l:
                                                        return True
                                                elif isinstance(conflicts, (list, tuple)):
                                                    for conflict_slot in conflicts:
                                                        if str(conflict_slot).lower()==slot_name_l:
                                                            return True
                                            except Exception:
                                                pass
                                    except Exception:
                                        pass
                            return False
                        except Exception:
                            return False

                    if weapon_subtype =="pistol"and "waistband"in equipment and equipment["waistband"]is None and not _slot_blocked_by_subslots("waistband"):
                        add_choice("Waistband", slot = "waistband")

                    for parent_slot, equipped_item in equipment.items():
                        if isinstance(equipped_item, dict)and equipped_item.get("holster_sling", False):
                            compatible_types = equipped_item.get("weapon_types", [])
                            if weapon_subtype in compatible_types or weapon_melee_type in compatible_types:
                                for subslot_data in equipped_item.get("subslots", []):
                                    if subslot_data.get("slot")!="weapon_slot"or subslot_data.get("current")is not None:
                                        continue
                                    conflicts = subslot_data.get("conflicts_with")
                                    blocked = False
                                    if conflicts:
                                        if isinstance(conflicts, dict):
                                            conflict_type = conflicts.get("type")
                                            conflict_slot = conflicts.get("slot")
                                            if conflict_type =="main"and conflict_slot in equipment and equipment.get(conflict_slot)is not None:
                                                blocked = True
                                        elif isinstance(conflicts, (list, tuple)):
                                            for conflict_slot in conflicts:
                                                if conflict_slot in equipment and equipment.get(conflict_slot)is not None:
                                                    blocked = True
                                                    break
                                    if blocked:
                                        continue
                                    label = f"{parent_slot.title()} - {subslot_data.get('name', 'Weapon Slot')}"
                                    add_choice(label, parent_slot = parent_slot, subslot = subslot_data)

                    if not choices:
                        if weapon_subtype =="pistol":
                            self._popup_show_info("Error", "No available holster/sling or waistband slot for this pistol.", sound = "error")
                        else:
                            self._popup_show_info("Error", f"No available holster/sling slot for this weapon(type: {weapon_subtype or weapon_melee_type}).", sound = "error")
                        return

                else:

                    valid_slots = item.get("slot", [])
                    if not isinstance(valid_slots, list):
                        valid_slots =[valid_slots]

                    def _slot_blocked_by_subslots(slot_name):
                        try:
                            slot_name_l = str(slot_name).lower()if slot_name is not None else ''
                            for other_slot, other_item in equipment.items():
                                if not other_item or not isinstance(other_item, dict):
                                    continue
                                for subslot_data in other_item.get('subslots', [])or[]:
                                    try:
                                        conflicts = subslot_data.get('conflicts_with')
                                        cur = subslot_data.get('current')
                                        if not cur:
                                            continue
                                        if isinstance(conflicts, dict):
                                            if conflicts.get('type')=='main'and str(conflicts.get('slot')).lower()==slot_name_l:
                                                return True
                                        elif isinstance(conflicts, (list, tuple)):
                                            for conflict_slot in conflicts:
                                                if str(conflict_slot).lower()==slot_name_l:
                                                    return True
                                    except Exception:
                                        pass
                                for acc in other_item.get('accessories', [])or[]:
                                    try:
                                        curacc = acc.get('current')
                                        if not isinstance(curacc, dict):
                                            continue
                                        for subslot_data in curacc.get('subslots', [])or[]:
                                            try:
                                                conflicts = subslot_data.get('conflicts_with')
                                                cur = subslot_data.get('current')
                                                if not cur:
                                                    continue
                                                if isinstance(conflicts, dict):
                                                    if conflicts.get('type')=='main'and str(conflicts.get('slot')).lower()==slot_name_l:
                                                        return True
                                                elif isinstance(conflicts, (list, tuple)):
                                                    for conflict_slot in conflicts:
                                                        if str(conflict_slot).lower()==slot_name_l:
                                                            return True
                                            except Exception:
                                                pass
                                    except Exception:
                                        pass
                            return False
                        except Exception:
                            return False

                    for slot in valid_slots:
                        cur = equipment.get(slot)

                        if slot in equipment and cur is None:

                            if _slot_blocked_by_subslots(slot):
                                continue
                            add_choice(f"{slot.title()}", slot = slot)
                        else:

                            try:
                                if item.get('can_equip_multiple'):
                                    max_e = item.get('max_equip')

                                    count = 0
                                    if isinstance(cur, dict)and cur.get('id')==item.get('id'):
                                        count = 1
                                    elif isinstance(cur, list):

                                        same =[c for c in cur if isinstance(c, dict)and c.get('id')==item.get('id')]
                                        count = len(same)

                                    if max_e is None or(isinstance(max_e, int)and count <int(max_e)):

                                        allow = False
                                        if cur is None:
                                            allow = True
                                        elif isinstance(cur, dict)and cur.get('id')==item.get('id'):
                                            allow = True
                                        elif isinstance(cur, list)and all(isinstance(c, dict)and c.get('id')==item.get('id')for c in cur):
                                            allow = True
                                        if allow:
                                            lbl = f"{slot.title()}"
                                            if count >0:
                                                lbl = f"{lbl}(x{count})"
                                            add_choice(lbl, slot = slot)
                            except Exception:
                                pass

                    for parent_slot, equipped_item in equipment.items():
                        if isinstance(equipped_item, dict)and "subslots"in equipped_item:
                            for subslot_data in equipped_item["subslots"]:
                                subslot_type = subslot_data.get("slot", "")
                                if subslot_type in valid_slots and subslot_data.get("current")is None:
                                    conflicts = subslot_data.get("conflicts_with")
                                    blocked = False
                                    if conflicts:
                                        if isinstance(conflicts, dict):
                                            conflict_type = conflicts.get("type")
                                            conflict_slot = conflicts.get("slot")
                                            if conflict_type =="main"and conflict_slot in equipment and equipment.get(conflict_slot)is not None:
                                                blocked = True
                                        elif isinstance(conflicts, (list, tuple)):
                                            for conflict_slot in conflicts:
                                                if conflict_slot in equipment and equipment.get(conflict_slot)is not None:
                                                    blocked = True
                                                    break
                                    if blocked:
                                        continue
                                    label = f"{parent_slot.title()} - {subslot_data.get('name', subslot_type)}"
                                    add_choice(label, parent_slot = parent_slot, subslot = subslot_data)

                    for parent_slot, equipped_item in equipment.items():
                        if isinstance(equipped_item, dict)and isinstance(equipped_item.get("accessories"), list):
                            for acc in equipped_item.get("accessories")or[]:
                                try:
                                    cur = acc.get("current")
                                    if not isinstance(cur, dict):
                                        continue
                                    for subslot_data in(cur.get("subslots")or[]):
                                        subslot_type = subslot_data.get("slot", "")
                                        if subslot_type in valid_slots and subslot_data.get("current")is None:
                                            conflicts = subslot_data.get("conflicts_with")
                                            blocked = False
                                            if conflicts:
                                                if isinstance(conflicts, dict):
                                                    conflict_type = conflicts.get("type")
                                                    conflict_slot = conflicts.get("slot")
                                                    if conflict_type =="main"and conflict_slot in equipment and equipment.get(conflict_slot)is not None:
                                                        blocked = True
                                                elif isinstance(conflicts, (list, tuple)):
                                                    for conflict_slot in conflicts:
                                                        if conflict_slot in equipment and equipment.get(conflict_slot)is not None:
                                                            blocked = True
                                                            break
                                            if blocked:
                                                continue
                                            parent_label = f"{parent_slot.title()} - {acc.get('name', 'Accessory')} -> {subslot_data.get('name', subslot_type)}"
                                            add_choice(parent_label, parent_slot = parent_slot, subslot = subslot_data)
                                except Exception:
                                    pass

                    if not choices:
                        self._popup_show_info("Error", f"No available slots for this item.Valid slots: {', '.join(valid_slots)}", sound = "error")
                        return

                def apply_choice(choice):
                    if location =="storage":
                        removed_item = save_data["storage"].pop(item_idx)
                    elif location =="hands":
                        removed_item = save_data["hands"]["items"].pop(item_idx)
                        item_weight = removed_item.get("weight", 0)*removed_item.get("quantity", 1)
                        save_data["hands"]["encumbrance"]= max(0, save_data["hands"].get("encumbrance", 0)-item_weight)
                    elif location.startswith("equipment."):

                        parts = location.split(".")
                        eq_slot = parts[1]
                        eq_item = save_data.get("equipment", {}).get(eq_slot)
                        if len(parts)==3 and parts[2]=="items":

                            if eq_item and isinstance(eq_item, dict)and "items"in eq_item:
                                removed_item = eq_item["items"].pop(item_idx)
                            else:
                                removed_item = item
                        elif len(parts)==5 and parts[2]=="subslot"and parts[4]=="items":

                            ss_idx = int(parts[3])
                            if eq_item and isinstance(eq_item, dict):
                                subslots = eq_item.get("subslots", [])
                                if ss_idx <len(subslots):
                                    subslot_item = subslots[ss_idx].get("current")
                                    if subslot_item and isinstance(subslot_item, dict)and "items"in subslot_item:
                                        removed_item = subslot_item["items"].pop(item_idx)
                                    else:
                                        removed_item = item
                                else:
                                    removed_item = item
                            else:
                                removed_item = item
                        else:
                            removed_item = item
                    else:
                        removed_item = item

                    if choice.get("slot"):
                        slot = choice["slot"]
                        cur = save_data["equipment"].get(slot)

                        if cur is None:
                            save_data["equipment"][slot]= removed_item
                        else:

                            try:
                                if item.get('can_equip_multiple')and item.get('id')is not None:
                                    max_e = item.get('max_equip')

                                    if isinstance(cur, dict):
                                        if cur.get('id')==item.get('id'):
                                            lst =[cur, removed_item]
                                            save_data["equipment"][slot]= lst
                                        else:

                                            save_data["equipment"][slot]= removed_item
                                    elif isinstance(cur, list):

                                        same =[c for c in cur if isinstance(c, dict)and c.get('id')==item.get('id')]
                                        if len(same)==len(cur):

                                            if max_e is None or len(cur)<int(max_e):
                                                cur.append(removed_item)
                                                save_data["equipment"][slot]= cur
                                            else:
                                                self._popup_show_info("Equip", f"Cannot equip more than {max_e} of this item into slot '{slot}'.", sound = "error")
                                                return
                                        else:

                                            save_data["equipment"][slot]= removed_item
                                    else:
                                        save_data["equipment"][slot]= removed_item
                                else:

                                    save_data["equipment"][slot]= removed_item
                            except Exception:
                                save_data["equipment"][slot]= removed_item
                    elif choice.get("subslot")is not None:
                        choice["subslot"]["current"]= removed_item

                    self._save_file(save_data)
                    try:
                        globals()['ATTACHMENTS_VERSION']= globals().get('ATTACHMENTS_VERSION', 0)+1
                    except Exception:
                        pass
                    refresh_display()

                    try:
                        played = False

                        if choice.get("slot")=="waistband":
                            logging.debug("Playing slingequip for waistband equip: sounds/firearms/universal/slingequip.ogg")

                            self._safe_sound_play("", "sounds/firearms/universal/slingequip.ogg", block = False)
                            played = True
                        elif choice.get("parent_slot"):
                            parent = save_data.get("equipment", {}).get(choice.get("parent_slot"))
                            if parent and isinstance(parent, dict):
                                pname = parent.get("name", "").lower()
                                ptypes =[pt.lower()for pt in parent.get("weapon_types", [])if isinstance(pt, str)]

                                if "pistol"in ptypes or "holster"in pname:
                                    logging.debug("Playing holsterequip for holster equip: sounds/firearms/universal/holsterequip.ogg")

                                    self._safe_sound_play("", "sounds/firearms/universal/holsterequip.ogg", block = False)
                                    played = True
                                else:
                                    logging.debug("Playing slingequip for sling equip: sounds/firearms/universal/slingequip.ogg")
                                    self._safe_sound_play("", "sounds/firearms/universal/slingequip.ogg", block = False)
                                    played = True
                        if not played:

                            self._play_ui_sound("success")
                    except Exception:
                        try:
                            self._play_ui_sound("success")
                        except Exception:
                            pass

                    try:
                        logging.debug("apply_choice: about to play per-item equip sound for %s", removed_item.get("name"))
                        self._play_firearm_sound(removed_item, "equip")
                    except Exception:
                        logging.exception("Failed to play per-item equip sound")

                if len(choices)==1:
                    apply_choice(choices[0])
                    return

                popup = customtkinter.CTkToplevel(self.root)
                popup.title("Select Slot")
                popup.transient(self.root)
                self._center_popup_on_window(popup, 360, 200)

                prompt_label = customtkinter.CTkLabel(popup, text = "Choose where to equip:", font = customtkinter.CTkFont(size = 14, weight = "bold"))
                prompt_label.pack(pady =(15, 10))

                choice_labels =[c["label"]for c in choices]
                selection = customtkinter.StringVar(value = choice_labels[0])

                choice_menu = customtkinter.CTkOptionMenu(popup, values = choice_labels, variable = selection)
                choice_menu.pack(pady = 10, padx = 20, fill = "x")

                def _on_equip_selection_change(*a):
                    try:
                        label = selection.get()
                        chosen = next((c for c in choices if c["label"]==label), None)
                        if not chosen:
                            return

                        if chosen.get("slot")=="waistband":
                            self._safe_sound_play("", "sounds/firearms/universal/slingequip.ogg")
                        elif chosen.get("parent_slot"):
                            parent = save_data.get("equipment", {}).get(chosen.get("parent_slot"))
                            if parent and isinstance(parent, dict):
                                pname = parent.get("name", "").lower()
                                ptypes =[pt.lower()for pt in parent.get("weapon_types", [])if isinstance(pt, str)]
                                if "pistol"in ptypes or "holster"in pname:
                                    self._safe_sound_play("", "sounds/firearms/universal/holsterequip.ogg")
                                else:
                                    self._safe_sound_play("", "sounds/firearms/universal/slingequip.ogg")
                        else:

                            try:
                                self._play_ui_sound("hover")
                            except Exception:
                                pass
                    except Exception:
                        pass

                try:

                    selection.trace_add("write", _on_equip_selection_change)
                except Exception:
                    try:
                        selection.trace("w", lambda *a:_on_equip_selection_change())
                    except Exception:
                        pass

                button_frame = customtkinter.CTkFrame(popup, fg_color = "transparent")
                button_frame.pack(pady = 15)

                def confirm_choice():
                    label = selection.get()
                    chosen = next((c for c in choices if c["label"]==label), None)
                    if chosen:
                        apply_choice(chosen)
                    popup.destroy()

                def cancel_choice():
                    popup.destroy()

                confirm_btn = self._create_sound_button(button_frame, "Equip", confirm_choice, width = 120, height = 35)
                confirm_btn.pack(side = "left", padx = 10)

                cancel_btn = self._create_sound_button(button_frame, "Cancel", cancel_choice, width = 120, height = 35)
                cancel_btn.pack(side = "left", padx = 10)

                popup.grab_set()
                popup.lift()
                self._safe_focus(popup)
            except Exception as e:
                logging.error(f"Equip failed: {e}")
                self._popup_show_info("Error", f"Equip failed: {e}", sound = "error")

        def unequip_item(slot):
            try:
                item = save_data["equipment"].get(slot)
                if not item:
                    return

                if isinstance(item, dict)and item.get("curse_of_binding"):
                    self._popup_show_info("Curse of Binding", f"{item.get('name', 'This item')} is bound and cannot be unequipped.", sound = "error")
                    return
                if isinstance(item, list):
                    last_item = item[-1]if item else None
                    if isinstance(last_item, dict)and last_item.get("curse_of_binding"):
                        self._popup_show_info("Curse of Binding", f"{last_item.get('name', 'This item')} is bound and cannot be unequipped.", sound = "error")
                        return

                played = False
                try:
                    if slot =="waistband":
                        logging.debug("Playing slingunequip for waistband unequip: sounds/firearms/universal/slingunequip.ogg")

                        self._safe_sound_play("", "sounds/firearms/universal/slingunequip.ogg", block = True)
                        played = True
                    else:
                        parent = save_data.get("equipment", {}).get(slot)
                        if parent and isinstance(parent, dict):
                            pname = parent.get("name", "").lower()
                            ptypes =[pt.lower()for pt in parent.get("weapon_types", [])if isinstance(pt, str)]
                            if "pistol"in ptypes or "holster"in pname:
                                logging.debug("Playing holsterunequip: sounds/firearms/universal/holsterunequip.ogg")
                                self._safe_sound_play("", "sounds/firearms/universal/holsterunequip.ogg", block = True)
                                played = True
                            elif parent.get("holster_sling"):
                                logging.debug("Playing slingunequip: sounds/firearms/universal/slingunequip.ogg")
                                self._safe_sound_play("", "sounds/firearms/universal/slingunequip.ogg", block = True)
                                played = True
                except Exception:
                    played = False

                if isinstance(item, list):
                    rem = item.pop()
                    save_data["hands"]["items"].append(rem)
                    if len(item)==1 and isinstance(item[0], dict):

                        save_data["equipment"][slot]= item[0]
                    elif len(item)==0:
                        save_data["equipment"][slot]= None
                    else:
                        save_data["equipment"][slot]= item
                else:
                    save_data["hands"]["items"].append(item)
                    save_data["equipment"][slot]= None

                self._save_file(save_data)

                refresh_display()
                if not played:
                    self._play_ui_sound("success")
            except Exception as e:
                logging.error(f"Unequip failed: {e}")
                self._popup_show_info("Error", f"Unequip failed: {e}", sound = "error")

        def unequip_from_subslot(parent_slot, subslot_data):
            try:
                current_item = subslot_data.get("current")
                if not current_item:
                    return

                if isinstance(current_item, dict)and current_item.get("curse_of_binding"):
                    self._popup_show_info("Curse of Binding", f"{current_item.get('name', 'This item')} is bound and cannot be unequipped.", sound = "error")
                    return

                played = False
                try:
                    parent = save_data.get("equipment", {}).get(parent_slot)
                    if parent and isinstance(parent, dict):
                        pname = parent.get("name", "").lower()
                        ptypes =[pt.lower()for pt in parent.get("weapon_types", [])if isinstance(pt, str)]
                        if parent_slot =="waistband"or(parent.get("holster_sling")and any(pt in("rifle", "smg", "shotgun", "mg")for pt in ptypes)):

                            self._safe_sound_play("", "sounds/firearms/universal/slingunequip.ogg", block = True)
                            played = True
                        else:

                            if "pistol"in ptypes or "holster"in pname:
                                self._safe_sound_play("", "sounds/firearms/universal/holsterunequip.ogg", block = True)
                                played = True
                except Exception:
                    played = False

                try:
                    if not isinstance(current_item, dict)and(isinstance(current_item, int)or(isinstance(current_item, str)and current_item.isdigit())):
                        iid = int(current_item)

                        table_files = sorted(glob.glob(os.path.join("tables", f"*{global_variables.get('table_extension', '.sldtbl')}")))
                        for tf in table_files:
                            try:
                                with open(tf, 'r', encoding = 'utf-8')as f:
                                    td = json.load(f)
                            except Exception:
                                continue
                            for arr in td.get('tables', {}).values():
                                if isinstance(arr, list):
                                    for cand in arr:
                                        if isinstance(cand, dict)and cand.get('id')==iid:
                                            current_item = cand.copy()
                                            break
                                    if isinstance(current_item, dict):
                                        break
                            if isinstance(current_item, dict):
                                break
                except Exception:
                    pass

                save_data["hands"]["items"].append(current_item)
                subslot_data["current"]= None

                self._save_file(save_data)

                refresh_display()
                if not played:
                    self._play_ui_sound("success")
            except Exception as e:
                logging.error(f"Unequip from subslot failed: {e}")
                self._popup_show_info("Error", f"Unequip failed: {e}", sound = "error")

        def view_container_contents(container_item):
            try:
                self._play_ui_sound("click")

                popup = customtkinter.CTkToplevel(self.root)
                popup.title(f"Container: {container_item.get('name', 'Unknown')}")
                popup.transient(self.root)
                self._center_popup_on_window(popup, 500, 600)

                main_container = customtkinter.CTkFrame(popup)
                main_container.pack(fill = "both", expand = True, padx = 20, pady = 20)

                title = customtkinter.CTkLabel(
                main_container,
                text = container_item.get('name', 'Unknown Container'),
                font = customtkinter.CTkFont(size = 18, weight = "bold")
                )
                title.pack(pady =(0, 10))

                total_weight = sum(i.get("weight", 0)*i.get("quantity", 1)for i in container_item.get("items", []))
                capacity = container_item.get("capacity", 0)
                capacity_label = customtkinter.CTkLabel(
                main_container,
                text = f"Capacity: {self._format_weight(total_weight)} / {self._format_weight(capacity)}",
                font = customtkinter.CTkFont(size = 14)
                )
                capacity_label.pack(pady =(0, 15))

                items_frame = customtkinter.CTkScrollableFrame(main_container, height = 400)
                items_frame.pack(fill = "both", expand = True, pady =(0, 10))

                items = container_item.get("items", [])
                if items:
                    for i, item in enumerate(items):
                        item_frame = customtkinter.CTkFrame(items_frame)
                        item_frame.pack(fill = "x", pady = 3, padx = 5)

                        item_name = item.get("name", "Unknown")
                        quantity = item.get("quantity", 1)
                        weight = item.get("weight", 0)

                        info_text = f"{item_name}"
                        if quantity >1:
                            info_text +=f"(x{quantity})"
                        info_text +=f" - {self._format_weight(weight *quantity)}"

                        item_label = customtkinter.CTkLabel(
                        item_frame,
                        text = info_text,
                        anchor = "w"
                        )
                        item_label.pack(side = "left", padx = 10, pady = 5, fill = "x", expand = True)
                else:
                    empty_label = customtkinter.CTkLabel(
                    items_frame,
                    text = "Container is empty",
                    text_color = "gray"
                    )
                    empty_label.pack(pady = 20)

                close_button = self._create_sound_button(
                main_container,
                "Close",
                popup.destroy,
                width = 120,
                height = 35
                )
                close_button.pack(pady =(10, 0))

                popup.update_idletasks()
                popup.grab_set()
                popup.lift()
                self._safe_focus(popup)
            except Exception as e:
                logging.error(f"View container failed: {e}")
                self._popup_show_info("Error", f"Failed to view container: {e}", sound = "error")

        refresh_display()

        back_button = self._create_sound_button(
        main_frame,
        "Back",
        lambda:[self._clear_window(), self._open_inventory_manager_tool()],
        width = 200,
        height = 40
        )
        back_button.pack(pady = 10)
    def _open_combat_mode_tool(self):

        logging.info("Combat Mode opened")
        logging.debug("currentsave=%s debugmode=%s", currentsave, global_variables.get("debugmode", {}).get("value"))

        if currentsave is None:
            self._popup_show_info("Error", "No character loaded.Please load a character first.", sound = "error")
            return

        try:
            save_path = os.path.join(saves_folder or "saves", currentsave or "")
            if not save_path.endswith('.sldsv'):
                save_path +='.sldsv'
            save_data = self._load_file((currentsave or "")+".sldsv")
            if save_data is None:
                logging.error("Failed to load save for combat mode")
                self._popup_show_info("Error", "Failed to load save.", sound = "error")
                return
        except Exception as e:
            logging.error(f"Failed to load save: {e}")
            self._popup_show_info("Error", f"Failed to load save: {e}", sound = "error")
            return

        try:
            table_files = glob.glob(os.path.join("tables", "*.sldtbl"))
            if not table_files:
                self._popup_show_info("Error", "No table file found.", sound = "error")
                return
            with open(table_files[0], 'r')as f:
                table_data = json.load(f)
        except Exception as e:
            logging.error(f"Failed to load table: {e}")
            self._popup_show_info("Error", f"Failed to load table: {e}", sound = "error")
            return

        if "combat_state"not in save_data:
            save_data["combat_state"]= {
            "current_weapon_index":0,
            "barrel_temperatures":{},
            "barrel_cleanliness":{},
            "ambient_temperature":70,
            "weapon_last_used":{}
            }

        combat_state = save_data["combat_state"]

        equipped_weapons = self._get_equipped_weapons(save_data, table_data)

        if not equipped_weapons:
            self._popup_show_info("Error", "No weapons equipped.Please equip a weapon first.", sound = "error")
            return

        if combat_state["current_weapon_index"]>=len(equipped_weapons):
            combat_state["current_weapon_index"]= 0

        now_ts = time.time()
        ambient = combat_state.get("ambient_temperature", 70)

        for wpn in equipped_weapons:
            weapon_id = str(wpn["item"].get("id"))
            temp_map = combat_state.setdefault("barrel_temperatures", {})
            last_used_map = combat_state.setdefault("weapon_last_used", {})

            current_temp = temp_map.get(weapon_id, ambient)
            last_used = last_used_map.get(weapon_id)

            if last_used is None and weapon_id in temp_map:
                assumed_interval = combat_state.get("temp_poll_interval", 15)
                last_used = now_ts -float(assumed_interval)

            elapsed = max(0.0, now_ts -last_used)if last_used is not None else 0.0

            if elapsed >0 and current_temp !=ambient:

                default_k = math.log(2.0)/300.0
                magic_k = math.log(2.0)/600.0
                magicsys_local = str(wpn.get("magicsoundsystem")or "").lower()
                is_magic_local =(str(wpn.get("type")or "").lower()=="magic")or(magicsys_local in("hg", "at", "mg", "rf"))
                k = magic_k if is_magic_local else default_k
                new_temp = ambient +(current_temp -ambient)*math.exp(-k *elapsed)

                low = min(ambient, current_temp)
                high = max(ambient, current_temp)
                new_temp = min(max(new_temp, low), high)
                temp_map[weapon_id]= new_temp

                last_used_map[weapon_id]= now_ts
                logging.debug(
                "Weapon %s cooling: was %.1fÂ°F, now %.1fÂ°F after %.1f seconds",
                weapon_id,
                current_temp,
                new_temp,
                elapsed,
                )

        logging.info(
        "Combat UI init: %s weapons, current index=%s(%s)",
        len(equipped_weapons),
        combat_state["current_weapon_index"],
        equipped_weapons[combat_state["current_weapon_index"]]["item"].get("name", "Unknown")if equipped_weapons else "n/a"
        )

        self._clear_window()
        self._play_ui_sound("whoosh1")

        main_frame = customtkinter.CTkScrollableFrame(self.root, fg_color = "transparent")
        main_frame.pack(fill = "both", expand = True, padx = 20, pady = 20)

        title_label = customtkinter.CTkLabel(
        main_frame,
        text = "Combat Mode",
        font = customtkinter.CTkFont(size = 24, weight = "bold")
        )
        title_label.pack(pady =(0, 20))

        temp_frame = customtkinter.CTkFrame(main_frame)
        temp_frame.pack(fill = "x", pady =(0, 10))

        ambient_temp = combat_state['ambient_temperature']
        if appearance_settings["units"]=="metric":
            ambient_temp = round((ambient_temp -32)*5 /9, 1)
            temp_unit = "Â°C"
        else:
            temp_unit = "Â°F"

        ambient_label = customtkinter.CTkLabel(
        temp_frame,
        text = f"Ambient Temperature: {ambient_temp}{temp_unit}",
        font = customtkinter.CTkFont(size = 14)
        )
        ambient_label.pack(side = "left", padx = 10, pady = 10)

        def _show_combat_stats():

            try:
                parts =[]

                sd_stats = save_data.get("stats", {})or {}
                parts.append("Player base stats:")
                if isinstance(sd_stats, dict)and sd_stats:
                    for k, v in sd_stats.items():
                        parts.append(f" {k}: {v}")
                else:
                    parts.append("(no base stats)")

                agg = {}
                parts.append("")
                parts.append("Weapon modifiers(per-weapon):")
                for idx, entry in enumerate(equipped_weapons):
                    w = entry.get("item")if isinstance(entry, dict)else None
                    name = w.get("name", f"weapon_{idx}")if isinstance(w, dict)else str(entry)
                    mods = {}
                    if isinstance(w, dict):
                        mods = w.get("_active_modifiers", {})or {}
                    parts.append(f" {name}:")
                    stats_mods = mods.get("stats", {})if isinstance(mods, dict)else {}
                    if stats_mods:
                        for sk, sv in stats_mods.items():
                            parts.append(f" {sk}: {sv}")
                            try:
                                agg[sk]= agg.get(sk, 0)+(int(sv)if isinstance(sv, (int, float))else 0)
                            except Exception:
                                pass
                    else:
                        parts.append("(no modifiers)")

                parts.append("")
                parts.append("Aggregated weapon modifiers:")

                try:
                    stat_clamp = 20
                    try:
                        table_files = glob.glob(os.path.join("tables", "*.sldtbl"))
                        if table_files:
                            with open(table_files[0], 'r')as tf:
                                td = json.load(tf)
                                stat_clamp = td.get("additional_settings", {}).get("stat_clamp", stat_clamp)
                    except Exception:
                        pass
                except Exception:
                    stat_clamp = 20

                if agg:
                    for k, v in agg.items():
                        try:
                            num = int(v)if isinstance(v, (int, float))else int(float(v))
                        except Exception:
                            try:
                                num = int(v)
                            except Exception:
                                num = 0

                        num = max(num, -20)
                        num = min(num, int(stat_clamp or 20))
                        parts.append(f" {k}: {num}")
                else:
                    parts.append("(none)")

                try:
                    equip_agg = {}
                    active_sets =[]
                    applied_set_keys = set()
                    equipment = save_data.get("equipment", {})if isinstance(save_data, dict)else {}
                    if isinstance(equipment, dict):

                        for slot_name, equipped_item in equipment.items():
                            if not equipped_item or not isinstance(equipped_item, dict):
                                continue
                            mods = equipped_item.get("modifiers")or {}
                            if isinstance(mods, dict):
                                stats = mods.get("stats")or {}
                                if isinstance(stats, dict):
                                    for sk, sv in stats.items():
                                        try:
                                            equip_agg[sk]= equip_agg.get(sk, 0)+(int(sv)if isinstance(sv, (int, float))else 0)
                                        except Exception:
                                            pass
                            istats = equipped_item.get("stats")or {}
                            if isinstance(istats, dict):
                                for sk, sv in istats.items():
                                    try:
                                        equip_agg[sk]= equip_agg.get(sk, 0)+(int(sv)if isinstance(sv, (int, float))else 0)
                                    except Exception:
                                        pass

                        for slot_name, equipped_item in equipment.items():
                            try:
                                if not equipped_item or not isinstance(equipped_item, dict):
                                    continue
                                sb = equipped_item.get("set_bonus")or {}
                                if not sb or not isinstance(sb, dict):
                                    continue
                                requires = sb.get("requires")or[]
                                if not isinstance(requires, list)or not requires:
                                    continue

                                try:
                                    req_pairs =[]
                                    for req in requires:
                                        rslot = req.get("slot")
                                        rid = req.get("id")
                                        req_pairs.append((str(rslot), int(rid)if rid is not None and isinstance(rid, (int, float, str))and str(rid).isdigit()else rid))
                                    req_key = tuple(sorted(req_pairs))
                                except Exception:
                                    req_key = None
                                if req_key is None:
                                    continue
                                if req_key in applied_set_keys:
                                    continue

                                ok = True
                                member_names =[]
                                for req in requires:
                                    try:
                                        rslot = req.get("slot")
                                        rid = req.get("id")
                                        cur = equipment.get(rslot)
                                        if not cur or not isinstance(cur, dict)or cur.get("id")!=rid:
                                            ok = False
                                            break
                                        member_names.append(cur.get("name", f"{rslot}"))
                                    except Exception:
                                        ok = False
                                        break
                                if not ok:
                                    continue

                                sstats = sb.get("stats")or {}
                                if isinstance(sstats, dict):
                                    for sk, sv in sstats.items():
                                        try:
                                            equip_agg[sk]= equip_agg.get(sk, 0)+(int(sv)if isinstance(sv, (int, float))else 0)
                                        except Exception:
                                            pass
                                applied_set_keys.add(req_key)
                                set_name = sb.get("name")or equipped_item.get("name")or "Set Bonus"
                                active_sets.append({"name":set_name, "members":member_names, "stats":sstats})
                            except Exception:
                                pass

                    parts.append("")
                    parts.append("Equipment modifiers / Set bonuses:")
                    try:
                        clamp_val = None
                        table_files = glob.glob(os.path.join("tables", "*.sldtbl"))
                        if table_files:
                            with open(table_files[0], 'r')as tf:
                                td = json.load(tf)
                                clamp_val = td.get('additional_settings', {}).get('bonus_clamp')
                    except Exception:
                        clamp_val = None

                    if equip_agg:
                        for k, v in equip_agg.items():
                            try:
                                num = int(v)if isinstance(v, (int, float))else int(float(v))
                            except Exception:
                                try:
                                    num = int(v)
                                except Exception:
                                    num = 0
                            if k.lower()=='aim'and clamp_val is not None:
                                try:
                                    cnum = int(float(clamp_val))
                                    num = min(num, cnum)
                                except Exception:
                                    pass
                            parts.append(f" {k}: {num}")
                    else:
                        parts.append("(none)")

                    if active_sets:
                        parts.append("")
                        parts.append("Active set bonuses:")
                        for s in active_sets:
                            try:
                                stats_text =[]
                                if isinstance(s.get('stats'), dict):
                                    for sk, sv in s.get('stats', {}).items():
                                        stats_text.append(f"+{sv} {sk}")
                                members_text = ", ".join(s.get('members', [])or[])
                                parts.append(f" {s.get('name')}: {'; '.join(stats_text)}({members_text})")
                            except Exception:
                                pass
                except Exception as e:
                    logging.debug("Failed aggregating equipment modifiers for combat stats: %s", e)

                popup_text = "\n".join(parts)
            except Exception as e:
                logging.exception("Failed to build combat stats: %s", e)
                popup_text = f"Error building stats: {e}"
            try:
                self._popup_show_info("Combat Stats", popup_text)
            except Exception:
                try:

                    from tkinter import messagebox as _mb
                    _mb.showinfo("Combat Stats", popup_text)
                except Exception:
                    logging.error("Unable to display combat stats popup")

        stats_btn = self._create_sound_button(temp_frame, "Show Stats", _show_combat_stats, width = 160, height = 36)
        stats_btn.pack(side = "right", padx = 8, pady = 10)

        weapon_switch_outer = customtkinter.CTkFrame(main_frame)
        weapon_switch_outer.pack(fill = "x", pady =(0, 20))

        weapon_switch_frame = customtkinter.CTkScrollableFrame(weapon_switch_outer, orientation = "horizontal", height = 60, fg_color = "transparent")
        weapon_switch_frame.pack(fill = "x", expand = True)

        def refresh_weapon_display():

            self._save_combat_state(save_data)
            try:
                _update_nvg_button()
            except Exception:
                pass
            self._open_combat_mode_tool()

        def select_previous():
            logging.debug(
            "Switching weapon: prev from %s/%s",
            combat_state["current_weapon_index"],
            len(equipped_weapons)
            )

            try:

                try:
                    combat_state.pop("active_underbarrel", None)
                except Exception:
                    pass
                cur_idx = combat_state.get("current_weapon_index", 0)

                new_idx =(combat_state["current_weapon_index"]-1)%len(equipped_weapons)

                def _parent_slot_from_entry(entry):
                    slot = entry.get("slot", "")
                    if slot =="Hands":
                        return None
                    if "->"in slot:
                        return slot.split("->")[0].strip()
                    return slot

                def _container_type(parent_slot):

                    if parent_slot is None:
                        return "hands"
                    if parent_slot =="waistband":
                        return "waistband"
                    parent = save_data.get("equipment", {}).get(parent_slot)
                    if parent and isinstance(parent, dict):
                        pname = parent.get("name", "").lower()
                        ptypes =[pt.lower()for pt in parent.get("weapon_types", [])if isinstance(pt, str)]
                        if "pistol"in ptypes or "holster"in pname:
                            return "holster"
                        if parent.get("holster_sling"):
                            return "sling"
                    return "unknown"

                try:
                    combat_state.pop("active_underbarrel", None)
                except Exception:
                    pass

                old_entry = equipped_weapons[cur_idx]if 0 <=cur_idx <len(equipped_weapons)else None
                new_entry = equipped_weapons[new_idx]

                old_parent = _parent_slot_from_entry(old_entry)if old_entry else None
                new_parent = _parent_slot_from_entry(new_entry)

                old_type = _container_type(old_parent)
                new_type = _container_type(new_parent)

                if old_type in("sling", "waistband"):
                    self._safe_sound_play("", "sounds/firearms/universal/slingunequip.ogg", block = True)
                elif old_type =="holster":
                    self._safe_sound_play("", "sounds/firearms/universal/holsterunequip.ogg", block = True)

                combat_state["current_weapon_index"]= new_idx

                if new_type in("sling", "waistband"):
                    self._safe_sound_play("", "sounds/firearms/universal/slingequip.ogg", block = False)
                elif new_type =="holster":
                    self._safe_sound_play("", "sounds/firearms/universal/holsterequip.ogg", block = False)

                try:
                    self._play_firearm_sound(new_entry["item"], "equip")
                except Exception:
                    pass
            except Exception:
                pass
            refresh_weapon_display()

        def select_next():
            logging.debug(
            "Switching weapon: next from %s/%s",
            combat_state["current_weapon_index"],
            len(equipped_weapons)
            )

            try:
                cur_idx = combat_state.get("current_weapon_index", 0)

                new_idx =(combat_state["current_weapon_index"]+1)%len(equipped_weapons)

                def _parent_slot_from_entry(entry):
                    slot = entry.get("slot", "")
                    if slot =="Hands":
                        return None
                    if "->"in slot:
                        return slot.split("->")[0].strip()
                    return slot

                def _container_type(parent_slot):
                    if parent_slot is None:
                        return "hands"
                    if parent_slot =="waistband":
                        return "waistband"
                    parent = save_data.get("equipment", {}).get(parent_slot)
                    if parent and isinstance(parent, dict):
                        pname = parent.get("name", "").lower()
                        ptypes =[pt.lower()for pt in parent.get("weapon_types", [])if isinstance(pt, str)]
                        if "pistol"in ptypes or "holster"in pname:
                            return "holster"
                        if parent.get("holster_sling"):
                            return "sling"
                    return "unknown"

                old_entry = equipped_weapons[cur_idx]if 0 <=cur_idx <len(equipped_weapons)else None
                new_entry = equipped_weapons[new_idx]

                old_parent = _parent_slot_from_entry(old_entry)if old_entry else None
                new_parent = _parent_slot_from_entry(new_entry)

                old_type = _container_type(old_parent)
                new_type = _container_type(new_parent)

                if old_type in("sling", "waistband"):
                    self._safe_sound_play("", "sounds/firearms/universal/slingunequip.ogg", block = True)
                elif old_type =="holster":
                    self._safe_sound_play("", "sounds/firearms/universal/holsterunequip.ogg", block = True)

                combat_state["current_weapon_index"]= new_idx

                if new_type in("sling", "waistband"):
                    self._safe_sound_play("", "sounds/firearms/universal/slingequip.ogg", block = False)
                elif new_type =="holster":
                    self._safe_sound_play("", "sounds/firearms/universal/holsterequip.ogg", block = False)

                try:
                    new_weapon = new_entry["item"]
                    self._play_firearm_sound(new_weapon, "equip")
                except Exception:
                    pass
            except Exception:
                pass
            refresh_weapon_display()

        def on_left_arrow(event):
            logging.debug("Left arrow pressed - switching weapon")
            select_previous()

        def on_right_arrow(event):
            logging.debug("Right arrow pressed - switching weapon")
            select_next()

        self.root.bind("<Left>", on_left_arrow)
        self.root.bind("<Right>", on_right_arrow)

        self._create_sound_button(
        weapon_switch_frame,
        text = "â† Previous Weapon",
        command = select_previous,
        width = 150,
        height = 40
        ).pack(side = "left", padx = 10, pady = 10)

        active_ub = combat_state.get("active_underbarrel")
        def _resolve_active_underbarrel_obj(active_entry):
            try:
                if not active_entry or not isinstance(active_entry, dict):
                    return None
                parent_index = active_entry.get("parent_index")
                aid = active_entry.get("accessory_id")
                aname = active_entry.get("accessory_name")
                try:
                    logging.info("Resolving active underbarrel: parent_index=%s accessory_id=%s accessory_name=%s current_weapon_index=%s equipped_count=%s",
                    parent_index, aid, aname, combat_state.get("current_weapon_index"), len(equipped_weapons))
                except Exception:
                    pass
                if parent_index is None:
                    return None
                if parent_index <0 or parent_index >=len(equipped_weapons):
                    return None
                parent_slot = equipped_weapons[parent_index].get("slot", "")
                try:
                    logging.info("Resolved parent_slot from equipped_weapons[%s]-> %s", parent_index, parent_slot)
                except Exception:
                    pass

                if "->"in parent_slot:
                    parent_slot = parent_slot.split("->")[0].strip()
                parent_item = save_data.get("equipment", {}).get(parent_slot)
                try:
                    logging.info("Parent item found: %s", bool(parent_item))
                except Exception:
                    pass
                if not parent_item or not isinstance(parent_item, dict):
                    try:
                        logging.info("No parent_item present for slot '%s'", parent_slot)
                    except Exception:
                        pass
                    return None

                for acc in parent_item.get("accessories", [])or[]:
                    cur = acc.get("current")
                    try:
                        logging.info("Checking parent accessory entry current=%s", repr(cur))
                    except Exception:
                        pass
                    if isinstance(cur, dict):
                        if aid is not None and cur.get("id")==aid:
                            try:
                                logging.info("Resolver matched accessory by id: %s", cur.get("id"))
                            except Exception:
                                pass
                            return cur
                        if aname and cur.get("name")==aname:
                            try:
                                logging.info("Resolver matched accessory by name: %s", cur.get("name"))
                            except Exception:
                                pass
                            return cur
                    else:

                        try:
                            if aid is not None and(isinstance(cur, int)or(isinstance(cur, str)and cur.isdigit()))and int(cur)==int(aid):

                                tables = table_data.get("tables", {})if isinstance(table_data, dict)else {}
                                for arr in tables.values():
                                    if isinstance(arr, list):
                                        for it in arr:
                                            if isinstance(it, dict)and it.get("id")==int(cur):
                                                return it
                        except Exception:
                            pass

                for sub in parent_item.get("subslots", [])or[]:
                    try:
                        logging.info("Checking parent subslot '%s' for accessories", sub.get("name"))
                    except Exception:
                        pass
                    sub_cur = sub.get("current")if isinstance(sub, dict)else None
                    if not sub_cur or not isinstance(sub_cur, dict):
                        continue
                    for acc in sub_cur.get("accessories", [])or[]:
                        cur = acc.get("current")
                        try:
                            logging.info("Checking subslot accessory entry current=%s", repr(cur))
                        except Exception:
                            pass
                        if isinstance(cur, dict):
                            if aid is not None and cur.get("id")==aid:
                                try:
                                    logging.info("Resolver matched accessory in subslot by id: %s", cur.get("id"))
                                except Exception:
                                    pass
                                return cur
                            if aname and cur.get("name")==aname:
                                try:
                                    logging.info("Resolver matched accessory in subslot by name: %s", cur.get("name"))
                                except Exception:
                                    pass
                                return cur
                        else:
                            try:
                                if aid is not None and(isinstance(cur, int)or(isinstance(cur, str)and cur.isdigit()))and int(cur)==int(aid):
                                    tables = table_data.get("tables", {})if isinstance(table_data, dict)else {}
                                    for arr in tables.values():
                                        if isinstance(arr, list):
                                            for it in arr:
                                                if isinstance(it, dict)and it.get("id")==int(cur):
                                                    return it
                            except Exception:
                                pass
                return None
            except Exception:
                return None

        try:
            logging.info("Active underbarrel raw state: %s", repr(active_ub))
        except Exception:
            pass
        resolved_active_acc = _resolve_active_underbarrel_obj(active_ub)
        try:
            if resolved_active_acc is not None and hasattr(resolved_active_acc, 'get')and callable(getattr(resolved_active_acc, 'get')):
                name = resolved_active_acc.get('name', resolved_active_acc)
            else:
                name = resolved_active_acc
            logging.info("Resolved active accessory from resolver: %s", name)
        except Exception:
            try:
                logging.info("Resolved active accessory: %s", str(resolved_active_acc))
            except Exception:
                pass
        if active_ub and isinstance(active_ub, dict)and active_ub.get("parent_index")==combat_state.get("current_weapon_index")and resolved_active_acc:

            current_weapon = resolved_active_acc
            current_weapon_data = {"item":current_weapon, "slot":f"{equipped_weapons[combat_state['current_weapon_index']]['slot']} -> underbarrel"}
        else:
            current_weapon_data = equipped_weapons[combat_state["current_weapon_index"]]
            current_weapon = current_weapon_data["item"]
        current_weapon_state = {
        "weapon":current_weapon,
        "ammo_label_ref":None,
        "original_ammo_text":"",
        "clean_label_ref":None
        }
        weapon_name_label = customtkinter.CTkLabel(
        weapon_switch_frame,
        text = f"Selected: {current_weapon.get('name', 'Unknown')}",
        font = customtkinter.CTkFont(size = 14, weight = "bold")
        )
        weapon_name_label.pack(side = "left", padx = 20, pady = 10, expand = True)

        self._create_sound_button(
        weapon_switch_frame,
        text = "Next Weapon â†’",
        command = select_next,
        width = 150,
        height = 40
        ).pack(side = "right", padx = 10, pady = 10)

        details_frame = customtkinter.CTkFrame(main_frame)
        details_frame.pack(fill = "both", expand = True, pady =(0, 20))

        try:
            self._apply_item_overrides(current_weapon)
        except Exception:
            pass
        self._display_weapon_details(details_frame, current_weapon, combat_state, save_data, table_data, current_weapon_state)

        def update_weapon_view():

            wpn = current_weapon_state["weapon"]
            weapon_name_label.configure(text = f"Selected: {wpn.get('name', 'Unknown')}")
            for child in details_frame.winfo_children():
                child.destroy()

            sd = globals().get('save_data')if 'save_data'in globals()else save_data
            try:
                self._apply_item_overrides(wpn)
            except Exception:
                pass
            self._display_weapon_details(details_frame, wpn, combat_state, sd, table_data, current_weapon_state)

            try:
                dev_menu = current_weapon_state.get("dev_variant_menu_ref")
                dev_var = current_weapon_state.get("dev_variant_var")
                dev_cal_menu = current_weapon_state.get("dev_caliber_menu_ref")
                dev_cal_var = current_weapon_state.get("dev_caliber_var")
                if dev_menu and dev_var is not None:

                    try:

                        new_choices =[]
                        caliber_list = wpn.get("caliber", [])or[]

                        try:
                            if dev_cal_var and hasattr(dev_cal_var, 'get'):
                                sel_cal = dev_cal_var.get()
                                if sel_cal:
                                    cal = sel_cal
                                else:
                                    cal = caliber_list[0]if caliber_list else None
                            else:
                                cal = caliber_list[0]if caliber_list else None
                        except Exception:
                            cal = caliber_list[0]if caliber_list else None
                        ammo_tables = table_data.get("tables", {}).get("ammunition", [])if table_data else[]
                        for ammo in ammo_tables:
                            try:
                                if cal and ammo.get("caliber")==cal:
                                    for var in ammo.get("variants", [])or[]:
                                        new_choices.append(var.get("name", "Unknown"))
                                else:
                                    w_sounds = wpn.get("sounds")or wpn.get("sound_folder")or wpn.get("ammo_type")
                                    if w_sounds and(ammo.get("sounds")==w_sounds or ammo.get("ammo_type")==w_sounds):
                                        for var in ammo.get("variants", [])or[]:
                                            new_choices.append(var.get("name", "Unknown"))
                            except Exception:
                                pass
                        if not new_choices:
                            new_choices =["Ball"]

                        try:
                            dev_menu.configure(values = new_choices)
                            if dev_var.get()not in new_choices:
                                dev_var.set(new_choices[0])
                        except Exception:

                            try:
                                dev_menu.set_values(new_choices)
                                if dev_var.get()not in new_choices:
                                    dev_var.set(new_choices[0])
                            except Exception:
                                pass

                        try:
                            if dev_cal_menu is not None and dev_cal_var is not None:
                                calib_vals =[]
                                if isinstance(caliber_list, (list, tuple)):
                                    calib_vals =[str(x)for x in caliber_list if x is not None]
                                elif isinstance(caliber_list, str):
                                    calib_vals =[caliber_list]
                                if not calib_vals:
                                    calib_vals =[""]
                                try:
                                    dev_cal_menu.configure(values = calib_vals)
                                    if dev_cal_var.get()not in calib_vals:
                                        try:
                                            dev_cal_var.set(calib_vals[0])
                                        except Exception:
                                            pass

                                    if len(calib_vals)<=1:
                                        try:
                                            dev_cal_menu.configure(state = "disabled")
                                        except Exception:
                                            pass
                                    else:
                                        try:
                                            dev_cal_menu.configure(state = "normal")
                                        except Exception:
                                            pass
                                except Exception:
                                    try:
                                        dev_cal_menu.set_values(calib_vals)
                                    except Exception:
                                        pass
                        except Exception:
                            pass
                    except Exception:
                        pass
            except Exception:
                pass
            sd2 = globals().get('save_data')if 'save_data'in globals()else save_data
            self._save_combat_state(sd2)

            try:
                rb = current_weapon_state.get('reload_mag_btn_ref')
                if rb:
                    def _hands_have_compatible_rounds(wpn):
                        try:

                            if wpn and isinstance(wpn, dict)and wpn.get('has_ammo_in_pool')is False:
                                return False
                            cal_list = wpn.get('caliber')if isinstance(wpn, dict)else None
                            cal = None
                            if isinstance(cal_list, (list, tuple)):
                                cal = str(cal_list[0])if cal_list else None
                            elif isinstance(cal_list, str):
                                cal = cal_list

                            for itm in save_data.get('hands', {}).get('items', []):
                                if not itm or not isinstance(itm, dict):
                                    continue

                                if itm.get('magazinesystem')or itm.get('capacity'):
                                    continue

                                rds = itm.get('rounds')
                                if isinstance(rds, list)and rds:
                                    first = rds[0]
                                    if isinstance(first, dict)and cal and str(first.get('caliber'))==str(cal):
                                        return True
                                    if isinstance(first, str)and cal and str(cal)in first:
                                        return True

                                    return True

                                qty = int(itm.get('quantity')or 0)if isinstance(itm.get('quantity'), (int, float))else 0
                                if qty >0:
                                    ical = itm.get('caliber')or itm.get('name')
                                    if not cal or(ical and str(ical)==str(cal)):
                                        return True

                                if itm.get('caliber')and(not cal or str(itm.get('caliber'))==str(cal)):
                                    return True
                            return False
                        except Exception:
                            return False

                    def _inventory_has_nonfull_magazine():
                        try:
                            def check_item(itm):
                                if not itm or not isinstance(itm, dict):
                                    return False
                                cap = itm.get('capacity')
                                if cap is None:
                                    return False
                                try:
                                    cap_i = int(cap)
                                except Exception:
                                    return False
                                rounds = itm.get('rounds')
                                cur = 0
                                if isinstance(rounds, list):
                                    cur = len(rounds)
                                else:
                                    try:
                                        cur = int(rounds or 0)
                                    except Exception:
                                        cur = 0
                                return cur <cap_i

                            for itm in save_data.get('hands', {}).get('items', []):
                                try:
                                    if check_item(itm):
                                        return True
                                except Exception:
                                    pass
                            for slot_name, eq_item in save_data.get('equipment', {}).items():
                                try:
                                    if not eq_item or not isinstance(eq_item, dict):
                                        continue
                                    for itm in eq_item.get('items', [])or[]:
                                        try:
                                            if check_item(itm):
                                                return True
                                        except Exception:
                                            pass
                                    for sub in eq_item.get('subslots', [])or[]:
                                        try:
                                            curr = sub.get('current')
                                            if curr and isinstance(curr, dict):
                                                for itm in curr.get('items', [])or[]:
                                                    try:
                                                        if check_item(itm):
                                                            return True
                                                    except Exception:
                                                        pass
                                        except Exception:
                                            pass
                                except Exception:
                                    pass
                            return False
                        except Exception:
                            return False

                    def _inventory_has_nonempty_magazine():

                        try:
                            def check_mag(itm):
                                if not itm or not isinstance(itm, dict):
                                    return False
                                if itm.get('capacity')is None:
                                    return False
                                rounds = itm.get('rounds', [])
                                return isinstance(rounds, list)and len(rounds)>0

                            for itm in save_data.get('hands', {}).get('items', []):
                                if check_mag(itm):
                                    return True
                            for slot_name, eq_item in save_data.get('equipment', {}).items():
                                try:
                                    if not eq_item or not isinstance(eq_item, dict):
                                        continue
                                    for itm in eq_item.get('items', [])or[]:
                                        if check_mag(itm):
                                            return True
                                    for sub in eq_item.get('subslots', [])or[]:
                                        try:
                                            curr = sub.get('current')
                                            if curr and isinstance(curr, dict):
                                                for itm in curr.get('items', [])or[]:
                                                    if check_mag(itm):
                                                        return True
                                        except Exception:
                                            pass
                                except Exception:
                                    pass

                            wpn = current_weapon_state.get('weapon')or {}
                            loaded_mag = wpn.get('loaded')
                            if check_mag(loaded_mag):
                                return True
                            return False
                        except Exception:
                            return False

                    has_nonfull = _inventory_has_nonfull_magazine()
                    has_nonempty = _inventory_has_nonempty_magazine()
                    enabled = has_nonfull or has_nonempty
                    try:
                        rb.configure(state = 'normal'if enabled else 'disabled')
                    except Exception:
                        try:
                            if not enabled:
                                rb.configure(state = 'disabled')
                            else:
                                rb.configure(state = 'normal')
                        except Exception:
                            pass
            except Exception:
                pass

        nvg_btn = None

        def _find_nvg_item():

            def _is_nvg(itm):
                try:
                    if not itm or not isinstance(itm, dict):
                        return False
                    iid = itm.get("id")
                    if iid is not None and str(iid)=="98":
                        return True
                    if itm.get("night_vision"):
                        return True
                    name = itm.get("name")or ""
                    if isinstance(name, str)and "night"in name.lower()and "vision"in name.lower():
                        return True
                except Exception:
                    pass
                return False

            try:

                for itm in save_data.get("hands", {}).get("items", []):
                    try:
                        if _is_nvg(itm):
                            return itm
                    except Exception:
                        pass

                for slot_name, eq in save_data.get("equipment", {}).items():
                    try:
                        if not eq:
                            continue
                        if "items"in eq and isinstance(eq["items"], list):
                            for itm in eq["items"]:
                                try:
                                    if _is_nvg(itm):
                                        return itm
                                except Exception:
                                    pass

                        if "subslots"in eq:
                            for sub in eq.get("subslots", []):
                                try:
                                    curr = sub.get("current")if isinstance(sub, dict)else None

                                    try:
                                        if _is_nvg(curr):
                                            return curr
                                    except Exception:
                                        pass

                                    if curr and "items"in curr and isinstance(curr["items"], list):
                                        for itm in curr["items"]:
                                            try:
                                                if _is_nvg(itm):
                                                    return itm
                                            except Exception:
                                                pass

                                    try:
                                        nested = curr
                                        depth = 0
                                        while isinstance(nested, dict)and depth <4:
                                            nested = nested.get("current")
                                            if _is_nvg(nested):
                                                return nested
                                            depth +=1
                                    except Exception:
                                        pass
                                except Exception:
                                    pass
                    except Exception:
                        pass

                try:
                    for acc in current_weapon.get("accessories", [])or[]:
                        try:
                            cur = acc.get("current")
                            if _is_nvg(cur):
                                return cur

                            if isinstance(cur, dict)and "items"in cur and isinstance(cur["items"], list):
                                for itm in cur["items"]:
                                    try:
                                        if _is_nvg(itm):
                                            return itm
                                    except Exception:
                                        pass
                        except Exception:
                            pass
                except Exception:
                    pass
            except Exception:
                pass
            return None

        def _update_nvg_button():

            try:
                has = _find_nvg_item()is not None
                active = bool(combat_state.get("nvg_active"))
                if nvg_btn is None:
                    return
                if not has:
                    try:
                        nvg_btn.configure(state = "disabled", fg_color = None)
                    except Exception:
                        nvg_btn.configure(state = "disabled")
                    return

                try:
                    nvg_btn.configure(state = "normal")
                    if active:
                        nvg_btn.configure(fg_color = "#228B22", hover_color = "#2E8B57")
                    else:
                        nvg_btn.configure(fg_color = "#444444", hover_color = "#666666")
                except Exception:
                    pass
            except Exception:
                pass

        actions_outer_frame = customtkinter.CTkFrame(main_frame)
        actions_outer_frame.pack(fill = "x", pady =(0, 20))

        actions_frame = customtkinter.CTkScrollableFrame(actions_outer_frame, orientation = "horizontal", height = 280, fg_color = "transparent")
        actions_frame.pack(fill = "x", expand = True)

        rounds_label_frame = customtkinter.CTkFrame(actions_frame)
        rounds_label_frame.pack(fill = "x", padx = 10, pady = 5)

        customtkinter.CTkLabel(
        rounds_label_frame,
        text = "Rounds to Fire:",
        font = customtkinter.CTkFont(size = 12)
        ).pack(side = "left", padx = 10)

        rounds_var = customtkinter.IntVar(value = 3)
        rounds_value_label = customtkinter.CTkLabel(
        rounds_label_frame,
        text = "3",
        font = customtkinter.CTkFont(size = 12, weight = "bold")
        )
        rounds_value_label.pack(side = "left", padx = 5)

        def update_rounds_label(val):

            try:
                iv = int(round(float(val)))
            except Exception:
                try:
                    iv = int(float(val))
                except Exception:
                    iv = 1
            rounds_value_label.configure(text = str(iv))
            try:

                rounds_slider.set(iv)
                rounds_var.set(iv)
            except Exception:
                pass

        rounds_slider = customtkinter.CTkSlider(
        rounds_label_frame,
        from_ = 1,
        to = 10,
        variable = rounds_var,
        command = update_rounds_label,
        width = 200
        )
        rounds_slider.pack(side = "left", padx = 10, expand = True, fill = "x")

        firemode_label_frame = customtkinter.CTkFrame(actions_frame)
        firemode_label_frame.pack(side = "left", padx = 10, pady = 10)

        customtkinter.CTkLabel(
        firemode_label_frame,
        text = "Fire Mode:",
        font = customtkinter.CTkFont(size = 12)
        ).pack(side = "top", padx = 5, pady = 2)

        raw_modes = current_weapon.get("action", ["Semi"])or["Semi"]
        supported_modes =[]
        for m in raw_modes:
            try:
                if isinstance(m, str):
                    supported_modes.append(m.title())
                else:
                    supported_modes.append(str(m))
            except Exception:
                pass
        if not supported_modes:
            supported_modes =["Semi"]

        selected_modes = combat_state.setdefault("selected_firemode", {})
        weapon_id = str(current_weapon.get("id"))
        initial_mode = selected_modes.get(weapon_id, supported_modes[0])
        if initial_mode not in supported_modes:
            initial_mode = supported_modes[0]

        mode_angles = {
        "Safe":0,
        "Semi":90,
        "Auto":180,
        "Burst":270,
        "Bolt":315,
        "Single":135,
        "Double":225,
        "Pump":45
        }

        firemode_var = customtkinter.StringVar(value = initial_mode)

        def play_fireselector_sound():
            self._safe_sound_play("firearms/universal", "fireselector")

        def on_firemode_change(new_mode):
            selected_modes[weapon_id]= new_mode
            play_fireselector_sound()

        dial_canvas = customtkinter.CTkCanvas(
        firemode_label_frame,
        width = 140,
        height = 140,
        bg = "#212121",
        highlightthickness = 0
        )
        dial_canvas.pack(side = "top", padx = 5, pady = 5)

        dial_state = {"current_angle":mode_angles.get(initial_mode, 90), "dragging":False}

        def draw_dial():
            dial_canvas.delete("all")
            center_x, center_y = 70, 70
            radius = 35

            dial_canvas.create_oval(
            center_x -radius, center_y -radius,
            center_x +radius, center_y +radius,
            fill = "#333333", outline = "#555555", width = 2
            )

            labels = {
            0:"SAFE",
            45:"PUMP",
            90:"SEMI",
            135:"SINGLE",
            180:"AUTO",
            225:"DOUBLE",
            270:"BURST",
            315:"BOLT"
            }

            for mode, angle in mode_angles.items():
                if mode not in supported_modes:
                    continue
                rad = math.radians(angle)

                x1 = center_x +(radius -8)*math.cos(rad)
                y1 = center_y +(radius -8)*math.sin(rad)
                x2 = center_x +radius *math.cos(rad)
                y2 = center_y +radius *math.sin(rad)
                dial_canvas.create_line(x1, y1, x2, y2, fill = "#888888", width = 3)

                label_dist = radius +14
                label_x = center_x +label_dist *math.cos(rad)
                label_y = center_y +label_dist *math.sin(rad)
                dial_canvas.create_text(
                label_x, label_y,
                text = labels.get(angle, mode),
                fill = "#AAAAAA",
                font =("Arial", 9, "bold")
                )

            current_angle = dial_state["current_angle"]
            rad = math.radians(current_angle)
            pointer_x = center_x +28 *math.cos(rad)
            pointer_y = center_y +28 *math.sin(rad)
            dial_canvas.create_line(center_x, center_y, pointer_x, pointer_y, fill = "#FF4444", width = 4)

            knob_radius = 6
            dial_canvas.create_oval(
            center_x -knob_radius, center_y -knob_radius,
            center_x +knob_radius, center_y +knob_radius,
            fill = "#FF4444", outline = "#FFFFFF", width = 2
            )

            dial_canvas.create_text(
            center_x, 10,
            text = firemode_var.get(),
            fill = "#00FF00",
            font =("Arial", 11, "bold")
            )

        def get_angle_from_point(x, y):

            center_x, center_y = 70, 70
            dx = x -center_x
            dy = y -center_y
            angle = math.degrees(math.atan2(dy, dx))%360
            return angle

        def snap_to_nearest_mode(angle):

            best_mode = None
            best_diff = 360

            for mode, mode_angle in mode_angles.items():
                if mode not in supported_modes:
                    continue
                diff = min(abs(angle -mode_angle), 360 -abs(angle -mode_angle))
                if diff <best_diff:
                    best_diff = diff
                    best_mode = mode

            return best_mode, mode_angles.get(best_mode or "", angle)

        def on_mouse_down(event):
            center_x, center_y = 70, 70
            dx = event.x -center_x
            dy = event.y -center_y
            distance = math.sqrt(dx **2 +dy **2)

            if distance <40:
                dial_state["dragging"]= True

        def on_mouse_move(event):
            if not dial_state["dragging"]:
                return

            angle = get_angle_from_point(event.x, event.y)
            dial_state["current_angle"]= angle
            draw_dial()

        def on_mouse_up(event):
            if not dial_state["dragging"]:
                return

            dial_state["dragging"]= False

            best_mode, snapped_angle = snap_to_nearest_mode(dial_state["current_angle"])
            if best_mode:
                dial_state["current_angle"]= snapped_angle
                firemode_var.set(best_mode)
                on_firemode_change(best_mode)
                draw_dial()

        dial_canvas.bind("<Button-1>", on_mouse_down)
        dial_canvas.bind("<B1-Motion>", on_mouse_move)
        dial_canvas.bind("<ButtonRelease-1>", on_mouse_up)

        if len(supported_modes)==1:
            dial_canvas.configure(state = "disabled")

        draw_dial()

        attach_mode_frame = customtkinter.CTkFrame(actions_frame)
        attach_mode_frame.pack(side = "left", padx = 10, pady = 10)

        customtkinter.CTkLabel(
        attach_mode_frame,
        text = "Attachment Mode:",
        font = customtkinter.CTkFont(size = 12)
        ).pack(side = "top", padx = 5, pady = 2)

        attach_canvas = customtkinter.CTkCanvas(
        attach_mode_frame,
        width = 140,
        height = 140,
        bg = "#212121",
        highlightthickness = 0
        )
        attach_canvas.pack(side = "top", padx = 5, pady = 5)

        acc_with_modes = None
        acc_modes =[]
        acc_slot_ref = None
        attachments_with_modes =[]
        for ai, acc in enumerate(current_weapon.get("accessories", [])or[]):
            cur = acc.get("current")
            if cur and isinstance(cur, dict)and isinstance(cur.get("modes"), list)and cur.get("modes"):

                display = str(cur.get('name', 'Attachment'))
                attachments_with_modes.append((ai, acc, display))

        attach_select_var = customtkinter.StringVar(value = "")
        def _update_attachment_selection(choice):
            nonlocal acc_with_modes, acc_modes, acc_slot_ref, attachments_with_modes

            attachments_with_modes =[]
            for ai, acc in enumerate(current_weapon.get("accessories", [])or[]):
                cur = acc.get("current")
                if cur and isinstance(cur, dict)and isinstance(cur.get("modes"), list)and cur.get("modes"):
                    display = str(cur.get('name', 'Attachment'))
                    attachments_with_modes.append((ai, acc, display))

            try:
                new_names =[disp for(_ai, _acc, disp)in attachments_with_modes]
                if hasattr(attach_mode_frame, 'mode_option')and attach_mode_frame.mode_option:
                    try:
                        attach_mode_frame.mode_option.configure(values = new_names)
                    except Exception:
                        pass
                if 'attach_select'in locals()or 'attach_select'in globals():
                    try:
                        attach_select.configure(values = new_names)
                    except Exception:
                        pass
            except Exception:
                logging.exception("Failed to refresh attachment option menu values")

            sel = None
            for ai, acc, disp in attachments_with_modes:
                if disp ==choice:
                    sel =(ai, acc)
                    break
            if sel is None:
                acc_with_modes = None
                acc_modes =[]
                acc_slot_ref = None
            else:
                acc_with_modes = sel[1]
                cur =(acc_with_modes.get("current")if isinstance(acc_with_modes, dict)else None)or {}
                orig_modes = cur.get("modes")or[]

                try:
                    cleaned =[m for m in orig_modes if not(isinstance(m, dict)and m.get("mode_method")is not None and not m.get("name"))]
                except Exception:
                    cleaned = orig_modes

                try:
                    if acc_with_modes.get("_mode_index")is None:
                        acc_with_modes["_mode_index"]= 0
                    else:
                        old_idx = int(acc_with_modes.get("_mode_index")or 0)
                        if 0 <=old_idx <len(orig_modes):
                            try:
                                elem = orig_modes[old_idx]
                                if elem in cleaned:
                                    acc_with_modes["_mode_index"]= int(cleaned.index(elem))
                                else:
                                    acc_with_modes["_mode_index"]= 0
                            except Exception:
                                acc_with_modes["_mode_index"]= 0
                except Exception:
                    try:
                        acc_with_modes["_mode_index"]= int(acc_with_modes.get("_mode_index")or 0)
                    except Exception:
                        acc_with_modes["_mode_index"]= 0

                acc_modes = cleaned
                acc_slot_ref = acc_with_modes

                try:
                    if acc_modes:
                        idx = int(acc_with_modes.get("_mode_index")or 0)
                        idx = max(0, min(idx, len(acc_modes)-1))
                        mode_obj = acc_modes[idx]
                        pos_deg = mode_obj.get("position")if isinstance(mode_obj, dict)else None
                        if pos_deg is None:
                            pos_deg =(idx *(360.0 /max(1, len(acc_modes))))
                        try:
                            attach_state["current_angle"]= float(pos_deg)
                        except Exception:
                            pass
                except Exception:
                    pass

                _refresh_mode_controls()
            draw_attach_dial()

        attach_names =[disp for(_ai, _acc, disp)in attachments_with_modes]
        if attach_names:
            attach_select = customtkinter.CTkOptionMenu(attach_mode_frame, values = attach_names, variable = attach_select_var, command = _update_attachment_selection)
            attach_select.pack(side = "top", padx = 5, pady =(2, 4))

            attach_select_var.set(attach_names[0])
        else:

            customtkinter.CTkLabel(attach_mode_frame, text = "No attachment selected", font = customtkinter.CTkFont(size = 10), text_color = "#888888").pack(side = "top", padx = 5, pady =(2, 4))

        attach_mode_var = customtkinter.StringVar(value = "")
        attach_mode_slider = None

        def _refresh_mode_controls():
            nonlocal attach_mode_slider

            visible_modes =[]
            mode_index_map =[]
            for mi, mode in enumerate(acc_modes):
                if isinstance(mode, dict)and mode.get("mode_method")is not None and not mode.get("name"):

                    continue

                visible_modes.append(mode)
                mode_index_map.append(mi)
            mode_names =[]
            for vmi, mode in enumerate(visible_modes):
                if isinstance(mode, dict):
                    mode_names.append(mode.get("name", f"Mode {vmi}"))
                else:
                    mode_names.append(str(mode))

            mode_method = None
            try:

                cur =(acc_with_modes.get("current")if acc_with_modes else None)or {}
                mode_method = cur.get("mode_method")
                if not mode_method and acc_with_modes and isinstance(acc_with_modes, dict):
                    mode_method = acc_with_modes.get("mode_method")
                if not mode_method and acc_slot_ref and isinstance(acc_slot_ref, dict):
                    mode_method = acc_slot_ref.get("mode_method")

                if not mode_method:
                    for m in acc_modes:
                        if isinstance(m, dict)and m.get("mode_method"):
                            mode_method = m.get("mode_method")
                            break
            except Exception:
                mode_method = None

            if not mode_method:
                has_position = any(isinstance(m, dict)and m.get("position")is not None for m in acc_modes)
                mode_method = "dial"if has_position else "option"

            try:

                if mode_method =="option":
                    if hasattr(attach_mode_frame, 'mode_option'):
                        try:
                            attach_mode_frame.mode_option.configure(values = mode_names)
                            attach_mode_frame.mode_option.pack(side = "top", padx = 5, pady =(2, 4))
                        except Exception:
                            pass
                    else:
                        attach_mode_frame.mode_option = customtkinter.CTkOptionMenu(attach_mode_frame, values = mode_names, variable = attach_mode_var, command = lambda v:_set_mode_by_name(v))
                        attach_mode_frame.mode_option.pack(side = "top", padx = 5, pady =(2, 4))
                else:

                    if hasattr(attach_mode_frame, 'mode_option'):
                        try:
                            attach_mode_frame.mode_option.pack_forget()
                        except Exception:
                            pass
            except Exception:
                logging.exception("Failed to refresh mode option menu")

            try:

                if mode_method =="slider":

                    if hasattr(attach_mode_frame, 'mode_slider')and attach_mode_frame.mode_slider:
                        try:
                            attach_mode_frame.mode_slider.configure(from_ = 0, to = max(0, len(visible_modes)-1), number_of_steps = max(1, len(visible_modes)-1))
                            attach_mode_frame.mode_slider.pack(side = "top", padx = 5, pady =(2, 6), fill = "x")
                        except Exception:
                            pass
                    else:
                        attach_mode_frame.mode_slider = customtkinter.CTkSlider(attach_mode_frame, from_ = 0, to = max(0, len(visible_modes)-1), number_of_steps = max(1, len(visible_modes)-1), command = lambda v:_set_mode_by_index(round(float(v))))
                        attach_mode_frame.mode_slider.pack(side = "top", padx = 5, pady =(2, 6), fill = "x")
                else:

                    if hasattr(attach_mode_frame, 'mode_slider')and attach_mode_frame.mode_slider:
                        try:
                            attach_mode_frame.mode_slider.pack_forget()
                        except Exception:
                            pass
            except Exception:
                logging.exception("Failed to refresh mode slider")

            if acc_with_modes and acc_modes:
                actual_mi = int(acc_with_modes.get("_mode_index")or 0)

                try:
                    vis_index = mode_index_map.index(actual_mi)if actual_mi in mode_index_map else 0
                except Exception:
                    vis_index = 0
                try:
                    attach_mode_var.set(mode_names[vis_index]if mode_names else "")
                except Exception:
                    attach_mode_var.set(mode_names[0]if mode_names else "")
                try:
                    attach_mode_frame.mode_slider.set(vis_index)
                except Exception:
                    pass

            attach_mode_frame._visible_modes = visible_modes
            attach_mode_frame._mode_index_map = mode_index_map

            try:
                if not hasattr(attach_mode_frame, 'mode_label')or attach_mode_frame.mode_label is None:
                    attach_mode_frame.mode_label = customtkinter.CTkLabel(attach_mode_frame, text = "", font = customtkinter.CTkFont(size = 12, weight = "bold"), text_color = "#44AAFF")
            except Exception:
                attach_mode_frame.mode_label = None

            try:
                ml = getattr(attach_mode_frame, 'mode_label', None)
                current_mode_name = ""
                try:
                    if acc_with_modes and acc_modes:
                        actual_mi = int(acc_with_modes.get("_mode_index")or 0)
                        actual_mi = max(0, min(actual_mi, len(acc_modes)-1))
                        mode_obj = acc_modes[actual_mi]
                        current_mode_name = mode_obj.get("name")if isinstance(mode_obj, dict)else str(mode_obj)
                except Exception:
                    current_mode_name = ""
                if ml:
                    try:
                        ml.configure(text = current_mode_name)
                    except Exception:
                        pass
                    try:
                        if mode_method in("slider", "option"):
                            ml.pack(side = "top", padx = 5, pady =(0, 6))
                        else:
                            ml.pack_forget()
                    except Exception:
                        pass
            except Exception:
                pass

            try:
                if mode_method =="dial":
                    try:
                        attach_canvas.pack(side = "top", padx = 5, pady = 5)
                    except Exception:
                        pass

                    attach_canvas.configure(state = "normal")
                else:
                    try:
                        attach_canvas.pack_forget()
                    except Exception:
                        pass
            except Exception:
                logging.exception("Failed to adjust attach canvas visibility")

        def _set_mode_by_name(name):
            if not acc_with_modes or not acc_modes:
                return

            vis = getattr(attach_mode_frame, '_visible_modes', None)
            map_ = getattr(attach_mode_frame, '_mode_index_map', None)
            if vis is not None and map_ is not None:
                for vmi, mode in enumerate(vis):
                    mode_name = mode.get("name")if isinstance(mode, dict)else str(mode)
                    if mode_name ==name:

                        actual = map_[vmi]
                        _set_mode_by_index(actual)
                        return

            for mi, mode in enumerate(acc_modes):
                mode_name = mode.get("name")if isinstance(mode, dict)else str(mode)
                if mode_name ==name:
                    _set_mode_by_index(mi)
                    return

        def _set_mode_by_index(idx):
            if not acc_with_modes or not acc_modes:
                return

            try:
                map_ = getattr(attach_mode_frame, '_mode_index_map', None)
                if map_ is not None and 0 <=int(idx)<len(map_):
                    actual_idx = int(map_[int(idx)])
                else:
                    actual_idx = int(idx)
            except Exception:
                actual_idx = 0
            try:
                old_index = acc_with_modes.get("_mode_index")
            except Exception:
                old_index = None
            try:
                acc_with_modes["_mode_index"]= int(actual_idx)
            except Exception:
                acc_with_modes["_mode_index"]= 0

            try:
                new_index = acc_with_modes.get("_mode_index")
                if new_index !=old_index:
                    self._safe_sound_play("firearms/universal", "fireselector")
            except Exception:
                pass
            try:
                self._apply_item_overrides(current_weapon)
            except Exception:
                logging.exception("Failed to apply overrides after attachment mode change")

            _refresh_mode_controls()

            try:
                mi = int(acc_with_modes.get("_mode_index")or 0)
                pos_deg = acc_modes[mi].get("position")if isinstance(acc_modes[mi], dict)and acc_modes[mi].get("position")is not None else(mi *(360.0 /max(1, len(acc_modes))))
                attach_state["current_angle"]= float(pos_deg)# type: ignore
            except Exception:
                pass

            try:
                ml = getattr(attach_mode_frame, 'mode_label', None)
                if ml:
                    try:
                        mode_obj = acc_modes[int(acc_with_modes.get("_mode_index")or 0)]
                        mname = mode_obj.get("name")if isinstance(mode_obj, dict)else str(mode_obj)
                    except Exception:
                        mname = ""
                    try:
                        ml.configure(text = mname)
                    except Exception:
                        pass
            except Exception:
                pass
            draw_attach_dial()

        attach_state = {"current_angle":90, "dragging":False}

        def draw_attach_dial():
            attach_canvas.delete("all")
            center_x, center_y = 70, 70
            radius = 35
            attach_canvas.create_oval(
            center_x -radius, center_y -radius,
            center_x +radius, center_y +radius,
            fill = "#333333", outline = "#555555", width = 2
            )

            if not acc_modes:
                attach_canvas.create_text(center_x, center_y, text = "No Modes", fill = "#AAAAAA", font =("Arial", 10))
                return

            for mi, mode in enumerate(acc_modes):
                try:
                    pos_deg = None
                    if isinstance(mode, dict):
                        pos_deg = mode.get("position")
                    if pos_deg is None:
                        pos_deg =(mi *(360.0 /max(1, len(acc_modes))))
                    rad = math.radians(float(pos_deg))
                    x1 = center_x +(radius -8)*math.cos(rad)
                    y1 = center_y +(radius -8)*math.sin(rad)
                    x2 = center_x +radius *math.cos(rad)
                    y2 = center_y +radius *math.sin(rad)
                    attach_canvas.create_line(x1, y1, x2, y2, fill = "#888888", width = 3)

                    label_dist = radius +12
                    label_x = center_x +label_dist *math.cos(rad)
                    label_y = center_y +label_dist *math.sin(rad)
                    label_text = mode.get("name", f"Mode {mi}")if isinstance(mode, dict)else str(mode)
                    attach_canvas.create_text(label_x, label_y, text = label_text.upper(), fill = "#AAAAAA", font =("Arial", 9, "bold"))
                except Exception:
                    logging.exception("draw_attach_dial tick failed")

            current_angle = attach_state["current_angle"]
            rad = math.radians(current_angle)
            pointer_x = center_x +28 *math.cos(rad)
            pointer_y = center_y +28 *math.sin(rad)
            attach_canvas.create_line(center_x, center_y, pointer_x, pointer_y, fill = "#44AAFF", width = 4)
            knob_radius = 6
            attach_canvas.create_oval(
            center_x -knob_radius, center_y -knob_radius,
            center_x +knob_radius, center_y +knob_radius,
            fill = "#44AAFF", outline = "#FFFFFF", width = 2
            )

            if acc_with_modes and isinstance(acc_with_modes.get("current"), dict):
                mode_idx = acc_with_modes.get("_mode_index")
                try:
                    mode_idx = int(mode_idx)if mode_idx is not None else 0
                except Exception:
                    mode_idx = 0
                mode_idx = max(0, min(mode_idx, len(acc_modes)-1))
                mode_name = acc_modes[mode_idx].get("name", "Mode")if isinstance(acc_modes[mode_idx], dict)else str(acc_modes[mode_idx])
            else:
                mode_name = "None"

            attach_canvas.create_text(70, 10, text = mode_name, fill = "#00FF00", font =("Arial", 11, "bold"))

        def get_attach_angle_from_point(x, y):
            center_x, center_y = 70, 70
            dx = x -center_x
            dy = y -center_y
            angle = math.degrees(math.atan2(dy, dx))%360
            return angle

        def snap_attach_to_nearest(angle):
            if not acc_modes:
                return None, angle
            best_idx = 0
            best_diff = 360
            for mi, mode in enumerate(acc_modes):
                try:
                    pos_deg = mode.get("position")if isinstance(mode, dict)else None
                    if pos_deg is None:
                        pos_deg =(mi *(360.0 /max(1, len(acc_modes))))
                    md = float(pos_deg)
                    diff = min(abs(angle -md), 360 -abs(angle -md))
                    if diff <best_diff:
                        best_diff = diff
                        best_idx = mi
                except Exception:
                    pass
            chosen_angle = acc_modes[best_idx].get("position")if isinstance(acc_modes[best_idx], dict)and acc_modes[best_idx].get("position")is not None else(best_idx *(360.0 /max(1, len(acc_modes))))
            return best_idx, float(chosen_angle)# type: ignore

        def attach_on_mouse_down(event):
            center_x, center_y = 70, 70
            dx = event.x -center_x
            dy = event.y -center_y
            distance = math.sqrt(dx **2 +dy **2)
            if distance <40:
                attach_state["dragging"]= True

        def attach_on_mouse_move(event):
            if not attach_state["dragging"]:
                return
            angle = get_attach_angle_from_point(event.x, event.y)
            attach_state["current_angle"]= angle
            draw_attach_dial()

        def attach_on_mouse_up(event):
            if not attach_state["dragging"]:
                return
            attach_state["dragging"]= False
            if not acc_modes:
                return
            idx, snapped = snap_attach_to_nearest(attach_state["current_angle"])
            if idx is None:
                return
            attach_state["current_angle"]= snapped

            try:
                old_index = acc_with_modes.get("_mode_index")
            except Exception:
                old_index = None
            try:
                acc_with_modes["_mode_index"]= int(idx)
            except Exception:
                acc_with_modes["_mode_index"]= 0

            try:
                new_index = acc_with_modes.get("_mode_index")
                if new_index !=old_index:
                    self._safe_sound_play("firearms/universal", "fireselector")
            except Exception:
                pass
            try:
                self._apply_item_overrides(current_weapon)
            except Exception:
                logging.exception("Failed to apply overrides after attachment mode change")

            try:
                ml = getattr(attach_mode_frame, 'mode_label', None)
                if ml:
                    try:
                        mode_obj = acc_modes[int(acc_with_modes.get("_mode_index")or 0)]
                        mname = mode_obj.get("name")if isinstance(mode_obj, dict)else str(mode_obj)
                    except Exception:
                        mname = ""
                    try:
                        ml.configure(text = mname)
                    except Exception:
                        pass
            except Exception:
                pass
            draw_attach_dial()

        attach_canvas.bind("<Button-1>", attach_on_mouse_down)
        attach_canvas.bind("<B1-Motion>", attach_on_mouse_move)
        attach_canvas.bind("<ButtonRelease-1>", attach_on_mouse_up)

        if not acc_modes:
            attach_canvas.configure(state = "disabled")

        try:
            if attach_names:
                _update_attachment_selection(attach_names[0])
        except Exception:
            logging.exception("Initial attachment selection failed")

        draw_attach_dial()

        def fire_weapon():
            wpn = current_weapon_state["weapon"]

            try:
                magicsys_local = str(wpn.get("magicsoundsystem")or "").lower()
                is_magic_local =(str(wpn.get("type")or "").lower()=="magic")or(magicsys_local in("hg", "at", "mg", "rf"))
                if is_magic_local:
                    weapon_id_local = str(wpn.get("id"))
                    temp_local = combat_state.get("barrel_temperatures", {}).get(weapon_id_local, combat_state.get("ambient_temperature", 70))
                    overheat_thresh = float(wpn.get("overheat_temp", wpn.get("shutdown_temp", 600)or 600))
                    if temp_local >=overheat_thresh:
                        try:
                            self._popup_show_info("Overheated", "Weapon is overheated and cannot fire.Wait for cooling.")
                        except Exception:
                            pass
                        return
            except Exception:
                pass
            rounds_to_fire = rounds_var.get()
            logging.info(
            "Fire button pressed: weapon=%s, rounds=%s, mode=%s",
            wpn.get("name", "Unknown"),
            rounds_to_fire,
            firemode_var.get()
            )

            def _do_fire():
                try:
                    res = self._fire_weapon(wpn, combat_state, rounds_to_fire, firemode_var.get(), save_data)
                    logging.info("Fire result(background): %s", res)
                    try:

                        self.root.after(0, lambda:self._popup_show_info("Fire Result", res))
                        self.root.after(0, update_weapon_view)
                    except Exception:
                        pass
                except Exception as e:
                    logging.exception("Fire action failed(background): %s", e)
                    try:
                        self.root.after(0, lambda:self._popup_show_info("Fire Error", str(e)))
                    except Exception:
                        pass
                finally:
                    try:
                        fb = current_weapon_state.get('fire_button_ref')
                        if fb:
                            try:
                                self.root.after(0, lambda:(fb.configure(state = 'normal')))
                                self.root.after(0, lambda:fb.configure(text =(current_weapon_state.get('fire_button_orig_text')or "Fire")))
                            except Exception:
                                pass
                    except Exception:
                        pass

            try:
                fb = current_weapon_state.get('fire_button_ref')
                if fb:
                    try:
                        fb.configure(state = 'disabled')
                        fb.configure(text = "Firing...")
                    except Exception:
                        pass
            except Exception:
                pass

            try:
                t = threading.Thread(target = _do_fire, name = "CombatFireThread", daemon = True)
                t.start()
            except Exception:

                try:
                    result = self._fire_weapon(wpn, combat_state, rounds_to_fire, firemode_var.get(), save_data)
                    logging.info("Fire result(sync fallback): %s", result)
                    self._popup_show_info("Fire Result", result)
                except Exception as e:
                    logging.exception("Fire action failed: %s", e)
                    self._popup_show_info("Fire Error", str(e))
                update_weapon_view()

        def reload_weapon():
            wpn = current_weapon_state["weapon"]
            logging.info("Reload requested for %s", wpn.get("name", "Unknown"))
            magazine_system = wpn.get("magazinesystem")
            magazine_type = wpn.get("magazinetype", "").lower()

            pf = None
            try:
                pf = wpn.get("platform")or wpn.get("underbarrel_platform")
            except Exception:
                pf = None
            if wpn.get("underbarrel_weapon")or(pf and pf in getattr(self, "PLATFORM_DEFAULTS", {})):
                result = self._reload_weapon(wpn, save_data)
                self._popup_show_info("Reload Result", result)
                update_weapon_view()
                return

            if wpn.get("infinite_ammo"):
                result = self._reload_weapon(wpn, save_data)
                self._popup_show_info("Reload Result", result)
                update_weapon_view()
                return

            if "internal"in magazine_type or "revolver"in wpn.get("platform", "").lower()or "cylinder"in magazine_type:
                result = self._reload_weapon(wpn, save_data)
                self._popup_show_info("Reload Result", result)
                update_weapon_view()
                return

            if not magazine_system:
                inferred_ms = None
                if wpn.get("magazinetype"):
                    inferred_ms = wpn.get("magazinetype")
                else:
                    loaded_mag = wpn.get("loaded")
                    if isinstance(loaded_mag, dict)and loaded_mag.get("magazinesystem"):
                        inferred_ms = loaded_mag.get("magazinesystem")
                    else:

                        for item in save_data.get("hands", {}).get("items", []):
                            if item and isinstance(item, dict)and("rounds"in item or "capacity"in item):
                                inferred_ms = item.get("magazinesystem")or item.get("magazinetype")
                                if inferred_ms:
                                    break
                        if not inferred_ms:
                            for slot_name, eq_item in save_data.get("equipment", {}).items():
                                if eq_item and isinstance(eq_item, dict):
                                    if "items"in eq_item and isinstance(eq_item["items"], list):
                                        for mag in eq_item["items"]:
                                            if mag and isinstance(mag, dict)and("rounds"in mag or "capacity"in mag):
                                                inferred_ms = mag.get("magazinesystem")or mag.get("magazinetype")
                                                break
                                    if inferred_ms:
                                        break
                if inferred_ms:

                    wpn["magazinesystem"]= inferred_ms

            self._show_magazine_selection_menu(wpn, save_data, table_data, current_weapon_state, update_weapon_view)

        def clean_weapon():
            wpn = current_weapon_state["weapon"]
            logging.info("Clean requested for %s", wpn.get("name", "Unknown"))
            result = self._clean_weapon(wpn, combat_state)
            self._popup_show_info("Clean Result", result)
            update_weapon_view()

        def on_spacebar(event):
            logging.debug("Spacebar pressed - firing")
            fire_weapon()

        self.root.bind("<space>", on_spacebar)

        reload_last_press_time =[0.0]
        reload_pending_id =[None]

        def on_r_press(event):

            current_time = time.time()
            time_since_last = current_time -reload_last_press_time[0]
            reload_last_press_time[0]= current_time

            if reload_pending_id[0]:
                self.root.after_cancel(reload_pending_id[0])
                reload_pending_id[0]= None

            if time_since_last <0.4:
                logging.debug("R double-tapped - auto-reload with drop")
                reload_auto_drop()
            else:

                try:
                    _rid = self.root.after(400, lambda:reload_weapon())
                    reload_pending_id[0]= _rid # type: ignore
                except Exception:
                    reload_pending_id[0]= None

        self.root.bind("r", on_r_press)
        self.root.bind("R", on_r_press)

        def reload_auto_drop():

            wpn = current_weapon_state["weapon"]

            if wpn.get("infinite_ammo"):
                result = self._reload_weapon(wpn, save_data)
                self._popup_show_info("Auto-Reload", result)
                update_weapon_view()
                return

            magazine_system = wpn.get("magazinesystem")
            if not magazine_system:
                self._popup_show_info("Auto-Reload", "Weapon doesn't use detachable magazines")
                return

            all_magazines =[]

            for item in save_data.get("hands", {}).get("items", []):
                if item and isinstance(item, dict)and item.get("magazinesystem")==magazine_system:
                    all_magazines.append(("hands", item))

            for slot_name, eq_item in save_data.get("equipment", {}).items():
                if eq_item and isinstance(eq_item, dict):
                    if "items"in eq_item and isinstance(eq_item["items"], list):
                        for item in eq_item["items"]:
                            if item and isinstance(item, dict)and item.get("magazinesystem")==magazine_system:
                                all_magazines.append(("equipment", item))
                    if "subslots"in eq_item:
                        for subslot in eq_item["subslots"]:
                            if subslot.get("current"):
                                curr = subslot["current"]
                                if "items"in curr and isinstance(curr["items"], list):
                                    for item in curr["items"]:
                                        if item and isinstance(item, dict)and item.get("magazinesystem")==magazine_system:
                                            all_magazines.append(("equipment", item))

            if not all_magazines:
                self._popup_show_info("Auto-Reload", "No compatible magazines in inventory!")
                return

            best_mag_idx = 0
            best_round_count = len(all_magazines[0][1].get("rounds", []))

            for idx, (location, mag_item)in enumerate(all_magazines):
                round_count = len(mag_item.get("rounds", []))
                if round_count >best_round_count:
                    best_round_count = round_count
                    best_mag_idx = idx

            location, mag_item = all_magazines[best_mag_idx]

            current_mag = wpn.get("loaded")
            chambered = wpn.get("chambered")
            is_gun_empty = not chambered and(not current_mag or not current_mag.get("rounds", []))

            try:

                mag_type_current =((current_mag.get("magazinetype")if current_mag else None)or wpn.get("magazinetype")or "").lower()
                platform =(wpn.get("platform")or "").lower()
                is_belt = "belt"in mag_type_current or "belt"in platform or "m249"in platform

                try:
                    logging.debug("reload_auto_drop: weapon=%s platform=%s magazinetype=%s current_mag_present=%s dualfeed=%s submagazinetype=%s submagazinesystem=%s is_belt=%s",
                    wpn.get("name", wpn.get("id", "unknown")),
                    platform,
                    mag_type_current,
                    bool(current_mag),
                    bool(wpn.get("dualfeed")),
                    wpn.get("submagazinetype"),
                    wpn.get("submagazinesystem"),
                    is_belt)
                except Exception:
                    pass

                handled_belt = False

                if current_mag and not("belt"in mag_type_current):

                    try:
                        self._play_weapon_action_sound(wpn, "magout")
                    except Exception:
                        pass

                    time.sleep(random.uniform(0.5, 1.0))

                    try:
                        magdrop_sound = f"magdrop{random.randint(0, 1)}"
                        self._safe_sound_play("", f"sounds/firearms/universal/{magdrop_sound}.ogg")
                    except Exception:
                        pass
                    time.sleep(random.uniform(0.5, 1.0))

                    try:
                        self._safe_sound_play("", "sounds/firearms/universal/pouchout.ogg")
                    except Exception:
                        pass
                    time.sleep(random.uniform(0.25, 0.5))

                    mag_type = wpn.get("magazinetype", "").lower()
                    platform_check = wpn.get("platform", "").lower()
                    if not any(k in mag_type for k in("internal", "tube", "cylinder"))and "revolver"not in platform_check:
                        try:
                            self._play_weapon_action_sound(wpn, "magin")
                        except Exception:
                            pass
                    time.sleep(random.uniform(0.25, 0.5))

                elif is_belt:

                    if wpn.get("dualfeed")and(wpn.get("submagazinesystem")or wpn.get("submagazinetype")):
                        try:
                            self._perform_dualfeed_belt_reload_sequence(wpn)
                        except Exception:
                            pass
                    else:
                        try:
                            self._perform_belt_reload_sequence(wpn)
                        except Exception:
                            pass
                    handled_belt = True

                else:

                    try:
                        self._safe_sound_play("", "sounds/firearms/universal/pouchout.ogg")
                    except Exception:
                        pass
                    time.sleep(0.8)

                if not handled_belt and is_gun_empty:
                    rt_mag_type = str(wpn.get("magazinetype", "")or "").lower()
                    rt_platform_raw = wpn.get("platform", "")or ""
                    if isinstance(rt_platform_raw, (list, tuple)):
                        rt_platform_raw = rt_platform_raw[0]if rt_platform_raw else ""
                    rt_platform = str(rt_platform_raw).lower()
                    rt_action_raw = wpn.get("action", "")or ""
                    if isinstance(rt_action_raw, (list, tuple)):
                        rt_action_raw = rt_action_raw[0]if rt_action_raw else ""
                    rt_action = str(rt_action_raw).lower()
                    is_pump_reload =("pump"in rt_platform or rt_action =="pump"or "pump"in rt_mag_type)

                    if is_pump_reload:
                        try:
                            self._play_weapon_action_sound(wpn, "pumpback", block = True)
                        except Exception:
                            pass
                        try:
                            self._play_weapon_action_sound(wpn, "pumpforward")
                        except Exception:
                            pass
                    elif not wpn.get("bolt_catch"):
                        try:
                            self._play_weapon_action_sound(wpn, "boltback", block = True)
                        except Exception:
                            pass

                        try:
                            self._play_weapon_action_sound(wpn, "boltforward")
                        except Exception:
                            pass
                    else:
                        try:
                            self._play_weapon_action_sound(wpn, "boltforward")
                        except Exception:
                            pass

                try:
                    mag_type =(wpn.get("magazinetype")or "").lower()
                    platform_check =(wpn.get("platform")or "").lower()
                    is_detachable_box =(not any(k in mag_type for k in("internal", "tube", "cylinder"))
                    and "revolver"not in platform_check
                    and "belt"not in mag_type and "belt"not in platform_check
                    and "m249"not in platform_check)
                except Exception:
                    is_detachable_box = True

                if is_detachable_box:

                    time.sleep(0.01)
                else:
                    time.sleep(0.75)
            except Exception as e:
                logging.error(f"reload_auto_drop sound sequence error: {e}")

            if current_mag:
                pass

            previous_chambered = wpn.get("chambered")
            wpn["loaded"]= mag_item

            if is_gun_empty and mag_item.get("rounds", []):

                try:
                    wpn["chambered"]= mag_item["rounds"].pop(0)
                except Exception:
                    wpn["chambered"]= None
            else:

                wpn["chambered"]= previous_chambered

            if location =="hands":
                if mag_item in save_data.get("hands", {}).get("items", []):
                    save_data["hands"]["items"].remove(mag_item)
            elif location =="equipment":

                try:
                    self._play_weapon_action_sound(wpn, "pouchout")
                except Exception:
                    pass
                for slot_name, eq_item in save_data.get("equipment", {}).items():
                    if eq_item:
                        if "items"in eq_item and isinstance(eq_item["items"], list):
                            if mag_item in eq_item["items"]:
                                eq_item["items"].remove(mag_item)
                        if "subslots"in eq_item:
                            for subslot in eq_item["subslots"]:
                                if subslot.get("current"):
                                    curr = subslot["current"]
                                    if "items"in curr and isinstance(curr["items"], list):
                                        if mag_item in curr["items"]:
                                            curr["items"].remove(mag_item)

            mag_name = mag_item.get("name", "magazine")
            rounds = len(mag_item.get("rounds", []))
            chambered_info = " +1 in chamber"if is_gun_empty and wpn.get("chambered")else ""
            self._popup_show_info("Auto-Reload", f"Loaded {mag_name}({rounds}{chambered_info} rounds)!")
            update_weapon_view()

        fire_btn = self._create_sound_button(
        actions_frame,
        text = "Fire(Press SPACE)",
        command = fire_weapon,
        width = 150,
        height = 50,
        font = customtkinter.CTkFont(size = 14)
        )
        fire_btn.pack(side = "left", padx = 10, pady = 10)

        try:
            current_weapon_state['fire_button_ref']= fire_btn
            current_weapon_state['fire_button_orig_text']= "Fire(Press SPACE)"
        except Exception:
            pass

        self._create_sound_button(
        actions_frame,
        text = "Reload(Press R)",
        command = reload_weapon,
        width = 150,
        height = 50,
        font = customtkinter.CTkFont(size = 14)
        ).pack(side = "left", padx = 10, pady = 10)

        self._create_sound_button(
        actions_frame,
        text = "Clean",
        command = clean_weapon,
        width = 150,
        height = 50,
        font = customtkinter.CTkFont(size = 14),
        fg_color = "#006400",
        hover_color = "#228B22"
        ).pack(side = "left", padx = 10, pady = 10)

        def cycle_bolt():
            wpn = current_weapon_state["weapon"]
            logging.info("Cycle bolt requested for %s", wpn.get("name", "Unknown"))
            result = self._cycle_bolt(wpn)
            self._popup_show_info("Bolt Cycle", result)
            update_weapon_view()

        if "Bolt"in current_weapon.get("action", []):
            self._create_sound_button(
            actions_frame,
            text = "Cycle Bolt",
            command = cycle_bolt,
            width = 150,
            height = 50,
            font = customtkinter.CTkFont(size = 14),
            fg_color = "#8B4513",
            hover_color = "#A0522D"
            ).pack(side = "left", padx = 10, pady = 10)

        def _toggle_nvg():
            try:
                nvg_item = _find_nvg_item()
                if not nvg_item:
                    self._popup_show_info("NVG", "No night-vision goggles found in inventory.")
                    try:
                        nvg_btn.configure(state = "disabled")
                    except Exception:
                        pass
                    return
                active = bool(combat_state.get("nvg_active"))

                combat_state["nvg_active"]= not active

                try:
                    combat_state["nvg_item_id"]= int(nvg_item.get("id"))
                except Exception:
                    combat_state["nvg_item_id"]= nvg_item.get("id")

                try:
                    if combat_state["nvg_active"]:
                        self._safe_sound_play("misc/nvg", "on")
                    else:
                        self._safe_sound_play("misc/nvg", "off")
                except Exception:
                    pass

                try:
                    _update_nvg_button()
                except Exception:
                    pass
            except Exception:
                logging.exception("NVG toggle failed")

        try:
            nvg_btn = self._create_sound_button(actions_frame, "NVG", _toggle_nvg, width = 150, height = 50, font = customtkinter.CTkFont(size = 14))
            nvg_btn.pack(side = "left", padx = 10, pady = 10)
        except Exception:
            logging.exception("Failed to create NVG button")
        try:
            _update_nvg_button()
        except Exception:
            pass

        def cooling_tick():
            try:
                ambient_temp = combat_state.get("ambient_temperature", 70)
                temps = combat_state.setdefault("barrel_temperatures", {})
                magic_ids = list(combat_state.get("magic_weapon_ids", {}).keys())

                for mid in magic_ids:
                    try:
                        t = float(temps.get(mid, ambient_temp))
                        if t >ambient_temp:

                            drop = max(1.0, (t -ambient_temp)*0.18)
                            t = max(ambient_temp, t -drop)
                            temps[mid]= t
                    except Exception:
                        pass

                try:
                    w = current_weapon_state.get("weapon")
                    fb = current_weapon_state.get("fire_button_ref")
                    if fb and isinstance(fb, (customtkinter.CTkButton, )):
                        is_magic_w = False
                        try:
                            ms = str(w.get("magicsoundsystem")or "").lower()
                            is_magic_w =(str(w.get("type")or "").lower()=="magic")or(ms in("hg", "at", "mg", "rf"))
                        except Exception:
                            is_magic_w = False

                        if is_magic_w:
                            wid = str(w.get("id"))
                            tnow = temps.get(wid, ambient_temp)
                            overheat_thresh = float(w.get("overheat_temp", w.get("shutdown_temp", 600)or 600))
                            if tnow >=overheat_thresh:
                                try:
                                    fb.configure(state = "disabled")
                                    fb.configure(text =(current_weapon_state.get('fire_button_orig_text')or "Fire")+"(Overheated)")
                                except Exception:
                                    pass
                            else:
                                try:
                                    fb.configure(state = "normal")
                                    fb.configure(text = current_weapon_state.get('fire_button_orig_text')or "Fire")
                                except Exception:
                                    pass
                except Exception:
                    pass
            except Exception:
                logging.exception("cooling_tick failed")
            finally:
                try:
                    self.root.after(1000, cooling_tick)
                except Exception:
                    pass

        try:
            self.root.after(1000, cooling_tick)
        except Exception:
            pass

        def manage_attachments():
            wpn = current_weapon_state["weapon"]
            accessories = wpn.get("accessories", [])or[]
            if not accessories:
                self._popup_show_info("Attachments", "This weapon has no attachment slots.")
                return

            popup = customtkinter.CTkToplevel(self.root)
            popup.title("Attachments")
            popup.transient(self.root)
            self._center_popup_on_window(popup, 420, 400)

            rows =[]

            def candidates_for_slot(slot_req):
                matches =[]

                for itm in save_data.get("hands", {}).get("items", []):
                    if itm and isinstance(itm, dict)and itm.get("attachment"):
                        slot_field = itm.get("slot")
                        if slot_field ==slot_req or(isinstance(slot_field, list)and slot_req in slot_field):
                            matches.append(itm)

                for slot_name, eq_item in save_data.get("equipment", {}).items():
                    if eq_item and "items"in eq_item:
                        for itm in eq_item["items"]:
                            if itm and isinstance(itm, dict)and itm.get("attachment"):
                                slot_field = itm.get("slot")
                                if slot_field ==slot_req or(isinstance(slot_field, list)and slot_req in slot_field):
                                    matches.append(itm)
                return matches

            for acc in accessories:
                frame = customtkinter.CTkFrame(popup)
                frame.pack(fill = "x", padx = 10, pady = 6)
                customtkinter.CTkLabel(frame, text = acc.get("name", "Slot"), font = customtkinter.CTkFont(size = 12, weight = "bold")).pack(anchor = "w")
                opts =[(None, "None")]
                for itm in candidates_for_slot(acc.get("slot")):
                    label = itm.get("name", "Attachment")
                    opts.append((itm, label))

                cur = acc.get("current")
                current_label = "None"
                try:
                    if cur and isinstance(cur, dict):

                        found = False
                        cur_id = cur.get("id")
                        for itm, lbl in opts:
                            try:
                                if itm is cur:
                                    current_label = lbl
                                    found = True
                                    break
                                if isinstance(itm, dict)and cur_id is not None and itm.get("id")==cur_id:
                                    current_label = lbl
                                    found = True
                                    break
                            except Exception:
                                pass
                        if not found:

                            try:
                                installed_label = cur.get("name", "Installed")
                            except Exception:
                                installed_label = "Installed"
                            opts.append((cur, installed_label))# type: ignore
                            current_label = installed_label
                except Exception:
                    current_label = "None"

                current_choice = customtkinter.StringVar(value = current_label)
                option = customtkinter.CTkOptionMenu(frame, values =[o[1]for o in opts], variable = current_choice, width = 220)
                option.pack(anchor = "w", pady = 4)

                def _open_mode_dial_for(acc_ref):
                    try:

                        cur = acc_ref.get("current")
                        if not cur or not isinstance(cur, dict):
                            self._popup_show_info("Attachment Modes", "No attachment installed in this slot.")
                            return
                        modes = cur.get("modes")or[]
                        if not modes or not isinstance(modes, list):
                            self._popup_show_info("Attachment Modes", "This attachment has no selectable modes.")
                            return

                        import tkinter as tk

                        dial = customtkinter.CTkToplevel(self.root)
                        dial.title("Select Mode")
                        size = 320
                        dial.transient(self.root)
                        self._center_popup_on_window(dial, size, size)

                        canvas = tk.Canvas(dial, width = size, height = size, highlightthickness = 0)
                        canvas.pack(fill = "both", expand = True)

                        cx = size //2
                        cy = size //2
                        r = int(size *0.35)

                        canvas.create_oval(cx -r, cy -r, cx +r, cy +r, outline = "#888", width = 2)

                        for mi, mode in enumerate(modes):
                            try:
                                pos_deg = mode.get("position")if isinstance(mode, dict)else None
                                if pos_deg is None:
                                    pos_deg =(mi *(360.0 /max(1, len(modes))))
                                theta = math.radians(float(pos_deg))
                                mx = cx +int(r *math.cos(theta))
                                my = cy +int(r *math.sin(theta))
                                label = mode.get("name", f"Mode {mi}")if isinstance(mode, dict)else str(mode)

                                btn = customtkinter.CTkButton(dial, text = label, width = 110, command =(lambda idx = mi, a = acc_ref, d = dial:_set_mode_and_close(a, idx, d)))

                                canvas.create_window(mx, my, window = btn)
                            except Exception:
                                logging.exception("Failed to render mode button")

                        cur_index = acc_ref.get("_mode_index")
                        if cur_index is None:
                            cur_index = acc_ref.get("mode_index")or 0
                        try:
                            cur_index = int(cur_index)
                        except Exception:
                            cur_index = 0

                        def _set_mode_and_close(acc_set, idx_set, dial_win):
                            try:
                                acc_set["_mode_index"]= int(idx_set)
                            except Exception:
                                acc_set["_mode_index"]= 0
                            try:

                                self._apply_item_overrides(wpn)
                            except Exception:
                                logging.exception("Failed to apply overrides after mode change")
                            try:
                                dial_win.destroy()
                            except Exception:
                                pass

                    except Exception:
                        logging.exception("open_mode_dial failed")

                def _find_table_candidates(slot_req):
                    candidates =[]
                    try:
                        table_files = sorted(glob.glob(os.path.join('tables', f"*{global_variables.get('table_extension', '.sldtbl')}")))
                        for tf in table_files:
                            try:
                                with open(tf, 'r', encoding = 'utf-8')as tfh:
                                    td = json.load(tfh)
                                tables = td.get('tables', {})
                                for subname, items in tables.items():
                                    if not isinstance(items, list):
                                        continue
                                    for it in items:
                                        if not isinstance(it, dict):
                                            continue
                                        matched = False
                                        try:
                                            slot_field = it.get('slot')
                                            if slot_field ==slot_req or(isinstance(slot_field, (list, tuple))and slot_req in slot_field):
                                                matched = True
                                        except Exception:
                                            pass
                                        try:
                                            accs = it.get('accessories')or[]
                                            if isinstance(accs, list):
                                                for a in accs:
                                                    if isinstance(a, dict)and a.get('slot'):
                                                        if a.get('slot')==slot_req:
                                                            matched = True
                                                            break
                                        except Exception:
                                            pass

                                        if matched:

                                            try:
                                                if it.get('firearm'):
                                                    continue
                                            except Exception:
                                                pass
                                            candidates.append((it, tf, subname))
                            except Exception:
                                continue
                    except Exception:
                        pass
                    return candidates

                def _open_add_from_table(acc_ref):
                    try:
                        slot_req = acc_ref.get("slot")
                        if not slot_req:
                            self._popup_show_info("Add From Table", "This slot has no slot name defined.")
                            return

                        candidates =[]
                        table_files = sorted(glob.glob(os.path.join('tables', f"*{global_variables.get('table_extension', '.sldtbl')}")))
                        for tf in table_files:
                            try:
                                with open(tf, 'r', encoding = 'utf-8')as tfh:
                                    td = json.load(tfh)
                                tables = td.get('tables', {})
                                for subname, items in tables.items():
                                    if not isinstance(items, list):
                                        continue
                                    for it in items:
                                        if not isinstance(it, dict):
                                            continue

                                        matched = False
                                        try:
                                            slot_field = it.get('slot')
                                            if slot_field ==slot_req or(isinstance(slot_field, (list, tuple))and slot_req in slot_field):
                                                matched = True
                                        except Exception:
                                            pass
                                        try:
                                            accs = it.get('accessories')or[]
                                            if isinstance(accs, list):
                                                for a in accs:
                                                    if isinstance(a, dict)and a.get('slot'):
                                                        if a.get('slot')==slot_req:
                                                            matched = True
                                                            break
                                        except Exception:
                                            pass
                                        try:
                                            subs = it.get('subslots')or[]
                                            if isinstance(subs, list):
                                                for s in subs:
                                                    if isinstance(s, dict)and s.get('slot'):
                                                        if s.get('slot')==slot_req:
                                                            matched = True
                                                            break
                                        except Exception:
                                            pass

                                        if matched:

                                            try:
                                                if it.get('firearm'):
                                                    continue
                                            except Exception:
                                                pass
                                            candidates.append((it, tf, subname))
                            except Exception:
                                continue

                        if not candidates:
                            self._popup_show_info("Add From Table", f"No table items found for slot '{slot_req}'.")
                            return

                        popup = customtkinter.CTkToplevel(self.root)
                        popup.title("Add From Table")
                        popup.transient(self.root)
                        self._center_popup_on_window(popup, 520, 360)

                        label = customtkinter.CTkLabel(popup, text = f"Select an item to add into slot '{slot_req}':", font = customtkinter.CTkFont(size = 13))
                        label.pack(pady = 8, padx = 12)

                        sel_var = customtkinter.StringVar(value = "")
                        names =[]
                        for it, tf, sub in candidates:
                            names.append(f"{it.get('name', '<unnamed>')}({os.path.basename(tf)}:{sub})")

                        opt = customtkinter.CTkOptionMenu(popup, values = names, variable = sel_var)
                        opt.pack(fill = "x", padx = 12, pady = 8)

                        def _do_add():
                            choice = sel_var.get()
                            if not choice:
                                self._popup_show_info("Add From Table", "Please select an item to add.")
                                return
                            idx = 0
                            try:
                                idx = names.index(choice)
                            except Exception:
                                idx = 0
                            item = candidates[idx][0]
                            try:
                                import copy as _copy
                                new_item = _copy.deepcopy(item)
                                save_data.setdefault('hands', {})
                                save_data['hands'].setdefault('items', [])
                                save_data['hands']['items'].append(new_item)
                                self._popup_show_info("Add From Table", f"Added '{new_item.get('name', 'item')}' to hands.")
                                try:
                                    popup.destroy()
                                except Exception:
                                    pass
                            except Exception as e:
                                logging.exception("Failed to add item from table: %s", e)

                        add_btn = customtkinter.CTkButton(popup, text = "Add Selected", command = _do_add, width = 140)
                        add_btn.pack(pady = 10)

                        cancel_btn = customtkinter.CTkButton(popup, text = "Cancel", command = popup.destroy, width = 120, fg_color = "#444444", hover_color = "#555555")
                        cancel_btn.pack(pady = 6)

                    except Exception as e:
                        logging.exception("_open_add_from_table failed: %s", e)

                dev_ok = False
                try:
                    dev_ok = bool(global_variables.get('devmode', {}).get('value'))
                except Exception:
                    dev_ok = False

                try:
                    slot_req = acc.get('slot')
                    candidates_here = _find_table_candidates(slot_req)if slot_req else[]
                except Exception:
                    candidates_here =[]

                add_table_btn = customtkinter.CTkButton(frame, text = "Add From Table...", width = 140, command =(lambda a = acc:_open_add_from_table(a)))
                if(not dev_ok)or(not candidates_here):
                    try:
                        add_table_btn.configure(state = "disabled")
                    except Exception:
                        pass
                add_table_btn.pack(anchor = "w", pady = 2)

                rows.append((acc, opts, current_choice, None))

            def apply_changes():
                def _sync_attachment_subslot(weapon, flattened_acc, new_value):

                    try:
                        parent_slot = flattened_acc.get('_parent_accessory_slot')
                        subslot_slot = flattened_acc.get('_subslot_slot')
                        if not parent_slot or not subslot_slot:
                            return

                        for parent_acc in weapon.get('accessories', [])or[]:
                            try:
                                if parent_acc.get('slot')!=parent_slot:
                                    continue
                                cur = parent_acc.get('current')
                                if not cur or not isinstance(cur, dict):
                                    continue
                                for sub in cur.get('subslots', [])or[]:
                                    if sub.get('slot')==subslot_slot:
                                        try:
                                            import copy as _c
                                            sub['current']= _c.deepcopy(new_value)if isinstance(new_value, dict)else new_value
                                        except Exception:
                                            sub['current']= new_value
                                        return
                            except Exception:
                                pass
                    except Exception:
                        pass

                for acc, opts, var, subslot_ref in rows:
                    chosen_label = var.get()
                    chosen_item = None
                    for itm, lbl in opts:
                        if lbl ==chosen_label:
                            chosen_item = itm
                            break

                    def _remove_all_references(item):
                        try:
                            if not item or not isinstance(item, dict):
                                return
                            item_id = item.get("id")
                        except Exception:
                            item_id = None

                        def _scan(obj):
                            if isinstance(obj, dict):
                                for k, v in list(obj.items()):
                                    _scan(v)
                            elif isinstance(obj, list):

                                to_remove =[]
                                for el in obj:
                                    try:
                                        if el is item:
                                            to_remove.append(el)
                                        elif isinstance(el, dict)and item_id is not None and el.get("id")==item_id:
                                            to_remove.append(el)
                                    except Exception:
                                        pass
                                for r in to_remove:
                                    try:
                                        while r in obj:
                                            obj.remove(r)
                                    except Exception:
                                        pass
                                for el in obj:
                                    _scan(el)

                        try:
                            _scan(save_data)
                        except Exception:
                            pass

                    if subslot_ref is not None:

                        if subslot_ref.get("current"):
                            try:
                                _remove_all_references(subslot_ref.get("current"))
                            except Exception:
                                pass
                            save_data.get("hands", {}).get("items", []).append(subslot_ref.get("current"))

                        if chosen_item is None:
                            subslot_ref["current"]= None
                        else:
                            try:
                                _remove_all_references(chosen_item)
                            except Exception:
                                pass
                            hands_items = save_data.get("hands", {}).get("items", [])
                            try:
                                if chosen_item in hands_items:
                                    hands_items.remove(chosen_item)
                            except Exception:
                                pass
                            try:
                                for slot_name, eq_item in save_data.get("equipment", {}).items():
                                    if eq_item and "items"in eq_item and isinstance(eq_item["items"], list):
                                        try:
                                            while chosen_item in eq_item["items"]:
                                                eq_item["items"].remove(chosen_item)
                                        except Exception:
                                            pass

                                    if eq_item and "subslots"in eq_item:
                                        for sub in eq_item.get("subslots", []):
                                            if sub and sub.get("current")and "items"in sub.get("current", {}):
                                                try:
                                                    while chosen_item in sub["current"]["items"]:
                                                        sub["current"]["items"].remove(chosen_item)
                                                except Exception:
                                                    pass
                            except Exception:
                                pass

                            try:
                                import copy as _copy
                                new_installed = _copy.deepcopy(chosen_item)if isinstance(chosen_item, dict)else chosen_item
                            except Exception:
                                new_installed = chosen_item

                            subslot_ref["current"]= new_installed

                            try:
                                def _sync_subslot_to_save(accessory_obj, subslot_obj, installed_obj):
                                    try:

                                        aid = accessory_obj.get('id')if isinstance(accessory_obj, dict)else None
                                        aname = accessory_obj.get('name')if isinstance(accessory_obj, dict)else None
                                        aslot = accessory_obj.get('slot')if isinstance(accessory_obj, dict)else None
                                        for slot_name, eq_item in save_data.get('equipment', {}).items():
                                            if not eq_item or not isinstance(eq_item, dict):
                                                continue

                                            for acc in eq_item.get('accessories', [])or[]:
                                                try:
                                                    if not isinstance(acc, dict):
                                                        continue
                                                    match = False
                                                    if aid is not None and acc.get('id')==aid:
                                                        match = True
                                                    elif aname and acc.get('name')==aname:
                                                        match = True
                                                    elif aslot and acc.get('slot')==aslot:
                                                        match = True
                                                    if match:

                                                        for sub in acc.get('current', {}).get('subslots', [])if acc.get('current')else[]:
                                                            try:
                                                                if(sub.get('slot')and sub.get('slot')==subslot_obj.get('slot'))or(sub.get('name')and sub.get('name')==subslot_obj.get('name')):

                                                                    try:
                                                                        import copy as _c
                                                                        sub['current']= _c.deepcopy(installed_obj)if isinstance(installed_obj, dict)else installed_obj
                                                                    except Exception:
                                                                        sub['current']= installed_obj
                                                                    return True
                                                            except Exception:
                                                                pass
                                                except Exception:
                                                    pass
                                        return False
                                    except Exception:
                                        return False

                                try:
                                    _sync_subslot_to_save(acc, subslot_ref, new_installed)
                                except Exception:
                                    pass
                            except Exception:
                                pass

                    else:

                        if acc.get("current"):
                            try:
                                _remove_all_references(acc["current"])
                            except Exception:
                                pass
                            save_data.get("hands", {}).get("items", []).append(acc["current"])

                        if chosen_item is None:
                            acc["current"]= None
                            if acc.get("_is_attachment_subslot"):
                                try:
                                    _sync_attachment_subslot(wpn, acc, None)
                                except Exception:
                                    pass
                        else:
                            try:
                                _remove_all_references(chosen_item)
                            except Exception:
                                pass

                            hands_items = save_data.get("hands", {}).get("items", [])
                            try:
                                if chosen_item in hands_items:
                                    hands_items.remove(chosen_item)
                            except Exception:
                                pass

                            try:
                                for slot_name, eq_item in save_data.get("equipment", {}).items():
                                    if eq_item and "items"in eq_item and isinstance(eq_item["items"], list):
                                        try:
                                            while chosen_item in eq_item["items"]:
                                                eq_item["items"].remove(chosen_item)
                                        except Exception:
                                            pass

                                    if eq_item and "subslots"in eq_item:
                                        for sub in eq_item.get("subslots", []):
                                            if sub and sub.get("current")and "items"in sub.get("current", {}):
                                                try:
                                                    while chosen_item in sub["current"]["items"]:
                                                        sub["current"]["items"].remove(chosen_item)
                                                except Exception:
                                                    pass
                            except Exception:
                                pass

                            try:
                                import copy as _copy
                                new_installed = _copy.deepcopy(chosen_item)if isinstance(chosen_item, dict)else chosen_item
                            except Exception:
                                new_installed = chosen_item

                            acc["current"]= new_installed

                            if acc.get("_is_attachment_subslot"):
                                try:
                                    _sync_attachment_subslot(wpn, acc, new_installed)
                                except Exception:
                                    pass

                            try:
                                if isinstance(acc.get("current"), dict):
                                    add_subslots_to_item(acc.get("current"))
                            except Exception:
                                pass

                            try:
                                modes = acc.get("current", {}).get("modes")or[]
                                if isinstance(modes, list)and modes:
                                    if acc.get("_mode_index")is None and acc.get("mode_index")is None:
                                        acc["_mode_index"]= 0
                            except Exception:
                                pass

                for acc, opts, var, subslot_ref in rows:
                    if acc.get('_is_attachment_subslot'):
                        continue
                    try:
                        acc_slot = acc.get('slot')
                        to_remove =[]
                        for i, other_acc in enumerate(wpn.get('accessories', [])or[]):
                            if other_acc.get('_is_attachment_subslot')and other_acc.get('_parent_accessory_slot')==acc_slot:
                                to_remove.append(other_acc)
                        for r in to_remove:
                            try:
                                wpn['accessories'].remove(r)
                            except Exception:
                                pass

                        if acc.get('current')and isinstance(acc.get('current'), dict):
                            try:
                                _add_attachment_subslots_to_weapon(wpn, acc, acc.get('current'))
                            except Exception:
                                pass
                    except Exception:
                        pass

                try:
                    self._apply_item_overrides(wpn)
                except Exception:
                    logging.exception("Failed to apply attachment overrides")

                try:
                    self._save_file(save_data)
                except Exception:
                    logging.exception("Failed to save save_data after applying attachments")

                popup.destroy()
                update_weapon_view()

            apply_btn = customtkinter.CTkButton(popup, text = "Apply", command = apply_changes, width = 120)
            apply_btn.pack(pady = 10)

            try:
                popup.update_idletasks()
                req_w = popup.winfo_reqwidth()
                req_h = popup.winfo_reqheight()
                screen_w = popup.winfo_screenwidth()
                screen_h = popup.winfo_screenheight()

                max_w = max(200, screen_w -100)
                max_h = max(150, screen_h -100)
                final_w = min(req_w, max_w)
                final_h = min(req_h, max_h)
                self._center_popup_on_window(popup, final_w, final_h)
            except Exception:

                try:
                    self._center_popup_on_window(popup, 420, 400)
                except Exception:
                    pass

        def check_magazine():
            import time
            wpn = current_weapon_state["weapon"]
            loaded_mag = wpn.get("loaded")

            if not loaded_mag:
                ammo_label_ref = current_weapon_state.get("ammo_label_ref")
                if ammo_label_ref:
                    ammo_label_ref.configure(text = "Ammo: No magazine loaded", text_color =("gray10", "gray90"))
                    self.root.update()
                return

            rounds = loaded_mag.get("rounds", [])
            round_count = len(rounds)
            capacity = loaded_mag.get("capacity", "Unknown")

            tip_color = None
            if rounds:
                first_round = rounds[0]
                if isinstance(first_round, dict):
                    tip_color = first_round.get("tip")
                elif isinstance(first_round, str)and "|"in first_round:
                    variant_name = first_round.split("|")[-1].strip()
                    caliber_part = first_round.split("|")[0].strip()
                    try:
                        table_files = glob.glob(os.path.join("tables", "*.sldtbl"))
                        if table_files:
                            with open(table_files[0], 'r')as f:
                                table_data = json.load(f)
                            for ammo in table_data.get("tables", {}).get("ammunition", []):
                                if ammo.get("caliber")==caliber_part or ammo.get("name")==caliber_part:
                                    for var in ammo.get("variants", []):
                                        if var.get("name")==variant_name:
                                            tip_color = var.get("tip")
                                            break
                                    break
                    except Exception:
                        pass

            is_belt =("belt"in(wpn.get("magazinetype", "")or ""))or("belt"in(wpn.get("platform", "")or ""))or("m249"in(wpn.get("platform", "")or ""))
            try:
                if is_belt:
                    logging.debug("check_magazine: skipping magout for belt-fed weapon(platform=%s)", wpn.get("platform"))
                else:
                    self._play_weapon_action_sound(wpn, "magout")
            except Exception:

                if not is_belt:
                    try:
                        self._play_weapon_action_sound(wpn, "magout")
                    except Exception:
                        pass

            ammo_label_ref = current_weapon_state.get("ammo_label_ref")

            if ammo_label_ref:
                ammo_label_ref.configure(text = "Checking magazine...", text_color =("gray10", "gray90"))
                self.root.update()

            time.sleep(2.5)

            if capacity !="Unknown"and capacity >0:
                fill_ratio = round_count /capacity
                if fill_ratio ==0:
                    estimation = "Ammo: Empty"
                elif fill_ratio <0.5:
                    estimation = "Ammo: Less than halfway full"
                elif fill_ratio ==0.5:
                    estimation = "Ammo: Halfway full"
                elif fill_ratio <1.0:
                    estimation = "Ammo: More than halfway full"
                else:
                    estimation = "Ammo: Full"
            else:
                estimation = "Ammo: Unknown capacity"

            self._play_weapon_action_sound(wpn, "magin")

            if ammo_label_ref:
                if tip_color and round_count >0:
                    ammo_label_ref.configure(text = estimation, text_color = tip_color)
                else:
                    ammo_label_ref.configure(text = estimation, text_color =("gray10", "gray90"))
                self.root.update()

        def reload_magazine():

            try:
                wpn_check = current_weapon_state.get("weapon")or {}

                wpn_sounds = wpn_check.get("sounds")or wpn_check.get("sound_folder")or wpn_check.get("ammo_type")
                if wpn_check.get("underbarrel_weapon")or(isinstance(wpn_sounds, str)and "40mm"in wpn_sounds):

                    try:
                        result = self._reload_underbarrel(wpn_check, save_data, combat_reload = False)
                        if result:
                            update_weapon_view()
                        return
                    except Exception:
                        logging.exception("Underbarrel reload failed")
            except Exception:
                pass

            wpn = current_weapon_state["weapon"]

            wpn_mag_system = wpn.get("magazinesystem")or wpn.get("magazinetype")
            wpn_caliber_raw = wpn.get("caliber")
            wpn_calibers = set()
            if isinstance(wpn_caliber_raw, (list, tuple)):
                for c in wpn_caliber_raw:
                    if c:
                        wpn_calibers.add(str(c).lower().strip())
            elif isinstance(wpn_caliber_raw, str)and wpn_caliber_raw:
                wpn_calibers.add(wpn_caliber_raw.lower().strip())

            def _mag_is_compatible(mag_item):

                if not mag_item or not isinstance(mag_item, dict):
                    return False

                mag_system = mag_item.get("magazinesystem")
                if wpn_mag_system and mag_system:
                    if str(mag_system).lower().strip()!=str(wpn_mag_system).lower().strip():
                        return False

                mag_caliber_raw = mag_item.get("caliber")
                mag_calibers = set()
                if isinstance(mag_caliber_raw, (list, tuple)):
                    for c in mag_caliber_raw:
                        if c:
                            mag_calibers.add(str(c).lower().strip())
                elif isinstance(mag_caliber_raw, str)and mag_caliber_raw:
                    mag_calibers.add(mag_caliber_raw.lower().strip())
                if wpn_calibers and mag_calibers:
                    if not wpn_calibers.intersection(mag_calibers):
                        return False

                capacity = mag_item.get("capacity", 0)
                try:
                    capacity = int(capacity)
                except(ValueError, TypeError):
                    capacity = 0
                current_rounds = len(mag_item.get("rounds", []))
                if current_rounds >=capacity:
                    return False
                return True

            all_magazines =[]

            for item in save_data.get("hands", {}).get("items", []):
                if item and "magazinesystem"in item and "capacity"in item:
                    if _mag_is_compatible(item):
                        all_magazines.append(("hands", item))

            for slot_name, eq_item in save_data.get("equipment", {}).items():
                if eq_item:
                    if "items"in eq_item and isinstance(eq_item["items"], list):
                        for item in eq_item["items"]:
                            if item and "magazinesystem"in item and "capacity"in item:
                                if _mag_is_compatible(item):
                                    all_magazines.append(("equipment", item))

                    if "subslots"in eq_item:
                        for subslot in eq_item["subslots"]:
                            if subslot.get("current"):
                                curr = subslot["current"]
                                if "items"in curr and isinstance(curr["items"], list):
                                    for item in curr["items"]:
                                        if item and "magazinesystem"in item and "capacity"in item:
                                            if _mag_is_compatible(item):
                                                all_magazines.append(("equipment", item))

            loaded_mag = wpn.get("loaded")
            if loaded_mag and "magazinesystem"in loaded_mag and "capacity"in loaded_mag:
                if _mag_is_compatible(loaded_mag):
                    all_magazines.append(("loaded", loaded_mag))

            if not all_magazines:
                msg = "No compatible magazines found!\n\nMake sure you have magazines that:\nâ€¢ Match the weapon's magazine system"
                if wpn_mag_system:
                    msg +=f"({wpn_mag_system})"
                msg +="\nâ€¢ Match the weapon's caliber"
                if wpn_calibers:
                    msg +=f"({', '.join(wpn_calibers)})"
                msg +="\nâ€¢ Are not already full"
                self._popup_show_info("Reload Magazine", msg)
                return

            popup = customtkinter.CTkToplevel(self.root)
            popup.title("Select Magazine to Reload")
            popup.transient(self.root)
            self._center_popup_on_window(popup, 550, 500)

            label = customtkinter.CTkLabel(
            popup,
            text = "Select a magazine to reload with rounds:",
            font = customtkinter.CTkFont(size = 13),
            wraplength = 500
            )
            label.pack(pady = 10, padx = 20)

            scroll_frame = customtkinter.CTkScrollableFrame(popup, fg_color = "transparent")
            scroll_frame.pack(fill = "both", expand = True, padx = 10, pady = 10)

            selected_mag = customtkinter.StringVar(value = "0")

            for idx, (location, mag_item)in enumerate(all_magazines):
                mag_name = mag_item.get("name", "Unknown Magazine")
                capacity = mag_item.get("capacity", "?")
                rounds = len(mag_item.get("rounds", []))
                mag_system = mag_item.get("magazinesystem", "Unknown")

                radio_frame = customtkinter.CTkFrame(scroll_frame, fg_color = "transparent")
                radio_frame.pack(fill = "x", pady = 5, padx = 5)

                radio_text = f"{mag_name}({rounds}/{capacity}) - {mag_system} - {location}"
                radio = customtkinter.CTkRadioButton(
                radio_frame,
                text = radio_text,
                variable = selected_mag,
                value = str(idx),
                font = customtkinter.CTkFont(size = 11)
                )
                radio.pack(anchor = "w")

            def reload_selected():
                if not selected_mag.get():
                    self._popup_show_info("Reload Magazine", "Please select a magazine!")
                    return

                idx = int(selected_mag.get())
                location, mag_item = all_magazines[idx]

                capacity = mag_item.get("capacity", 0)
                current_rounds = len(mag_item.get("rounds", []))

                if current_rounds >=capacity:
                    self._popup_show_info("Reload Magazine", f"Magazine is already full({current_rounds}/{capacity})")
                    return

                mcal = mag_item.get('caliber')
                mag_cals = set()
                if isinstance(mcal, (list, tuple)):
                    for c in mcal:
                        if c:
                            mag_cals.add(str(c).lower().strip())
                elif isinstance(mcal, str)and mcal:
                    mag_cals.add(mcal.lower().strip())

                filter_calibers = wpn_calibers if wpn_calibers else mag_cals

                def _get_available_rounds_by_variant():

                    variants = {}

                    def _caliber_matches(item_cal):

                        if not filter_calibers:
                            return True
                        if not item_cal:
                            return False
                        item_cal_str = str(item_cal).lower().strip()
                        return item_cal_str in filter_calibers

                    def _get_variant_name(itm):

                        variant = itm.get('variant')
                        if variant:
                            return str(variant)

                        name = itm.get('name')
                        if name:
                            return str(name)
                        return 'Unknown'

                    def _process_item(itm):

                        if not itm or not isinstance(itm, dict):
                            return
                        if itm.get('magazinesystem')or itm.get('capacity'):
                            return

                        itm_cal = itm.get('caliber')
                        if not _caliber_matches(itm_cal):
                            return

                        rds = itm.get('rounds')
                        if isinstance(rds, list)and rds:
                            for r in rds:
                                if isinstance(r, dict):
                                    r_cal = r.get('caliber')
                                    if not _caliber_matches(r_cal):
                                        continue
                                    variant = _get_variant_name(r)
                                    variants[variant]= variants.get(variant, 0)+1
                            return

                        qty = int(itm.get('quantity')or 0)if isinstance(itm.get('quantity'), (int, float))else 0
                        if qty >0:
                            variant = _get_variant_name(itm)
                            variants[variant]= variants.get(variant, 0)+qty
                            return

                        if itm.get('caliber'):
                            variant = _get_variant_name(itm)
                            variants[variant]= variants.get(variant, 0)+1

                    for itm in save_data.get('hands', {}).get('items', []):
                        _process_item(itm)

                    for slot_name, eq_item in save_data.get('equipment', {}).items():
                        if not eq_item or not isinstance(eq_item, dict):
                            continue

                        for itm in eq_item.get('items', [])or[]:
                            _process_item(itm)

                        for sub in eq_item.get('subslots', [])or[]:
                            curr = sub.get('current')
                            if curr and isinstance(curr, dict):
                                for itm in curr.get('items', [])or[]:
                                    _process_item(itm)

                    return variants

                try:
                    available_by_variant = _get_available_rounds_by_variant()
                except Exception:
                    available_by_variant = {}

                total_available = sum(available_by_variant.values())

                if total_available <=0:
                    cal_str = ", ".join(sorted(filter_calibers))if filter_calibers else "compatible caliber"
                    self._popup_show_info("Reload Magazine", f"No loose rounds in hands matching {cal_str}")
                    return

                def proceed_with_reload(selected_variant):

                    if selected_variant and selected_variant !="All Variants":
                        variant_available = available_by_variant.get(selected_variant, 0)
                    else:
                        variant_available = total_available
                        selected_variant = None

                    max_load = min(variant_available, capacity -current_rounds)
                    if max_load <=0:
                        self._popup_show_info("Reload Magazine", "Magazine has no space to load rounds")
                        return

                    def on_amount_selected(to_load):
                        if to_load is None or to_load <=0:
                            return

                        def on_reload_complete(result_msg):
                            self._popup_show_info("Reload Magazine", result_msg)
                            update_weapon_view()

                        self._reload_magazine(mag_item, save_data, max_rounds = to_load, has_ammo_in_pool = wpn.get('has_ammo_in_pool', True), on_complete = on_reload_complete, is_loaded_in_weapon =(location =="loaded"), weapon = wpn, variant_filter = selected_variant)

                    self._popup_ask_integer("Load Rounds", f"Enter rounds to load(1-{max_load}):", initial_value = max_load, min_value = 1, max_value = max_load, on_result = on_amount_selected)

                if len(available_by_variant)>1:

                    try:
                        popup.destroy()
                    except Exception:
                        pass
                    variant_popup = customtkinter.CTkToplevel(self.root)
                    variant_popup.title("Select Ammo Variant")
                    variant_popup.transient(self.root)
                    self._center_popup_on_window(variant_popup, 400, 350)

                    label = customtkinter.CTkLabel(
                    variant_popup,
                    text = "Multiple ammo variants available.\nSelect which to load:",
                    font = customtkinter.CTkFont(size = 13),
                    wraplength = 380
                    )
                    label.pack(pady = 10, padx = 10)

                    scroll_frame = customtkinter.CTkScrollableFrame(variant_popup, fg_color = "transparent")
                    scroll_frame.pack(fill = "both", expand = True, padx = 10, pady = 5)

                    selected_variant_var = customtkinter.StringVar(value = "All Variants")

                    radio = customtkinter.CTkRadioButton(
                    scroll_frame,
                    text = f"All Variants({total_available} rounds)",
                    variable = selected_variant_var,
                    value = "All Variants",
                    font = customtkinter.CTkFont(size = 11)
                    )
                    radio.pack(anchor = "w", pady = 3)

                    for variant, count in sorted(available_by_variant.items()):
                        radio = customtkinter.CTkRadioButton(
                        scroll_frame,
                        text = f"{variant}({count} rounds)",
                        variable = selected_variant_var,
                        value = variant,
                        font = customtkinter.CTkFont(size = 11)
                        )
                        radio.pack(anchor = "w", pady = 3)

                    def on_variant_selected():
                        variant_popup.destroy()
                        proceed_with_reload(selected_variant_var.get())

                    btn_frame = customtkinter.CTkFrame(variant_popup, fg_color = "transparent")
                    btn_frame.pack(fill = "x", padx = 10, pady = 10)

                    ok_btn = customtkinter.CTkButton(btn_frame, text = "Continue", command = on_variant_selected, width = 120)
                    ok_btn.pack(side = "left", padx = 5)

                    cancel_btn = customtkinter.CTkButton(btn_frame, text = "Cancel", command = variant_popup.destroy, width = 120, fg_color = "#444444")
                    cancel_btn.pack(side = "left", padx = 5)

                    variant_popup.update_idletasks()
                    screen_width = variant_popup.winfo_screenwidth()
                    screen_height = variant_popup.winfo_screenheight()
                    x =(screen_width //2)-(200)
                    y =(screen_height //2)-(175)
                    variant_popup.geometry(f"+{x}+{y}")
                    variant_popup.grab_set()
                    variant_popup.lift()
                    self._safe_focus(variant_popup)
                else:

                    try:
                        popup.destroy()
                    except Exception:
                        pass
                    variant = list(available_by_variant.keys())[0]if available_by_variant else None
                    proceed_with_reload(variant)

            button_frame = customtkinter.CTkFrame(popup, fg_color = "transparent")
            button_frame.pack(fill = "x", padx = 10, pady = 10)

            reload_btn = customtkinter.CTkButton(
            button_frame,
            text = "Reload Selected",
            command = reload_selected,
            width = 150,
            height = 40
            )
            reload_btn.pack(side = "left", padx = 5)

            cancel_btn = customtkinter.CTkButton(
            button_frame,
            text = "Cancel",
            command = popup.destroy,
            width = 150,
            height = 40,
            fg_color = "#444444",
            hover_color = "#555555"
            )
            cancel_btn.pack(side = "left", padx = 5)

            popup.update_idletasks()
            popup_width = popup.winfo_reqwidth()
            popup_height = popup.winfo_reqheight()
            screen_width = popup.winfo_screenwidth()
            screen_height = popup.winfo_screenheight()
            x =(screen_width //2)-(popup_width //2)
            y =(screen_height //2)-(popup_height //2)
            popup.geometry(f"+{x}+{y}")
            popup.deiconify()
            popup.grab_set()
            popup.lift()
            self._safe_focus(popup)

        def check_cleanliness():
            import time
            wpn = current_weapon_state["weapon"]
            wpn_id = str(wpn.get("id"))
            cleanliness = combat_state.get("barrel_cleanliness", {}).get(wpn_id, 100.0)

            self._play_weapon_action_sound(wpn, "boltback", block = True)
            time.sleep(0.3)

            clean_label_ref = current_weapon_state.get("clean_label_ref")

            if clean_label_ref:
                clean_label_ref.configure(text = "Inspecting barrel...")
                self.root.update()

            time.sleep(2.5)

            if cleanliness >=90:
                estimation = "Cleanliness: Pristine"
            elif cleanliness >=70:
                estimation = "Cleanliness: Clean"
            elif cleanliness >=50:
                estimation = "Cleanliness: Dirty"
            elif cleanliness >=30:
                estimation = "Cleanliness: Very dirty"
            else:
                estimation = "Cleanliness: Fouled"

            self._play_weapon_action_sound(wpn, "boltforward")
            time.sleep(0.2)

            loaded_mag = wpn.get("loaded")
            if loaded_mag and loaded_mag.get("rounds"):
                removed_round = loaded_mag["rounds"].pop(0)
                logging.info(f"Removed round during inspection: {removed_round}")

            if clean_label_ref:
                clean_label_ref.configure(text = estimation)
                self.root.update()

        try:
            check_clean_btn = self._create_sound_button(
            actions_frame,
            text = "Check Cleanliness",
            command = check_cleanliness,
            width = 150,
            height = 50,
            font = customtkinter.CTkFont(size = 14)
            )
        except Exception:
            check_clean_btn = None
        try:
            check_mag_btn = self._create_sound_button(
            actions_frame,
            text = "Check Magazine",
            command = check_magazine,
            width = 150,
            height = 50,
            font = customtkinter.CTkFont(size = 14)
            )
        except Exception:
            check_mag_btn = None

        reload_mag_btn = self._create_sound_button(
        actions_frame,
        text = "Magazine Management",

        command = lambda:_show_magazine_popup(),
        width = 150,
        height = 50,
        font = customtkinter.CTkFont(size = 14),
        fg_color = "#1a4d1a",
        hover_color = "#2d7a2d"
        )
        reload_mag_btn.pack(side = "left", padx = 10, pady = 10)
        try:
            current_weapon_state['reload_mag_btn_ref']= reload_mag_btn
        except Exception:
            pass

        def unload_magazine():
            try:
                wpn = current_weapon_state.get('weapon')or {}
                loaded = wpn.get('loaded')
                if not loaded:
                    self._popup_show_info('Unload', 'No magazine loaded to unload')
                    return

                save_data.get('hands', {}).get('items', []).append(loaded)
                wpn['loaded']= None

                self._popup_show_info('Unload', f"Unloaded {loaded.get('name', 'magazine')} to hands")
                update_weapon_view()
            except Exception as e:
                logging.exception('Failed to unload magazine: %s', e)

        unload_btn = self._create_sound_button(actions_frame, text = 'Unload Magazine', command = unload_magazine, width = 150, height = 50, font = customtkinter.CTkFont(size = 14), fg_color = '#444444', hover_color = '#555555')
        try:
            current_weapon_state['unload_mag_btn_ref']= unload_btn
        except Exception:
            pass

        def remove_magazine():
            try:
                import random as _rand
                wpn = current_weapon_state.get('weapon')or {}
                loaded = wpn.get('loaded')
                if not loaded:
                    self._popup_show_info('Remove Magazine', 'No magazine loaded to remove')
                    return

                try:
                    is_belt =('belt'in(wpn.get('magazinetype', '')or ''))or('belt'in(wpn.get('platform', '')or ''))or('m249'in(wpn.get('platform', '')or ''))
                except Exception:
                    is_belt = False

                try:
                    if not is_belt:
                        self._play_weapon_action_sound(wpn, 'magout')
                except Exception:
                    pass
                try:
                    time.sleep(_rand.uniform(1, 1.25))
                except Exception:
                    pass
                try:
                    self._safe_sound_play("", "sounds/firearms/universal/pouchin.wav")
                except Exception:
                    pass

                try:
                    save_data.setdefault('hands', {}).setdefault('items', []).append(loaded)
                except Exception:
                    pass

                try:
                    wpn['loaded']= None
                except Exception:
                    pass

                mag_name = loaded.get('name', 'magazine')if isinstance(loaded, dict)else str(loaded)
                self._popup_show_info('Remove Magazine', f'Removed {mag_name} to hands')
                update_weapon_view()
            except Exception as e:
                logging.exception('Failed to remove magazine: %s', e)

        try:
            remove_btn = self._create_sound_button(actions_frame, text = 'Remove Magazine', command = remove_magazine, width = 150, height = 50, font = customtkinter.CTkFont(size = 14), fg_color = '#8B0000', hover_color = '#A00000')
            remove_btn.pack(side = 'left', padx = 10, pady = 10)
            try:
                current_weapon_state['remove_mag_btn_ref']= remove_btn
            except Exception:
                pass
        except Exception:
            pass

        def _show_magazine_popup():
            try:
                popup = customtkinter.CTkToplevel(self.root)
                popup.title('Magazine')
                popup.geometry('420x220')
                popup.transient(self.root)

                lab = customtkinter.CTkLabel(popup, text = 'Magazine Actions', font = customtkinter.CTkFont(size = 14, weight = 'bold'))
                lab.pack(pady = 8)

                try:
                    wpn_local = current_weapon_state.get('weapon')or {}

                    wpn_mag_system = wpn_local.get("magazinesystem")or wpn_local.get("magazinetype")
                    wpn_caliber_raw = wpn_local.get("caliber")
                    wpn_calibers = set()
                    if isinstance(wpn_caliber_raw, (list, tuple)):
                        for c in wpn_caliber_raw:
                            if c:
                                wpn_calibers.add(str(c).lower().strip())
                    elif isinstance(wpn_caliber_raw, str)and wpn_caliber_raw:
                        wpn_calibers.add(wpn_caliber_raw.lower().strip())

                    def _mag_is_compatible_local(mag_item):

                        if not mag_item or not isinstance(mag_item, dict):
                            return False

                        mag_system = mag_item.get("magazinesystem")
                        if wpn_mag_system and mag_system:
                            if str(mag_system).lower().strip()!=str(wpn_mag_system).lower().strip():
                                return False

                        mag_caliber_raw = mag_item.get("caliber")
                        mag_calibers = set()
                        if isinstance(mag_caliber_raw, (list, tuple)):
                            for c in mag_caliber_raw:
                                if c:
                                    mag_calibers.add(str(c).lower().strip())
                        elif isinstance(mag_caliber_raw, str)and mag_caliber_raw:
                            mag_calibers.add(mag_caliber_raw.lower().strip())
                        if wpn_calibers and mag_calibers:
                            if not wpn_calibers.intersection(mag_calibers):
                                return False

                        capacity = mag_item.get("capacity", 0)
                        try:
                            capacity = int(capacity)
                        except(ValueError, TypeError):
                            capacity = 0
                        current_rounds = len(mag_item.get("rounds", []))
                        if current_rounds >=capacity:
                            return False
                        return True

                    def _hands_have_compatible_rounds_local(wpn):
                        try:
                            def check_container_items(item_iterable):
                                for itm in item_iterable:
                                    try:
                                        if not itm or not isinstance(itm, dict):
                                            continue

                                        if itm.get('magazinesystem')or itm.get('capacity'):
                                            continue
                                        rds = itm.get('rounds')
                                        if isinstance(rds, list)and rds:
                                            return True
                                        qty = int(itm.get('quantity')or 0)if isinstance(itm.get('quantity'), (int, float))else 0
                                        if qty >0:
                                            return True
                                        if itm.get('caliber'):
                                            return True
                                    except Exception:
                                        continue
                                return False

                            if check_container_items(save_data.get('hands', {}).get('items', [])):
                                return True

                            for slot_name, eq_item in save_data.get('equipment', {}).items():
                                try:
                                    if not eq_item or not isinstance(eq_item, dict):
                                        continue
                                    for itm in eq_item.get('items', [])or[]:
                                        if check_container_items([itm]):
                                            return True
                                    for sub in eq_item.get('subslots', [])or[]:
                                        try:
                                            curr = sub.get('current')
                                            if curr and isinstance(curr, dict):
                                                for itm in curr.get('items', [])or[]:
                                                    if check_container_items([itm]):
                                                        return True
                                        except Exception:
                                            pass
                                except Exception:
                                    pass

                            return False
                        except Exception:
                            return False

                    def _inventory_has_compatible_nonfull_mag():

                        try:
                            def check_nonfull_mag(itm):
                                if not itm or not isinstance(itm, dict):
                                    return False
                                cap = itm.get('capacity')
                                if cap is None:
                                    return False
                                try:
                                    cap_i = int(cap)
                                except Exception:
                                    return False
                                rounds = itm.get('rounds', [])
                                cur = len(rounds)if isinstance(rounds, list)else 0
                                return cur <cap_i

                            for itm in save_data.get('hands', {}).get('items', []):
                                try:
                                    if check_nonfull_mag(itm):
                                        return True
                                except Exception:
                                    pass

                            for slot_name, eq_item in save_data.get('equipment', {}).items():
                                try:
                                    if not eq_item or not isinstance(eq_item, dict):
                                        continue
                                    for itm in eq_item.get('items', [])or[]:
                                        try:
                                            if check_nonfull_mag(itm):
                                                return True
                                        except Exception:
                                            pass
                                    for sub in eq_item.get('subslots', [])or[]:
                                        try:
                                            curr = sub.get('current')
                                            if curr and isinstance(curr, dict):
                                                for itm in curr.get('items', [])or[]:
                                                    try:
                                                        if check_nonfull_mag(itm):
                                                            return True
                                                    except Exception:
                                                        pass
                                        except Exception:
                                            pass
                                except Exception:
                                    pass

                            loaded_mag = wpn_local.get('loaded')
                            if check_nonfull_mag(loaded_mag):
                                return True

                            return False
                        except Exception:
                            return False

                    can_reload = _hands_have_compatible_rounds_local(wpn_local)and _inventory_has_compatible_nonfull_mag()

                    def _inventory_has_mag_with_rounds():

                        try:
                            def check_mag(itm):
                                if not itm or not isinstance(itm, dict):
                                    return False
                                if 'magazinesystem'not in itm and 'capacity'not in itm:
                                    return False
                                rounds = itm.get('rounds', [])
                                return isinstance(rounds, list)and len(rounds)>0

                            for itm in save_data.get('hands', {}).get('items', []):
                                if check_mag(itm):
                                    return True

                            for slot_name, eq_item in save_data.get('equipment', {}).items():
                                try:
                                    if not eq_item or not isinstance(eq_item, dict):
                                        continue
                                    for itm in eq_item.get('items', [])or[]:
                                        if check_mag(itm):
                                            return True
                                    for sub in eq_item.get('subslots', [])or[]:
                                        try:
                                            curr = sub.get('current')
                                            if curr and isinstance(curr, dict):
                                                for itm in curr.get('items', [])or[]:
                                                    if check_mag(itm):
                                                        return True
                                        except Exception:
                                            pass
                                except Exception:
                                    pass

                            loaded_mag_local = wpn_local.get('loaded')
                            if check_mag(loaded_mag_local):
                                return True

                            return False
                        except Exception:
                            return False

                    can_unload = _inventory_has_mag_with_rounds()
                except Exception:
                    can_reload = False
                    can_unload = False

                def unload_magazine_rounds():

                    try:
                        popup.destroy()
                    except Exception:
                        pass

                    wpn = current_weapon_state.get('weapon')or {}

                    all_magazines =[]

                    def check_mag_has_rounds(itm):
                        if not itm or not isinstance(itm, dict):
                            return False
                        if 'magazinesystem'not in itm and 'capacity'not in itm:
                            return False
                        rounds = itm.get('rounds', [])
                        return isinstance(rounds, list)and len(rounds)>0

                    for item in save_data.get("hands", {}).get("items", []):
                        if check_mag_has_rounds(item):
                            all_magazines.append(("hands", item))

                    for slot_name, eq_item in save_data.get("equipment", {}).items():
                        if eq_item:
                            if "items"in eq_item and isinstance(eq_item["items"], list):
                                for item in eq_item["items"]:
                                    if check_mag_has_rounds(item):
                                        all_magazines.append(("equipment", item))
                            if "subslots"in eq_item:
                                for subslot in eq_item["subslots"]:
                                    if subslot.get("current"):
                                        curr = subslot["current"]
                                        if "items"in curr and isinstance(curr["items"], list):
                                            for item in curr["items"]:
                                                if check_mag_has_rounds(item):
                                                    all_magazines.append(("equipment", item))

                    loaded_mag = wpn.get("loaded")
                    if check_mag_has_rounds(loaded_mag):
                        all_magazines.append(("loaded", loaded_mag))

                    if not all_magazines:
                        self._popup_show_info("Unload Magazine", "No magazines with rounds found!")
                        return

                    unload_popup = customtkinter.CTkToplevel(self.root)
                    unload_popup.title("Select Magazine to Unload")
                    unload_popup.transient(self.root)
                    self._center_popup_on_window(unload_popup, 550, 500)

                    label = customtkinter.CTkLabel(
                    unload_popup,
                    text = "Select a magazine to unload rounds from:",
                    font = customtkinter.CTkFont(size = 13),
                    wraplength = 500
                    )
                    label.pack(pady = 10, padx = 20)

                    scroll_frame = customtkinter.CTkScrollableFrame(unload_popup, fg_color = "transparent")
                    scroll_frame.pack(fill = "both", expand = True, padx = 10, pady = 10)

                    selected_mag = customtkinter.StringVar(value = "0")

                    for idx, (location, mag_item)in enumerate(all_magazines):
                        mag_name = mag_item.get("name", "Unknown Magazine")
                        capacity = mag_item.get("capacity", "?")
                        rounds = len(mag_item.get("rounds", []))
                        mag_system = mag_item.get("magazinesystem", "Unknown")

                        radio_frame = customtkinter.CTkFrame(scroll_frame, fg_color = "transparent")
                        radio_frame.pack(fill = "x", pady = 5, padx = 5)

                        radio_text = f"{mag_name}({rounds}/{capacity}) - {mag_system} - {location}"
                        radio = customtkinter.CTkRadioButton(
                        radio_frame,
                        text = radio_text,
                        variable = selected_mag,
                        value = str(idx),
                        font = customtkinter.CTkFont(size = 11)
                        )
                        radio.pack(anchor = "w")

                    def unload_selected():
                        if not selected_mag.get():
                            self._popup_show_info("Unload Magazine", "Please select a magazine!")
                            return

                        idx = int(selected_mag.get())
                        location, mag_item = all_magazines[idx]

                        mag_rounds = mag_item.get("rounds", [])
                        current_round_count = len(mag_rounds)
                        if current_round_count <=0:
                            self._popup_show_info("Unload Magazine", "Magazine is already empty")
                            return

                        variants_in_mag = {}
                        for r in mag_rounds:
                            if isinstance(r, dict):
                                variant = r.get('variant', 'Unknown')
                                variants_in_mag[variant]= variants_in_mag.get(variant, 0)+1

                        def proceed_with_unload(selected_variant):

                            if selected_variant and selected_variant !="All Variants":
                                variant_count = variants_in_mag.get(selected_variant, 0)
                            else:
                                variant_count = current_round_count
                                selected_variant = None

                            if variant_count <=0:
                                self._popup_show_info("Unload Magazine", "No rounds to unload")
                                return

                            def on_amount_selected(to_unload):
                                        if to_unload is None or to_unload <=0:
                                            return

                                        def on_unload_complete(result_msg):
                                            self._popup_show_info("Unload Magazine", result_msg)
                                            update_weapon_view()

                                        is_loaded =(location =="loaded")
                                        self._unload_magazine_rounds(mag_item, save_data, max_rounds = to_unload, on_complete = on_unload_complete, is_loaded_in_weapon = is_loaded, weapon = wpn if is_loaded else None, variant_filter = selected_variant)

                            self._popup_ask_integer("Unload Rounds", f"Enter rounds to unload(1-{variant_count}):", initial_value = variant_count, min_value = 1, max_value = variant_count, on_result = on_amount_selected)

                        if len(variants_in_mag)>1:

                            try:
                                unload_popup.destroy()
                            except Exception:
                                pass
                            variant_popup = customtkinter.CTkToplevel(self.root)
                            variant_popup.title("Select Ammo Variant")
                            variant_popup.transient(self.root)
                            self._center_popup_on_window(variant_popup, 400, 350)

                            label = customtkinter.CTkLabel(
                            variant_popup,
                            text = "Multiple ammo variants in magazine.\nSelect which to unload:",
                            font = customtkinter.CTkFont(size = 13),
                            wraplength = 380
                            )
                            label.pack(pady = 10, padx = 10)

                            scroll_frame = customtkinter.CTkScrollableFrame(variant_popup, fg_color = "transparent")
                            scroll_frame.pack(fill = "both", expand = True, padx = 10, pady = 5)

                            selected_variant_var = customtkinter.StringVar(value = "All Variants")

                            radio = customtkinter.CTkRadioButton(
                            scroll_frame,
                            text = f"All Variants({current_round_count} rounds)",
                            variable = selected_variant_var,
                            value = "All Variants",
                            font = customtkinter.CTkFont(size = 11)
                            )
                            radio.pack(anchor = "w", pady = 3)

                            for variant, count in sorted(variants_in_mag.items()):
                                radio = customtkinter.CTkRadioButton(
                                scroll_frame,
                                text = f"{variant}({count} rounds)",
                                variable = selected_variant_var,
                                value = variant,
                                font = customtkinter.CTkFont(size = 11)
                                )
                                radio.pack(anchor = "w", pady = 3)

                            def on_variant_selected():
                                variant_popup.destroy()
                                proceed_with_unload(selected_variant_var.get())

                            btn_frame = customtkinter.CTkFrame(variant_popup, fg_color = "transparent")
                            btn_frame.pack(fill = "x", padx = 10, pady = 10)

                            ok_btn = customtkinter.CTkButton(btn_frame, text = "Continue", command = on_variant_selected, width = 120)
                            ok_btn.pack(side = "left", padx = 5)

                            cancel_btn = customtkinter.CTkButton(btn_frame, text = "Cancel", command = variant_popup.destroy, width = 120, fg_color = "#444444")
                            cancel_btn.pack(side = "left", padx = 5)

                            variant_popup.update_idletasks()
                            screen_width = variant_popup.winfo_screenwidth()
                            screen_height = variant_popup.winfo_screenheight()
                            x =(screen_width //2)-(200)
                            y =(screen_height //2)-(175)
                            variant_popup.geometry(f"+{x}+{y}")
                            variant_popup.grab_set()
                            variant_popup.lift()
                            self._safe_focus(variant_popup)
                        else:

                            try:
                                unload_popup.destroy()
                            except Exception:
                                pass
                            variant = list(variants_in_mag.keys())[0]if variants_in_mag else None
                            proceed_with_unload(variant)

                    button_frame = customtkinter.CTkFrame(unload_popup, fg_color = "transparent")
                    button_frame.pack(fill = "x", padx = 10, pady = 10)

                    unload_btn = customtkinter.CTkButton(
                    button_frame,
                    text = "Unload Selected",
                    command = unload_selected,
                    width = 150,
                    height = 40
                    )
                    unload_btn.pack(side = "left", padx = 5)

                    cancel_btn = customtkinter.CTkButton(
                    button_frame,
                    text = "Cancel",
                    command = unload_popup.destroy,
                    width = 150,
                    height = 40,
                    fg_color = "#444444",
                    hover_color = "#555555"
                    )
                    cancel_btn.pack(side = "left", padx = 5)

                    unload_popup.update_idletasks()
                    popup_width = unload_popup.winfo_reqwidth()
                    popup_height = unload_popup.winfo_reqheight()
                    screen_width = unload_popup.winfo_screenwidth()
                    screen_height = unload_popup.winfo_screenheight()
                    x =(screen_width //2)-(popup_width //2)
                    y =(screen_height //2)-(popup_height //2)
                    unload_popup.geometry(f"+{x}+{y}")
                    unload_popup.deiconify()
                    unload_popup.grab_set()
                    unload_popup.lift()
                    self._safe_focus(unload_popup)

                try:
                    def reload_and_close():
                        try:
                            popup.destroy()
                        except Exception:
                            pass
                        reload_magazine()

                    reload_btn = self._create_sound_button(popup, text = 'Reload Magazine', command = reload_and_close, width = 240, height = 40, font = customtkinter.CTkFont(size = 12), fg_color = '#1a4d1a')
                    reload_btn.pack(pady = 6)
                    try:
                        reload_btn.configure(state = 'normal'if can_reload else 'disabled')
                    except Exception:
                        pass
                except Exception:
                    pass

                try:
                    unload_btn_popup = self._create_sound_button(popup, text = 'Unload Magazine', command = unload_magazine_rounds, width = 240, height = 40, font = customtkinter.CTkFont(size = 12), fg_color = '#444444')
                    unload_btn_popup.pack(pady = 6)
                    try:
                        unload_btn_popup.configure(state = 'normal'if can_unload else 'disabled')
                    except Exception:
                        pass
                except Exception:
                    pass

                try:
                    customtkinter.CTkButton(popup, text = 'Close', command = popup.destroy, width = 140).pack(pady = 8)
                except Exception:
                    pass

                try:
                    popup.grab_set()
                    popup.lift()
                    self._safe_focus(popup)
                except Exception:
                    pass
            except Exception:
                pass

        def _find_throwables_in_inventory():
            items =[]

            for itm in save_data.get('hands', {}).get('items', []):
                try:
                    if itm and isinstance(itm, dict)and str(itm.get('type', '')).lower()in('fragmentation', 'smoke', 'stun', '9-bang', '9bang', '9_bang'):
                        items.append(('hands', itm))
                except Exception:
                    pass

            for slot_name, eq_item in save_data.get('equipment', {}).items():
                try:
                    if not eq_item or not isinstance(eq_item, dict):
                        continue
                    if 'items'in eq_item and isinstance(eq_item['items'], list):
                        for itm in eq_item['items']:
                            try:
                                if itm and isinstance(itm, dict)and str(itm.get('type', '')).lower()in('fragmentation', 'smoke', 'stun', '9-bang', '9bang', '9_bang'):
                                    items.append(('equipment', itm))
                            except Exception:
                                pass
                    if 'subslots'in eq_item:
                        for sub in eq_item.get('subslots', []):
                            try:
                                curr = sub.get('current')if isinstance(sub, dict)else None
                                if curr and isinstance(curr, dict)and 'items'in curr and isinstance(curr['items'], list):
                                    for itm in curr['items']:
                                        try:
                                            if itm and isinstance(itm, dict)and str(itm.get('type', '')).lower()in('fragmentation', 'smoke', 'stun', '9-bang', '9bang', '9_bang'):
                                                items.append(('equipment', itm))
                                        except Exception:
                                            pass
                            except Exception:
                                pass
                except Exception:
                    pass
            return items

        def _find_consumables_in_inventory():

            items =[]

            for itm in save_data.get('hands', {}).get('items', []):
                try:
                    if itm and isinstance(itm, dict)and itm.get('consumable'):
                        items.append(('hands', itm))
                except Exception:
                    pass

            for slot_name, eq_item in save_data.get('equipment', {}).items():
                try:
                    if not eq_item or not isinstance(eq_item, dict):
                        continue

                    if 'items'in eq_item and isinstance(eq_item['items'], list):
                        for itm in eq_item['items']:
                            try:
                                if itm and isinstance(itm, dict)and itm.get('consumable'):
                                    items.append((f'equipment.{slot_name}', itm))
                            except Exception:
                                pass

                    if 'subslots'in eq_item:
                        for sub_idx, sub in enumerate(eq_item.get('subslots', [])):
                            try:
                                curr = sub.get('current')if isinstance(sub, dict)else None
                                if curr and isinstance(curr, dict):

                                    if curr.get('consumable'):
                                        items.append((f'equipment.{slot_name}.subslots.{sub_idx}.current', curr))

                                    if 'items'in curr and isinstance(curr['items'], list):
                                        for itm in curr['items']:
                                            try:
                                                if itm and isinstance(itm, dict)and itm.get('consumable'):
                                                    items.append((f'equipment.{slot_name}.subslots.{sub_idx}.current', itm))
                                            except Exception:
                                                pass
                            except Exception:
                                pass
                except Exception:
                    pass
            return items

        def _has_ear_protection():
            try:
                for slot, eq in save_data.get('equipment', {}).items():
                    if not eq or not isinstance(eq, dict):
                        continue

                    if eq.get('ear_protection'):
                        return True

                    for itm in eq.get('items', [])or[]:
                        try:
                            if itm and isinstance(itm, dict)and itm.get('ear_protection'):
                                return True
                        except Exception:
                            pass
                    for sub in eq.get('subslots', [])or[]:
                        try:
                            curr = sub.get('current')
                            if curr and isinstance(curr, dict):
                                if curr.get('ear_protection'):
                                    return True
                                for itm in curr.get('items', [])or[]:
                                    try:
                                        if itm and isinstance(itm, dict)and itm.get('ear_protection'):
                                            return True
                                    except Exception:
                                        pass
                        except Exception:
                            pass
                return False
            except Exception:
                return False

        def _has_flash_goggles():
            try:
                for slot, eq in save_data.get('equipment', {}).items():
                    if not eq or not isinstance(eq, dict):
                        continue
                    if eq.get('flashbang_goggle'):
                        return True
                    for itm in eq.get('items', [])or[]:
                        try:
                            if itm and isinstance(itm, dict)and itm.get('flashbang_goggle'):
                                return True
                        except Exception:
                            pass
                    for sub in eq.get('subslots', [])or[]:
                        try:
                            curr = sub.get('current')
                            if curr and isinstance(curr, dict):
                                if curr.get('flashbang_goggle'):
                                    return True
                                for itm in curr.get('items', [])or[]:
                                    try:
                                        if itm and isinstance(itm, dict)and itm.get('flashbang_goggle'):
                                            return True
                                    except Exception:
                                        pass
                        except Exception:
                            pass
                return False
            except Exception:
                return False

        def _handle_flashbang_effects(bang_count = 1):

            try:
                has_ears = _has_ear_protection()
                has_gog = _has_flash_goggles()

                if not has_ears:
                    try:
                        self._flashbang_mute = True
                        self._flashbang_volume = 0.0
                    except Exception:
                        pass

                    try:
                        def _play_ring():
                            try:
                                logging.debug("Flashbang: spawning ring playback thread")
                                self._safe_sound_play('', 'sounds/misc/throwable/ring.ogg')
                                logging.debug("Flashbang: ring playback attempted")
                            except Exception:
                                logging.exception('Flashbang ring playback failed')
                        threading.Thread(target = _play_ring, daemon = True).start()
                    except Exception:
                        logging.exception('Failed to start ring playback thread')

                    try:

                        try:
                            if hasattr(self, '_flashbang_fade_cancel')and self._flashbang_fade_cancel is not None:
                                try:
                                    self._flashbang_fade_cancel.set()
                                except Exception:
                                    pass
                        except Exception:
                            pass

                        fade_cancel = threading.Event()
                        self._flashbang_fade_cancel = fade_cancel

                        def _fade_in_after_delay(cancel_evt = fade_cancel):
                            try:
                                wait = random.uniform(7.0, 8.0)

                                waited = 0.0
                                step_wait = 0.1
                                while waited <wait:
                                    if cancel_evt.is_set():
                                        return
                                    time.sleep(step_wait)
                                    waited +=step_wait

                                steps = 20
                                dur = 3.0
                                step_sleep = dur /steps
                                for i in range(1, steps +1):
                                    if cancel_evt.is_set():
                                        return
                                    try:
                                        self._flashbang_volume = float(i)/float(steps)
                                    except Exception:
                                        self._flashbang_volume = 1.0
                                    time.sleep(step_sleep)

                                try:
                                    self._flashbang_mute = False
                                    self._flashbang_volume = 1.0

                                    try:
                                        cache = getattr(self, '_sound_cache', {})or {}
                                        for spath, ssound in cache.items():
                                            try:
                                                ssound.set_volume(1.0)
                                            except Exception:
                                                pass
                                    except Exception:
                                        pass
                                except Exception:
                                    pass
                            except Exception:
                                try:
                                    self._flashbang_mute = False
                                    self._flashbang_volume = 1.0
                                except Exception:
                                    pass

                        t = threading.Thread(target = _fade_in_after_delay, daemon = True)
                        t.start()
                        self._flashbang_fade_thread = t
                    except Exception:
                        pass
                else:

                    try:
                        self._bang_muffle = True

                        self._bang_muffle_volume = getattr(self, '_bang_muffle_volume', 0.45)

                        try:
                            prev = getattr(self, '_bang_muffle_timer', None)
                            if prev:
                                try:
                                    prev.cancel()
                                except Exception:
                                    pass
                        except Exception:
                            pass

                        try:
                            mt = threading.Timer(5.0, lambda:setattr(self, '_bang_muffle', False))
                            mt.daemon = True
                            mt.start()
                            self._bang_muffle_timer = mt
                        except Exception:
                            pass
                    except Exception:
                        pass

                if not has_gog:
                    def _create_overlay():
                        try:
                            ov = customtkinter.CTkToplevel(self.root)
                            ov.overrideredirect(True)
                            sw = self.root.winfo_screenwidth()
                            sh = self.root.winfo_screenheight()
                            ov.geometry(f"{sw}x{sh}+0+0")
                            try:
                                ov.attributes('-topmost', True)
                            except Exception:
                                pass
                            try:
                                ov.attributes('-alpha', 1.0)
                            except Exception:
                                pass
                            try:
                                ov.configure(fg_color = 'white')
                            except Exception:
                                try:
                                    ov.configure(bg = 'white')
                                except Exception:
                                    pass
                            return ov
                        except Exception:
                            return None

                    try:
                        def _make_and_fade():
                            try:

                                existing = getattr(self, '_flashbang_overlay', None)
                                existing_after = getattr(self, '_flashbang_overlay_after_id', None)
                                overlay = existing
                                if overlay is None or not getattr(overlay, 'winfo_exists', lambda:False)():
                                    overlay = _create_overlay()
                                    try:
                                        self._flashbang_overlay = overlay
                                    except Exception:
                                        pass
                                else:
                                    try:

                                        if existing_after:
                                            try:
                                                overlay.after_cancel(existing_after)
                                            except Exception:
                                                pass
                                    except Exception:
                                        pass
                                    try:
                                        overlay.attributes('-alpha', 1.0)
                                    except Exception:
                                        pass

                                delay = int(random.uniform(7000, 8000))
                                def _fade_step(count = 0, steps = None):
                                    try:
                                        if not getattr(overlay, 'winfo_exists', lambda:False)():
                                            try:
                                                if getattr(self, '_flashbang_overlay', None)is overlay:
                                                    self._flashbang_overlay = None
                                                    self._flashbang_overlay_after_id = None
                                            except Exception:
                                                pass
                                            return

                                        dur = 3.0

                                        target_fps = 165

                                        if not steps:
                                            try:
                                                steps = max(1, int(dur *target_fps))
                                            except Exception:
                                                steps = 60

                                        try:
                                            interval_ms = max(1, int((dur *1000.0)/float(steps)))
                                        except Exception:
                                            interval_ms = max(1, int((dur *1000.0)/60))

                                        t = float(count)/float(steps)if steps else 1.0

                                        smooth = t *t *(3.0 -2.0 *t)
                                        alpha = 1.0 -smooth
                                        alpha = max(0.0, min(1.0, alpha))
                                        try:
                                            overlay.attributes('-alpha', alpha)
                                        except Exception:
                                            pass

                                        if count <steps:
                                            aid = overlay.after(int(interval_ms), lambda:_fade_step(count +1, steps))
                                            try:
                                                self._flashbang_overlay_after_id = aid
                                            except Exception:
                                                pass
                                        else:
                                            try:
                                                overlay.destroy()
                                            except Exception:
                                                pass
                                            try:
                                                if getattr(self, '_flashbang_overlay', None)is overlay:
                                                    self._flashbang_overlay = None
                                                    self._flashbang_overlay_after_id = None
                                            except Exception:
                                                pass
                                    except Exception:
                                        try:
                                            if overlay:
                                                overlay.destroy()
                                        except Exception:
                                            pass

                                try:
                                    aid = overlay.after(delay, lambda:_fade_step(0))
                                    try:
                                        self._flashbang_overlay_after_id = aid
                                    except Exception:
                                        pass
                                except Exception:
                                    try:

                                        _fade_step(0)
                                    except Exception:
                                        pass
                            except Exception:
                                pass

                        self.root.after(0, _make_and_fade)
                    except Exception:
                        pass

                return True
            except Exception:
                return False

        def _handle_fragmentation_flash_effects():

            try:
                has_gog = _has_flash_goggles()
                if has_gog:
                    return True

                def _create_quick_flash():
                    try:
                        ov = customtkinter.CTkToplevel(self.root)
                        ov.overrideredirect(True)
                        sw = self.root.winfo_screenwidth()
                        sh = self.root.winfo_screenheight()
                        ov.geometry(f"{sw}x{sh}+0+0")
                        try:
                            ov.attributes('-topmost', True)
                        except Exception:
                            pass
                        try:
                            ov.attributes('-alpha', 1.0)
                        except Exception:
                            pass
                        try:
                            ov.configure(fg_color = 'white')
                        except Exception:
                            try:
                                ov.configure(bg = 'white')
                            except Exception:
                                pass

                        def _quick_fade(step = 0, steps = None):
                            try:
                                if not getattr(ov, 'winfo_exists', lambda:False)():
                                    return

                                dur = random.uniform(0.2, 0.35)
                                target_fps = 165
                                if not steps:
                                    try:
                                        steps = max(1, int(dur *target_fps))
                                    except Exception:
                                        steps = 60

                                try:
                                    interval_ms = max(1, int((dur *1000.0)/float(steps)))
                                except Exception:
                                    interval_ms = max(1, int((dur *1000.0)/60))

                                t = float(step)/float(steps)if steps else 1.0
                                smooth = t *t *(3.0 -2.0 *t)
                                alpha = 1.0 -smooth
                                alpha = max(0.0, min(1.0, alpha))
                                try:
                                    ov.attributes('-alpha', alpha)
                                except Exception:
                                    pass

                                if step <steps:
                                    ov.after(int(interval_ms), lambda:_quick_fade(step +1, steps))
                                else:
                                    try:
                                        ov.destroy()
                                    except Exception:
                                        pass
                            except Exception:
                                try:
                                    ov.destroy()
                                except Exception:
                                    pass

                        ov.after(int(random.uniform(10, 30)), lambda:_quick_fade(1, None))
                        return ov
                    except Exception:
                        return None

                try:

                    try:
                        if _has_ear_protection():
                            try:
                                self._bang_muffle = True
                                self._bang_muffle_volume = getattr(self, '_bang_muffle_volume', 0.45)
                                prev = getattr(self, '_bang_muffle_timer', None)
                                if prev:
                                    try:
                                        prev.cancel()
                                    except Exception:
                                        pass
                                mt = threading.Timer(3.0, lambda:setattr(self, '_bang_muffle', False))
                                mt.daemon = True
                                mt.start()
                                self._bang_muffle_timer = mt
                            except Exception:
                                pass
                    except Exception:
                        pass

                    self.root.after(0, _create_quick_flash)
                except Exception:
                    pass
                return True
            except Exception:
                return False

        def _handle_goggle_dark_flash_effects():

            try:

                if not _has_flash_goggles():
                    return False

                def _create_quick_dark():
                    try:
                        ov = customtkinter.CTkToplevel(self.root)
                        ov.overrideredirect(True)
                        sw = self.root.winfo_screenwidth()
                        sh = self.root.winfo_screenheight()
                        ov.geometry(f"{sw}x{sh}+0+0")
                        try:
                            ov.attributes('-topmost', True)
                        except Exception:
                            pass

                        try:
                            ov.attributes('-alpha', 0.8)
                        except Exception:
                            pass
                        try:
                            ov.configure(fg_color = 'black')
                        except Exception:
                            try:
                                ov.configure(bg = 'black')
                            except Exception:
                                pass

                        def _quick_fade(step = 0, steps = None):
                            try:
                                if not getattr(ov, 'winfo_exists', lambda:False)():
                                    return

                                dur = random.uniform(0.2, 0.4)
                                target_fps = 165
                                if not steps:
                                    try:
                                        steps = max(1, int(dur *target_fps))
                                    except Exception:
                                        steps = 60

                                try:
                                    interval_ms = max(1, int((dur *1000.0)/float(steps)))
                                except Exception:
                                    interval_ms = max(1, int((dur *1000.0)/60))

                                t = float(step)/float(steps)if steps else 1.0
                                smooth = t *t *(3.0 -2.0 *t)
                                alpha = 0.8 *(1.0 -smooth)
                                alpha = max(0.0, min(1.0, alpha))
                                try:
                                    ov.attributes('-alpha', alpha)
                                except Exception:
                                    pass

                                if step <steps:
                                    ov.after(int(interval_ms), lambda:_quick_fade(step +1, steps))
                                else:
                                    try:
                                        ov.destroy()
                                    except Exception:
                                        pass
                            except Exception:
                                try:
                                    ov.destroy()
                                except Exception:
                                    pass

                        ov.after(int(random.uniform(10, 30)), lambda:_quick_fade(1, None))
                        return ov
                    except Exception:
                        return None

                try:
                    self.root.after(0, _create_quick_dark)
                except Exception:
                    pass
                return True
            except Exception:
                return False

        def _do_throw_sequence(location, throwable_item):
            try:

                try:
                    if location =='hands':
                        if throwable_item in save_data.get('hands', {}).get('items', []):
                            save_data.get('hands', {}).get('items', []).remove(throwable_item)
                    elif location =='equipment':
                        for slot_name, eq_item in save_data.get('equipment', {}).items():
                            if not eq_item or not isinstance(eq_item, dict):
                                continue
                            if 'items'in eq_item and throwable_item in eq_item['items']:
                                try:
                                    eq_item['items'].remove(throwable_item)
                                    break
                                except Exception:
                                    pass
                            if 'subslots'in eq_item:
                                for sub in eq_item.get('subslots', []):
                                    try:
                                        curr = sub.get('current')
                                        if curr and isinstance(curr, dict)and 'items'in curr and throwable_item in curr['items']:
                                            try:
                                                curr['items'].remove(throwable_item)
                                                break
                                            except Exception:
                                                pass
                                    except Exception:
                                        pass
                except Exception:
                    pass

                try:
                    self._safe_sound_play('', 'sounds/misc/throwable/pin.ogg')
                except Exception:
                    pass
                time.sleep(random.uniform(0.2, 0.5))
                try:
                    self._safe_sound_play('', 'sounds/misc/throwable/throw.ogg')
                except Exception:
                    pass
                time.sleep(random.uniform(0.2, 0.3))
                try:
                    self._safe_sound_play('', 'sounds/misc/throwable/spoon.ogg')
                except Exception:
                    pass

                fuse = float(throwable_item.get('fuse_time')or throwable_item.get('fuse', 3))
                start_t = time.time()
                end_t = start_t +fuse

                time.sleep(random.uniform(0.8, 1.3))
                try:
                    idx = random.randint(0, 3)
                    self._safe_sound_play('', f'sounds/misc/throwable/bounce{idx}.ogg')
                except Exception:
                    pass

                extra = random.randint(0, 3)
                for bi in range(extra):

                    if time.time()>=end_t and str(throwable_item.get('type', '')).lower()in('fragmentation', 'stun', '9-bang', '9bang', '9_bang'):
                        break
                    if bi ==0:
                        time.sleep(random.uniform(0.2, 0.3))
                    elif bi ==1:
                        time.sleep(random.uniform(0.2, 0.3))
                    else:
                        time.sleep(random.uniform(0.1, 0.2))
                    try:
                        idx = random.randint(0, 3)
                        self._safe_sound_play('', f'sounds/misc/throwable/bounce{idx}.ogg')
                    except Exception:
                        pass

                typ = str(throwable_item.get('type', '')).lower()

                remaining = end_t -time.time()
                if remaining >0:
                    time.sleep(remaining)

                if typ =='fragmentation':
                    try:

                        try:
                            _handle_fragmentation_flash_effects()
                        except Exception:
                            pass

                        try:
                            if _has_flash_goggles():
                                try:
                                    _handle_goggle_dark_flash_effects()
                                except Exception:
                                    pass
                        except Exception:
                            pass
                        self._safe_sound_play('', 'sounds/misc/throwable/explosion.ogg')
                    except Exception:
                        pass
                elif typ =='smoke':
                    try:
                        self._safe_sound_play('', 'sounds/misc/throwable/smoke.ogg')
                    except Exception:
                        pass
                elif typ in('stun', 'flashbang', 'flash'):

                    try:
                        _handle_flashbang_effects(bang_count = 1)
                        self._safe_sound_play('', 'sounds/misc/throwable/flashbang.ogg')
                        try:

                            if _has_flash_goggles():
                                try:
                                    _handle_goggle_dark_flash_effects()
                                except Exception:
                                    pass
                        except Exception:
                            pass
                    except Exception:
                        pass
                elif typ in('9-bang', '9bang', '9_bang'):
                    try:
                        _handle_flashbang_effects(bang_count = 9)
                        for i in range(9):
                            try:
                                self._safe_sound_play('', 'sounds/misc/throwable/flashbang.ogg')

                                try:
                                    if _has_flash_goggles():
                                        try:
                                            _handle_goggle_dark_flash_effects()
                                        except Exception:
                                            pass
                                except Exception:
                                    pass
                            except Exception:
                                pass
                            if i <8:
                                time.sleep(random.uniform(0.3, 0.5))
                    except Exception:
                        pass

                try:
                    update_weapon_view()
                except Exception:
                    pass
            except Exception:
                logging.exception('Throwable sequence failed')

        def throw_throwable():
            all_throw = _find_throwables_in_inventory()
            if not all_throw:
                self._popup_show_info('Throw', 'No throwables in inventory')
                return

            popup = customtkinter.CTkToplevel(self.root)
            popup.title('Select Throwable')
            popup.transient(self.root)
            self._center_popup_on_window(popup, 420, 320)

            lab = customtkinter.CTkLabel(popup, text = 'Select a throwable to throw:', font = customtkinter.CTkFont(size = 12))
            lab.pack(pady = 8)

            sel_var = customtkinter.StringVar(value = '0')
            frame = customtkinter.CTkScrollableFrame(popup, fg_color = 'transparent')
            frame.pack(fill = 'both', expand = True, padx = 10, pady = 10)
            for idx, (loc, itm)in enumerate(all_throw):
                name = itm.get('name')or itm.get('type')or f'Throwable {idx}'
                desc = f"{name} - {loc} - fuse {itm.get('fuse_time')or itm.get('fuse', '?')}s"
                rb = customtkinter.CTkRadioButton(frame, text = desc, variable = sel_var, value = str(idx))
                rb.pack(anchor = 'w', pady = 2)

            def do_throw():
                try:
                    idx = int(sel_var.get())
                    loc, itm = all_throw[idx]
                except Exception:
                    popup.destroy()
                    return
                popup.destroy()

                try:
                    threading.Thread(target = _do_throw_sequence, args =(loc, itm), daemon = True).start()
                except Exception:
                    _do_throw_sequence(loc, itm)

            bframe = customtkinter.CTkFrame(popup, fg_color = 'transparent')
            bframe.pack(fill = 'x', padx = 10, pady = 6)
            customtkinter.CTkButton(bframe, text = 'Throw', command = do_throw, width = 120).pack(side = 'left', padx = 6)
            customtkinter.CTkButton(bframe, text = 'Cancel', command = popup.destroy, width = 120).pack(side = 'left', padx = 6)
            try:
                popup.grab_set()
                popup.lift()
                self._safe_focus(popup)
            except Exception:
                pass

        def use_consumable():

            all_consumables = _find_consumables_in_inventory()
            if not all_consumables:
                self._popup_show_info('Use Consumable', 'No consumables in inventory(hands/equipment)')
                return

            popup = customtkinter.CTkToplevel(self.root)
            popup.title('Select Consumable')
            popup.transient(self.root)
            self._center_popup_on_window(popup, 500, 400)

            lab = customtkinter.CTkLabel(popup, text = 'Select a consumable to use:', font = customtkinter.CTkFont(size = 12))
            lab.pack(pady = 8)

            sel_var = customtkinter.StringVar(value = '0')
            frame = customtkinter.CTkScrollableFrame(popup, fg_color = 'transparent')
            frame.pack(fill = 'both', expand = True, padx = 10, pady = 10)

            for idx, (loc, itm)in enumerate(all_consumables):
                name = itm.get('name')or f'Consumable {idx}'
                uses = itm.get('uses_left')
                loc_display = loc.replace('equipment.', '').replace('.subslots.', ' > ').replace('.current', '')
                if uses:
                    uses_text = f"{uses} use{'s'if uses !=1 else ''}"
                elif itm.get('used_up'):
                    uses_text = "1 use"
                else:
                    uses_text = "âˆž uses"
                desc = f"{name}({uses_text}) - {loc_display}"
                rb = customtkinter.CTkRadioButton(frame, text = desc, variable = sel_var, value = str(idx))
                rb.pack(anchor = 'w', pady = 2)

            def do_consume():
                try:
                    idx = int(sel_var.get())
                    loc, itm = all_consumables[idx]
                except Exception:
                    popup.destroy()
                    return
                popup.destroy()

                item_id = itm.get('id')
                item_name = itm.get('name')

                actual_item = None
                if loc =="hands":
                    for inv_item in save_data.get('hands', {}).get('items', []):
                        if isinstance(inv_item, dict)and inv_item.get('id')==item_id and inv_item.get('name')==item_name:
                            actual_item = inv_item
                            break
                elif loc.startswith("equipment."):
                    parts = loc.split(".")
                    slot = parts[1]
                    eq = save_data.get("equipment", {}).get(slot)
                    if eq and isinstance(eq, dict):
                        if len(parts)>=5 and parts[2]=="subslots":
                            try:
                                subslot_idx = int(parts[3])
                                subslots = eq.get("subslots", [])
                                if subslot_idx <len(subslots):
                                    subslot = subslots[subslot_idx]
                                    curr = subslot.get("current")if isinstance(subslot, dict)else None
                                    if curr and isinstance(curr, dict):
                                        if curr.get('id')==item_id and curr.get('name')==item_name:
                                            actual_item = curr
                                        elif 'items'in curr:
                                            for inv_item in curr.get('items', []):
                                                if isinstance(inv_item, dict)and inv_item.get('id')==item_id and inv_item.get('name')==item_name:
                                                    actual_item = inv_item
                                                    break
                            except(ValueError, IndexError):
                                pass
                        else:
                            for inv_item in eq.get('items', []):
                                if isinstance(inv_item, dict)and inv_item.get('id')==item_id and inv_item.get('name')==item_name:
                                    actual_item = inv_item
                                    break

                if actual_item is None:
                    self._popup_show_info('Error', 'Could not find item in inventory', sound = 'error')
                    return

                def on_consume_complete():
                    try:
                        update_weapon_view()
                    except Exception:
                        pass

                self._consume_item(actual_item, loc, save_data, on_complete = on_consume_complete)

            bframe = customtkinter.CTkFrame(popup, fg_color = 'transparent')
            bframe.pack(fill = 'x', padx = 10, pady = 6)
            customtkinter.CTkButton(bframe, text = 'Use', command = do_consume, width = 120).pack(side = 'left', padx = 6)
            customtkinter.CTkButton(bframe, text = 'Cancel', command = popup.destroy, width = 120).pack(side = 'left', padx = 6)

            try:
                popup.grab_set()
                popup.lift()
                self._safe_focus(popup)
            except Exception:
                pass

        def _show_more_actions():
            try:
                popup = customtkinter.CTkToplevel(self.root)
                popup.title('More Actions')
                popup.geometry('520x420')
                popup.transient(self.root)

                frame = customtkinter.CTkScrollableFrame(popup, fg_color = 'transparent')
                frame.pack(fill = 'both', expand = True, padx = 10, pady = 10)

                def _add(name, cmd, width = 200, height = 44, fg = None):
                    try:

                        def _wrap():
                            try:
                                cmd()
                            except Exception:
                                pass
                            try:
                                popup.destroy()
                            except Exception:
                                pass

                        btn = self._create_sound_button(frame, text = name, command = _wrap, width = width, height = height, font = customtkinter.CTkFont(size = 12))
                        if fg:
                            try:
                                btn.configure(fg_color = fg)
                            except Exception:
                                pass
                        btn.pack(pady = 6)
                    except Exception:
                        pass

                if check_clean_btn is not None:
                    _add('Check Cleanliness', check_cleanliness)
                if check_mag_btn is not None:
                    _add('Check Magazine', check_magazine)
                if throw_btn is not None:
                    _add('Throw', throw_throwable)
                if manage_attach_btn is not None:
                    _add('Manage Attachments', manage_attachments)

                try:
                    has_consumables = len(_find_consumables_in_inventory())>0

                    def _wrap_consume():
                        try:
                            use_consumable()
                        except Exception:
                            pass
                        try:
                            popup.destroy()
                        except Exception:
                            pass

                    consume_btn = self._create_sound_button(frame, text = 'Use Consumable', command = _wrap_consume, width = 200, height = 44, font = customtkinter.CTkFont(size = 12))
                    if not has_consumables:
                        consume_btn.configure(state = 'disabled')
                    consume_btn.pack(pady = 6)
                except Exception:
                    pass

                try:
                    b = customtkinter.CTkButton(popup, text = 'Close', command = popup.destroy, width = 120)
                    b.pack(pady = 6)
                except Exception:
                    pass

                try:
                    popup.grab_set()
                    popup.lift()
                    self._safe_focus(popup)
                except Exception:
                    pass
            except Exception:
                pass

        try:
            self._create_sound_button(actions_frame, text = 'More Actions', command = _show_more_actions, width = 150, height = 50, font = customtkinter.CTkFont(size = 14)).pack(side = 'left', padx = 10, pady = 10)
        except Exception:
            pass

        try:
            throw_btn = self._create_sound_button(actions_frame, text = 'Throw', command = throw_throwable, width = 150, height = 50, font = customtkinter.CTkFont(size = 14), fg_color = '#333333', hover_color = '#444444')
        except Exception:
            throw_btn = None
        try:
            manage_attach_btn = self._create_sound_button(
            actions_frame,
            text = "Manage Attachments",
            command = manage_attachments,
            width = 170,
            height = 50,
            font = customtkinter.CTkFont(size = 14)
            )
        except Exception:
            manage_attach_btn = None

        if global_variables.get("devmode", {}).get("value", False):
            devmode_outer_frame = customtkinter.CTkFrame(main_frame)
            devmode_outer_frame.pack(fill = "x", pady =(0, 20))

            devmode_frame = customtkinter.CTkScrollableFrame(devmode_outer_frame, orientation = "horizontal", height = 60, fg_color = "transparent")
            devmode_frame.pack(fill = "x", expand = True)

            customtkinter.CTkLabel(
            devmode_frame,
            text = "DevMode:",
            font = customtkinter.CTkFont(size = 12)
            ).pack(side = "left", padx = 10)

            def get_variant_choices():
                choices =[]
                weapon_obj = current_weapon_state.get("weapon")or {}
                raw_cal = weapon_obj.get("caliber")

                cal = None
                if isinstance(raw_cal, (list, tuple)):
                    cal = raw_cal[0]if raw_cal else None
                elif isinstance(raw_cal, str):
                    cal = raw_cal

                w_sounds = weapon_obj.get("sounds")or weapon_obj.get("sound_folder")or weapon_obj.get("ammo_type")
                if not cal:
                    active_ub = combat_state.get("active_underbarrel")

                    if active_ub and isinstance(active_ub, dict)and active_ub.get("parent_index")==combat_state.get("current_weapon_index"):
                        aid = active_ub.get("accessory_id")
                        aname = active_ub.get("accessory_name")

                        parent_entry = equipped_weapons[combat_state.get("current_weapon_index")]
                        parent_slot = parent_entry.get("slot", "")
                        if "->"in parent_slot:
                            parent_slot = parent_slot.split("->")[0].strip()
                        parent_item = save_data.get("equipment", {}).get(parent_slot)
                        acc = None
                        if parent_item and isinstance(parent_item, dict):
                            for acc_entry in parent_item.get("accessories", [])or[]:
                                cur = acc_entry.get("current")
                                if isinstance(cur, dict):
                                    if aid is not None and cur.get("id")==aid:
                                        acc = cur ;break
                                    if aname and cur.get("name")==aname:
                                        acc = cur ;break
                                else:
                                    try:
                                        if aid is not None and(isinstance(cur, int)or(isinstance(cur, str)and cur.isdigit()))and int(cur)==int(aid):

                                            tables = table_data.get("tables", {})if isinstance(table_data, dict)else {}
                                            for arr in tables.values():
                                                if isinstance(arr, list):
                                                    for it in arr:
                                                        if isinstance(it, dict)and it.get("id")==int(cur):
                                                            acc = it ;break
                                                    if acc:break
                                    except Exception:
                                        pass
                        if acc and isinstance(acc, dict):
                            raw_cal2 = acc.get("caliber")
                            if isinstance(raw_cal2, (list, tuple)):
                                cal = raw_cal2[0]if raw_cal2 else None
                            elif isinstance(raw_cal2, str):
                                cal = raw_cal2
                            if not cal:
                                w_sounds = acc.get("sounds")or acc.get("sound_folder")or acc.get("ammo_type")

                try:
                    dev_cal_var = current_weapon_state.get("dev_caliber_var")
                    if dev_cal_var and hasattr(dev_cal_var, 'get'):
                        sel = dev_cal_var.get()
                        if sel:
                            cal = sel
                except Exception:
                    pass

                ammo_tables = table_data.get("tables", {}).get("ammunition", [])if table_data else[]
                for ammo in ammo_tables:
                    try:

                        ammo_cal = ammo.get("caliber")
                        match_cal = False
                        if cal and ammo_cal:
                            if isinstance(ammo_cal, (list, tuple)):
                                match_cal = any((isinstance(a, str)and a ==cal)for a in ammo_cal)
                            elif isinstance(ammo_cal, str):
                                match_cal =(ammo_cal ==cal)

                        if match_cal:
                            for var in ammo.get("variants", [])or[]:
                                choices.append(var.get("name", "Unknown"))
                            continue

                        if w_sounds and(ammo.get("sounds")==w_sounds or ammo.get("ammo_type")==w_sounds):
                            for var in ammo.get("variants", [])or[]:
                                choices.append(var.get("name", "Unknown"))
                    except Exception:
                        pass
                return choices or["Ball"]

            variant_var = customtkinter.StringVar(value = get_variant_choices()[0])
            customtkinter.CTkLabel(
            devmode_frame,
            text = "Variant:",
            font = customtkinter.CTkFont(size = 12)
            ).pack(side = "left", padx = 5)

            try:

                wpn_for_dev =(current_weapon_state.get("weapon")if isinstance(current_weapon_state, dict)else None)or {}
                raw_cal_list = wpn_for_dev.get("caliber")if isinstance(wpn_for_dev, dict)else None
                calib_values =[]
                if isinstance(raw_cal_list, (list, tuple)):
                    calib_values =[str(x)for x in raw_cal_list if x is not None]
                elif isinstance(raw_cal_list, str):
                    calib_values =[raw_cal_list]

                if not calib_values:
                    calib_values =[]

                caliber_var = customtkinter.StringVar(value =(calib_values[0]if calib_values else ""))

                def _on_caliber_change(val):
                    try:
                        current_weapon_state["dev_caliber_var"]= caliber_var

                        try:
                            new_choices = get_variant_choices()

                            try:
                                if variant_menu:
                                    variant_menu.configure(values = new_choices)
                                    if variant_var.get()not in new_choices:
                                        variant_var.set(new_choices[0])
                            except Exception:
                                try:
                                    variant_menu.set_values(new_choices)
                                    if variant_var.get()not in new_choices:
                                        variant_var.set(new_choices[0])
                                except Exception:
                                    pass
                        except Exception:
                            pass
                    except Exception:
                        pass

                calib_vals_for_widget = calib_values if calib_values else["None"]
                caliber_menu = customtkinter.CTkOptionMenu(devmode_frame, values = calib_vals_for_widget, variable = caliber_var, command = _on_caliber_change, width = 140)
                caliber_menu.pack(side = "left", padx = 5)
                if len(calib_values)<=1:
                    try:
                        caliber_menu.configure(state = "disabled")
                    except Exception:
                        pass
                current_weapon_state["dev_caliber_menu_ref"]= caliber_menu
                current_weapon_state["dev_caliber_var"]= caliber_var
            except Exception:
                logging.exception("Failed to create DevMode caliber menu")

            variant_menu = customtkinter.CTkOptionMenu(
            devmode_frame,
            values = get_variant_choices(),
            variable = variant_var,
            width = 120
            )
            variant_menu.pack(side = "left", padx = 5)

            current_weapon_state["dev_variant_menu_ref"]= variant_menu
            current_weapon_state["dev_variant_var"]= variant_var

            def add_ammo():
                try:
                    current_weapon = current_weapon_state["weapon"]
                    mag_type = current_weapon.get("magazinetype", "Unknown")
                    capacity = current_weapon.get("capacity", 30)

                    caliber_name = caliber_var.get()if caliber_var.get()else current_weapon.get('caliber', ['rnd'])[0]
                    variant_name = variant_var.get()

                    ammo_tables = table_data.get("tables", {}).get("ammunition", [])if table_data else[]
                    ammo_sounds = None
                    ammo_entry = None
                    for ammo in ammo_tables:
                        try:
                            ammo_cal = ammo.get("caliber")
                            if ammo_cal ==caliber_name:
                                ammo_sounds = ammo.get("sounds")
                                ammo_entry = ammo
                                break

                            if isinstance(ammo_cal, (list, tuple))and caliber_name in ammo_cal:
                                ammo_sounds = ammo.get("sounds")
                                ammo_entry = ammo
                                break
                        except Exception:
                            pass

                    dummy_round = {
                    "name":f"{caliber_name} | {variant_name}",
                    "caliber":caliber_name,
                    "variant":variant_name
                    }
                    if ammo_sounds:
                        dummy_round["sounds"]= ammo_sounds

                    if ammo_entry:
                        for var in ammo_entry.get("variants", [])or[]:
                            if var.get("name")==variant_name:
                                if var.get("type"):
                                    dummy_round["type"]= var.get("type")
                                if var.get("pen"):
                                    dummy_round["pen"]= var.get("pen")
                                if var.get("tip"):
                                    dummy_round["tip"]= var.get("tip")
                                if var.get("modifiers"):
                                    dummy_round["modifiers"]= var.get("modifiers")
                                break

                    loaded_mag = {
                    "magazinetype":mag_type,
                    "magazinesystem":current_weapon.get("magazinesystem"),
                    "capacity":capacity,
                    "rounds":[dict(dummy_round)for _ in range(capacity)]
                    }
                    current_weapon["loaded"]= loaded_mag

                    if loaded_mag["rounds"]:
                        current_weapon["chambered"]= loaded_mag["rounds"].pop(0)

                    self._popup_show_info("DevMode Ammo", f"Filled mag({mag_type}) with {capacity} {caliber_name} {variant_name} rounds and chambered one")
                    update_weapon_view()
                except Exception as e:
                    self._popup_show_info("DevMode Error", str(e))

            def devmode_debug():
                try:
                    wpn = current_weapon_state.get("weapon")or {}
                    cal =(wpn.get("caliber")or[])
                    if isinstance(cal, (list, tuple)):
                        cal_val = cal[0]if cal else None
                    else:
                        cal_val = cal
                    w_sounds = wpn.get("sounds")or wpn.get("sound_folder")or wpn.get("ammo_type")
                    ammo_tables = table_data.get("tables", {}).get("ammunition", [])if table_data else[]
                    matches =[]
                    for ammo in ammo_tables:
                        try:
                            if cal_val and ammo.get("caliber")==cal_val:
                                matches.append(ammo.get("name"))
                            elif w_sounds and(ammo.get("sounds")==w_sounds or ammo.get("ammo_type")==w_sounds):
                                matches.append(ammo.get("name"))
                        except Exception:
                            pass

                    msg = f"Weapon: {wpn.get('name')}\ncaliber: {cal_val}\nsounds: {w_sounds}\nMatched ammo: {matches}"
                    self._popup_show_info("DevMode Debug", msg)
                except Exception as e:
                    logging.exception("DevMode debug failed: %s", e)

            customtkinter.CTkButton(devmode_frame, text = "Debug Variants", command = devmode_debug, width = 140).pack(side = "left", padx = 8)

            def add_all_throwables():
                try:

                    found =[]
                    tables = table_data.get("tables", {})if table_data else {}
                    for tname, items in tables.items():
                        try:
                            for it in items:
                                try:
                                    typ = str(it.get('type', '')).lower()
                                    if typ in('fragmentation', 'smoke', 'stun', '9-bang', '9bang', '9_bang'):
                                        item_copy = it.copy()
                                        item_copy = add_subslots_to_item(item_copy)
                                        found.append(item_copy)
                                except Exception:
                                    pass
                        except Exception:
                            pass

                    if not found:

                        found =[
                        {"name":"Fragmentation Grenade", "type":"fragmentation", "fuse":3},
                        {"name":"Smoke Grenade", "type":"smoke", "fuse":3},
                        {"name":"Stun Grenade", "type":"stun", "fuse":3},
                        {"name":"9-Bang", "type":"9-bang", "fuse":3},
                        ]

                    if not currentsave:
                        self._popup_show_info('DevMode Error', 'No active save to modify.', sound = 'error')
                        return
                    save_path = os.path.join(saves_folder or "", (currentsave or "")+".sldsv")
                    if not os.path.exists(save_path):
                        self._popup_show_info('DevMode Error', f'Save file not found: {save_path}', sound = 'error')
                        return

                    added = 0
                    sd = globals().get('save_data')if 'save_data'in globals()else None
                    logging.debug(f"DevMode Add Throwables: currentsave={currentsave}, save_path={save_path}, in_memory_save_present={isinstance(sd, dict)}")
                    if isinstance(sd, dict):
                        try:
                            before = len(sd.get('hands', {}).get('items', []))if sd.get('hands')else 0
                            sd.setdefault('hands', {})
                            sd['hands'].setdefault('items', [])
                            for itm in found:
                                try:
                                    sd['hands']['items'].append(itm.copy()if isinstance(itm, dict)else itm)
                                    added +=1
                                except Exception:
                                    logging.exception('Failed to append throwable to in-memory hands')
                            after = len(sd.get('hands', {}).get('items', []))
                            logging.debug(f"Added to in-memory hands: before={before}, after={after}, added={added}")

                            try:
                                globals()['save_data']= sd
                            except Exception:
                                pass

                            try:
                                self._save_file(sd)
                            except Exception:
                                logging.exception('Failed to persist save_data after adding throwables')

                            try:
                                if 'save_data'in globals():

                                    outer = globals().get('save_data')
                                    if outer is not sd and isinstance(outer, dict)and isinstance(sd, dict):
                                        outer.clear()
                                        outer.update(sd)
                                        globals()['save_data']= outer
                                        logging.debug('Synchronized global save_data object in-place after in-memory save')
                            except Exception:
                                logging.exception('Failed to synchronize save_data object in-place')
                        except Exception:
                            logging.exception('Failed to add throwables to in-memory save_data')
                    else:

                        try:
                            file_sd = self._read_save_from_path(save_path)
                            if file_sd is None:
                                file_sd = {}
                        except Exception:
                            file_sd = {}
                        try:
                            before = len(file_sd.get('hands', {}).get('items', []))if file_sd.get('hands')else 0
                            file_sd.setdefault('hands', {})
                            file_sd['hands'].setdefault('items', [])
                            for itm in found:
                                try:
                                    file_sd['hands']['items'].append(itm.copy()if isinstance(itm, dict)else itm)
                                    added +=1
                                except Exception:
                                    logging.exception('Failed to append throwable to save file hands')
                            after = len(file_sd.get('hands', {}).get('items', []))
                            logging.debug(f"Added to file hands: before={before}, after={after}, added={added}")

                            try:
                                self._save_file(file_sd)
                            except Exception:
                                logging.exception('Failed to persist save file after adding throwables')

                            try:
                                loaded = self._load_file(currentsave)
                                if loaded and isinstance(loaded, dict):

                                    globals()['save_data']= loaded
                                    logging.debug('Reloaded save into memory after DevMode add_all_throwables')

                                    try:

                                        if isinstance(save_data, dict):
                                            save_data.clear()
                                            save_data.update(loaded)
                                            logging.debug('Updated enclosing save_data object in-place after reload')
                                    except Exception:
                                        logging.debug('No enclosing save_data to update in-place or update failed')
                            except Exception:
                                logging.exception('Failed to reload save into memory after adding throwables')
                        except Exception:
                            logging.exception('Failed to add throwables to save file')

                    self._popup_show_info('DevMode', f'Added {added} throwables to hands', sound = 'success')
                    try:
                        update_weapon_view()
                    except Exception:
                        pass
                except Exception as e:
                    logging.exception('Failed to add throwables: %s', e)
                    self._popup_show_info('DevMode Error', str(e), sound = 'error')

            customtkinter.CTkButton(devmode_frame, text = "Add All Throwables", command = add_all_throwables, width = 160).pack(side = "left", padx = 8)

            def reset_temperature():
                try:
                    current_weapon = current_weapon_state["weapon"]
                    weapon_id = str(current_weapon.get("id"))
                    combat_state["barrel_temperatures"][weapon_id]= combat_state["ambient_temperature"]
                    self._popup_show_info("DevMode Temp", f"Barrel temperature reset to ambient")
                    update_weapon_view()
                except Exception as e:
                    self._popup_show_info("DevMode Error", str(e))

            def reset_cleanliness():
                try:
                    current_weapon = current_weapon_state["weapon"]
                    weapon_id = str(current_weapon.get("id"))
                    combat_state["barrel_cleanliness"][weapon_id]= 100
                    self._popup_show_info("DevMode Clean", f"Barrel cleanliness reset to 100%")
                    update_weapon_view()
                except Exception as e:
                    self._popup_show_info("DevMode Error", str(e))

            def add_individual_rounds():

                try:
                    current_weapon = current_weapon_state["weapon"]
                    raw_cal = current_weapon.get("caliber", [])or[]
                    if isinstance(raw_cal, (list, tuple)):
                        caliber = raw_cal[0]if raw_cal else None
                    else:
                        caliber = raw_cal

                    ammo_tables = table_data.get("tables", {}).get("ammunition", [])if table_data else[]
                    ammo_def = None
                    for a in ammo_tables:
                        try:
                            a_cal = a.get("caliber")

                            if caliber is not None:
                                if isinstance(a_cal, (list, tuple))and isinstance(caliber, str)and caliber in a_cal:
                                    ammo_def = a ;break
                                if isinstance(a_cal, str)and isinstance(caliber, str)and a_cal ==caliber:
                                    ammo_def = a ;break

                            a_id = a.get("id")
                            if a_id is not None and str(a_id)==str(caliber):
                                ammo_def = a ;break

                            w_sounds = None
                            if isinstance(caliber, str):
                                w_sounds = caliber
                            if w_sounds and(a.get("sounds")==w_sounds or a.get("ammo_type")==w_sounds):
                                ammo_def = a ;break
                        except Exception:
                            continue

                    if not ammo_def:
                        self._popup_show_info("DevMode Error", f"No ammunition definition found for {repr(caliber)}")
                        return

                    variant_name = variant_var.get()
                    variant_info = None
                    for var in ammo_def.get("variants", []):
                        if var.get("name")==variant_name:
                            variant_info = var
                            break
                    if not variant_info and ammo_def.get("variants"):
                        variant_info = ammo_def["variants"][0]

                    single_round = {
                    "name":f"{caliber} | {variant_name}",
                    "caliber":caliber,
                    "variant":variant_name,
                    "weight":ammo_def.get("weight", 0.01),
                    "value":ammo_def.get("value", 0),
                    "sounds":ammo_def.get("sounds", ""),
                    "description":f"{caliber} - {variant_name}"
                    }
                    if variant_info:
                        if variant_info.get("type"):
                            single_round["type"]= variant_info.get("type")
                        if variant_info.get("pen"):
                            single_round["pen"]= variant_info.get("pen")
                        if variant_info.get("tip"):
                            single_round["tip"]= variant_info.get("tip")
                        if variant_info.get("modifiers"):
                            single_round["modifiers"]= variant_info.get("modifiers")

                    hands = save_data.get("hands", {})
                    if "items"not in hands or not isinstance(hands.get("items"), list):
                        hands["items"]=[]
                        save_data["hands"]= hands

                    ammo_item = dict(single_round)
                    ammo_item["quantity"]= 500
                    hands["items"].append(ammo_item)

                    self._popup_show_info("DevMode Ammo", f"Added 500 rounds(stacked) to hands")
                    update_weapon_view()
                except Exception as e:
                    logging.error(f"Error adding rounds: {e}")
                    self._popup_show_info("DevMode Error", str(e))

            def add_individual_magazine():

                try:
                    current_weapon = current_weapon_state["weapon"]
                    mag_system = current_weapon.get("magazinesystem")

                    sub_mag_system = current_weapon.get("submagazinesystem")or current_weapon.get("submagazinetype")
                    caliber_list = current_weapon.get("caliber", [])or[]
                    caliber = caliber_list[0]if caliber_list else "Unknown"
                    try:
                        dev_cal_var = current_weapon_state.get("dev_caliber_var")
                        if dev_cal_var and hasattr(dev_cal_var, 'get'):
                            sel = dev_cal_var.get()
                            if sel:
                                caliber = sel
                    except Exception:
                        pass

                    if not mag_system and sub_mag_system:
                        mag_system = sub_mag_system

                    if not mag_system:
                        self._popup_show_info("DevMode Error", "Weapon doesn't use detachable magazines")
                        return

                    magazines_table = table_data.get("tables", {}).get("magazines", [])

                    compatible_mags =[]
                    for mag in magazines_table:
                        m_ms = mag.get("magazinesystem")
                        if m_ms ==mag_system or(sub_mag_system and m_ms ==sub_mag_system):
                            compatible_mags.append(mag)

                    try:
                        dev_cal_var = current_weapon_state.get("dev_caliber_var")
                        if dev_cal_var and hasattr(dev_cal_var, 'get'):
                            sel_cal = dev_cal_var.get()
                            if sel_cal:
                                def _template_matches_cal(m, c):
                                    try:
                                        mcal = m.get("caliber")
                                        if isinstance(mcal, (list, tuple)):
                                            return any(str(e)==str(c)for e in mcal)
                                        if isinstance(mcal, str):
                                            return str(mcal)==str(c)
                                        return False
                                    except Exception:
                                        return False
                                compatible_mags =[m for m in compatible_mags if _template_matches_cal(m, sel_cal)]
                    except Exception:
                        pass

                    if not compatible_mags:
                        self._popup_show_info("DevMode Error", f"No magazines in table for {mag_system}")
                        return

                    if len(compatible_mags)>1:
                        try:
                            opt_names =[str(m.get('name')or f"Mag {i}")for i, m in enumerate(compatible_mags)]
                            choice = self._popup_select_option("Select Magazine", "Multiple compatible magazines found.Choose one to add:", opt_names)
                            if not choice:
                                return

                            sel_index = opt_names.index(choice)
                            mag_template = compatible_mags[sel_index]
                        except Exception:
                            mag_template = compatible_mags[0]
                    else:
                        mag_template = compatible_mags[0]
                    capacity = mag_template.get("capacity", 30)

                    variant_name = variant_var.get()
                    round_format = f"{caliber} | {variant_name}"

                    ammo_tables = table_data.get("tables", {}).get("ammunition", [])if table_data else[]
                    variant_info = None
                    for ammo in ammo_tables:
                        ammo_cal = ammo.get("caliber")
                        cal_match = False
                        if isinstance(ammo_cal, (list, tuple)):
                            cal_match = caliber in ammo_cal
                        elif isinstance(ammo_cal, str):
                            cal_match = ammo_cal ==caliber
                        if cal_match:
                            for var in ammo.get("variants", []):
                                if var.get("name")==variant_name:
                                    variant_info = var
                                    break
                            if not variant_info and ammo.get("variants"):
                                variant_info = ammo["variants"][0]
                            break

                    round_obj = {"name":round_format, "caliber":caliber, "variant":variant_name}
                    if variant_info:
                        if variant_info.get("type"):
                            round_obj["type"]= variant_info.get("type")
                        if variant_info.get("pen"):
                            round_obj["pen"]= variant_info.get("pen")
                        if variant_info.get("tip"):
                            round_obj["tip"]= variant_info.get("tip")
                        if variant_info.get("modifiers"):
                            round_obj["modifiers"]= variant_info.get("modifiers")

                    new_mag = {
                    "name":mag_template.get("name"),
                    "id":mag_template.get("id"),
                    "magazinetype":mag_template.get("magazinetype", "Unknown"),
                    "magazinesystem":mag_system,
                    "capacity":capacity,
                    "rounds":[dict(round_obj)for _ in range(capacity)]
                    }

                    save_data.get("hands", {}).get("items", []).append(new_mag)

                    self._popup_show_info("DevMode Ammo", f"Added {mag_template.get('name')} to hands\n({capacity} rounds, {mag_system})")
                    update_weapon_view()
                except Exception as e:
                    logging.error(f"Error adding magazine: {e}")
                    self._popup_show_info("DevMode Error", str(e))

            def add_belt():

                try:
                    current_weapon = current_weapon_state["weapon"]
                    magazines_table = table_data.get("tables", {}).get("magazines", [])

                    beltlink = str(current_weapon.get("beltlink", "")or "").lower()
                    candidates =[]
                    for mag in magazines_table:
                        name = str(mag.get("name", "")or "").lower()
                        mtype = str(mag.get("magazinetype", "")or "").lower()
                        if mtype =="belt":
                            candidates.append(mag)
                        elif beltlink and str(mag.get("beltlink", "")or "").lower()==beltlink:
                            candidates.append(mag)
                        elif "belt"in name:
                            candidates.append(mag)

                    if not candidates:
                        self._popup_show_info("DevMode Error", "No belt entries found in tables")
                        return

                    mag_template = candidates[0]

                    rnd = mag_template.get("random_quantity")
                    if isinstance(rnd, dict)and "min"in rnd and "max"in rnd:
                        import random as _r
                        capacity = _r.randint(int(rnd.get("min", 50)), int(rnd.get("max", 200)))
                    else:
                        capacity = int(mag_template.get("capacity")or 200)

                    caliber_list = current_weapon.get("caliber", [])or[]
                    caliber = caliber_list[0]if caliber_list else mag_template.get("caliber", ["Unknown"])[0]
                    variant_name = variant_var.get()

                    ammo_tables = table_data.get("tables", {}).get("ammunition", [])if table_data else[]
                    variant_info = None
                    for ammo in ammo_tables:
                        ammo_cal = ammo.get("caliber")
                        cal_match = False
                        if isinstance(ammo_cal, (list, tuple)):
                            cal_match = caliber in ammo_cal
                        elif isinstance(ammo_cal, str):
                            cal_match = ammo_cal ==caliber
                        if cal_match:
                            for var in ammo.get("variants", []):
                                if var.get("name")==variant_name:
                                    variant_info = var
                                    break
                            if not variant_info and ammo.get("variants"):
                                variant_info = ammo["variants"][0]
                            break

                    round_obj = {"name":f"{caliber} | {variant_name}", "caliber":caliber, "variant":variant_name}
                    if variant_info:
                        if variant_info.get("type"):
                            round_obj["type"]= variant_info.get("type")
                        if variant_info.get("pen"):
                            round_obj["pen"]= variant_info.get("pen")
                        if variant_info.get("tip"):
                            round_obj["tip"]= variant_info.get("tip")
                        if variant_info.get("modifiers"):
                            round_obj["modifiers"]= variant_info.get("modifiers")

                    new_belt = {
                    "name":mag_template.get("name", "Belt"),
                    "id":mag_template.get("id"),
                    "magazinetype":mag_template.get("magazinetype", "Belt"),
                    "magazinesystem":mag_template.get("magazinesystem"),
                    "capacity":capacity,
                    "rounds":[dict(round_obj)for _ in range(capacity)]
                    }

                    save_data.get("hands", {}).get("items", []).append(new_belt)
                    self._popup_show_info("DevMode Belt", f"Added {new_belt.get('name')} to hands({capacity} rounds)")
                    update_weapon_view()
                except Exception as e:
                    logging.exception("Error adding belt: %s", e)
                    self._popup_show_info("DevMode Error", str(e))

            self._create_sound_button(
            devmode_frame,
            text = "Fill Magazine",
            command = add_ammo,
            width = 120,
            height = 40,
            font = customtkinter.CTkFont(size = 12),
            fg_color = "#8B4513",
            hover_color = "#A0522D"
            ).pack(side = "left", padx = 5, pady = 10)

            self._create_sound_button(
            devmode_frame,
            text = "Add Rounds",
            command = add_individual_rounds,
            width = 120,
            height = 40,
            font = customtkinter.CTkFont(size = 12),
            fg_color = "#8B4513",
            hover_color = "#A0522D"
            ).pack(side = "left", padx = 5, pady = 10)

            self._create_sound_button(
            devmode_frame,
            text = "Add Magazine",
            command = add_individual_magazine,
            width = 120,
            height = 40,
            font = customtkinter.CTkFont(size = 12),
            fg_color = "#8B4513",
            hover_color = "#A0522D"
            ).pack(side = "left", padx = 5, pady = 10)

            self._create_sound_button(
            devmode_frame,
            text = "Add Belt",
            command = add_belt,
            width = 120,
            height = 40,
            font = customtkinter.CTkFont(size = 12),
            fg_color = "#8B4513",
            hover_color = "#A0522D"
            ).pack(side = "left", padx = 5, pady = 10)

            self._create_sound_button(
            devmode_frame,
            text = "Reset Temp",
            command = reset_temperature,
            width = 120,
            height = 40,
            font = customtkinter.CTkFont(size = 12),
            fg_color = "#8B4513",
            hover_color = "#A0522D"
            ).pack(side = "left", padx = 5, pady = 10)

            self._create_sound_button(
            devmode_frame,
            text = "Reset Clean",
            command = reset_cleanliness,
            width = 120,
            height = 40,
            font = customtkinter.CTkFont(size = 12),
            fg_color = "#8B4513",
            hover_color = "#A0522D"
            ).pack(side = "left", padx = 5, pady = 10)

        list_label = customtkinter.CTkLabel(
        main_frame,
        text = "Available Weapons",
        font = customtkinter.CTkFont(size = 14, weight = "bold")
        )
        list_label.pack(pady =(10, 5))

        list_frame = customtkinter.CTkFrame(main_frame)
        list_frame.pack(fill = "both", padx = 10, pady =(0, 20))

        for idx, weapon_data in enumerate(equipped_weapons):
            weapon_item = weapon_data["item"]
            is_selected =(idx ==combat_state["current_weapon_index"])

            weapon_btn_frame = customtkinter.CTkFrame(
            list_frame,
            fg_color = "#2D3B45"if is_selected else "#1F2B35"
            )
            weapon_btn_frame.pack(fill = "x", pady = 2)

            weapon_label = customtkinter.CTkLabel(
            weapon_btn_frame,
            text = f"{weapon_data['display_name']} - {weapon_data['slot']}",
            font = customtkinter.CTkFont(size = 12),
            text_color = "#00FF00"if is_selected else "#FFFFFF"
            )
            weapon_label.pack(side = "left", padx = 10, pady = 5)

            def switch_to(w_idx = idx, w_item = weapon_item):

                try:
                    self._play_firearm_sound(w_item, "equip")
                except Exception:
                    pass
                combat_state["current_weapon_index"]= w_idx
                refresh_weapon_display()

            self._create_sound_button(
            weapon_btn_frame,
            text = "Select",
            command = switch_to,
            width = 100,
            height = 30,
            font = customtkinter.CTkFont(size = 11)
            ).pack(side = "right", padx = 10, pady = 5)

        poll_cancel = None

        def poll_temperature_update():

            nonlocal poll_cancel
            try:
                wpn = current_weapon_state["weapon"]
                weapon_id = str(wpn.get("id"))
                current_temp = combat_state.get("barrel_temperatures", {}).get(weapon_id)

                if current_temp is not None and current_temp !=combat_state.get("ambient_temperature", 70):
                    now_ts = time.time()
                    last_used = combat_state.get("weapon_last_used", {}).get(weapon_id)
                    if last_used is None and weapon_id in combat_state.get("barrel_temperatures", {}):

                        assumed_interval = combat_state.get("temp_poll_interval", 15)
                        last_used = now_ts -float(assumed_interval)
                    elapsed = max(0.0, now_ts -last_used)if last_used is not None else 0.0

                    if elapsed >0:
                        ambient = combat_state.get("ambient_temperature", 70)
                        default_k = math.log(2.0)/300.0
                        magic_k = math.log(2.0)/600.0
                        magicsys_local = str(wpn.get("magicsoundsystem")or "").lower()
                        is_magic_local =(str(wpn.get("type")or "").lower()=="magic")or(magicsys_local in("hg", "at", "mg", "rf"))
                        k = magic_k if is_magic_local else default_k
                        new_temp = ambient +(current_temp -ambient)*math.exp(-k *elapsed)
                        low = min(ambient, current_temp)
                        high = max(ambient, current_temp)
                        new_temp = min(max(new_temp, low), high)
                        combat_state["barrel_temperatures"][weapon_id]= new_temp
                        combat_state.setdefault("weapon_last_used", {})[weapon_id]= now_ts

                        update_weapon_view()
                        logging.debug(f"Temperature cooled from {current_temp:.2f}Â°F to {new_temp:.2f}Â°F")

                        try:
                            cookoff_thresh = float(combat_state.get("cookoff_temp", 1500))
                        except Exception:
                            cookoff_thresh = 1500.0
                        if new_temp >=cookoff_thresh:

                            per_sec_prob = min(0.02, max(0.0, (new_temp -cookoff_thresh)/10000.0))
                            cookoff_prob = 1.0 -((1.0 -per_sec_prob)**max(1.0, elapsed))
                            if random.random()<cookoff_prob:
                                try:

                                    fired = False
                                    if isinstance(wpn, dict)and wpn.get("chambered"):
                                        wpn["chambered"]= None
                                        fired = True
                                    elif isinstance(wpn, dict)and wpn.get("loaded")and isinstance(wpn.get("loaded"), dict)and wpn["loaded"].get("rounds"):
                                        try:
                                            wpn["loaded"]["rounds"].pop(0)
                                            fired = True
                                        except Exception:
                                            fired = False
                                    elif isinstance(wpn, dict)and wpn.get("rounds"):
                                        try:
                                            wpn["rounds"].pop(0)
                                            fired = True
                                        except Exception:
                                            fired = False

                                    if fired:
                                        try:

                                            self._play_firearm_sound(wpn, "fire")
                                        except Exception:
                                            pass

                                        try:
                                            temp_gain = float(wpn.get("temp_gain_per_shot", wpn.get("temp_gain", 7)))
                                        except Exception:
                                            temp_gain = 7.0
                                        if self._check_weapon_suppressed(wpn):
                                            temp_gain *=1.5
                                        new_temp = new_temp +(temp_gain *0.5)
                                        combat_state["barrel_temperatures"][weapon_id]= new_temp
                                        combat_state.setdefault("weapon_last_used", {})[weapon_id]= now_ts
                                        update_weapon_view()
                                        logging.warning("Cook-off occurred for weapon %s at %.1fÂ°F", wpn.get("name", weapon_id), new_temp)
                                except Exception:
                                    logging.exception("Cook-off handling failed")

                poll_cancel = self.root.after(15000, poll_temperature_update)
            except Exception as e:
                logging.debug(f"Temperature polling error: {e}")

                poll_cancel = self.root.after(15000, poll_temperature_update)

        poll_cancel = self.root.after(15000, poll_temperature_update)

        def exit_combat():

            nonlocal poll_cancel, reload_pending_id

            if poll_cancel:
                try:
                    self.root.after_cancel(poll_cancel)
                except Exception:
                    pass

            try:
                if reload_pending_id and reload_pending_id[0]:
                    try:
                        self.root.after_cancel(reload_pending_id[0])
                    except Exception:
                        pass
                    reload_pending_id[0]= None
            except Exception:
                pass

            try:
                for k in("<Left>", "<Right>", "<space>", "r", "R"):
                    try:
                        self.root.unbind(k)
                    except Exception:
                        pass
            except Exception:
                pass

            self._save_combat_state(save_data)

            try:
                prev = current_weapon_state.get('prev_tk_scaling')
                if prev is not None:
                    try:
                        self.root.tk.call('tk', 'scaling', float(prev))
                    except Exception:
                        pass
            except Exception:
                pass

            self._clear_window()
            self._build_main_menu()

        self._create_sound_button(
        main_frame,
        text = "Exit Combat Mode",
        command = exit_combat,
        fg_color = "#8B0000",
        hover_color = "#A52A2A",
        height = 50,
        font = customtkinter.CTkFont(size = 14)
        ).pack(pady = 10)

        try:

            main_frame.update_idletasks()
            req_w = main_frame.winfo_reqwidth()or 1
            req_h = main_frame.winfo_reqheight()or 1
            sw = self.root.winfo_screenwidth()or 1
            sh = self.root.winfo_screenheight()or 1
            margin = 40
            if req_w +margin >sw or req_h +margin >sh:
                scale_w = float(sw -margin)/float(req_w)
                scale_h = float(sh -margin)/float(req_h)
                new_scale = min(scale_w, scale_h, 1.0)

                new_scale = max(new_scale, 0.6)
                try:
                    prev_scale = float(self.root.tk.call('tk', 'scaling'))
                except Exception:
                    prev_scale = 1.0

                try:
                    current_weapon_state['prev_tk_scaling']= prev_scale
                except Exception:
                    pass
                try:
                    self.root.tk.call('tk', 'scaling', new_scale)
                    main_frame.update_idletasks()
                except Exception:
                    pass
        except Exception:
            pass

        self._save_combat_state(save_data)
        self._save_combat_state(save_data)

    def _get_equipped_weapons(self, save_data, table_data):

        weapons =[]
        import copy

        def _resolve_table_item(tid):
            try:

                tables = table_data.get("tables", {})if isinstance(table_data, dict)else {}
                for tname, arr in tables.items():
                    if isinstance(arr, list):
                        for it in arr:
                            if isinstance(it, dict)and it.get("id")==tid:
                                return copy.deepcopy(it)
            except Exception:
                pass
            return None

        for slot_name, item in save_data.get("equipment", {}).items():
            if item and isinstance(item, dict)and item.get("firearm"):
                weapons.append({
                "item":item,
                "slot":slot_name,
                "display_name":item.get("name", "Unknown Weapon")
                })

            if item and isinstance(item, dict)and "subslots"in item:
                for subslot in item["subslots"]:
                    if subslot.get("current")and isinstance(subslot.get("current"), dict)and subslot["current"].get("firearm"):
                        weapons.append({
                        "item":subslot["current"],
                        "slot":f"{slot_name} -> {subslot['name']}",
                        "display_name":subslot["current"].get("name", "Unknown Weapon")
                        })

            try:
                if item and isinstance(item, dict)and item.get("accessories"):
                    for acc in(item.get("accessories")or[]):
                        cur = acc.get("current")
                        resolved = None
                        if cur and isinstance(cur, dict):
                            resolved = cur
                        else:

                            try:
                                if isinstance(cur, int)or(isinstance(cur, str)and cur.isdigit()):
                                    tid = int(cur)
                                    resolved = _resolve_table_item(tid)
                            except Exception:
                                resolved = None

                        if resolved and isinstance(resolved, dict)and resolved.get("underbarrel_weapon"):
                            weapons.append({
                            "item":resolved,
                            "slot":f"{slot_name} -> {acc.get('name', 'Underbarrel')}",
                            "display_name":resolved.get("name", "Underbarrel Weapon"),
                            "underbarrel":True,
                            "parent_slot":slot_name,
                            "underbarrel_platform":resolved.get("underbarrel_platform")or resolved.get("platform")
                            })
            except Exception:
                pass

        return weapons

    def _apply_item_overrides(self, weapon):

        import copy

        MISSING = object()

        applied = weapon.get("_applied_overrides", {})or {}
        if applied:
            try:
                logging.info("_apply_item_overrides: restoring previous applied overrides keys=%s for weapon id=%s", list(applied.keys()), weapon.get('id'))
            except Exception:
                pass
        for k, orig in list(applied.items()):
            try:
                if orig is MISSING:
                    if k in weapon:
                        del weapon[k]
                else:
                    weapon[k]= orig
            except Exception:

                pass

        weapon["_applied_overrides"]= {}

        def _resolve_table_current(cur_val):

            if cur_val and isinstance(cur_val, dict):
                return cur_val
            try:
                if isinstance(cur_val, int)or(isinstance(cur_val, str)and str(cur_val).isdigit()):
                    tid = int(cur_val)
                else:
                    return None
            except Exception:
                return None

            try:
                tdata = globals().get('table_data')
                if isinstance(tdata, dict):
                    tables = tdata.get('tables', {})
                    for arr in tables.values():
                        if isinstance(arr, list):
                            for it in arr:
                                if isinstance(it, dict)and it.get('id')==tid:
                                    return it
            except Exception:
                pass

            try:
                import json, os, glob
                table_files = sorted(glob.glob(os.path.join('tables', f"*{global_variables.get('table_extension', '.sldtbl')}")))
                for tf in table_files:
                    try:
                        with open(tf, 'r', encoding = 'utf-8')as fh:
                            td = json.load(fh)
                    except Exception:
                        continue
                    for arr in td.get('tables', {}).values():
                        if isinstance(arr, list):
                            for it in arr:
                                if isinstance(it, dict)and it.get('id')==tid:
                                    return it
            except Exception:
                pass

            return None

        for acc in weapon.get("accessories", [])or[]:
            cur_raw = acc.get("current")
            cur = _resolve_table_current(cur_raw)if cur_raw is not None else None

            if cur and isinstance(cur, dict):
                try:
                    logging.info("_apply_item_overrides: found accessory for overrides: id=%s name=%s on weapon id=%s", cur.get('id'), cur.get('name'), weapon.get('id'))
                except Exception:
                    pass
                overrides = cur.get("overrides")or {}
                if isinstance(overrides, dict):
                    for k, v in overrides.items():

                        if k not in weapon.get("_applied_overrides", {}):
                            orig = weapon.get(k, MISSING)
                            weapon.setdefault("_applied_overrides", {})[k]= orig
                            try:
                                logging.info("_apply_item_overrides: recording original value for key=%s orig=%s", k, orig)
                            except Exception:
                                pass

                        try:
                            weapon[k]= copy.deepcopy(v)
                        except Exception:
                            weapon[k]= v
                        try:
                            logging.info("_apply_item_overrides: applied override key=%s value=%s from accessory id=%s", k, v, cur.get('id'))
                        except Exception:
                            pass

        try:
            agg = {"stats":{}}
            for acc in weapon.get("accessories", [])or[]:
                cur = _resolve_table_current(acc.get("current"))if acc.get("current")is not None else None

                def _wavelength_allows(item):
                    try:
                        if not item or not isinstance(item, dict):
                            return True
                        wl = item.get("wavelength")
                        if not wl:
                            return True
                        if isinstance(wl, str):
                            if wl.lower()in("infrared", "ir", "infra-red"):

                                try:
                                    cs = globals().get('combat_state')or {}
                                    return bool(cs.get('nvg_active'))
                                except Exception:
                                    return False

                            return True

                        return True
                    except Exception:
                        return True

                if cur and isinstance(cur, dict):
                    mods = cur.get("modifiers")or {}
                    if isinstance(mods, dict):
                        stats = mods.get("stats")or {}
                        if isinstance(stats, dict):

                                if _wavelength_allows(cur):
                                    for sname, sval in stats.items():
                                        try:
                                            agg["stats"][sname]= agg["stats"].get(sname, 0)+(int(sval)if isinstance(sval, (int, float))else 0)
                                        except Exception:
                                            pass

                    try:
                        modes = cur.get("modes")or[]
                        if isinstance(modes, list)and modes:
                            mode_index = acc.get("_mode_index")
                            if mode_index is None:

                                mode_index = acc.get("mode_index")
                            try:
                                mi = int(mode_index)if mode_index is not None else 0
                            except Exception:
                                mi = 0
                            mi = max(0, min(mi, len(modes)-1))
                            mode = modes[mi]
                            if isinstance(mode, dict):
                                mm = mode.get("modifiers")or {}
                                if isinstance(mm, dict):
                                    mstats = mm.get("stats")or {}
                                    if isinstance(mstats, dict):

                                                if _wavelength_allows(mode):
                                                    for sname, sval in mstats.items():
                                                        try:
                                                            agg["stats"][sname]= agg["stats"].get(sname, 0)+(int(sval)if isinstance(sval, (int, float))else 0)
                                                        except Exception:
                                                            pass

                                try:
                                    mode_overrides = mode.get("overrides")if isinstance(mode, dict)else None
                                    if isinstance(mode_overrides, dict):
                                        for k, v in mode_overrides.items():
                                            if k not in weapon.get("_applied_overrides", {}):
                                                orig = weapon.get(k, MISSING)
                                                weapon.setdefault("_applied_overrides", {})[k]= orig
                                                try:
                                                    logging.info("_apply_item_overrides: recording original value for key=%s orig=%s(mode override)", k, orig)
                                                except Exception:
                                                    pass
                                            try:
                                                weapon[k]= copy.deepcopy(v)
                                            except Exception:
                                                weapon[k]= v
                                            try:
                                                logging.info("_apply_item_overrides: applied mode override key=%s value=%s from accessory id=%s", k, v, cur.get('id'))
                                            except Exception:
                                                pass
                                except Exception:
                                    pass
                    except Exception:

                        pass
            weapon["_active_modifiers"]= agg
        except Exception:

            try:
                weapon["_active_modifiers"]= {"stats":{}}
            except Exception:
                pass

        try:
            wid = str(weapon.get("id"))
            act = weapon.get("action")
            acc_names =[]
            for a in weapon.get("accessories", [])or[]:
                try:
                    cur = a.get("current")
                    if cur and isinstance(cur, dict):
                        acc_names.append(cur.get("name")or str(cur.get("id")or "?"))
                except Exception:
                    pass
            logging.debug("_apply_item_overrides: weapon id=%s action=%s installed_attachments=%s", wid, act, acc_names)
        except Exception:
            pass

    def _display_weapon_details(self, parent, weapon, combat_state, save_data, table_data, current_weapon_state = None):

        detail_frame = customtkinter.CTkFrame(parent)
        detail_frame.pack(fill = "both", expand = True, padx = 10, pady = 10)

        name_label = customtkinter.CTkLabel(
        detail_frame,
        text = weapon.get("name", "Unknown Weapon"),
        font = customtkinter.CTkFont(size = 16, weight = "bold")
        )
        name_label.pack(pady = 5)

        stats_text = f"Platform: {weapon.get('platform', 'Unknown')}\n"
        stats_text +=f"Caliber: {', '.join(weapon.get('caliber', ['Unknown']))}\n"
        stats_text +=f"Action: {', '.join(weapon.get('action', ['Unknown']))}\n"
        stats_text +=f"Cyclic Rate: {weapon.get('cyclic', 0)} RPM\n"
        stats_text +=f"Magazine Type: {weapon.get('magazinetype', 'Unknown')}\n"

        if weapon.get("magazinesystem"):
            stats_text +=f"Magazine System: {weapon.get('magazinesystem')}\n"

        if weapon.get("capacity"):
            stats_text +=f"Capacity: {weapon.get('capacity')}\n"

        customtkinter.CTkLabel(
        detail_frame,
        text = stats_text,
        font = customtkinter.CTkFont(size = 12),
        justify = "left"
        ).pack(pady = 5)

        try:
            def _resolve_current(cur):

                if isinstance(cur, dict):
                    return cur
                try:
                    if isinstance(cur, int)or(isinstance(cur, str)and cur.isdigit()):
                        tid = int(cur)
                        tables = table_data.get("tables", {})if isinstance(table_data, dict)else {}
                        for arr in tables.values():
                            if isinstance(arr, list):
                                for it in arr:
                                    if isinstance(it, dict)and it.get("id")==tid:
                                        return it
                except Exception:
                    pass
                return None

            active = combat_state.get("active_underbarrel")

            try:
                equipped_weapons = self._get_equipped_weapons(save_data, table_data)
            except Exception:
                equipped_weapons =[]
            is_displaying_ub = False
            resolved_acc_for_display = None
            if active and isinstance(active, dict)and active.get("parent_index")==combat_state.get("current_weapon_index"):

                aid = active.get("accessory_id")
                aname = active.get("accessory_name")
                parent_slot = equipped_weapons[combat_state.get("current_weapon_index")].get("slot", "")
                if "->"in parent_slot:
                    parent_slot = parent_slot.split("->")[0].strip()
                parent_item = save_data.get("equipment", {}).get(parent_slot)
                if parent_item and isinstance(parent_item, dict):
                    for acc_entry in parent_item.get("accessories", [])or[]:
                        cur = acc_entry.get("current")
                        if isinstance(cur, dict):
                            if aid is not None and cur.get("id")==aid:
                                resolved_acc_for_display = cur ;break
                            if aname and cur.get("name")==aname:
                                resolved_acc_for_display = cur ;break
                        else:
                            try:
                                if aid is not None and(isinstance(cur, int)or(isinstance(cur, str)and cur.isdigit()))and int(cur)==int(aid):
                                    tables = table_data.get("tables", {})if isinstance(table_data, dict)else {}
                                    for arr in tables.values():
                                        if isinstance(arr, list):
                                            for it in arr:
                                                if isinstance(it, dict)and it.get("id")==int(cur):
                                                    resolved_acc_for_display = it ;break
                                            if resolved_acc_for_display:break
                            except Exception:
                                pass

                if not resolved_acc_for_display:
                    for sub in parent_item.get("subslots", [])or[]:
                        try:
                            logging.info("Checking parent subslot '%s' for active accessory", sub.get("name"))
                        except Exception:
                            pass
                        sub_cur = sub.get("current")if isinstance(sub, dict)else None
                        if not sub_cur or not isinstance(sub_cur, dict):
                            continue
                        for acc_entry in sub_cur.get("accessories", [])or[]:
                            cur = acc_entry.get("current")
                            if isinstance(cur, dict):
                                if aid is not None and cur.get("id")==aid:
                                    resolved_acc_for_display = cur ;break
                                if aname and cur.get("name")==aname:
                                    resolved_acc_for_display = cur ;break
                            else:
                                try:
                                    if aid is not None and(isinstance(cur, int)or(isinstance(cur, str)and cur.isdigit()))and int(cur)==int(aid):
                                        tables = table_data.get("tables", {})if isinstance(table_data, dict)else {}
                                        for arr in tables.values():
                                            if isinstance(arr, list):
                                                for it in arr:
                                                    if isinstance(it, dict)and it.get("id")==int(cur):
                                                        resolved_acc_for_display = it ;break
                                                if resolved_acc_for_display:break
                                except Exception:
                                    pass
                if resolved_acc_for_display and isinstance(resolved_acc_for_display, dict):
                    try:
                        logging.info("Resolved active accessory for display: id=%s name=%s", resolved_acc_for_display.get("id"), resolved_acc_for_display.get("name"))
                    except Exception:
                        pass
                    is_displaying_ub = True

            try:
                logging.info("Underbarrel display decision: is_displaying_ub=%s resolved=%s active=%s", is_displaying_ub, getattr(resolved_acc_for_display, 'get', lambda k:None)('name')if isinstance(resolved_acc_for_display, dict)else resolved_acc_for_display, active)
            except Exception:
                pass

            if is_displaying_ub:
                def _switch_to_parent():
                    try:

                        ub = resolved_acc_for_display
                        ub_pf = ub.get("underbarrel_platform")or ub.get("platform")if isinstance(ub, dict)else None
                        if ub_pf:
                            wf = os.path.join("sounds", "firearms", "weaponsounds", str(ub_pf).lower())
                            candidates = glob.glob(os.path.join(wf, "unselect*.ogg"))+glob.glob(os.path.join(wf, "holster*.ogg"))
                            if candidates:
                                self._safe_sound_play("", random.choice(candidates), block = True)

                        combat_state.pop("active_underbarrel", None)
                        try:
                            logging.info("Cleared active_underbarrel for parent_index=%s", combat_state.get("current_weapon_index"))
                        except Exception:
                            pass
                        try:
                            self._save_combat_state(save_data)
                        except Exception:
                            pass
                        try:
                            self._open_combat_mode_tool()
                        except Exception:
                            pass
                    except Exception:
                        pass

                customtkinter.CTkButton(detail_frame, text = "Switch to Parent", command = _switch_to_parent, width = 160).pack(pady = 6)
            else:

                ub_found = None
                try:
                    logging.info("Underbarrel detection: weapon_id=%s accessories=%s", weapon.get("id"), weapon.get("accessories"))
                except Exception:
                    pass
                for acc in weapon.get("accessories", [])or[]:
                    cur = acc.get("current")
                    resolved = _resolve_current(cur)
                    try:
                        logging.info("Resolving accessory current=%s -> resolved=%s", repr(cur), getattr(resolved, 'get', lambda k, d = None:None)('id', resolved))
                    except Exception:
                        logging.info("Resolving accessory current=%s -> resolved=%s", repr(cur), str(resolved))
                    if resolved and isinstance(resolved, dict)and resolved.get("underbarrel_weapon"):
                        ub_found = resolved
                        break

                if ub_found:
                    def _switch_to_underbarrel():
                        try:

                            ub_pf = ub_found.get("underbarrel_platform")or ub_found.get("platform")
                            played = False
                            if ub_pf:
                                wf = os.path.join("sounds", "firearms", "weaponsounds", str(ub_pf).lower())
                                candidates = glob.glob(os.path.join(wf, "select*.ogg"))+glob.glob(os.path.join(wf, "draw*.ogg"))
                                if candidates:
                                    self._safe_sound_play("", random.choice(candidates), block = False)
                                    played = True
                            if not played:
                                try:
                                    self._play_firearm_sound(ub_found, "equip")
                                except Exception:
                                    pass

                            combat_state["active_underbarrel"]= {
                            "parent_index":combat_state.get("current_weapon_index"),
                            "accessory_id":ub_found.get("id")if isinstance(ub_found, dict)else None,
                            "accessory_name":ub_found.get("name")if isinstance(ub_found, dict)else None
                            }
                            try:
                                logging.info("Set active_underbarrel: parent_index=%s accessory_id=%s accessory_name=%s", combat_state.get("current_weapon_index"), ub_found.get("id"), ub_found.get("name"))
                            except Exception:
                                pass
                            try:
                                self._save_combat_state(save_data)
                            except Exception:
                                pass
                            try:
                                self._open_combat_mode_tool()
                            except Exception:
                                pass
                        except Exception:
                            pass

                    customtkinter.CTkButton(detail_frame, text = "Switch to Underbarrel", command = _switch_to_underbarrel, width = 160).pack(pady = 6)
        except Exception:
            pass

        weapon_id = weapon.get("id")
        temperature = combat_state.get("barrel_temperatures", {}).get(str(weapon_id), combat_state["ambient_temperature"])
        cleanliness = combat_state.get("barrel_cleanliness", {}).get(str(weapon_id), 100)

        has_hud = self._check_for_hud(save_data)

        def _has_equipped_item(save_data, target_id):
            try:
                for slot_name, item in save_data.get("equipment", {}).items():
                    if not item or not isinstance(item, dict):
                        continue

                    if item.get("id")==target_id:
                        return True

                    for sub in(item.get("items")or[]):
                        try:
                            if sub and isinstance(sub, dict)and sub.get("id")==target_id:
                                return True
                        except Exception:
                            pass

                    for subslot in(item.get("subslots")or[]):
                        try:
                            curr = subslot.get("current")
                            if curr and isinstance(curr, dict):
                                if curr.get("id")==target_id:
                                    return True
                                for s in(curr.get("items")or[]):
                                    try:
                                        if s and isinstance(s, dict)and s.get("id")==target_id:
                                            return True
                                    except Exception:
                                        pass
                        except Exception:
                            pass
            except Exception:
                return False
            return False

        has_csad = _has_equipped_item(save_data, 37)

        gunlink_on_weapon = False
        try:
            for acc in(weapon.get("accessories")or[]):
                if not acc or not isinstance(acc, dict):
                    continue
                cur = acc.get("current")

                try:
                    if isinstance(cur, int)and cur in(85, 94):
                        gunlink_on_weapon = True
                        break
                except Exception:
                    pass

                try:
                    if isinstance(cur, dict):
                        cid = cur.get("id")
                        cname = str(cur.get("name")or "").lower()
                        if(isinstance(cid, int)and cid in(85, 94))or("gun link"in cname):
                            gunlink_on_weapon = True
                            break
                except Exception:
                    pass
        except Exception:
            gunlink_on_weapon = False

        temp_exact = bool(has_hud or has_csad)
        clean_exact = bool(has_hud or(has_csad and gunlink_on_weapon))
        ammo_exact = bool(has_hud or(has_csad and gunlink_on_weapon))

        if appearance_settings["units"]=="metric":
            display_temp =(temperature -32)*5 /9
            temp_unit = "Â°C"
        else:
            display_temp = temperature
            temp_unit = "Â°F"

        if temperature >=1200:
            temp_color = "#FF5E00"
        elif temperature >=1000:
            temp_color = "#FF3000"
        elif temperature >=800:
            temp_color = "#CC0000"
        elif temperature >=700:
            temp_color = "#AA2200"
        elif temperature >=600:
            temp_color = "#A65A2E"
        elif temperature >=500:
            temp_color = "#8040A0"
        elif temperature >=400:
            temp_color = "#4060C0"
        elif temperature >=300:
            temp_color = "#00A0FF"
        elif temperature >=212:
            temp_color = "#00C878"
        elif temperature >=120:
            temp_color = "#00AA00"
        else:
            temp_color = "#007700"

        if temp_exact:
            temp_text = f"Barrel Temperature: {display_temp:.2f}{temp_unit}"
        else:

            if temperature >200:
                temp_desc = "Critical hot"
            elif temperature >150:
                temp_desc = "Very hot"
            elif temperature >100:
                temp_desc = "Hot"
            elif temperature >80:
                temp_desc = "Warm"
            else:
                temp_desc = "Cool"
            temp_text = f"Barrel Temperature: {temp_desc}"

        customtkinter.CTkLabel(
        detail_frame,
        text = temp_text,
        font = customtkinter.CTkFont(size = 14),
        text_color = temp_color
        ).pack(pady = 5)

        clean_color = "#00FF00"
        if cleanliness <30:
            clean_color = "#FF0000"
        elif cleanliness <50:
            clean_color = "#FFA500"
        elif cleanliness <70:
            clean_color = "#FFFF00"

        clean_text = f"Cleanliness: {cleanliness:.2f}%"if clean_exact else "Cleanliness: Status only"
        clean_label = customtkinter.CTkLabel(
        detail_frame,
        text = clean_text,
        font = customtkinter.CTkFont(size = 14),
        text_color = clean_color
        )
        clean_label.pack(pady = 5)

        if current_weapon_state is not None:
            current_weapon_state["clean_label_ref"]= clean_label

        ammo_text = self._get_ammo_display(weapon, bool(ammo_exact))

        ammo_label = customtkinter.CTkLabel(
        detail_frame,
        text = ammo_text,
        font = customtkinter.CTkFont(size = 14)
        )
        ammo_label.pack(pady = 5)

        if current_weapon_state is not None:
            current_weapon_state["ammo_label_ref"]= ammo_label
            current_weapon_state["original_ammo_text"]= ammo_text

        if weapon.get("accessories"):
            customtkinter.CTkLabel(
            detail_frame,
            text = "Attachments:",
            font = customtkinter.CTkFont(size = 14, weight = "bold")
            ).pack(pady =(10, 5))

            for accessory in weapon["accessories"]:
                if accessory.get("current"):
                    att_text = f"â€¢ {accessory['name']}: {accessory['current'].get('name', 'Unknown')}"
                else:
                    att_text = f"â€¢ {accessory['name']}: Empty"

                customtkinter.CTkLabel(
                detail_frame,
                text = att_text,
                font = customtkinter.CTkFont(size = 12)
                ).pack(anchor = "w", padx = 20)

    def _check_for_hud(self, save_data):

        for slot_name, item in save_data.get("equipment", {}).items():
            if item and isinstance(item, dict)and item.get("hud"):
                return True
        return False

    def _get_ammo_display(self, weapon, has_hud):

        loaded_mag = weapon.get("loaded")
        chambered = weapon.get("chambered")
        magazine_type = weapon.get("magazinetype", "").lower()

        is_internal = "internal"in magazine_type or "tube"in magazine_type
        is_revolver = "revolver"in weapon.get("platform", "").lower()

        if is_internal or is_revolver:

            internal_rounds = weapon.get("rounds", [])
            total_rounds = len(internal_rounds)
            if chambered:
                total_rounds +=1

            if has_hud:
                chamber_text = "(+1 chambered)"if chambered else ""
                capacity = weapon.get("capacity", 0)
                return f"Ammo: {total_rounds}/{capacity} rounds{chamber_text}"
            else:
                if total_rounds ==0:
                    return "Ammo: Empty(no rounds)"
                return "Ammo: Loaded(exact count unknown)"

        if not loaded_mag and not chambered:
            return "Ammo: Empty(no magazine)"

        total_rounds = 0
        if chambered:
            total_rounds +=1

        if loaded_mag:
            rounds_in_mag = len(loaded_mag.get("rounds", []))
            total_rounds +=rounds_in_mag

        if has_hud:

            chamber_text = "(+1 chambered)"if chambered else ""
            if loaded_mag and not loaded_mag.get("rounds"):
                return f"Ammo: 0 rounds(empty magazine loaded){chamber_text}"
            return f"Ammo: {total_rounds} rounds{chamber_text}"
        else:

            if not loaded_mag and chambered:
                return "Ammo: Unknown(mag out, round chambered)"
            if not loaded_mag:
                return "Ammo: No magazine"
            if not loaded_mag.get("rounds"):
                return "Ammo: Empty magazine loaded(check/reload)"
            return "Ammo: Unknown(remove mag to check)"

    def _save_combat_state(self, save_data):

        try:

            self._save_file(save_data)
            logging.info("Combat state saved for %s", (currentsave or "<unknown>"))
        except Exception as e:
            logging.error(f"Failed to save combat state: {e}")

    def _get_firearm_sound_folder(self, weapon):

        try:
            if isinstance(weapon, dict):
                sf = weapon.get("sounds")or weapon.get("sound_folder")or weapon.get("fire_sounds")or weapon.get("fire_sound")
                if sf:
                    if isinstance(sf, (list, tuple)):
                        sf = sf[0]if sf else None
                    if sf:
                        return sf
        except Exception:
            pass

        caliber = weapon.get("caliber", [])[0]if weapon.get("caliber")else None

        if not caliber:
            return None

        caliber_map = {
        "5.56x45mm NATO":"556",
        ".45 ACP":"45acp",
        "9x19mm Parabellum":"9x19",
        "12 Gauge":"12gauge",
        "7.62x51mm NATO":"762_51",
        "7.62x39mm":"762_39",
        "7.62x54mmR":"762_54",
        ".308 Winchester":"308",
        ".223 Remington":"223",
        ".380 ACP":"380acp",
        "5.45x39mm":"545_39",
        "9x18mm Makarov":"9x18",
        ".357 Magnum":"357mag",
        ".44 Magnum":"44mag",
        ".38 Special":"38special",
        ".50 AE":"50ae",
        "20 Gauge":"20gauge",
        ".410 Bore":"410bore",
        ".45-70 Government":"45_70",
        ".30-06 Springfield":"30_06",
        ".30-30 Winchester":"30_30",
        ".277 Wolverine":"277baker",
        ".224 Valkyrie":"224baker",
        ".303 British":"303"
        }

        caliber_map.update({
        "6.5x45mm":"277baker",
        "6.5x45mm Colt":"277baker",
        "6.5x45 Colt":"277baker",
        "6.5x45":"277baker",
        "5.7x28mm":"224baker",
        "5.7x28mm NATO":"224baker",
        "5.7x28":"224baker",
        })

        extra_map = {
        "10mm Auto":"45acp",
        "10mm":"45acp",
        ".10mm":"45acp"
        }

        return caliber_map.get(caliber)or extra_map.get(caliber)

    def _caliber_to_sound_folder(self, caliber):

        if not caliber or not isinstance(caliber, str):
            return None

        try:
            td = globals().get('table_data')or {}
            ammo_tables = td.get('tables', {}).get('ammunition', [])if isinstance(td, dict)else[]
            if isinstance(ammo_tables, list):
                cal_lower = caliber.strip().lower()
                for ammo_entry in ammo_tables:
                    if not isinstance(ammo_entry, dict):
                        continue
                    a_cal = ammo_entry.get('caliber')
                    if not a_cal:
                        continue
                    if isinstance(a_cal, (list, tuple)):
                        match = any(str(x).strip().lower()==cal_lower for x in a_cal)
                    else:
                        match = str(a_cal).strip().lower()==cal_lower
                    if match and ammo_entry.get('sounds'):
                        return str(ammo_entry.get('sounds'))
        except Exception:
            pass

        caliber_map = {
        "5.56x45mm NATO":"556",
        ".45 ACP":"45acp",
        "9x19mm Parabellum":"9x19",
        "12 Gauge":"12gauge",
        "7.62x51mm NATO":"762_51",
        "7.62x39mm":"762_39",
        "7.62x39mm Soviet":"762_39",
        "7.62x54mmR":"762_54",
        ".308 Winchester":"308",
        ".223 Remington":"223",
        ".380 ACP":"380acp",
        "5.45x39mm":"545_39",
        "5.45x39mm Soviet":"545_39",
        "9x18mm Makarov":"9x18",
        ".357 Magnum":"357mag",
        ".44 Magnum":"44mag",
        ".38 Special":"38special",
        ".50 AE":"50ae",
        "20 Gauge":"20gauge",
        ".410 Bore":"410bore",
        ".45-70 Government":"45_70",
        ".30-06 Springfield":"30_06",
        ".30-30 Winchester":"30_30",
        ".277 Wolverine":"277baker",
        ".224 Valkyrie":"224baker",
        ".303 British":"303",
        "6.5x45mm":"308",
        "6.5x45mm Colt":"308",
        "6.5x45 Colt":"308",
        "6.5x45":"308",
        "5.7x28mm":"223",
        "5.7x28mm NATO":"223",
        "5.7x28":"223",
        "10mm Auto":"45acp",
        "10mm":"45acp",
        ".10mm":"45acp",
        ".40 S&W":"45acp",
        ".30 Carbine":"30_30",
        }

        return caliber_map.get(caliber)

    def _check_weapon_suppressed(self, weapon):

        try:
            if weapon.get("suppressed")or weapon.get("integrally_suppressed"):
                return True
        except Exception:
            pass

        if weapon.get("accessories"):
            for accessory in weapon["accessories"]:
                if accessory.get("current")and accessory["current"].get("suppressor"):
                    return True

        return False

    def _play_firearm_sound(self, weapon, sound_type = "fire", fired_round = None):

        try:

            try:
                if isinstance(weapon, dict):

                    sf = weapon.get("sounds")or weapon.get("sound_folder")or weapon.get("ammo_type")
                    if isinstance(sf, str)and sf:

                        if sf.lower()in("40mm_grenade", "40mm"):
                            weapon_platform_hack = "40mm_grenade"

                            weapon.setdefault("platform", weapon_platform_hack)

                            weapon.setdefault("sound_folder", "40mm_grenade")
                            weapon.setdefault("sounds", "40mm_grenade")
                    else:

                        name =(weapon.get("name")or "").lower()
                        calib = weapon.get("caliber")
                        calib_ok = False
                        if isinstance(calib, (list, tuple)):
                            for c in calib:
                                if isinstance(c, str)and "40"in c and "mm"in c:
                                    calib_ok = True
                                    break
                        elif isinstance(calib, str)and "40"in calib and "mm"in calib:
                            calib_ok = True
                        if calib_ok or "40mm"in name or "40x46"in name or "40 x 46"in name:
                            weapon.setdefault("platform", "40mm_grenade")
                            weapon.setdefault("sound_folder", "40mm_grenade")
                            weapon.setdefault("sounds", "40mm_grenade")
            except Exception:
                pass

            if sound_type =="equip"and weapon.get("custom_equip_sound"):
                sound_path = weapon["custom_equip_sound"]
                if os.path.exists(sound_path):
                    self._safe_sound_play("", sound_path)
                    return

            sound_folder = self._get_firearm_sound_folder(weapon)

            raw_platform = weapon.get("platform", "")or ""
            if isinstance(raw_platform, (list, tuple)):
                raw_platform = raw_platform[0]if raw_platform else ""

            platform_folder = str(raw_platform).lower()if raw_platform else None

            try:
                pf_key =(weapon.get("platform")or weapon.get("underbarrel_platform")or "")
                if isinstance(pf_key, (list, tuple)):
                    pf_key = pf_key[0]if pf_key else ""
                if pf_key and pf_key in self.PLATFORM_DEFAULTS:
                    mapped_folder = self.PLATFORM_DEFAULTS[pf_key].get("reload_sound_folder")
                    if mapped_folder:
                        wf_map = os.path.join("sounds", "firearms", "weaponsounds", str(mapped_folder).lower())
                        candidates =[]
                        if sound_type =="equip":
                            candidates = glob.glob(os.path.join(wf_map, "equip*.ogg"))+glob.glob(os.path.join(wf_map, "draw*.ogg"))
                        elif sound_type =="reload":
                            candidates = glob.glob(os.path.join(wf_map, "reload*.ogg"))+glob.glob(os.path.join(wf_map, "load*.ogg"))+glob.glob(os.path.join(wf_map, "pump*.ogg"))
                        else:

                            candidates = glob.glob(os.path.join(wf_map, f"{sound_type}*.ogg"))
                        if candidates:
                            self._safe_sound_play("", random.choice(candidates), block =(sound_type in("reload", "unselect", "holster")))
                            return
            except Exception:
                pass

            if not sound_folder:

                if platform_folder:
                    wf_rel = os.path.join("weaponsounds", platform_folder)
                    wf_path = os.path.join("sounds", "firearms", wf_rel)
                    if os.path.isdir(wf_path):
                        sound_folder = wf_rel
                    else:

                        direct_pf = os.path.join("sounds", "firearms", platform_folder)
                        if os.path.isdir(direct_pf):
                            sound_folder = platform_folder

            if sound_type =="equip":

                tried = False
                if platform_folder:
                    wf = os.path.join("sounds", "firearms", "weaponsounds", platform_folder)
                    candidates = glob.glob(os.path.join(wf, "equip*.ogg"))+glob.glob(os.path.join(wf, "draw*.ogg"))
                    if candidates:
                        sound_file = random.choice(candidates)
                        self._safe_sound_play("", sound_file)
                        return
                    tried = True

                if sound_folder:
                    base_equip_candidates = glob.glob(os.path.join("sounds", "firearms", sound_folder, "equip*.ogg"))+glob.glob(os.path.join("sounds", "firearms", sound_folder, "draw*.ogg"))
                    if base_equip_candidates:
                        sound_file = random.choice(base_equip_candidates)
                        self._safe_sound_play("", sound_file)
                        return

                uni_candidates = glob.glob(os.path.join("sounds", "firearms", "universal", "equip*.ogg"))+glob.glob(os.path.join("sounds", "firearms", "universal", "draw*.ogg"))
                if uni_candidates:
                    sound_file = random.choice(uni_candidates)
                    self._safe_sound_play("", sound_file)
                    return

                logging.info(f"No equip/draw sound found for {weapon.get('name')}(checked platform, {sound_folder}, and universal)")
                return

            is_suppressed = self._check_weapon_suppressed(weapon)

            base_path = f"sounds/firearms/{sound_folder}"if sound_folder else None
            wf_platform = None
            if platform_folder:
                wf_platform = os.path.join("sounds", "firearms", "weaponsounds", platform_folder)

            def _dbg(msg, *args):
                try:
                    gv = globals().get('global_variables')or {}
                    if gv.get('debugmode', {}).get('value'):
                        logging.debug(msg, *args)
                except Exception:
                    logging.debug(msg, *args)

            def _select_from_folder(folder):
                try:
                    if not folder or not os.path.isdir(folder):
                        _dbg("_select_from_folder: missing folder %s", folder)
                        return None
                    _dbg("_select_from_folder: scanning folder %s(suppressed=%s)", folder, is_suppressed)
                    if is_suppressed:
                        cands = glob.glob(os.path.join(folder, "fire*_suppressed.wav"))+glob.glob(os.path.join(folder, "fire*_suppressed.ogg"))
                        _dbg("_select_from_folder: found %d suppressed candidates in %s", len(cands), folder)
                        if cands:
                            sel = random.choice(cands)
                            _dbg("_select_from_folder: selected %s", sel)
                            return sel
                        _dbg("_select_from_folder: no suppressed candidates in %s", folder)
                        return None
                    else:
                        cands = glob.glob(os.path.join(folder, "fire*.wav"))+glob.glob(os.path.join(folder, "fire*.ogg"))

                        cands =[f for f in cands if "_suppressed"not in os.path.basename(f)]
                        _dbg("_select_from_folder: found %d non-suppressed candidates in %s", len(cands), folder)
                        if cands:
                            sel = random.choice(cands)
                            _dbg("_select_from_folder: selected %s", sel)
                            return sel
                        _dbg("_select_from_folder: no non-suppressed candidates in %s", folder)
                        return None
                except Exception:
                    _dbg("_select_from_folder: exception scanning %s", folder)
                    return None

            if sound_type =="fire"and wf_platform:
                sel = _select_from_folder(wf_platform)
                if sel:
                    self._safe_sound_play("", sel)
                    return

            ammo_folder = None
            try:

                if fired_round and isinstance(fired_round, dict):
                    if fired_round.get("sounds"):
                        ammo_folder = fired_round.get("sounds")
                    elif fired_round.get("caliber"):

                        round_cal = fired_round.get("caliber")
                        if isinstance(round_cal, (list, tuple)):
                            round_cal = round_cal[0]if round_cal else None
                        if round_cal:
                            ammo_folder = self._caliber_to_sound_folder(round_cal)

                if not ammo_folder:
                    ch = weapon.get("chambered")if isinstance(weapon, dict)else None
                    if isinstance(ch, dict):
                        if ch.get("sounds"):
                            ammo_folder = ch.get("sounds")
                        elif ch.get("caliber"):
                            ch_cal = ch.get("caliber")
                            if isinstance(ch_cal, (list, tuple)):
                                ch_cal = ch_cal[0]if ch_cal else None
                            if ch_cal:
                                ammo_folder = self._caliber_to_sound_folder(ch_cal)

                if not ammo_folder:
                    loaded = weapon.get("loaded")if isinstance(weapon, dict)else None
                    if isinstance(loaded, dict):
                        rds = loaded.get("rounds")or[]
                        if isinstance(rds, list)and rds:
                            first = rds[0]
                            if isinstance(first, dict):
                                if first.get("sounds"):
                                    ammo_folder = first.get("sounds")
                                elif first.get("caliber"):
                                    first_cal = first.get("caliber")
                                    if isinstance(first_cal, (list, tuple)):
                                        first_cal = first_cal[0]if first_cal else None
                                    if first_cal:
                                        ammo_folder = self._caliber_to_sound_folder(first_cal)

                if not ammo_folder:
                    at = weapon.get("ammo_type")or weapon.get("ammo")
                    if isinstance(at, str)and at:
                        ammo_folder = at
            except Exception:
                ammo_folder = None

            if ammo_folder:

                wf_ammo_map = os.path.join("sounds", "firearms", "weaponsounds", str(ammo_folder).lower())
                sel = _select_from_folder(wf_ammo_map)
                if sel:
                    self._safe_sound_play("", sel)
                    return
                wf_ammo = os.path.join("sounds", "firearms", str(ammo_folder))
                sel = _select_from_folder(wf_ammo)
                if sel:
                    self._safe_sound_play("", sel)
                    return

            try:
                if not ammo_folder:
                    td = globals().get('table_data')or {}
                    ammo_tables = td.get('tables', {}).get('ammunition', [])if isinstance(td, dict)else[]

                    cal_list = weapon.get('caliber')if isinstance(weapon, dict)else None
                    if cal_list and isinstance(ammo_tables, list):
                        for ammo_entry in ammo_tables:
                            try:
                                if not isinstance(ammo_entry, dict):
                                    continue
                                a_cal = ammo_entry.get('caliber')
                                if not a_cal:
                                    continue

                                if isinstance(a_cal, (list, tuple)):
                                    match = any(str(x).strip().lower()in[str(c).strip().lower()for c in(cal_list or[])]for x in a_cal)
                                else:
                                    match = any(str(a_cal).strip().lower()==str(c).strip().lower()for c in(cal_list or[]))
                                if match and ammo_entry.get('sounds'):

                                    af = str(ammo_entry.get('sounds'))
                                    wf_ammo_map = os.path.join('sounds', 'firearms', 'weaponsounds', af.lower())
                                    sel = _select_from_folder(wf_ammo_map)
                                    if sel:
                                        self._safe_sound_play('', sel)
                                        return
                                    wf_ammo2 = os.path.join('sounds', 'firearms', af.lower())
                                    sel = _select_from_folder(wf_ammo2)
                                    if sel:
                                        self._safe_sound_play('', sel)
                                        return
                            except Exception:
                                pass
            except Exception:
                pass

            try:
                if weapon.get("has_ammo_in_pool")is False:
                    fs = weapon.get("fire_sounds")or weapon.get("fire_sound")
                    if fs:

                        wf = os.path.join("sounds", "firearms", "weaponsounds", str(fs).lower())
                        sel = _select_from_folder(wf)
                        if sel:
                            logging.debug("Fire sound selected(weapon.fire_sounds): %s", sel)
                            self._safe_sound_play("", sel)
                            return
                        wf2 = os.path.join("sounds", "firearms", str(fs).lower())
                        sel = _select_from_folder(wf2)
                        if sel:
                            logging.debug("Fire sound selected(weapon.fire_sounds): %s", sel)
                            self._safe_sound_play("", sel)
                            return
            except Exception:
                pass

            if base_path:
                sel = _select_from_folder(base_path)
                if sel:
                    self._safe_sound_play("", sel)
                    return

            subtype = weapon.get("subtype", "")

            if is_suppressed:

                if subtype =="shotgun":
                    shotgun_supp = glob.glob("sounds/firearms/universal/shotgunfire_suppressed.wav")+glob.glob("sounds/firearms/universal/shotgunfire_suppressed.ogg")
                    if shotgun_supp:
                        self._safe_sound_play("", random.choice(shotgun_supp))
                        return

                    rifle_supp = glob.glob("sounds/firearms/universal/riflefire_suppressed.wav")+glob.glob("sounds/firearms/universal/riflefire_suppressed.ogg")
                    if rifle_supp:
                        self._safe_sound_play("", random.choice(rifle_supp))
                        return
                elif subtype in["rifle", "mg"]:
                    rifle_supp = glob.glob("sounds/firearms/universal/riflefire_suppressed.wav")+glob.glob("sounds/firearms/universal/riflefire_suppressed.ogg")
                    if rifle_supp:
                        self._safe_sound_play("", random.choice(rifle_supp))
                        return
                elif subtype in["pistol", "smg"]:
                    pistol_supp = glob.glob("sounds/firearms/universal/pistolfire_suppressed.wav")+glob.glob("sounds/firearms/universal/pistolfire_suppressed.ogg")
                    if pistol_supp:
                        self._safe_sound_play("", random.choice(pistol_supp))
                        return
            else:

                if subtype =="shotgun":
                    shot = glob.glob("sounds/firearms/universal/shotgunfire.wav")
                    if shot:
                        self._safe_sound_play("", random.choice(shot))
                        return

                    rifle = glob.glob("sounds/firearms/universal/riflefire.wav")
                    if rifle:
                        self._safe_sound_play("", random.choice(rifle))
                        return
                elif subtype in["rifle", "mg"]:
                    rifle = glob.glob("sounds/firearms/universal/riflefire.wav")
                    if rifle:
                        self._safe_sound_play("", random.choice(rifle))
                        return
                elif subtype in["pistol", "smg"]:
                    pistol = glob.glob("sounds/firearms/universal/pistolfire.wav")
                    if pistol:
                        self._safe_sound_play("", random.choice(pistol))
                        return

            logging.warning(f"No fire sounds found for platform_folder={platform_folder} sound_folder={sound_folder} ammo_folder={ammo_folder}")

        except Exception as e:
            logging.error(f"Error playing firearm sound: {e}")

    def _play_weapon_action_sound(self, weapon, action_type, block = False):

        try:
            platform = weapon.get("platform", "").lower()
            mag_type = weapon.get("magazinetype", "").lower()

            platform_folder = platform if platform else None

            is_belt =("belt"in mag_type)or("belt"in(platform or ""))or("m249"in(platform or ""))

            should_block = bool(block)

            try:
                weapon_type = str(weapon.get("type")or "").lower()
                if weapon_type =="caseless":

                    if any(k in action_type.lower()for k in("eject", "shelleject", "caseeject")):
                        logging.debug("Skipping ejection sound for caseless weapon: %s", weapon.get("name"))
                        return
            except Exception:
                pass

            try:
                reload_actions =("reload", "magin", "magout", "magdrop", "pouchout", "pouchin", "boxin", "boxout", "coveropen", "coverclose")
                if action_type in reload_actions:

                    fs = weapon.get("fire_sounds")or weapon.get("sounds")or weapon.get("sound_folder")or weapon.get("reload_sounds")
                    candidates =[]

                    if fs:
                        wf = os.path.join("sounds", "firearms", str(fs).lower())
                        candidates = glob.glob(os.path.join(wf, f"{action_type}*.ogg"))+glob.glob(os.path.join(wf, f"{action_type}*.wav"))
                        if not candidates:

                            wf2 = os.path.join("sounds", "firearms", "weaponsounds", str(fs).lower())
                            candidates = glob.glob(os.path.join(wf2, f"{action_type}*.ogg"))+glob.glob(os.path.join(wf2, f"{action_type}*.wav"))

                    if not candidates and platform_folder:
                        wf = os.path.join("sounds", "firearms", "weaponsounds", platform_folder)
                        candidates = glob.glob(os.path.join(wf, f"{action_type}*.ogg"))+glob.glob(os.path.join(wf, f"{action_type}*.wav"))

                    if not candidates:
                        uni = os.path.join("sounds", "firearms", "universal")

                        action_map = {
                        "magin":["riflemagin*.ogg", "pistolmagin*.ogg", "magin*.ogg"],
                        "magout":["riflemagout*.ogg", "pistolmagout*.ogg", "magout*.ogg"],
                        "magdrop":["magdrop*.ogg"],
                        "pouchout":["pouchout*.ogg"],
                        "pouchin":["pouchin*.ogg"],
                        "reload":["reload*.ogg", "riflemagin*.ogg"],
                        }
                        patterns = action_map.get(action_type, [f"{action_type}*.ogg"])
                        for pat in patterns:
                            candidates +=glob.glob(os.path.join(uni, pat))
                    if candidates:
                        sound_file = random.choice(candidates)
                        logging.debug("Reload action sound: %s -> %s", action_type, sound_file)

                        if action_type =="magin":

                            try:
                                self._safe_sound_play("", sound_file, block = True)
                            except Exception:
                                try:
                                    self._safe_sound_play("", sound_file, block = should_block)
                                except Exception:
                                    pass

                            try:
                                if should_block:
                                    time.sleep(random.uniform(0.15, 0.35))
                                else:
                                    time.sleep(random.uniform(0.05, 0.12))
                            except Exception:
                                pass
                        else:
                            self._safe_sound_play("", sound_file, block = should_block)
                        return
            except Exception:
                logging.exception("Error in reload action sound lookup")
                pass

            try:
                if weapon.get("has_ammo_in_pool")is False:
                    fs = weapon.get("reload_sounds")or weapon.get("action_sounds")or weapon.get("sounds")or weapon.get("sound_folder")or weapon.get("fire_sounds")
                    if fs:
                        wf = os.path.join("sounds", "firearms", "weaponsounds", str(fs).lower())
                        candidates = glob.glob(os.path.join(wf, f"{action_type}*.ogg"))+glob.glob(os.path.join(wf, f"{action_type}*.wav"))
                        if candidates:
                            import random as _r
                            sound_file = _r.choice(candidates)
                            self._safe_sound_play("", sound_file, block = should_block)
                            return
            except Exception:
                pass

            if platform_folder:
                wf = os.path.join("sounds", "firearms", "weaponsounds", platform_folder)
                candidates =[]
                if action_type.startswith("tubeinsert")or action_type =="tubeinsert":
                    candidates = glob.glob(os.path.join(wf, "tubeinsert*.ogg"))
                elif action_type.startswith("bulletinsert"):
                    candidates = glob.glob(os.path.join(wf, "bulletinsert*.ogg"))
                else:

                    pattern_candidates = glob.glob(os.path.join(wf, f"{action_type}*.ogg"))+glob.glob(os.path.join(wf, f"{action_type}*.wav"))
                    if pattern_candidates:
                        candidates = pattern_candidates
                    else:

                        exact_ogg = os.path.join(wf, f"{action_type}.ogg")
                        exact_wav = os.path.join(wf, f"{action_type}.wav")
                        if os.path.exists(exact_ogg):
                            candidates =[exact_ogg]
                        elif os.path.exists(exact_wav):
                            candidates =[exact_wav]

                if candidates:
                    sound_file = random.choice(candidates)
                    logging.debug("_play_weapon_action_sound: platform-specific %s -> %s", action_type, sound_file)
                    self._safe_sound_play("", sound_file, block = should_block)
                    return

            internal_sounds = {
            "tubeinsert":"sounds/firearms/universal/tubeinsert.ogg",
            "bulletinsert0":"sounds/firearms/universal/bulletinsert0.ogg",
            "bulletinsert1":"sounds/firearms/universal/bulletinsert1.ogg",
            "cylinderopen":"sounds/firearms/universal/cylinderopen.ogg",
            "cylinderclose":"sounds/firearms/universal/cylinderclose.ogg",
            "cylinderrelease":"sounds/firearms/universal/cylinderrelease.ogg",
            }

            if action_type.startswith("tubeinsert")or action_type =="tubeinsert":

                uni_folder = os.path.join("sounds", "firearms", "universal")
                tube_candidates = glob.glob(os.path.join(uni_folder, "tubeinsert*.ogg"))
                if tube_candidates:
                    sound_file = random.choice(tube_candidates)
                    logging.debug("_play_weapon_action_sound: tubeinsert -> %s", sound_file)
                    self._safe_sound_play("", sound_file, block = should_block)
                    return

                if os.path.exists(internal_sounds["tubeinsert"]):
                    self._safe_sound_play("", internal_sounds["tubeinsert"], block = should_block)
                    return

            if action_type.startswith("bulletinsert"):

                uni_folder = os.path.join("sounds", "firearms", "universal")
                bullet_candidates = glob.glob(os.path.join(uni_folder, "bulletinsert*.ogg"))
                if bullet_candidates:
                    sound_file = random.choice(bullet_candidates)
                    logging.debug("_play_weapon_action_sound: bulletinsert -> %s", sound_file)
                    self._safe_sound_play("", sound_file, block = should_block)
                    return

                sound_file = internal_sounds.get(action_type)
                if sound_file and os.path.exists(sound_file):
                    self._safe_sound_play("", sound_file, block = should_block)
                    return

            if "revolver"in platform.lower()or "cylinder"in action_type:
                if action_type =="cylinderopen"and os.path.exists(internal_sounds["cylinderopen"]):
                    logging.debug("_play_weapon_action_sound: revolver cylinderopen -> %s", internal_sounds["cylinderopen"])
                    self._safe_sound_play("", internal_sounds["cylinderopen"], block = should_block)
                    return
                elif action_type =="cylinderclose"and os.path.exists(internal_sounds["cylinderclose"]):
                    logging.debug("_play_weapon_action_sound: revolver cylinderclose -> %s", internal_sounds["cylinderclose"])
                    self._safe_sound_play("", internal_sounds["cylinderclose"], block = should_block)
                    return
                elif action_type =="cylinderrelease"and os.path.exists(internal_sounds["cylinderrelease"]):
                    logging.debug("_play_weapon_action_sound: revolver cylinderrelease -> %s", internal_sounds["cylinderrelease"])
                    self._safe_sound_play("", internal_sounds["cylinderrelease"], block = should_block)
                    return
                elif action_type in("bulletinsert0", "bulletinsert1")and os.path.exists(internal_sounds[action_type]):
                    logging.debug("_play_weapon_action_sound: revolver bulletinsert -> %s", internal_sounds[action_type])
                    self._safe_sound_play("", internal_sounds[action_type], block = should_block)
                    return

            if action_type =="magin":
                mag_type = weapon.get("magazinetype", "").lower()
                if any(k in mag_type for k in("internal", "tube", "cylinder"))or "revolver"in platform.lower()or is_belt:
                    return

            if action_type in("coveropen", "coverclose", "boxout", "boxin"):
                preferred_map = {
                "coveropen":["pouchout"],
                "coverclose":["pouchin"],
                "boxout":["magdrop0", "magdrop1"],
                "boxin":["riflemagin", "pistolmagin"]
                }
                pf = platform_folder
                names = preferred_map.get(action_type, [action_type])

                if pf:
                    wf = os.path.join("sounds", "firearms", "weaponsounds", pf)
                    for nm in names:
                        for ext in(".ogg", ".wav"):
                            cand = os.path.join(wf, nm +ext)
                            if os.path.exists(cand):
                                logging.debug("_play_weapon_action_sound: platform preferred %s -> %s", action_type, cand)
                                self._safe_sound_play("", cand, block = should_block)
                                return

                uni_folder = os.path.join("sounds", "firearms", "universal")
                for nm in names:
                    for ext in(".ogg", ".wav"):
                        cand = os.path.join(uni_folder, nm +ext)
                        if os.path.exists(cand):
                            logging.debug("_play_weapon_action_sound: universal preferred %s -> %s", action_type, cand)
                            self._safe_sound_play("", cand, block = should_block)
                            return

            universal_sounds = {
            "magin":["riflemagin", "pistolmagin"],
            "magout":["riflemagout", "pistolmagout"],
            "boltback":["rifleboltback", "pistolslideback", "boltactionback"],
            "boltforward":["rifleboltforward", "pistolslideforward", "boltactionforward"],
            "pumpback":["shotgunpumpback", "pumpback"],
            "pumpforward":["shotgunpumpforward", "pumpforward"],
            "cleaning":["cleaning"],

            "coveropen":["pouchout", "magdrop0"],
            "coverclose":["pouchin"],
            "boxout":["magdrop0", "magdrop1"],
            "boxin":["magin", "riflemagin"]
            }

            if action_type in universal_sounds:
                for sound_name in universal_sounds[action_type]:
                    sound_path = f"sounds/firearms/universal/{sound_name}.ogg"
                    if os.path.exists(sound_path):
                        logging.debug("_play_weapon_action_sound: universal %s -> %s", action_type, sound_path)

                        if action_type =="magin":
                            try:
                                self._safe_sound_play("", sound_path, block = True)
                            except Exception:
                                try:
                                    self._safe_sound_play("", sound_path, block = should_block)
                                except Exception:
                                    pass
                            try:
                                if should_block:
                                    time.sleep(random.uniform(0.15, 0.35))
                                else:
                                    time.sleep(random.uniform(0.05, 0.12))
                            except Exception:
                                pass
                        else:
                            self._safe_sound_play("", sound_path, block = should_block)
                        break

        except Exception as e:
            logging.error(f"Error playing weapon action sound: {e}")

    def _cycle_bolt_sounds(self, weapon, single_forward = False, delay = 0.12):

        try:
            bolt_setting = str(weapon.get("bolt")or "").lower()
            bolt_catch = bool(weapon.get("bolt_catch", False))

            if bolt_setting =="open":
                if single_forward:
                    if bolt_catch:

                        self._play_weapon_action_sound(weapon, "boltback", block = True)
                    else:
                        self._play_weapon_action_sound(weapon, "boltforward")
                        time.sleep(delay)

                        self._play_weapon_action_sound(weapon, "boltback", block = True)
                else:

                    self._play_weapon_action_sound(weapon, "boltforward")
                    time.sleep(delay)
                    self._play_weapon_action_sound(weapon, "boltback", block = True)
            else:

                if single_forward:
                    if bolt_catch:
                        self._play_weapon_action_sound(weapon, "boltforward")
                    else:

                        self._play_weapon_action_sound(weapon, "boltback", block = True)
                        time.sleep(delay)
                        self._play_weapon_action_sound(weapon, "boltforward")
                else:

                    self._play_weapon_action_sound(weapon, "boltback", block = True)
                    time.sleep(delay)
                    self._play_weapon_action_sound(weapon, "boltforward")
        except Exception:
            try:

                self._play_weapon_action_sound(weapon, "boltforward")
                time.sleep(delay)
                self._play_weapon_action_sound(weapon, "boltback", block = True)
            except Exception:
                pass

    def _play_weapon_action_sound_strict(self, weapon, action_type, block = False):

        try:
            platform = weapon.get("platform", "").lower()
            platform_folder = platform if platform else None

            equivalents = {
            "boltback":["rifleboltback", "pistolslideback", "boltactionback"],
            "boltforward":["rifleboltforward", "pistolslideforward", "boltactionforward"],
            "coveropen":["pouchout"],
            "coverclose":["pouchin"],
            "boxout":["magdrop0", "magdrop1"],
            "boxin":["riflemagin", "pistolmagin"],
            "magout":["riflemagout", "pistolmagout", "magdrop0", "magdrop1"],
            "magin":["riflemagin", "pistolmagin"],
            "pouchout":["pouchout"],
            "pouchin":["pouchin"]
            }

            names = equivalents.get(action_type, [action_type])

            if platform_folder:
                wf = os.path.join("sounds", "firearms", "weaponsounds", platform_folder)
                exact = os.path.join(wf, action_type +".ogg")
                if os.path.exists(exact):
                    logging.debug("_play_weapon_action_sound_strict: platform exact %s -> %s", action_type, exact)
                    self._safe_sound_play("", exact, block = block)
                    return True

            uni = os.path.join("sounds", "firearms", "universal")
            for nm in names:
                cand = os.path.join(uni, nm +".ogg")
                if os.path.exists(cand):
                    logging.debug("_play_weapon_action_sound_strict: universal exact %s -> %s", action_type, cand)
                    self._safe_sound_play("", cand, block = block)
                    return True

            logging.debug("_play_weapon_action_sound_strict: no file for action '%s'(platform=%s)", action_type, platform_folder)
            return False
        except Exception as e:
            logging.error(f"_play_weapon_action_sound_strict error: {e}")
            return False

    def _perform_belt_reload_sequence(self, weapon):

        try:
            logging.debug("_perform_belt_reload_sequence called but belt-fed logic removed.")
        except Exception:
            pass

    def _perform_dualfeed_belt_reload_sequence(self, weapon):

        try:
            logging.debug("_perform_dualfeed_belt_reload_sequence called but belt-fed logic removed.")
        except Exception:
            pass

    def _roll_d20_dice(self, num_rolls):

        rolls =[secrets.randbelow(20)+1 for _ in range(num_rolls)]

        n = len(rolls)
        if n ==0:
            return rolls, 0
        avg = sum(rolls)/n
        rounded = int(math.floor(avg +0.5))

        return rolls, rounded

    def _copy_to_clipboard(self, text):
        try:
            pyperclip.copy(text)
            logging.info(f"Copied to clipboard: {text}")
            return True
        except Exception as e:
            logging.warning(f"Failed to copy to clipboard: {e}")
            return False

    def _fire_weapon_impl(self, weapon, combat_state, rounds_to_fire = 3, fire_mode = None, save_data = None):# type: ignore

        weapon_id = str(weapon.get("id"))
        logging.info(
        "_fire_weapon start: id=%s name=%s rounds=%s mode=%s",
        weapon_id,
        weapon.get("name", "Unknown"),
        rounds_to_fire,
        fire_mode or "unknown"
        )

        roll_summary_text = None

        chambered = weapon.get("chambered")
        loaded_mag = weapon.get("loaded")
        magazine_type = str(weapon.get("magazinetype", "")or "").lower()

        raw_platform = weapon.get("platform", "")or ""
        if isinstance(raw_platform, (list, tuple)):
            raw_platform = raw_platform[0]if raw_platform else ""
        platform = str(raw_platform)

        is_internal = "internal"in magazine_type or "tube"in magazine_type or "cylinder"in magazine_type or "revolver"in platform.lower()

        is_belt = False

        raw_action = weapon.get("action", "")or ""
        if isinstance(raw_action, (list, tuple)):
            action_list =[str(a).lower()for a in raw_action if a is not None]
        else:
            action_list =[str(raw_action).lower()]

        is_pump =(
        "pump"in platform.lower()
        or any("pump"in a for a in action_list)
        or "pump"in magazine_type
        )

        fire_mode_norm = str(fire_mode or "").title()
        effective_is_pump = is_pump and fire_mode_norm =="Pump"

        magicsys = str(weapon.get("magicsoundsystem")or "").lower()
        is_magic =(str(weapon.get("type")or "").lower()=="magic")or(magicsys in("hg", "at", "mg", "rf"))

        if is_magic:

            magic_folder = os.path.join("sounds", "firearms", "magic", magicsys if magicsys else "hg")

            requires_charge = magicsys in("at", "rf")

            temperature = combat_state.get("barrel_temperatures", {}).get(weapon_id, combat_state.get("ambient_temperature", 70))

            pre_fire_temp = temperature

            if requires_charge:
                charge_file = os.path.join(magic_folder, "charge.ogg")
                if os.path.exists(charge_file):
                    try:
                        self._safe_sound_play("", charge_file, block = True)
                    except Exception:
                        logging.exception("Failed to play charge sound for magic weapon")

            if magicsys =="rf":
                prefire_file = os.path.join(magic_folder, "prefire.ogg")
                if os.path.exists(prefire_file):
                    try:
                        self._safe_sound_play("", prefire_file, block = True)
                    except Exception:
                        logging.exception("Failed to play prefire for rf magic weapon")

            try:
                nshots = max(1, int(rounds_to_fire or 1))
            except Exception:
                nshots = 1

            if magicsys in("at", "rf"):
                nshots = 1

            try:
                rpm = float(weapon.get("cyclic", weapon.get("rpm", 600))or 600)
                if rpm <=0:
                    rpm = 600.0
            except Exception:
                rpm = 600.0
            shot_delay = 60.0 /float(rpm)

            try:
                import glob as _glob
                fire_candidates = _glob.glob(os.path.join(magic_folder, "fire*.ogg"))
            except Exception:
                fire_candidates =[]

            try:
                temp_gain = float(weapon.get("temp_gain_per_shot", weapon.get("temp_gain", 20)or 20))
            except Exception:
                temp_gain = random.uniform(15, 25)
            if self._check_weapon_suppressed(weapon):
                temp_gain *=1.5

            for i in range(nshots):

                try:

                    block_this_shot = magicsys in("at", "rf")
                    if fire_candidates:
                        chosen = random.choice(fire_candidates)
                        self._safe_sound_play("", chosen, block = block_this_shot)
                    else:

                        fallback_path = os.path.join("sounds", weapon.get("sound_folder", ""), "fire.ogg")
                        self._safe_sound_play("", fallback_path, block = block_this_shot)
                except Exception:
                    logging.exception("Magic weapon fire sound failed")

                if magicsys in("at", "rf"):
                    try:
                        self._play_weapon_action_sound_strict(weapon, "boltback", block = False)
                    except Exception:
                        pass

                try:
                    temperature +=temp_gain
                except Exception:
                    temperature = temperature +(temp_gain if isinstance(temp_gain, (int, float))else 0)

                try:
                    if not(magicsys in("at", "rf")):

                        try:
                            if str(fire_mode or "").title()=="Semi":
                                jitter = random.uniform(-0.06, 0.06)
                                time.sleep(max(0.0, shot_delay +0.18 +jitter))
                            else:
                                time.sleep(shot_delay)
                        except Exception:

                            time.sleep(shot_delay)
                except Exception:
                    pass

            cooling_file = os.path.join(magic_folder, "cooling.ogg")
            if magicsys in("at", "rf")and os.path.exists(cooling_file):
                try:
                    self._safe_sound_play("", cooling_file, block = True)
                except Exception:
                    logging.exception("Failed to play cooling sound for magic weapon")

            try:
                cool_amount = float(weapon.get("temp_loss_per_cooling_cycle", weapon.get("temp_loss", 20)or 20))
            except Exception:
                cool_amount = random.uniform(5, 15)

            cool_amount = cool_amount *float(weapon.get("magic_cooling_multiplier", 1.8))

            temperature = max(pre_fire_temp, temperature -cool_amount)

            try:
                combat_state.setdefault("magic_weapon_ids", {})[weapon_id]= True
            except Exception:
                pass

            if magicsys in("at", "rf"):
                try:
                    self._play_weapon_action_sound(weapon, "boltforward")
                except Exception:
                    pass

            combat_state.setdefault("barrel_temperatures", {})[weapon_id]= temperature
            return "Fired(magic)"

        if is_internal:
            internal_rounds = weapon.get("rounds", [])

            if not chambered and not internal_rounds:
                logging.info("Weapon empty(internal) - no rounds present")
                self._safe_sound_play("", "sounds/firearms/universal/dryfire.ogg")
                return "Empty! No rounds loaded."
        else:

            if not chambered and not loaded_mag:
                logging.info("Weapon empty - no magazine loaded")
                self._safe_sound_play("", "sounds/firearms/universal/dryfire.ogg")
                return "Empty! No magazine loaded."

            if not chambered and loaded_mag and not loaded_mag.get("rounds"):
                logging.info("Weapon empty - magazine loaded but empty")
                self._safe_sound_play("", "sounds/firearms/universal/dryfire.ogg")
                return "Empty! Magazine loaded but no rounds."

        temperature = combat_state.get("barrel_temperatures", {}).get(weapon_id, combat_state["ambient_temperature"])
        cleanliness = combat_state.get("barrel_cleanliness", {}).get(weapon_id, 100)

        base_jamrate = weapon.get("jamrate", 0.01)

        ambient = combat_state.get("ambient_temperature", 70)
        temp_above_boiling = max(0, temperature -212)
        temp_mult = 1.0 +(temp_above_boiling /400.0)

        clean_mult = 1.0 -(cleanliness -50)/100.0
        clean_mult = max(0.5, min(1.5, clean_mult))

        total_jamrate = base_jamrate *temp_mult *clean_mult

        logging.debug(
        "Jam calc: base=%s temp_mult=%s clean_mult=%s total=%s temp=%s clean=%s",
        base_jamrate,
        temp_mult,
        clean_mult,
        total_jamrate,
        temperature,
        cleanliness
        )

        cyclic = weapon.get("cyclic", 600)or 600
        base_delay = max(0.0, 60.0 /cyclic)

        burst_cyclic = weapon.get("burst_cyclic")
        try:
            if burst_cyclic:
                burst_cyclic = float(burst_cyclic)
            else:
                burst_cyclic = None
        except Exception:
            burst_cyclic = None
        burst_base_delay = max(0.0, 60.0 /burst_cyclic)if burst_cyclic and burst_cyclic >0 else base_delay

        try:
            burst_pause = float(weapon.get("burst_pause"))
            if burst_pause <0:
                burst_pause = None
        except Exception:
            burst_pause = None
        if burst_pause is None:

            burst_pause = max(0.22, base_delay *1.5)

        actual_rounds_to_fire = rounds_to_fire
        burst_count = weapon.get("burst_count", 0)

        if fire_mode =="Bolt":
            actual_rounds_to_fire = 1
            logging.debug("Bolt-action fire mode: forcing rounds to 1")

        elif effective_is_pump:
            actual_rounds_to_fire = 1
            logging.debug("Pump-action weapon(selected): forcing rounds to 1")
        elif fire_mode =="Burst"and burst_count >0:

            actual_rounds_to_fire =((rounds_to_fire +burst_count -1)//burst_count)*burst_count
            logging.debug(
            "Burst fire mode: requested=%s burst_count=%s actual=%s",
            rounds_to_fire,
            burst_count,
            actual_rounds_to_fire
            )

        if weapon.get("gas_melted", False):
            actual_rounds_to_fire = 1
            logging.debug("Gas-melted weapon detected: forcing single-shot behavior")

        is_semi = fire_mode =="Semi"
        is_burst = fire_mode =="Burst"and burst_count >0
        is_auto = fire_mode =="Auto"

        is_bolt = fire_mode =="Bolt"or bool(weapon.get("gas_melted", False))

        rounds_fired = 0
        jammed = False

        fire_to_pump_delay = weapon.get("pump_fire_to_back_delay", 0.12)
        pump_back_to_forward_delay = weapon.get("pump_back_to_forward_delay", 0.15)

        if effective_is_pump:
            if actual_rounds_to_fire !=1:
                logging.debug("Pump-action weapon detected(selected): limiting actual_rounds_to_fire to 1")
            actual_rounds_to_fire = 1

        for i in range(actual_rounds_to_fire):

            if random.random()<total_jamrate:
                jammed = True
                logging.info(f"Weapon jammed after {rounds_fired} rounds!")
                break

            fired_this_iteration = False
            fired_round = None
            if chambered:
                fired_round = chambered

                try:

                    self._play_firearm_sound(weapon, "fire", fired_round = fired_round)
                except Exception:
                    self._play_firearm_sound(weapon, "fire")
                rounds_fired +=1
                chambered = None
                fired_this_iteration = True
            elif is_internal and weapon.get("rounds"):
                chambered = weapon["rounds"].pop(0)
                fired_round = chambered
                try:
                    self._play_firearm_sound(weapon, "fire", fired_round = fired_round)
                except Exception:
                    self._play_firearm_sound(weapon, "fire")
                rounds_fired +=1
                fired_this_iteration = True
            elif loaded_mag and loaded_mag.get("rounds"):
                chambered = loaded_mag["rounds"].pop(0)
                fired_round = chambered
                try:
                    self._play_firearm_sound(weapon, "fire", fired_round = fired_round)
                except Exception:
                    self._play_firearm_sound(weapon, "fire")
                rounds_fired +=1
                fired_this_iteration = True
            else:

                logging.info("Ran out of ammo mid-burst after %s rounds", rounds_fired)
                break

            if fired_this_iteration:

                try:
                    if fired_round:

                        is_40mm = False
                        try:
                            if isinstance(fired_round, dict):
                                name = str(fired_round.get("name")or "").lower()
                                if "40x46"in name or "40mm"in name or "40 x 46"in name:
                                    is_40mm = True
                                calib = fired_round.get("caliber")
                                if calib and not is_40mm:
                                    if isinstance(calib, (list, tuple)):
                                        for c in calib:
                                            if isinstance(c, str)and "40"in c and "mm"in c:
                                                is_40mm = True
                                                break
                                    elif isinstance(calib, str)and "40"in calib and "mm"in calib:
                                        is_40mm = True

                                if not is_40mm and(str(fired_round.get("ammo_type")or "").lower()=="40mm_grenade"or str(fired_round.get("sounds")or "").lower()in("40mm_grenade", "40mm")):
                                    is_40mm = True
                        except Exception:
                            logging.exception("Error inspecting fired_round for 40mm detection")

                        if is_40mm:
                            try:
                                self._handle_40mm_post_fire_effects(weapon, fired_round)
                            except Exception:
                                logging.exception("Failed to schedule 40mm post-fire effects")
                except Exception:
                    logging.exception("Error checking fired_round for 40mm handling")

                try:
                    if isinstance(weapon, dict)and weapon.get("_ub_loaded")is not None:
                        try:
                            weapon["_ub_loaded"]= max(0, int(weapon.get("_ub_loaded", 0))-1)
                        except Exception:
                            weapon["_ub_loaded"]= 0
                        if weapon.get("_ub_loaded", 0)<=0:

                            pass
                except Exception:
                    logging.exception("Failed updating underbarrel loaded count after fire")

                try:
                    play_casing = False
                    if fired_round:
                        try:

                            is_40mm = False
                            if isinstance(fired_round, dict):
                                fname = str(fired_round.get("name")or "").lower()
                                if "40x46"in fname or "40mm"in fname or "40 x 46"in fname:
                                    is_40mm = True
                                fcal = fired_round.get("caliber")
                                if fcal and not is_40mm:
                                    if isinstance(fcal, (list, tuple)):
                                        for c in fcal:
                                            if isinstance(c, str)and "40"in c and "mm"in c:
                                                is_40mm = True
                                                break
                                    elif isinstance(fcal, str)and "40"in fcal and "mm"in fcal:
                                        is_40mm = True
                                if not is_40mm and(str(fired_round.get("ammo_type")or "").lower()=="40mm_grenade"or str(fired_round.get("sounds")or "").lower()in("40mm_grenade", "40mm")):
                                    is_40mm = True
                            if not is_40mm:
                                play_casing = True
                        except Exception:
                            logging.exception("Error detecting 40mm for casing logic")

                    if play_casing:
                        try:

                            try:
                                if str(weapon.get("type")or "").lower()=="caseless":

                                    play_casing = False

                            except Exception:
                                pass

                            is_shotgun = False
                            try:

                                if isinstance(fired_round, dict):
                                    fr_name = str(fired_round.get("name")or "").lower()
                                    fr_cal = fired_round.get("caliber")
                                    fr_cal_str = ""
                                    if isinstance(fr_cal, (list, tuple)):
                                        fr_cal_str = " ".join([str(x)for x in fr_cal]).lower()
                                    elif fr_cal:
                                        fr_cal_str = str(fr_cal).lower()
                                    if "gauge"in fr_name or "gauge"in fr_cal_str or "bore"in fr_cal_str:
                                        is_shotgun = True

                                if not is_shotgun:
                                    mag_type = str(weapon.get("magazinetype", "")or "").lower()
                                    platform = str(weapon.get("platform", "")or "").lower()
                                    calib = weapon.get("caliber")or[]
                                    calib_str = " ".join([str(x)for x in calib])if isinstance(calib, (list, tuple))else str(calib)
                                    if "tube"in mag_type or "shotgun"in platform or "gauge"in calib_str.lower()or "bore"in calib_str.lower():
                                        is_shotgun = True
                            except Exception:
                                pass

                            if is_shotgun:
                                candidates = glob.glob(os.path.join("sounds", "firearms", "universal", "shelldrop*.ogg"))+glob.glob(os.path.join("sounds", "firearms", "universal", "shelldrop*.wav"))
                            else:
                                candidates = glob.glob(os.path.join("sounds", "firearms", "universal", "casing*.ogg"))+glob.glob(os.path.join("sounds", "firearms", "universal", "casing*.wav"))

                            if candidates:
                                try:
                                    self._safe_sound_play("", random.choice(candidates))
                                except Exception:
                                    logging.exception("Failed to play casing/shelldrop sound")
                        except Exception:
                            logging.exception("Error selecting/playing casing sound")
                except Exception:
                    logging.exception("Casing/shelldrop handling failed")
                if effective_is_pump:

                    time.sleep(fire_to_pump_delay)
                    self._play_weapon_action_sound(weapon, "pumpback")
                    time.sleep(pump_back_to_forward_delay)

                    if is_internal and weapon.get("rounds"):
                        chambered = weapon["rounds"].pop(0)
                    elif loaded_mag and loaded_mag.get("rounds"):
                        chambered = loaded_mag["rounds"].pop(0)
                    self._play_weapon_action_sound(weapon, "pumpforward")
                else:

                    if not is_bolt:
                        if is_internal and weapon.get("rounds"):
                            chambered = weapon["rounds"].pop(0)
                        elif loaded_mag and loaded_mag.get("rounds"):
                            chambered = loaded_mag["rounds"].pop(0)

                try:
                    is_single_action = False
                    weapon_action = weapon.get("action", "")
                    if isinstance(weapon_action, (list, tuple)):
                        weapon_action = weapon_action[0]if weapon_action else ""
                    weapon_action = str(weapon_action).lower()
                    if weapon_action =="single":
                        is_single_action = True

                    is_cylinder = "cylinder"in magazine_type

                    if is_single_action and is_cylinder:
                        time.sleep(0.08)
                        self._play_cylinder_sound(weapon, "hammerdown")
                except Exception:
                    logging.exception("Error handling single-action hammer pull")
            else:

                logging.info("Ran out of ammo mid-burst after %s rounds", rounds_fired)
                break

            try:
                temp_gain = float(weapon.get("temp_gain_per_shot", weapon.get("temp_gain", None)))
            except Exception:
                temp_gain = None
            if temp_gain is None:

                temp_gain = random.uniform(5.0, 10.0)
            if self._check_weapon_suppressed(weapon):
                temp_gain *=1.5
            temperature +=temp_gain

            try:
                melt_temp = float(weapon.get("melt_temp", 3000))
            except Exception:
                melt_temp = 3000.0
            if temperature >=melt_temp and not weapon.get("gas_melted", False):
                weapon["gas_melted"]= True
                is_bolt = True
                logging.warning("Weapon %s gas system MELTED at %.1fÂ°F(in-shot)", weapon.get("name", weapon_id), temperature)

            cleanliness -=random.uniform(0.1, 0.3)
            cleanliness = max(0, cleanliness)

            if is_bolt:

                pass
            elif is_semi:

                time.sleep(base_delay +0.18)
            elif is_burst:

                shots_in_burst =(i +1)%burst_count
                if shots_in_burst ==0 and i +1 <actual_rounds_to_fire:

                    time.sleep(burst_pause)
                else:

                    time.sleep(burst_base_delay)
            else:

                time.sleep(base_delay)

        weapon["chambered"]= chambered
        weapon["loaded"]= loaded_mag

        if "barrel_temperatures"not in combat_state:
            combat_state["barrel_temperatures"]= {}
        if "barrel_cleanliness"not in combat_state:
            combat_state["barrel_cleanliness"]= {}
        if "weapon_last_used"not in combat_state:
            combat_state["weapon_last_used"]= {}

        try:
            melt_temp = float(weapon.get("melt_temp", 3000))
        except Exception:
            melt_temp = 3000.0
        if temperature >=melt_temp:
            weapon["gas_melted"]= True
            logging.warning("Weapon %s gas system MELTED at %.1fÂ°F", weapon.get("name", weapon_id), temperature)

        combat_state["barrel_temperatures"][weapon_id]= temperature
        combat_state["barrel_cleanliness"][weapon_id]= cleanliness
        combat_state["weapon_last_used"][weapon_id]= time.time()

        if is_bolt and rounds_fired >0 and not jammed:

            time.sleep(0.28)

            try:
                if is_internal:
                    if weapon.get("rounds"):
                        next_round = weapon["rounds"].pop(0)
                        weapon["chambered"]= next_round
                        cycle_result = "next round automatically chambered"
                    else:
                        weapon["chambered"]= None
                        cycle_result = "bolt cycled(no rounds left to chamber)"
                else:
                    if loaded_mag and loaded_mag.get("rounds"):
                        next_round = loaded_mag["rounds"].pop(0)
                        weapon["chambered"]= next_round
                        cycle_result = "next round automatically chambered"
                    else:
                        weapon["chambered"]= None
                        cycle_result = "bolt cycled(no rounds left to chamber)"
            except Exception:
                cycle_result = None

            try:
                if weapon.get("gas_melted", False):

                    self._cycle_bolt_sounds(weapon, single_forward = False, delay = 0.0)
                else:

                    if weapon.get("chambered")is None:

                        if bool(weapon.get("bolt_catch", False)):
                            try:
                                self._play_weapon_action_sound(weapon, "boltforward")
                            except Exception:
                                pass
                    else:

                        self._cycle_bolt_sounds(weapon, single_forward = False, delay = 0.12)
            except Exception:
                try:

                    self._cycle_bolt_sounds(weapon, single_forward = False, delay = 0.12)
                except Exception:
                    pass
        else:
            cycle_result = None

        if rounds_fired >0:
            rolls, median = self._roll_d20_dice(rounds_fired)
            weapon_name = weapon.get("name", "Unknown")
            caliber_list = weapon.get("caliber", [])or["Unknown"]
            caliber = caliber_list[0]

            variant = "Unknown"

            if chambered and isinstance(chambered, dict):
                variant = chambered.get("variant", "Unknown")

            elif loaded_mag and loaded_mag.get("rounds"):
                first_round = loaded_mag["rounds"][0]
                if isinstance(first_round, dict):
                    variant = first_round.get("variant", "Unknown")
                elif isinstance(first_round, str)and " | "in first_round:
                    variant = first_round.split(" | ")[1]

            elif chambered and isinstance(chambered, str)and " | "in chambered:
                variant = chambered.split(" | ")[1]

            effective_aim = 0
            try:

                if save_data and isinstance(save_data, dict):
                    sd_stats = save_data.get("stats", {})or {}
                    if isinstance(sd_stats, dict):
                        if "Aim"in sd_stats:
                            effective_aim +=float(sd_stats.get("Aim", 0)or 0)
                        else:

                            effective_aim +=float(sd_stats.get("aim", 0)or 0)
            except Exception:
                pass
            try:

                if isinstance(weapon, dict):
                    mods = weapon.get("_active_modifiers", {})or {}
                    stats_mods = mods.get("stats", {})if isinstance(mods, dict)else {}
                    if isinstance(stats_mods, dict):
                        effective_aim +=float(stats_mods.get("aim", 0)or 0)

                    wstats = weapon.get("stats", {})or {}
                    if isinstance(wstats, dict):
                        effective_aim +=float(wstats.get("aim", 0)or 0)
            except Exception:
                pass

            try:
                fired_round_for_bonus = chambered
                if not fired_round_for_bonus and loaded_mag and loaded_mag.get("rounds"):
                    fired_round_for_bonus = loaded_mag["rounds"][0]if loaded_mag["rounds"]else None

                if fired_round_for_bonus and isinstance(fired_round_for_bonus, dict):
                    round_mods = fired_round_for_bonus.get("modifiers", {})or {}
                    if isinstance(round_mods, dict):
                        round_stats = round_mods.get("stats", {})or {}
                        if isinstance(round_stats, dict):
                            effective_aim +=float(round_stats.get("aim", 0)or 0)
            except Exception:
                pass

            try:
                pre_clamp_aim = effective_aim
                clamp_val = None

                try:
                    if isinstance(weapon, dict)and weapon.get("bonus_clamp")is not None:
                        clamp_val = float(weapon.get("bonus_clamp"))
                except Exception:
                    clamp_val = None

                if clamp_val is None:
                    try:
                        tbl_path = os.path.join("tables", "lid.sldtbl")
                        if os.path.exists(tbl_path):
                            with open(tbl_path, 'r', encoding = 'utf-8')as tf:
                                import json as _json
                                tdata = _json.load(tf)
                                clamp_val = tdata.get('additional_settings', {}).get('bonus_clamp')
                    except Exception:
                        clamp_val = None

                applied_clamp = False
                if clamp_val is not None:
                    try:
                        clamp_num = float(clamp_val)
                        if effective_aim >clamp_num:
                            effective_aim = clamp_num
                            applied_clamp = True
                    except Exception:
                        applied_clamp = False
                final_total = int(median)+int(round(effective_aim))
            except Exception:
                final_total = median

            round_display = str(caliber)
            try:

                if isinstance(variant, dict):
                    vname = variant.get("name")or variant.get("variant")or variant.get("variant_name")
                    if vname:
                        round_display = f"{caliber} {vname}"

                elif isinstance(variant, (list, tuple)):
                    try:
                        parts =[str(x).strip()for x in variant if x is not None]
                        if parts:
                            round_display = f"{caliber} {' '.join(parts)}"
                    except Exception:
                        pass
                elif isinstance(variant, str)and variant and variant !="Unknown":
                    maybe = variant.strip()

                    try:
                        simple = True

                        for ch in "{}[](), '\"":
                            if ch in maybe:
                                simple = False
                                break

                        if "caliber"in maybe.lower()or "variant"in maybe.lower():
                            simple = False
                        if simple and maybe:
                            round_display = f"{caliber} {maybe}"

                            maybe = None
                    except Exception:
                        pass
                    if not maybe:

                        pass
                    else:
                        parsed = None
                    parsed = None

                    if maybe[0]in("{", "[", "("):
                        try:
                            import ast as _ast
                            parsed = _ast.literal_eval(maybe)
                        except Exception:
                            parsed = None
                    if isinstance(parsed, dict):
                        vname = parsed.get("name")or parsed.get("variant")or parsed.get("variant_name")
                        if vname:
                            round_display = f"{caliber} {vname}"
                        elif parsed.get("caliber")and parsed.get("variant"):
                            round_display = f"{parsed.get('caliber')} {parsed.get('variant')}"
                    elif isinstance(parsed, (list, tuple)):
                        try:
                            parts =[str(x).strip()for x in parsed if x is not None]
                            if parts:
                                round_display = f"{caliber} {' '.join(parts)}"
                        except Exception:
                            pass
                    else:

                        try:
                            import re as _re
                            m = _re.search(r"variant\s*[:=]\s*['\"]([^'\"]+)['\"]", maybe, _re.IGNORECASE)
                            if m:
                                round_display = f"{caliber} {m.group(1)}"
                            else:

                                cleaned = maybe
                        except Exception:
                            cleaned = maybe

                        if(cleaned.startswith("{")and cleaned.endswith("}"))or(cleaned.startswith("[")and cleaned.endswith("]"))or(cleaned.startswith("(")and cleaned.endswith(")")):
                            cleaned = cleaned[1:-1]

                        parts =[p.strip().strip("'\"")for p in cleaned.split(", ")if p.strip()]
                        if len(parts)==1:
                            if parts[0]:
                                round_display = f"{caliber} {parts[0]}"
                        elif len(parts)>=2:

                            candidate = parts[-1]
                            try:
                                import re as _re

                                m = _re.search(r"['\"]([^'\"]+)['\"]", candidate)
                                if m:
                                    candidate = m.group(1)
                                else:

                                    m2 = _re.search(r"variant\s*[:=]\s*([^,}\)\]]+)", candidate, _re.IGNORECASE)
                                    if m2:
                                        candidate = m2.group(1).strip().strip("'\"{}[]() ")
                                    else:

                                        candidate = candidate.strip().strip("'\"{}[]() ")
                            except Exception:
                                candidate = candidate.strip().strip("'\"{}[]() ")
                            round_display = f"{caliber} {candidate}"
            except Exception:
                pass

            try:
                import re as _re

                round_display = _re.sub(r"[\s:|]+$", "", round_display)

                round_display = _re.sub(r"\s+", " ", round_display).strip()
            except Exception:
                try:
                    round_display = round_display.strip()
                except Exception:
                    pass

            try:
                if round_display ==str(caliber):
                    tbl_path = os.path.join("tables", "lid.sldtbl")
                    if os.path.exists(tbl_path):
                        try:
                            with open(tbl_path, 'r', encoding = 'utf-8')as tf:
                                import json as _json
                                tdata = _json.load(tf)
                                ammo_arr = tdata.get('tables', {}).get('ammunition', [])
                                for a in ammo_arr:
                                    try:
                                        if a.get('caliber')==caliber:
                                            variants = a.get('variants')or[]
                                            if variants and isinstance(variants, list):
                                                first = variants[0]
                                                if isinstance(first, dict)and first.get('name'):
                                                    round_display = f"{caliber} {first.get('name')}"
                                                    break
                                                elif isinstance(first, str)and first:
                                                    round_display = f"{caliber} {first}"
                                                    break
                                    except Exception:
                                        continue
                        except Exception:
                            pass
            except Exception:
                pass

            is_suppressed = self._check_weapon_suppressed(weapon)
            suppressed_tag = " | Suppressed"if is_suppressed else ""
            clipboard_text = f"Roll: {final_total} | Weapon: {weapon_name} | Round: {round_display} | {rounds_fired} rounds fired{suppressed_tag}"
            self._copy_to_clipboard(clipboard_text)
            logging.info(f"D20 rolls: {rolls}, Rounded avg: {median}")

            try:
                sd_ref = save_data if isinstance(save_data, dict)else globals().get('save_data')or getattr(self, '_current_save_data', None)
                if isinstance(sd_ref, dict):
                    ts = sd_ref.setdefault('tracked_stats', {})
                    if isinstance(ts, dict):
                        ts['rounds_fired_total']= int(ts.get('rounds_fired_total', 0))+int(rounds_fired)
                        ts['d20_rolls_total']= int(ts.get('d20_rolls_total', 0))+len(rolls)
                        ts['d20_ones']= int(ts.get('d20_ones', 0))+sum(1 for r in rolls if r ==1)
                        ts['d20_twenties']= int(ts.get('d20_twenties', 0))+sum(1 for r in rolls if r ==20)
                        hist = ts.setdefault('d20_roll_history', [])
                        try:
                            hist.append({'weapon_id':weapon_id, 'rolls':rolls, 'time':time.time()})
                        except Exception:
                            pass
            except Exception:
                logging.exception('Failed updating tracked_stats after firing')

            try:
                popup_lines =[
                f"Base roll(rounded avg): {median}",
                f"Aim bonus: {int(round(effective_aim))}",
                f"Final total: {final_total}",
                f"Weapon: {weapon_name}",
                f"Round: {round_display}",
                f"Rounds fired: {rounds_fired}"
                ]
                try:
                    if 'applied_clamp'in locals()and applied_clamp:
                        popup_lines.insert(2, f"Bonus clamp applied: +{int(clamp_num)}(was {int(round(pre_clamp_aim))})")
                except Exception:
                    pass
                roll_summary_text = "\n".join(popup_lines)
            except Exception:
                roll_summary_text = None

        if jammed:

            import random as _rand

            if loaded_mag and isinstance(loaded_mag, dict)and loaded_mag.get("magazinetype"):
                magazine_type = str(loaded_mag.get("magazinetype", "")or "").lower()
            else:
                magazine_type = str(weapon.get("magazinetype", "")or "").lower()

            sub_mag = str(weapon.get("submagazinetype", "")or "").lower()

            weapon_platform = str(weapon.get("platform", "")or "").lower()
            if weapon.get("infinite_ammo")and not loaded_mag:

                has_detachable_mag = "box"in magazine_type and not any(k in magazine_type for k in("internal", "tube", "cylinder"))and "revolver"not in weapon_platform
            else:
                has_detachable_mag = bool(loaded_mag)and not any(k in magazine_type for k in("internal", "tube", "cylinder"))and "revolver"not in weapon_platform

            progress = None
            try:
                progress = self._popup_progress("Clearing Jam", "Preparing to clear jam...")
            except Exception:
                progress = None

            try:
                if has_detachable_mag:
                    if progress:
                        progress["update"]("Dropping magazine...")

                    try:
                        mag_type_rt =(weapon.get("magazinetype", "")or "").lower()
                        plat_rt =(weapon.get("platform", "")or "").lower()
                        is_belt_rt = "belt"in mag_type_rt or "belt"in plat_rt or "m249"in plat_rt
                        if is_belt_rt:
                            if weapon.get("dualfeed")and(weapon.get("submagazinesystem")or weapon.get("submagazinetype")):
                                self._perform_dualfeed_belt_reload_sequence(weapon)
                            else:
                                self._perform_belt_reload_sequence(weapon)
                        else:

                            self._play_weapon_action_sound(weapon, "magout")
                    except Exception:

                        try:
                            self._play_weapon_action_sound(weapon, "magout")
                        except Exception:
                            pass

                if progress:
                    progress["update"]("Waiting(1.0-1.5s)...")
                time.sleep(_rand.uniform(1.0, 1.5))

                if progress:
                    if is_pump:
                        progress["update"]("Pumping action back...")
                    else:
                        progress["update"]("Racking bolt back...")

                if is_pump:
                    self._play_weapon_action_sound(weapon, "pumpback")
                else:

                    self._cycle_bolt_sounds(weapon, single_forward = False, delay = 0.1)

                time.sleep(0.1)

                if progress:
                    if is_pump:
                        progress["update"]("Pumping action forward...")
                    else:
                        progress["update"]("Racking bolt forward...")

                if is_pump:
                    self._play_weapon_action_sound(weapon, "pumpforward")
                else:

                    pass

                if progress:
                    progress["update"]("Waiting(3.5-5.0s)...")
                time.sleep(_rand.uniform(3.5, 5.0))

                if has_detachable_mag:
                    if progress:
                        progress["update"]("Inserting magazine...")
                    try:
                        mag_type_rt =(weapon.get("magazinetype", "")or "").lower()
                        plat_rt =(weapon.get("platform", "")or "").lower()
                        is_belt_rt = "belt"in mag_type_rt or "belt"in plat_rt or "m249"in plat_rt

                        if is_belt_rt:

                            pass
                        else:
                            self._play_weapon_action_sound(weapon, "magin")
                    except Exception:
                        pass

                if progress:
                    progress["update"]("Waiting(1.0-1.5s)...")
                time.sleep(_rand.uniform(1.0, 1.5))

                if progress:
                    if is_pump:
                        progress["update"]("Pumping action back...")
                    else:
                        progress["update"]("Racking bolt back...")

                if is_pump:
                    self._play_weapon_action_sound(weapon, "pumpback")
                else:

                    self._cycle_bolt_sounds(weapon, single_forward = False, delay = 0.1)

                time.sleep(0.1)

                if progress:
                    if is_pump:
                        progress["update"]("Pumping action forward...")
                    else:
                        progress["update"]("Racking bolt forward...")

                if is_pump:
                    self._play_weapon_action_sound(weapon, "pumpforward")
                else:

                    pass
            finally:
                if progress:
                    try:
                        progress["close"]()
                    except Exception:
                        pass

            return f"Fired {rounds_fired} rounds - WEAPON JAMMED! Clear jam and try again."
        else:
            if is_bolt and rounds_fired >0 and cycle_result:
                base = f"Fired {rounds_fired} round(s) successfully - {cycle_result}."
            else:
                base = f"Fired {rounds_fired} rounds successfully."
            if roll_summary_text:
                return f"{base}\n{roll_summary_text}"
            return base

    def _fire_weapon(self, weapon, combat_state, rounds_to_fire = 3, fire_mode = None, save_data = None):
        try:
            return self._fire_weapon_impl(weapon, combat_state, rounds_to_fire = rounds_to_fire, fire_mode = fire_mode, save_data = save_data)
        except Exception:
            logging.exception("Unhandled exception in _fire_weapon for %s", weapon.get('name')if isinstance(weapon, dict)else str(weapon))
            return "Firing failed due to an internal error"

    def _reload_infinite_ammo_weapon(self, weapon, save_data):

        logging.info("_reload_infinite_ammo_weapon: %s", weapon.get("name", "Unknown"))

        try:

            caliber_list = weapon.get("caliber", [])or["Unknown"]
            caliber = caliber_list[0]if isinstance(caliber_list, list)else caliber_list

            mag_to_load = weapon.get("mag_to_load")
            has_magazine_in_pool = weapon.get("has_magazine_in_pool", True)

            table_data = None
            try:
                table_files = glob.glob(os.path.join("tables", "*.sldtbl"))
                if table_files:
                    with open(table_files[0], 'r', encoding = 'utf-8')as f:
                        table_data = json.load(f)
            except Exception:
                logging.exception("Failed to load table data for infinite ammo reload")

            new_mag = None

            if has_magazine_in_pool is False:

                if isinstance(mag_to_load, dict):
                    capacity = mag_to_load.get("capacity", 30)
                    if isinstance(capacity, list):
                        capacity = capacity[0]if capacity else 30
                    new_mag = {
                    "name":f"Infinite {caliber} Magazine",
                    "caliber":[caliber]if not isinstance(caliber, list)else caliber,
                    "capacity":capacity,
                    "magazinesystem":weapon.get("magazinesystem"),
                    "magazinetype":weapon.get("magazinetype", "Detachable box"),
                    "rounds":[],
                    "infinite":True
                    }

                    for _ in range(capacity):
                        new_mag["rounds"].append({
                        "name":f"{caliber} | Infinite",
                        "caliber":caliber,
                        "variant":"Infinite"
                        })
            elif mag_to_load is not None and table_data:

                mag_id = mag_to_load if isinstance(mag_to_load, int)else None
                if mag_id is not None:
                    magazines = table_data.get("tables", {}).get("magazines", [])
                    for mag in magazines:
                        if mag.get("id")==mag_id:

                            new_mag = json.loads(json.dumps(mag))
                            capacity = new_mag.get("capacity", 30)
                            new_mag["rounds"]=[]
                            new_mag["infinite"]= True

                            for _ in range(capacity):
                                new_mag["rounds"].append({
                                "name":f"{caliber} | Infinite",
                                "caliber":caliber,
                                "variant":"Infinite"
                                })
                            break

            if new_mag is None:
                capacity = 30
                loaded = weapon.get("loaded")
                if loaded and isinstance(loaded, dict):
                    capacity = loaded.get("capacity", 30)
                new_mag = {
                "name":f"Infinite {caliber} Magazine",
                "caliber":[caliber]if not isinstance(caliber, list)else caliber,
                "capacity":capacity,
                "magazinesystem":weapon.get("magazinesystem"),
                "magazinetype":weapon.get("magazinetype", "Detachable box"),
                "rounds":[],
                "infinite":True
                }
                for _ in range(capacity):
                    new_mag["rounds"].append({
                    "name":f"{caliber} | Infinite",
                    "caliber":caliber,
                    "variant":"Infinite"
                    })

            current_mag = weapon.get("loaded")
            is_gun_empty = not weapon.get("chambered")and(not current_mag or not current_mag.get("rounds", []))

            if current_mag:
                try:
                    self._play_weapon_action_sound(weapon, "magout", block = True)
                    time.sleep(random.uniform(0.5, 1.0))
                    magdrop_sound = f"magdrop{random.randint(0, 1)}"
                    self._safe_sound_play("", f"sounds/firearms/universal/{magdrop_sound}.ogg")
                except Exception:
                    pass

            time.sleep(random.uniform(0.25, 0.5))

            try:
                self._safe_sound_play("", "sounds/firearms/universal/pouchout.ogg")
            except Exception:
                pass
            time.sleep(random.uniform(0.5, 0.75))
            try:
                self._play_weapon_action_sound(weapon, "magin", block = True)
            except Exception:
                pass

            time.sleep(random.uniform(0.25, 0.5))

            rt_platform = str(weapon.get("platform", "")or "").lower()
            rt_mag_type = str(weapon.get("magazinetype", "")or "").lower()
            rt_action_raw = weapon.get("action", "")or ""
            if isinstance(rt_action_raw, (list, tuple)):
                rt_action_raw = rt_action_raw[0]if rt_action_raw else ""
            rt_action = str(rt_action_raw).lower()
            is_pump =("pump"in rt_platform or rt_action =="pump"or "pump"in rt_mag_type)

            if is_gun_empty:
                if is_pump:
                    try:
                        self._play_weapon_action_sound(weapon, "pumpback", block = True)
                        self._play_weapon_action_sound(weapon, "pumpforward")
                    except Exception:
                        pass
                elif not weapon.get("bolt_catch"):
                    try:
                        self._play_weapon_action_sound(weapon, "boltback", block = True)
                        self._play_weapon_action_sound(weapon, "boltforward")
                    except Exception:
                        pass
                else:
                    try:
                        self._play_weapon_action_sound(weapon, "boltforward")
                    except Exception:
                        pass

            rt_mag_type = str(weapon.get("magazinetype", "")or "").lower()
            # For internal/tube/cylinder magazine types, treat infinite ammo as rounds inside the weapon
            if any(k in rt_mag_type for k in ("internal", "tube", "cylinder")):
                cur_rounds = weapon.get("rounds", []) or []
                # extend with infinite rounds from the generated mag
                cur_rounds.extend(list(new_mag.get("rounds", [])))
                weapon["rounds"] = cur_rounds
                if is_gun_empty and weapon["rounds"] and not is_pump:
                    weapon["chambered"] = weapon["rounds"].pop(0)
                elif is_gun_empty:
                    weapon["chambered"] = {
                    "name":f"{caliber} | Infinite",
                    "caliber":caliber,
                    "variant":"Infinite"
                    }
            else:
                weapon["loaded"]= new_mag

                if is_gun_empty and new_mag.get("rounds")and not is_pump:
                    weapon["chambered"]= new_mag["rounds"].pop(0)
                elif is_gun_empty:
                    weapon["chambered"]= {
                    "name":f"{caliber} | Infinite",
                    "caliber":caliber,
                    "variant":"Infinite"
                    }

            rounds_loaded = len(new_mag.get("rounds", []))
            capacity = new_mag.get("capacity", "?")
            return f"Reloaded with infinite ammo({rounds_loaded}/{capacity})"

        except Exception as e:
            logging.exception("Failed to reload infinite ammo weapon")
            return f"Reload failed: {e}"

    def _reload_weapon(self, weapon, save_data, combat_reload = False):

        logging.info(
        "_reload_weapon start: name=%s magsystem=%s combat_reload=%s",
        weapon.get("name", "Unknown"),
        weapon.get("magazinesystem"),
        combat_reload
        )

        try:
            pf = None
            if isinstance(weapon, dict):
                pf = weapon.get("platform")or weapon.get("underbarrel_platform")
            if weapon.get("underbarrel_weapon")or(pf and pf in self.PLATFORM_DEFAULTS):
                return self._reload_underbarrel(weapon, save_data, combat_reload)
        except Exception:
            logging.exception("Underbarrel reload handler check failed")

        if weapon.get("infinite_ammo"):
            return self._reload_infinite_ammo_weapon(weapon, save_data)

        magazine_type = weapon.get("magazinetype", "")or ""
        magazine_type = magazine_type.lower()if isinstance(magazine_type, str)else str(magazine_type).lower()
        magazine_system = weapon.get("magazinesystem")

        if not magazine_system:

            if weapon.get("magazinetype"):
                magazine_system = weapon.get("magazinetype")
            else:

                loaded_mag = weapon.get("loaded")
                if isinstance(loaded_mag, dict)and loaded_mag.get("magazinesystem"):
                    magazine_system = loaded_mag.get("magazinesystem")
                else:

                    found_ms = None

                    for item in save_data.get("hands", {}).get("items", []):
                        if item and isinstance(item, dict)and("rounds"in item or "capacity"in item):
                            if item.get("magazinesystem"):
                                found_ms = item.get("magazinesystem");break
                            if item.get("magazinetype"):
                                found_ms = item.get("magazinetype");break

                    if not found_ms:
                        for slot_name, eq_item in save_data.get("equipment", {}).items():
                            if eq_item and isinstance(eq_item, dict)and("rounds"in eq_item or "capacity"in eq_item):
                                if eq_item.get("magazinesystem"):
                                    found_ms = eq_item.get("magazinesystem");break
                                if eq_item.get("magazinetype"):
                                    found_ms = eq_item.get("magazinetype");break
                    if found_ms:
                        magazine_system = found_ms

        if "internal"in magazine_type:
            return self._reload_internal_magazine(weapon, save_data, magazine_type)

        if "cylinder"in magazine_type:
            return self._reload_cylinder(weapon, save_data)

        if "revolver"in weapon.get("platform", "").lower():
            return self._reload_revolver(weapon, save_data)

        if not magazine_system:
            try:
                sugg = self.suggest_magazine_for_weapon(weapon)
                caps = sugg.get('suggested_capacities')if isinstance(sugg, dict)else None
                nid = sugg.get('next_id')if isinstance(sugg, dict)else None
                note = f"Weapon doesn't use magazines.Suggested capacities: {caps} Next ID: {nid}"
                return note
            except Exception:
                return "Weapon doesn't use magazines."

    def suggest_magazine_for_weapon(self, weapon):

        try:
            name =(weapon.get('name')or '').strip()
        except Exception:
            name = ''
        try:
            calib_raw = weapon.get('caliber')
            if isinstance(calib_raw, (list, tuple))and calib_raw:
                calib = str(calib_raw[0])
            else:
                calib = str(calib_raw or '')
        except Exception:
            calib = ''

        results = {
        'weapon_name':name,
        'caliber':calib,
        'wiki_matches':[],
        'suggested_capacities':[],
        'suggested_mag_item':None,
        'next_id':0,
        'notes':[]
        }

        caliber_map = {
        '9x19':[15, 17, 30],
        '9mm':[15, 17, 30],
        '5.56x45':[30],
        '5.56':[30],
        '7.62x39':[30],
        '7.62x51':[20, 30],
        '7.62':[20, 30],
        '.45 acp':[7, 8, 10],
        '.45':[7, 8, 10],
        '.308':[10, 20, 30],
        '.30-06':[5, 10],
        '12 gauge':[1, 4, 5, 8],
        '40mm':[1]
        }

        def _norm(s):
            try:
                return re.sub(r"[^0-9a-zA-Z\.x\-\s]", '', str(s or '')).strip().lower()
            except Exception:
                return ''

        wiki_candidates =[]
        session = requests.Session()
        try:
            if name:
                q = name
                url = 'https://en.wikipedia.org/w/api.php'
                params = {
                'action':'query',
                'list':'search',
                'srsearch':q,
                'format':'json',
                'srlimit':5
                }
                r = session.get(url, params = params, timeout = 6)
                j = r.json()
                for s in j.get('query', {}).get('search', [])or[]:
                    wiki_candidates.append(s.get('title'))
        except Exception:
            results['notes'].append('Wikipedia search failed for weapon name')

        try:
            if calib:
                q = calib
                url = 'https://en.wikipedia.org/w/api.php'
                params = {
                'action':'query',
                'list':'search',
                'srsearch':q,
                'format':'json',
                'srlimit':5
                }
                r = session.get(url, params = params, timeout = 6)
                j = r.json()
                for s in j.get('query', {}).get('search', [])or[]:
                    if s.get('title')not in wiki_candidates:
                        wiki_candidates.append(s.get('title'))
        except Exception:
            results['notes'].append('Wikipedia search failed for caliber')

        capacities_found =[]
        try:
            url = 'https://en.wikipedia.org/w/api.php'
            for title in wiki_candidates[:6]:
                try:
                    params = {
                    'action':'query',
                    'prop':'extracts',
                    'explaintext':1,
                    'titles':title,
                    'format':'json',
                    'exintro':1
                    }
                    r = session.get(url, params = params, timeout = 6)
                    j = r.json()
                    pages = j.get('query', {}).get('pages', {})or {}
                    text = ''
                    for p in pages.values():
                        text =(p.get('extract')or '')
                        break
                    if not text:

                        params['exintro']= 0
                        r = session.get(url, params = params, timeout = 6)
                        j = r.json()
                        pages = j.get('query', {}).get('pages', {})or {}
                        for p in pages.values():
                            text =(p.get('extract')or '')
                            break
                    if not text:
                        continue
                    results['wiki_matches'].append({'title':title, 'snippet':text[:800]})

                    lower = text.lower()

                    for m in re.finditer(r"magazine", lower):
                        start = max(0, m.start()-120)
                        end = min(len(lower), m.end()+120)
                        context = lower[start:end]
                        nums = re.findall(r"(\d{1, 3})\s*(?:-round|rounds|round|rd|rnd)", context)
                        for n in nums:
                            try:
                                capacities_found.append(int(n))
                            except Exception:
                                pass

                    for m in re.finditer(r"capacity|standard|commonly|usually", lower):
                        start = max(0, m.start()-120)
                        end = min(len(lower), m.end()+120)
                        context = lower[start:end]
                        nums = re.findall(r"(\d{1, 3})\s*(?:rounds|round|rnd|-round)", context)
                        for n in nums:
                            try:
                                capacities_found.append(int(n))
                            except Exception:
                                pass

                    nums = re.findall(r"(\d{1, 3})\s*-?\s*round(?:s)?", lower)
                    for n in nums:
                        try:
                            capacities_found.append(int(n))
                        except Exception:
                            pass
                except Exception:
                    continue
        except Exception:
            results['notes'].append('Failed fetching/parsing Wikipedia extracts')

        caps =[]
        try:
            if capacities_found:

                freq = {}
                for c in capacities_found:
                    freq[c]= freq.get(c, 0)+1
                caps = sorted(freq.keys(), key = lambda x:(-freq[x], x))[:5]
        except Exception:
            caps =[]

        try:
            if not caps and calib:
                ncal = _norm(calib)
                for k, v in caliber_map.items():
                    if k in ncal or ncal in k:
                        caps = v[:3]
                        break
        except Exception:
            pass

        if not caps:
            caps =[10, 20, 30]

        results['suggested_capacities']= caps

        try:
            table_files = glob.glob(os.path.join('tables', '*.sldtbl'))
            maxid = 0
            for tf in table_files:
                try:
                    with open(tf, 'r', encoding = 'utf-8')as fh:
                        td = json.load(fh)
                    tables = td.get('tables', {})
                    for sub, items in tables.items():
                        if isinstance(items, list):
                            for it in items:
                                try:
                                    if isinstance(it, dict)and 'id'in it:
                                        iid = it.get('id')
                                        try:
                                            if iid is None:
                                                continue
                                            iv = int(iid)
                                            if iv >maxid:
                                                maxid = iv
                                        except Exception:
                                            pass
                                except Exception:
                                    pass
                except Exception:
                    continue
            next_id = maxid +1
        except Exception:
            next_id = 0

        results['next_id']= next_id

        try:
            cap = caps[0]if caps else 30
            mag_name = f"Synthetic Mag({cap})"
            mag_item = {
            'id':next_id,
            'name':mag_name,
            'capacity':int(cap),
            'magazinetype':weapon.get('magazinetype')or 'detachable box',
            'magazinesystem':weapon.get('magazinesystem')or weapon.get('magazinetype')or '',
            'rounds':[]
            }

            try:
                round_name =(calib or 'Unknown')+' | FMJ'
            except Exception:
                round_name = 'FMJ'
            for i in range(int(cap)):
                mag_item['rounds'].append({'name':round_name, 'caliber':calib or None, 'variant':'fmj'})
            results['suggested_mag_item']= mag_item
        except Exception:
            results['notes'].append('Failed to build suggested_mag_item')

        return results

    def _categorize_40mm_round(self, round_info):

        try:
            if not isinstance(round_info, dict):
                return None
            keys = {}
            for k in("type", "variant", "subtype", "name"):
                v = round_info.get(k)
                if isinstance(v, str):
                    keys[k]= v.lower()
            name = keys.get("name", "")
            typ = keys.get("type", "")or keys.get("variant", "")or keys.get("subtype", "")

            if "airburst"in name or "air burst"in name or "airburst"in typ or "air burst"in typ:
                return "airburst"
            if "high-explosive"in name or "high explosive"in name or "he"==typ or "high-explosive"in typ:
                return "he"
            if "dual"in name and("high"in name or "explosive"in name or "dp"in name):
                return "hedp"
            if "apers"in name or "ap ers"in name or "ap"in typ or "anti-personnel"in name:
                return "apers"
            if "smoke"in name or "smoke"in typ:
                return "smoke"
            if "gas"in name or "gas"in typ:
                return "gas"

            if "expl"in name:
                return "he"
        except Exception:
            pass
        return None

    def _handle_40mm_post_fire_effects(self, weapon, round_info):

        try:

            platform_key =(weapon.get("platform")or weapon.get("underbarrel_platform")or "").strip()
            if isinstance(platform_key, (list, tuple)):
                platform_key = platform_key[0]if platform_key else ""
            wf = None
            if platform_key and platform_key in self.PLATFORM_DEFAULTS:
                wf = os.path.join("sounds", "firearms", "weaponsounds", str(self.PLATFORM_DEFAULTS[platform_key].get("reload_sound_folder", platform_key)).lower())
            else:

                pf = str(platform_key).lower()
                wf = os.path.join("sounds", "firearms", "weaponsounds", pf)

            cat = self._categorize_40mm_round(round_info)or "he"

            def play_pattern(patterns, block = False):
                candidates =[]
                try:
                    for p in patterns:

                        candidates +=glob.glob(os.path.join(wf, p))
                        try:
                            wav_pat = p.replace('.ogg', '.wav')if '.ogg'in p else p +'.wav'
                            candidates +=glob.glob(os.path.join(wf, wav_pat))
                        except Exception:
                            pass
                except Exception:
                    pass

                if not candidates:
                    for p in patterns:
                        candidates +=glob.glob(os.path.join("sounds", "firearms", "40mm_grenade", p))
                        try:
                            wav_pat = p.replace('.ogg', '.wav')if '.ogg'in p else p +'.wav'
                            candidates +=glob.glob(os.path.join("sounds", "firearms", "40mm_grenade", wav_pat))
                        except Exception:
                            pass
                if candidates:
                    self._safe_sound_play("", random.choice(candidates), block = block)

            import threading
            import random as _r

            if cat =="apers":

                play_pattern(["apers*.ogg"], block = False)
                return

            if cat =="airburst":

                def _airburst():
                    play_pattern(["explode*.ogg"], block = False)
                t = threading.Timer(5.0, _airburst)
                t.daemon = True
                t.start()
                return

            if cat in("he", "hedp"):

                delay = _r.uniform(0.2, 1.0)
                def _do_he():

                    play_pattern(["explode*.ogg"], block = False)
                    if cat =="he":

                        time.sleep(0.08)
                        play_pattern(["explode*.ogg"], block = False)
                t = threading.Timer(delay, _do_he)
                t.daemon = True
                t.start()
                return

            if cat in("smoke", "gas"):
                delay = _r.uniform(0.5, 2.5)
                def _do_smoke():

                    play_pattern(["smoke*.ogg"], block = False)
                t = threading.Timer(delay, _do_smoke)
                t.daemon = True
                t.start()
                return

            delay = _r.uniform(0.2, 1.0)
            def _do_default():
                play_pattern(["explode*.ogg"], block = False)
            t = threading.Timer(delay, _do_default)
            t.daemon = True
            t.start()
            return
        except Exception:
            logging.exception("Error in _handle_40mm_post_fire_effects")
            return

    def _reload_underbarrel(self, accessory, save_data, combat_reload = False):

        try:
            platform = None
            if isinstance(accessory, dict):
                platform = accessory.get("platform")or accessory.get("underbarrel_platform")

            if not platform and isinstance(accessory, dict):
                try:
                    aname = str(accessory.get("name")or "").lower()
                    if "m203"in aname or "m-203"in aname or "203"in aname:
                        platform = "M203"
                except Exception:
                    pass

            try:
                ub_type = None
                if isinstance(accessory, dict):
                    ub_type = accessory.get("underbarrel_type")or accessory.get("underbarrel")

                if isinstance(ub_type, str):
                    ut = ub_type.lower()
                    if "shot"in ut or "gauge"in ut or "12"in ut:
                        defaults = {"ammo_type":"12 Gauge", "capacity":accessory.get("capacity", 1)or 1, "reload_sound_folder":"12gauge", "magazinetype":accessory.get("magazinetype", "internal")}
                    elif "40"in ut or "m203"in ut or "grenade"in ut:
                        defaults = {"ammo_type":"40mm_grenade", "capacity":accessory.get("capacity", 1)or 1, "reload_sound_folder":"m203", "magazinetype":accessory.get("magazinetype", "single")}
                    else:
                        defaults = self.PLATFORM_DEFAULTS.get(platform or "", {"ammo_type":"40mm_grenade", "capacity":1, "reload_sound_folder":"40mm_grenade"})
                else:
                    defaults = self.PLATFORM_DEFAULTS.get(platform or "", {"ammo_type":"40mm_grenade", "capacity":1, "reload_sound_folder":"40mm_grenade"})
            except Exception:
                defaults = self.PLATFORM_DEFAULTS.get(platform or "", {"ammo_type":"40mm_grenade", "capacity":1, "reload_sound_folder":"40mm_grenade"})

            capacity = defaults.get("capacity", 1)

            try:
                ub_type = None
                ub_sub = None
                if isinstance(accessory, dict):
                    ub_type = accessory.get("underbarrel_type")or accessory.get("type")
                    ub_sub = accessory.get("underbarrel_subtype")or accessory.get("underbarrel_subtype")

                is_conventional = False
                if isinstance(ub_type, str)and ub_type.lower()=="conventional":
                    is_conventional = True
                if isinstance(ub_sub, str)and "shot"in ub_sub.lower():
                    is_conventional = True

                if is_conventional:
                    mag_type = accessory.get("magazinetype")or defaults.get("magazinetype")or "internal"
                    logging.debug("Underbarrel reload: treating as conventional underbarrel(underbarrel_type=%s, underbarrel_subtype=%s, magazinetype=%s)", ub_type, ub_sub, mag_type)
                    mt_l = str(mag_type).lower()
                    if any(k in mt_l for k in("internal", "tube", "box")):
                        return self._reload_internal_magazine(accessory, save_data, mag_type)
                    if "revolver"in mt_l:
                        return self._reload_revolver(accessory, save_data)
                    return self._reload_weapon(accessory, save_data, combat_reload)
            except Exception:
                logging.exception("Failed to delegate underbarrel reload to normal handlers; falling back to custom logic")

            def _is_compatible_ammo(it, desired):
                try:
                    if not isinstance(it, dict):
                        return False
                    name =(it.get("name")or "").lower()
                    calib = it.get("caliber")
                    ammo_type_field =(it.get("ammo_type")or "").lower()
                    desired_l =(desired or "").lower()

                    if "40"in desired_l or "40mm"in desired_l or "grenade"in desired_l:
                        if "40x46"in name or "40mm"in name or "40 x 46"in name:
                            return True
                        if calib:
                            if isinstance(calib, (list, tuple)):
                                for c in calib:
                                    if isinstance(c, str)and "40"in c and "mm"in c:
                                        return True
                            elif isinstance(calib, str)and "40"in calib and "mm"in calib:
                                return True
                        if ammo_type_field =="40mm_grenade":
                            return True
                        return False

                    if "gauge"in desired_l or "12"in desired_l:
                        if "gauge"in name or "12 gauge"in name or(isinstance(calib, str)and "12"in calib.lower()and "gauge"in calib.lower()):
                            return True
                        if isinstance(calib, (list, tuple)):
                            for c in calib:
                                if isinstance(c, str)and "12"in c and "gauge"in c.lower():
                                    return True
                        if ammo_type_field and("12"in ammo_type_field or "gauge"in ammo_type_field):
                            return True
                        return False

                    if calib:
                        if isinstance(calib, (list, tuple))and any((isinstance(c, str)and desired_l in c.lower())for c in calib):
                            return True
                        if isinstance(calib, str)and desired_l in calib.lower():
                            return True
                    if desired_l and(desired_l ==ammo_type_field or desired_l in name or desired_l in(it.get("sounds")or "")):
                        return True
                except Exception:
                    pass
                return False

            found_item = None
            found_location = None

            want_mag = False
            mag_type_hint =(defaults.get("magazinetype")or "").lower()
            if "mag"in mag_type_hint or "box"in mag_type_hint or "detachable"in mag_type_hint:
                want_mag = True

            hands_list = save_data.get("hands", {}).get("items", [])
            for idx, it in enumerate(list(hands_list)):
                try:

                    if want_mag and isinstance(it, dict)and it.get("rounds"):
                        if defaults.get("magazinesystem"):
                            if str(it.get("magazinesystem")or "").lower()==str(defaults.get("magazinesystem")or "").lower():
                                found_item = it
                                found_location =("hands", idx)
                                break
                        else:
                            found_item = it
                            found_location =("hands", idx)
                            break

                    if _is_compatible_ammo(it, defaults.get("ammo_type")):
                        found_item = it
                        found_location =("hands", idx)
                        break
                except Exception:
                    continue

            if not found_item:
                for storage_idx, container in enumerate(save_data.get("storage", [])or[]):
                    try:
                        if isinstance(container, dict)and container.get("items"):
                            for idx, it in enumerate(list(container.get("items", []))):
                                try:
                                    if want_mag and isinstance(it, dict)and it.get("rounds"):
                                        if defaults.get("magazinesystem"):
                                            if str(it.get("magazinesystem")or "").lower()==str(defaults.get("magazinesystem")or "").lower():
                                                found_item = it
                                                found_location =("storage", storage_idx, idx)
                                                break
                                        else:
                                            found_item = it
                                            found_location =("storage", storage_idx, idx)
                                            break
                                    if _is_compatible_ammo(it, defaults.get("ammo_type")):
                                        found_item = it
                                        found_location =("storage", storage_idx, idx)
                                        break
                                except Exception:
                                    continue
                            if found_item:
                                break
                    except Exception:
                        pass

            if not found_item:
                return f"No {defaults.get('ammo_type', 'compatible')} rounds/magazines found in inventory!"

            try:
                if found_location and found_location[0]=="hands":
                    _, idx = found_location
                    hand_items = save_data.get("hands", {}).get("items", [])
                    if idx <len(hand_items):
                        target = hand_items[idx]

                        if isinstance(target, dict)and target.get("quantity")and isinstance(target.get("quantity"), (int, float)):
                            try:
                                target["quantity"]-=1
                                if target["quantity"]<=0:
                                    hand_items.pop(idx)
                            except Exception:
                                hand_items.pop(idx)
                        else:

                            hand_items.pop(idx)
                elif found_location and found_location[0]=="storage":
                    _, storage_idx, idx = found_location
                    storage_list = save_data.get("storage", [])
                    if storage_idx <len(storage_list):
                        container = storage_list[storage_idx]
                        if isinstance(container, dict)and container.get("items"):
                            items_list = container.get("items")or[]
                            if idx <len(items_list):
                                target = items_list[idx]
                                if isinstance(target, dict)and target.get("quantity")and isinstance(target.get("quantity"), (int, float)):
                                    try:
                                        target["quantity"]-=1
                                        if target["quantity"]<=0:
                                            items_list.pop(idx)
                                    except Exception:
                                        items_list.pop(idx)
                                else:
                                    items_list.pop(idx)
            except Exception:
                logging.exception("Failed to remove consumed underbarrel ammo/magazine from inventory")

            accessory["_ub_loaded"]= capacity
            try:
                sd_ref = save_data if isinstance(save_data, dict)else globals().get('save_data')or getattr(self, '_current_save_data', None)
                if isinstance(sd_ref, dict):
                    ts = sd_ref.setdefault('tracked_stats', {})
                    if isinstance(ts, dict):
                        ts['mags_reloaded_total']= int(ts.get('mags_reloaded_total', 0))+1
                        ts['bullets_loaded_total']= int(ts.get('bullets_loaded_total', 0))+int(capacity)
                        bh = ts.setdefault('bullets_loaded_history', [])
                        try:
                            bh.append({'weapon_id':str(accessory.get('id', 'ub')), 'count':int(capacity), 'time':time.time()})
                        except Exception:
                            pass
            except Exception:
                logging.exception('Failed updating tracked_stats after underbarrel reload')
            try:
                accessory["_ub_loaded_item"]= found_item.get("id")or found_item.get("name")
            except Exception:
                pass

            try:
                if isinstance(found_item, dict)and found_item.get("rounds"):

                    try:
                        mag_copy = dict(found_item)

                        mag_copy["rounds"]= list(found_item.get("rounds", []))
                        accessory["loaded"]= mag_copy

                        if accessory["loaded"].get("rounds"):
                            accessory["chambered"]= accessory["loaded"]["rounds"].pop(0)
                    except Exception:
                        logging.exception("Failed to attach magazine as underbarrel loaded")
                else:

                    round_cal = None
                    if isinstance(found_item, dict):
                        raw_cal = found_item.get("caliber")or defaults.get("ammo_type")
                        if isinstance(raw_cal, (list, tuple)):
                            round_cal = raw_cal[0]if raw_cal else None
                        else:
                            round_cal = raw_cal
                        round_variant = found_item.get("variant")or found_item.get("name")
                    else:
                        round_cal = defaults.get("ammo_type")
                        round_variant = None

                    single_round = {"name":f"{round_cal} | {round_variant}"if round_variant else f"{round_cal}", "caliber":round_cal, "variant":round_variant}

                    accessory["loaded"]= {"magazinetype":"underbarrel", "magazinesystem":None, "capacity":capacity, "rounds":[dict(single_round)for _ in range(capacity)]}

                    if accessory["loaded"]["rounds"]:
                        accessory["chambered"]= accessory["loaded"]["rounds"].pop(0)
            except Exception:
                logging.exception("Failed to synthesize loaded rounds for underbarrel accessory")

            try:
                acc_id = accessory.get("id")
                acc_name = accessory.get("name")
                def _set_on_matching(obj):
                    try:
                        if not isinstance(obj, dict):
                            return False
                        if obj.get("id")==acc_id or obj.get("name")==acc_name:
                            obj["_ub_loaded"]= capacity
                            try:
                                obj["_ub_loaded_item"]= found_item.get("id")or found_item.get("name")
                            except Exception:
                                pass
                            return True

                        if obj.get("accessories")and isinstance(obj.get("accessories"), list):
                            for a in(obj.get("accessories")or[]):
                                cur = a.get("current")
                                if isinstance(cur, dict)and(cur.get("id")==acc_id or cur.get("name")==acc_name):
                                    cur["_ub_loaded"]= capacity
                                    try:
                                        cur["_ub_loaded_item"]= found_item.get("id")or found_item.get("name")
                                    except Exception:
                                        pass
                                    return True

                        if obj.get("items")and isinstance(obj.get("items"), list):
                            for it in(obj.get("items")or[]):
                                if isinstance(it, dict)and(it.get("id")==acc_id or it.get("name")==acc_name):
                                    it["_ub_loaded"]= capacity
                                    try:
                                        it["_ub_loaded_item"]= found_item.get("id")or found_item.get("name")
                                    except Exception:
                                        pass
                                    return True
                    except Exception:
                        pass
                    return False

                for slot_name, eq_item in(save_data.get("equipment")or {}).items():
                    if not eq_item or not isinstance(eq_item, dict):
                        continue
                    if _set_on_matching(eq_item):
                        break

                    if eq_item.get("subslots"):
                        for sub in(eq_item.get("subslots")or[]):
                            cur = sub.get("current")
                            if isinstance(cur, dict)and(cur.get("id")==acc_id or cur.get("name")==acc_name):
                                cur["_ub_loaded"]= capacity
                                try:
                                    cur["_ub_loaded_item"]= found_item.get("id")or found_item.get("name")
                                except Exception:
                                    pass
                                raise StopIteration

                for it in list(save_data.get("hands", {}).get("items", [])):
                    if isinstance(it, dict)and(it.get("id")==acc_id or it.get("name")==acc_name):
                        it["_ub_loaded"]= capacity
                        try:
                            it["_ub_loaded_item"]= found_item.get("id")or found_item.get("name")
                        except Exception:
                            pass
                        break
                for container in list(save_data.get("storage", [])):
                    try:
                        if isinstance(container, dict)and container.get("items"):
                            for it in(container.get("items")or[]):
                                if isinstance(it, dict)and(it.get("id")==acc_id or it.get("name")==acc_name):
                                    it["_ub_loaded"]= capacity
                                    try:
                                        it["_ub_loaded_item"]= found_item.get("id")or found_item.get("name")
                                    except Exception:
                                        pass
                                    raise StopIteration
                    except StopIteration:
                        break
            except Exception:
                logging.exception("Failed to persist underbarrel loaded state to save_data")

            wf = os.path.join("sounds", "firearms", "weaponsounds", str(defaults.get("reload_sound_folder", "40mm_grenade")).lower())
            logging.debug("Underbarrel reload: platform=%s wf=%s, defaults=%s, found_item=%s, found_location=%s", platform, wf, defaults, getattr(found_item, 'get', lambda k:None)('name')if isinstance(found_item, dict)else found_item, found_location)

            open_candidates = glob.glob(os.path.join(wf, "open*.ogg"))+glob.glob(os.path.join(wf, "open*.wav"))
            open_candidates +=glob.glob(os.path.join(wf, "door*.ogg"))+glob.glob(os.path.join(wf, "door*.wav"))
            logging.debug("Underbarrel reload: open_candidates=%s", open_candidates)
            if open_candidates:
                logging.debug("Playing underbarrel open sound: %s", open_candidates[0])
                self._safe_sound_play("", random.choice(open_candidates), block = True)
            else:

                alt_wf = os.path.join("sounds", "firearms", "weaponsounds", "m203")
                alt_open = glob.glob(os.path.join(alt_wf, "open*.ogg"))+glob.glob(os.path.join(alt_wf, "open*.wav"))
                alt_open +=glob.glob(os.path.join(alt_wf, "door*.ogg"))+glob.glob(os.path.join(alt_wf, "door*.wav"))
                logging.debug("Underbarrel reload: alt_open_candidates=%s", alt_open)
                if alt_open:
                    logging.debug("Playing underbarrel open sound from alt m203: %s", alt_open[0])
                    self._safe_sound_play("", random.choice(alt_open), block = True)
                else:
                    try:
                        self._play_firearm_sound(accessory, "open")
                    except Exception:
                        pass

            time.sleep(random.uniform(1.0, 1.5))

            insert_candidates = glob.glob(os.path.join(wf, "insert*.ogg"))+glob.glob(os.path.join(wf, "insert*.wav"))
            logging.debug("Underbarrel reload: insert_candidates=%s", insert_candidates)
            if insert_candidates:
                logging.debug("Playing underbarrel insert sound: %s", insert_candidates[0])
                self._safe_sound_play("", random.choice(insert_candidates), block = True)
            else:
                alt_wf = os.path.join("sounds", "firearms", "weaponsounds", "m203")
                alt_insert = glob.glob(os.path.join(alt_wf, "insert*.ogg"))+glob.glob(os.path.join(alt_wf, "insert*.wav"))
                logging.debug("Underbarrel reload: alt_insert_candidates=%s", alt_insert)
                if alt_insert:
                    logging.debug("Playing underbarrel insert sound from alt m203: %s", alt_insert[0])
                    self._safe_sound_play("", random.choice(alt_insert), block = True)
                else:
                    try:
                        self._play_firearm_sound(accessory, "insert")
                    except Exception:
                        pass

            time.sleep(random.uniform(1.0, 1.5))

            close_candidates = glob.glob(os.path.join(wf, "close*.ogg"))+glob.glob(os.path.join(wf, "close*.wav"))
            close_candidates +=glob.glob(os.path.join(wf, "shut*.ogg"))+glob.glob(os.path.join(wf, "shut*.wav"))
            logging.debug("Underbarrel reload: close_candidates=%s", close_candidates)
            if close_candidates:
                logging.debug("Playing underbarrel close sound: %s", close_candidates[0])
                self._safe_sound_play("", random.choice(close_candidates), block = True)
            else:
                alt_wf = os.path.join("sounds", "firearms", "weaponsounds", "m203")
                alt_close = glob.glob(os.path.join(alt_wf, "close*.ogg"))+glob.glob(os.path.join(alt_wf, "close*.wav"))
                alt_close +=glob.glob(os.path.join(alt_wf, "shut*.ogg"))+glob.glob(os.path.join(alt_wf, "shut*.wav"))
                logging.debug("Underbarrel reload: alt_close_candidates=%s", alt_close)
                if alt_close:
                    logging.debug("Playing underbarrel close sound from alt m203: %s", alt_close[0])
                    self._safe_sound_play("", random.choice(alt_close), block = True)
                else:
                    try:
                        self._play_firearm_sound(accessory, "close")
                    except Exception:
                        pass

            return f"Reloaded {accessory.get('name', 'launcher')}({capacity})"
        except Exception:
            logging.exception("Failed to reload underbarrel accessory")
            return "Failed to reload underbarrel accessory"

    def _reload_internal_magazine(self, weapon, save_data, magazine_type):

        capacity = weapon.get("capacity", 10)
        current_rounds = weapon.get("rounds", [])

        compatible_ammo =[]
        caliber_list = weapon.get("caliber", [])or[]
        caliber = caliber_list[0]if caliber_list else None

        if not caliber:
            return "Weapon has no caliber defined."

        if weapon.get("infinite_ammo"):
            ammo_needed = capacity -len(current_rounds)
            ammo_loaded = 0
            for _ in range(ammo_needed):
                current_rounds.append({"name":f"{caliber} | Infinite", "caliber":caliber, "variant":"infinite"})
                ammo_loaded +=1

            had_chambered = bool(weapon.get("chambered"))
            if not had_chambered:
                rt_mag_type = str(weapon.get("magazinetype", "")or "").lower()
                rt_platform_raw = weapon.get("platform", "")or ""
                if isinstance(rt_platform_raw, (list, tuple)):
                    rt_platform_raw = rt_platform_raw[0]if rt_platform_raw else ""
                rt_platform = str(rt_platform_raw).lower()
                rt_action_raw = weapon.get("action", "")or ""
                if isinstance(rt_action_raw, (list, tuple)):
                    rt_action_raw = rt_action_raw[0]if rt_action_raw else ""
                rt_action = str(rt_action_raw).lower()
                is_pump_reload =("pump"in rt_platform or rt_action =="pump"or "pump"in rt_mag_type)

                if is_pump_reload:
                    try:
                        self._play_weapon_action_sound(weapon, "pumpforward")
                    except Exception:
                        pass
                else:
                    if not weapon.get("bolt_catch"):
                            self._play_weapon_action_sound(weapon, "boltback", block = True)

                            if weapon.get("gas_melted", False):
                                if current_rounds:
                                    weapon["chambered"]= current_rounds.pop(0)
                                self._play_weapon_action_sound(weapon, "boltforward")
                            else:
                                if current_rounds:
                                    weapon["chambered"]= current_rounds.pop(0)
                                self._play_weapon_action_sound(weapon, "boltforward")
                    else:
                        if current_rounds:
                            weapon["chambered"]= current_rounds.pop(0)
                        self._play_weapon_action_sound(weapon, "boltforward")

            weapon["rounds"]= current_rounds
        try:
            sd_ref = save_data if isinstance(save_data, dict)else globals().get('save_data')or getattr(self, '_current_save_data', None)
            if isinstance(sd_ref, dict):
                ts = sd_ref.setdefault('tracked_stats', {})
                if isinstance(ts, dict):
                    ts['mags_reloaded_total']= int(ts.get('mags_reloaded_total', 0))+1
                    try:
                        added = int(ammo_loaded)
                    except Exception:
                        added = 0
                    ts['bullets_loaded_total']= int(ts.get('bullets_loaded_total', 0))+added
                    bh = ts.setdefault('bullets_loaded_history', [])
                    try:
                        bh.append({'weapon_id':str(weapon.get('id', 'unknown')), 'count':added, 'time':time.time()})
                    except Exception:
                        pass
        except Exception:
            logging.exception('Failed updating tracked_stats after internal reload')
            return f"Internal magazine reloaded with {ammo_loaded} rounds(total: {len(current_rounds)}/{capacity})"

        for item in save_data.get("hands", {}).get("items", []):
            if item and isinstance(item, dict)and item.get("caliber")==caliber:
                qty = item.get("quantity", 0)
                if qty >0:
                    compatible_ammo.append((item, qty))

        for slot_name, eq_item in save_data.get("equipment", {}).items():
            if eq_item and "items"in eq_item:
                for item in eq_item["items"]:
                    if item and isinstance(item, dict)and item.get("caliber")==caliber:
                        qty = item.get("quantity", 0)
                        if qty >0:
                            compatible_ammo.append((item, qty))

        if not compatible_ammo:
            if weapon.get("infinite_ammo"):

                ammo_needed = capacity -len(current_rounds)
                for _ in range(ammo_needed):
                    current_rounds.append({"name":f"{caliber} | Infinite", "caliber":caliber, "variant":"infinite"})

                time.sleep(0.1)
                self._play_weapon_action_sound(weapon, "cylinderclose")
                weapon["rounds"]= current_rounds
                return f"Revolver reloaded with {ammo_needed} rounds(total: {len(current_rounds)}/{capacity})"
            return "No compatible ammunition found!"

        ammo_needed = capacity -len(current_rounds)
        ammo_loaded = 0

        def make_round_obj(ammo_item):

            variant = ammo_item.get("variant")if isinstance(ammo_item, dict)else None
            name = ammo_item.get("name")if isinstance(ammo_item, dict)else None
            if variant:
                rnd_name = f"{caliber} | {variant}"
            elif name:
                rnd_name = f"{caliber} | {name}"
            else:
                rnd_name = f"{caliber}"
            return {"name":rnd_name, "caliber":caliber, "variant":variant}

        if "tube"in magazine_type:

            while ammo_loaded <ammo_needed and compatible_ammo:
                ammo_item, qty = compatible_ammo[0]
                rounds_to_load = min(1, qty, ammo_needed -ammo_loaded)

                for _ in range(rounds_to_load):

                    self._play_weapon_action_sound(weapon, "tubeinsert", block = True)
                    current_rounds.append(make_round_obj(ammo_item))
                    ammo_loaded +=1
                    ammo_item["quantity"]-=1

                if ammo_item["quantity"]<=0:
                    compatible_ammo.pop(0)

        elif "box"in magazine_type:

            rt_action_raw = weapon.get("action", "")or ""
            if isinstance(rt_action_raw, (list, tuple)):
                rt_action_raw = rt_action_raw[0]if rt_action_raw else ""
            rt_action = str(rt_action_raw).lower()
            is_bolt_action =(rt_action =="bolt"or "bolt"in rt_action)

            boltback_performed = False

            if is_bolt_action:
                self._play_weapon_action_sound(weapon, "boltback", block = True)
                time.sleep(0.2)
                boltback_performed = True

            insert_index = 0
            while ammo_loaded <ammo_needed and compatible_ammo:
                ammo_item, qty = compatible_ammo[0]
                rounds_to_load = min(1, qty, ammo_needed -ammo_loaded)

                for _ in range(rounds_to_load):
                    sound_action = f"bulletinsert{insert_index %2}"

                    self._play_weapon_action_sound(weapon, sound_action, block = False)
                    time.sleep(0.5)
                    current_rounds.append(make_round_obj(ammo_item))
                    ammo_loaded +=1
                    insert_index +=1
                    ammo_item["quantity"]-=1

                if ammo_item["quantity"]<=0:
                    compatible_ammo.pop(0)

        if ammo_loaded >0:

            had_chambered = bool(weapon.get("chambered"))
            if not had_chambered:

                rt_mag_type = str(weapon.get("magazinetype", "")or "").lower()
                rt_platform_raw = weapon.get("platform", "")or ""
                if isinstance(rt_platform_raw, (list, tuple)):
                    rt_platform_raw = rt_platform_raw[0]if rt_platform_raw else ""
                rt_platform = str(rt_platform_raw).lower()
                rt_action_raw = weapon.get("action", "")or ""
                if isinstance(rt_action_raw, (list, tuple)):
                    rt_action_raw = rt_action_raw[0]if rt_action_raw else ""
                rt_action = str(rt_action_raw).lower()
                is_pump_reload =("pump"in rt_platform or rt_action =="pump"or "pump"in rt_mag_type)

                if is_pump_reload:

                    cycle_result = "reloaded(pump required to chamber)"

                    try:
                        self._play_weapon_action_sound(weapon, "pumpforward")
                    except Exception:
                        pass
                else:

                    if not weapon.get("bolt_catch"):

                        if not boltback_performed:
                            self._play_weapon_action_sound(weapon, "boltback", block = True)

                        if weapon.get("gas_melted", False):
                            if current_rounds:
                                weapon["chambered"]= current_rounds.pop(0)
                            self._play_weapon_action_sound(weapon, "boltforward")
                        else:
                            if current_rounds:
                                weapon["chambered"]= current_rounds.pop(0)
                            self._play_weapon_action_sound(weapon, "boltforward")
                    else:

                        if current_rounds:
                            weapon["chambered"]= current_rounds.pop(0)
                        self._play_weapon_action_sound(weapon, "boltforward")

        weapon["rounds"]= current_rounds
        try:
            sd_ref = save_data if isinstance(save_data, dict)else globals().get('save_data')or getattr(self, '_current_save_data', None)
            if isinstance(sd_ref, dict):
                ts = sd_ref.setdefault('tracked_stats', {})
                if isinstance(ts, dict):
                    ts['mags_reloaded_total']= int(ts.get('mags_reloaded_total', 0))+1
                    try:
                        added = int(ammo_loaded)
                    except Exception:
                        added = 0
                    ts['bullets_loaded_total']= int(ts.get('bullets_loaded_total', 0))+added
                    bh = ts.setdefault('bullets_loaded_history', [])
                    try:
                        bh.append({'weapon_id':str(weapon.get('id', 'unknown')), 'count':added, 'time':time.time()})
                    except Exception:
                        pass
        except Exception:
            logging.exception('Failed updating tracked_stats after internal reload')
        return f"Internal magazine reloaded with {ammo_loaded} rounds(total: {len(current_rounds)}/{capacity})"

    def _reload_revolver(self, weapon, save_data):

        capacity = weapon.get("capacity", 6)
        current_rounds = weapon.get("rounds", [])

        compatible_ammo =[]
        caliber_list = weapon.get("caliber", [])or[]
        caliber = caliber_list[0]if caliber_list else None

        if not caliber:
            return "Weapon has no caliber defined."

        for item in save_data.get("hands", {}).get("items", []):
            if item and isinstance(item, dict)and item.get("caliber")==caliber:
                qty = item.get("quantity", 0)
                if qty >0:
                    compatible_ammo.append((item, qty))

        for slot_name, eq_item in save_data.get("equipment", {}).items():
            if eq_item and "items"in eq_item:
                for item in eq_item["items"]:
                    if item and isinstance(item, dict)and item.get("caliber")==caliber:
                        qty = item.get("quantity", 0)
                        if qty >0:
                            compatible_ammo.append((item, qty))

        if not compatible_ammo:
            return "No compatible ammunition found!"

        ammo_needed = capacity -len(current_rounds)
        ammo_loaded = 0

        self._play_weapon_action_sound(weapon, "cylinderopen", block = True)
        time.sleep(0.2)

        self._play_weapon_action_sound(weapon, "cylinderrelease", block = True)
        time.sleep(0.15)
        current_rounds.clear()

        insert_index = 0
        while ammo_loaded <ammo_needed and compatible_ammo:
            ammo_item, qty = compatible_ammo[0]
            rounds_to_load = min(1, qty, ammo_needed -ammo_loaded)

            for _ in range(rounds_to_load):

                sound_action = f"bulletinsert{insert_index %2}"

                self._play_weapon_action_sound(weapon, sound_action, block = False)
                time.sleep(0.5)
                current_rounds.append(f"{caliber}")
                ammo_loaded +=1
                insert_index +=1
                ammo_item["quantity"]-=1

            if ammo_item["quantity"]<=0:
                compatible_ammo.pop(0)

        time.sleep(0.1)
        self._play_weapon_action_sound(weapon, "cylinderclose")
        time.sleep(0.1)

        weapon["rounds"]= current_rounds
        try:
            sd_ref = save_data if isinstance(save_data, dict)else globals().get('save_data')or getattr(self, '_current_save_data', None)
            if isinstance(sd_ref, dict):
                ts = sd_ref.setdefault('tracked_stats', {})
                if isinstance(ts, dict):
                    ts['mags_reloaded_total']= int(ts.get('mags_reloaded_total', 0))+1
                    try:
                        added = int(ammo_loaded)
                    except Exception:
                        added = 0
                    ts['bullets_loaded_total']= int(ts.get('bullets_loaded_total', 0))+added
                    bh = ts.setdefault('bullets_loaded_history', [])
                    try:
                        bh.append({'weapon_id':str(weapon.get('id', 'unknown')), 'count':added, 'time':time.time()})
                    except Exception:
                        pass
        except Exception:
            logging.exception('Failed updating tracked_stats after revolver reload')
        return f"Revolver reloaded with {ammo_loaded} rounds(total: {len(current_rounds)}/{capacity})"

    def _reload_cylinder(self, weapon, save_data):

        capacity = weapon.get("capacity", 6)
        current_rounds = weapon.get("rounds", [])

        compatible_ammo =[]
        caliber_list = weapon.get("caliber", [])or[]
        caliber = caliber_list[0]if caliber_list else None

        if not caliber:
            return "Weapon has no caliber defined."

        for item in save_data.get("hands", {}).get("items", []):
            if item and isinstance(item, dict)and item.get("caliber")==caliber:
                qty = item.get("quantity", 0)
                if qty >0:
                    compatible_ammo.append((item, qty))

        for slot_name, eq_item in save_data.get("equipment", {}).items():
            if eq_item and "items"in eq_item:
                for item in eq_item["items"]:
                    if item and isinstance(item, dict)and item.get("caliber")==caliber:
                        qty = item.get("quantity", 0)
                        if qty >0:
                            compatible_ammo.append((item, qty))

        if not compatible_ammo:
            return "No compatible ammunition found!"

        ammo_needed = capacity -len(current_rounds)
        ammo_loaded = 0

        self._play_cylinder_sound(weapon, "cylinderopen", block = True)
        time.sleep(0.2)

        self._play_cylinder_sound(weapon, "cylinderrelease", block = True)
        time.sleep(0.15)
        current_rounds.clear()

        insert_index = 0
        while ammo_loaded <ammo_needed and compatible_ammo:
            ammo_item, qty = compatible_ammo[0]
            rounds_to_load = min(1, qty, ammo_needed -ammo_loaded)

            for _ in range(rounds_to_load):
                sound_action = f"bulletinsert{insert_index %2}"
                self._play_cylinder_sound(weapon, sound_action, block = False)
                time.sleep(0.5)
                current_rounds.append(f"{caliber}")
                ammo_loaded +=1
                insert_index +=1
                ammo_item["quantity"]-=1

            if ammo_item["quantity"]<=0:
                compatible_ammo.pop(0)

        time.sleep(0.1)
        self._play_cylinder_sound(weapon, "cylinderclose")
        time.sleep(0.1)

        weapon["rounds"]= current_rounds

        action = weapon.get("action", "")
        if isinstance(action, (list, tuple)):
            action = action[0]if action else ""
        action = str(action).lower()
        if action =="single":
            time.sleep(0.1)
            self._play_cylinder_sound(weapon, "hammerdown")

        try:
            sd_ref = save_data if isinstance(save_data, dict)else globals().get('save_data')or getattr(self, '_current_save_data', None)
            if isinstance(sd_ref, dict):
                ts = sd_ref.setdefault('tracked_stats', {})
                if isinstance(ts, dict):
                    ts['mags_reloaded_total']= int(ts.get('mags_reloaded_total', 0))+1
                    try:
                        added = int(ammo_loaded)
                    except Exception:
                        added = 0
                    ts['bullets_loaded_total']= int(ts.get('bullets_loaded_total', 0))+added
                    bh = ts.setdefault('bullets_loaded_history', [])
                    try:
                        bh.append({'weapon_id':str(weapon.get('id', 'unknown')), 'count':added, 'time':time.time()})
                    except Exception:
                        pass
        except Exception:
            logging.exception('Failed updating tracked_stats after cylinder reload')
        return f"Cylinder reloaded with {ammo_loaded} rounds(total: {len(current_rounds)}/{capacity})"

    def _play_cylinder_sound(self, weapon, action_type, block = False):

        try:
            platform = str(weapon.get("platform", "")or "").lower()
            sound_folder = weapon.get("sounds")or weapon.get("sound_folder")or weapon.get("fire_sounds")or weapon.get("reload_sounds")

            candidates =[]

            if sound_folder:
                wf = os.path.join("sounds", "firearms", "weaponsounds", str(sound_folder).lower())
                candidates = glob.glob(os.path.join(wf, f"{action_type}*.ogg"))+glob.glob(os.path.join(wf, f"{action_type}*.wav"))

            if not candidates and platform:
                wf = os.path.join("sounds", "firearms", "weaponsounds", platform)
                candidates = glob.glob(os.path.join(wf, f"{action_type}*.ogg"))+glob.glob(os.path.join(wf, f"{action_type}*.wav"))

            if not candidates:
                uni = os.path.join("sounds", "firearms", "universal")
                candidates = glob.glob(os.path.join(uni, f"{action_type}*.ogg"))+glob.glob(os.path.join(uni, f"{action_type}*.wav"))

            if candidates:
                sound_file = random.choice(candidates)
                logging.debug("_play_cylinder_sound: %s -> %s", action_type, sound_file)
                self._safe_sound_play("", sound_file, block = block)
            else:
                logging.debug("_play_cylinder_sound: no sound found for %s", action_type)
        except Exception as e:
            logging.error(f"Error playing cylinder sound: {e}")

    def _clean_weapon(self, weapon, combat_state):

        weapon_id = str(weapon.get("id"))
        logging.info("_clean_weapon start: id=%s name=%s", weapon_id, weapon.get("name", "Unknown"))

        self._play_weapon_action_sound(weapon, "cleaning")

        if "barrel_cleanliness"not in combat_state:
            combat_state["barrel_cleanliness"]= {}

        combat_state["barrel_cleanliness"][weapon_id]= 100

        try:
            if weapon.get("gas_melted", False):
                weapon["gas_melted"]= False
                logging.info("Weapon %s gas system repaired by cleaning", weapon.get("name", weapon_id))
        except Exception:
            pass

        return "Weapon cleaned and maintained."

    def _cycle_bolt(self, weapon):

        logging.info("_cycle_bolt start: name=%s", weapon.get("name", "Unknown"))

        actions = weapon.get("action", [])
        if "Bolt"not in actions:
            return "This weapon does not have a bolt to cycle."

        chambered = weapon.get("chambered")
        if chambered:
            logging.info("Bolt cycle: ejecting chambered round")
            self._play_weapon_action_sound(weapon, "boltback", block = True)
            self._play_weapon_action_sound(weapon, "shelleject")
            time.sleep(0.2)

            weapon["chambered"]= None
            message = "Ejected chambered round."
        else:
            message = ""

        loaded_mag = weapon.get("loaded")

        if not loaded_mag:
            self._play_weapon_action_sound(weapon, "boltback", block = True)
            self._play_weapon_action_sound(weapon, "boltforward")
            return message +"No magazine loaded - bolt cycled but no round chambered."

        rounds = loaded_mag.get("rounds", [])
        if not rounds:
            self._play_weapon_action_sound(weapon, "boltback", block = True)
            self._play_weapon_action_sound(weapon, "boltforward")
            return message +"Magazine empty - bolt cycled but no round chambered."

        self._play_weapon_action_sound(weapon, "boltback", block = True)
        next_round = rounds.pop(0)
        weapon["chambered"]= next_round
        self._play_weapon_action_sound(weapon, "boltforward")

        return message +f"Bolt cycled - chambered {next_round}."

    def _show_magazine_selection_menu(self, weapon, save_data, table_data, current_weapon_state, update_callback):

        magazine_system = weapon.get("magazinesystem")
        platform = str(weapon.get("platform", "")or "").lower()
        mag_type_weapon = str(weapon.get("magazinetype", "")or "").lower()

        is_belt_weapon =("belt"in mag_type_weapon)or("m249"in platform)
        sub_mag_type = str(weapon.get("submagazinetype", "")or "").lower()

        compatible_mags =[]

        def mag_is_compatible(mag):

            if not mag or not isinstance(mag, dict):
                return False

            try:
                if mag.get("firearm")is True:
                    return False
            except Exception:
                pass

            compat = False

            try:
                if magazine_system and mag.get("magazinesystem")==magazine_system:
                    compat = True
            except Exception:
                pass

            try:
                mag_type = str(mag.get("magazinetype", "")or "").lower()
                if is_belt_weapon and("belt"in mag_type):
                    compat = True
            except Exception:
                pass

            try:
                if sub_mag_type and mag_type ==sub_mag_type:
                    compat = True
            except Exception:
                pass

            try:
                if is_belt_weapon and weapon.get("beltlink")and mag.get("beltlink")and str(mag.get("beltlink")).lower()==str(weapon.get("beltlink")).lower():
                    compat = True
            except Exception:
                pass

            if not compat:
                return False

            try:
                dev_cal_var = None
                if isinstance(current_weapon_state, dict):
                    dev_cal_var = current_weapon_state.get("dev_caliber_var")
                if dev_cal_var and hasattr(dev_cal_var, 'get'):
                    sel_cal = dev_cal_var.get()
                    if sel_cal:
                        def _mag_matches_cal(m, c):
                            try:
                                mcal = m.get("caliber")
                                if isinstance(mcal, (list, tuple)):
                                    for e in mcal:
                                        try:
                                            if str(e)==str(c):
                                                return True
                                        except Exception:
                                            pass
                                elif isinstance(mcal, str):
                                    if str(mcal)==str(c):
                                        return True

                                rds = m.get("rounds")
                                if isinstance(rds, list)and rds:
                                    first = rds[0]
                                    if isinstance(first, dict):
                                        if str(first.get("caliber"))==str(c):
                                            return True
                                    elif isinstance(first, str):
                                        if str(c)in first:
                                            return True
                            except Exception:
                                pass
                            return False

                        if not _mag_matches_cal(mag, sel_cal):
                            return False
            except Exception:
                pass

            return True

        if weapon.get("has_magazine_in_pool")is not False:
            for item in save_data.get("hands", {}).get("items", []):
                if mag_is_compatible(item)and len(item.get("rounds", []))>0:
                    compatible_mags.append(("hands", item))

        for slot_name, item in save_data.get("equipment", {}).items():
                if item:

                    if "items"in item and isinstance(item["items"], list):
                        for mag in item["items"]:
                            if mag_is_compatible(mag)and len(mag.get("rounds", []))>0:
                                compatible_mags.append(("equipment", mag))

                    if "subslots"in item:
                        for subslot in item["subslots"]:
                            if subslot.get("current"):
                                curr = subslot["current"]
                                if "items"in curr and isinstance(curr["items"], list):
                                    for mag in curr["items"]:
                                        if mag_is_compatible(mag)and len(mag.get("rounds", []))>0:
                                            compatible_mags.append(("equipment", mag))

        if not compatible_mags:
            if is_belt_weapon:
                self._popup_show_info("Magazine", "No belts or compatible magazines in inventory for this weapon!")
            else:
                self._popup_show_info("Magazine", f"No compatible magazines in inventory for {magazine_system} system!")
            return

        popup = customtkinter.CTkToplevel(self.root)
        popup.title("Select Magazine")
        popup.transient(self.root)
        self._center_popup_on_window(popup, 500, 450)

        label = customtkinter.CTkLabel(
        popup,
        text = f"Select a magazine for {weapon.get('name')}:",
        font = customtkinter.CTkFont(size = 13),
        wraplength = 450
        )
        label.pack(pady = 10, padx = 20)

        scroll_frame = customtkinter.CTkScrollableFrame(popup, fg_color = "transparent")
        scroll_frame.pack(fill = "both", expand = True, padx = 10, pady = 10)

        selected_mag = customtkinter.StringVar(value = "0")

        for idx, (location, mag_item)in enumerate(compatible_mags):
            mag_name = mag_item.get("name", "Unknown Magazine")
            capacity = mag_item.get("capacity", "?")
            rounds = len(mag_item.get("rounds", []))

            mag_cal_display = None
            try:
                mag_cals =[]
                rds = mag_item.get('rounds')if isinstance(mag_item, dict)else[]
                if isinstance(rds, list)and rds:

                    seen =[]
                    for first in rds:
                        try:
                            if isinstance(first, dict):
                                fc = first.get('caliber')
                                if isinstance(fc, (list, tuple)):
                                    for x in fc:
                                        if x and str(x)not in seen:
                                            seen.append(str(x))
                                elif isinstance(fc, str)and fc and str(fc)not in seen:
                                    seen.append(str(fc))
                            elif isinstance(first, str)and first:
                                calpart = first.split('|', 1)[0].strip()
                                if calpart and calpart not in seen:
                                    seen.append(calpart)
                        except Exception:
                            continue
                    if seen:
                        mag_cals = seen

                if mag_cals:
                    mag_cal_display = ", ".join(mag_cals)
            except Exception:
                mag_cal_display = None

            radio_frame = customtkinter.CTkFrame(scroll_frame, fg_color = "transparent")
            radio_frame.pack(fill = "x", pady = 5, padx = 5)

            radio_text = f"{mag_name}({rounds}/{capacity})"
            if mag_cal_display:
                radio_text +=f" - {mag_cal_display}"
            radio_text +=f" - from {location}"
            radio = customtkinter.CTkRadioButton(
            radio_frame,
            text = radio_text,
            variable = selected_mag,
            value = str(idx),
            font = customtkinter.CTkFont(size = 11)
            )
            radio.pack(anchor = "w")

        def give_magazine():
            if not selected_mag.get():
                self._popup_show_info("Magazine", "Please select a magazine!")
                return

            idx = int(selected_mag.get())
            location, mag_item = compatible_mags[idx]

            try:
                wpn_cal_raw = weapon.get('caliber')or[]
                wpn_calibers = set()
                if isinstance(wpn_cal_raw, (list, tuple)):
                    for c in wpn_cal_raw:
                        if c:
                            wpn_calibers.add(str(c).lower().strip())
                elif isinstance(wpn_cal_raw, str)and wpn_cal_raw:
                    wpn_calibers.add(wpn_cal_raw.lower().strip())

                mag_rounds = mag_item.get('rounds', [])if isinstance(mag_item, dict)else[]
                if wpn_calibers and mag_rounds:
                    for rd in mag_rounds:
                        try:
                            rd_cals = set()
                            if isinstance(rd, dict):
                                rcal = rd.get('caliber')
                                if isinstance(rcal, (list, tuple)):
                                    for rc in rcal:
                                        if rc:
                                            rd_cals.add(str(rc).lower().strip())
                                elif isinstance(rcal, str)and rcal:
                                    rd_cals.add(rcal.lower().strip())
                            elif isinstance(rd, str)and rd:
                                if '|'in rd:
                                    rd_cal_part = rd.split('|', 1)[0].strip()
                                else:
                                    rd_cal_part = rd.strip()
                                if rd_cal_part:
                                    rd_cals.add(rd_cal_part.lower().strip())

                            if rd_cals and not(rd_cals &wpn_calibers):
                                self._popup_show_info("Magazine Incompatible", f"Cannot insert magazine: it contains rounds of an incompatible caliber({next(iter(rd_cals))}).", sound = "error")
                                return
                        except Exception:
                            self._popup_show_info("Magazine Incompatible", "Cannot insert magazine: failed to validate contained rounds.", sound = "error")
                            return
            except Exception:
                pass

            import time

            current_mag = weapon.get("loaded")
            chambered = weapon.get("chambered")
            is_gun_empty = not chambered and(not current_mag or not current_mag.get("rounds", []))

            if current_mag:
                try:
                    self._play_weapon_action_sound(weapon, "magout")
                except Exception:
                    pass

                time.sleep(random.uniform(1.0, 1.5))

                try:
                    self._safe_sound_play("", "sounds/firearms/universal/pouchin.wav")
                except Exception:
                    pass
                time.sleep(random.uniform(1.0, 1.5))

            try:
                self._safe_sound_play("", "sounds/firearms/universal/pouchout.ogg")
            except Exception:
                pass
            time.sleep(random.uniform(1.0, 1.5))

            mag_type = weapon.get("magazinetype", "").lower()
            platform = weapon.get("platform", "").lower()
            if not any(k in mag_type for k in("internal", "tube", "cylinder"))and "revolver"not in platform:
                try:
                    self._play_weapon_action_sound(weapon, "magin")
                except Exception:
                    pass

                time.sleep(random.uniform(0.5, 1.0))

            rt_mag_type = str(weapon.get("magazinetype", "")or "").lower()
            rt_platform_raw = weapon.get("platform", "")or ""
            if isinstance(rt_platform_raw, (list, tuple)):
                rt_platform_raw = rt_platform_raw[0]if rt_platform_raw else ""
            rt_platform = str(rt_platform_raw).lower()
            rt_action_raw = weapon.get("action", "")or ""
            if isinstance(rt_action_raw, (list, tuple)):
                rt_action_raw = rt_action_raw[0]if rt_action_raw else ""
            rt_action = str(rt_action_raw).lower()
            is_pump_reload_local =("pump"in rt_platform or rt_action =="pump"or "pump"in rt_mag_type)

            if is_gun_empty:
                if is_pump_reload_local:
                    try:
                        self._play_weapon_action_sound(weapon, "pumpback", block = True)
                    except Exception:
                        pass
                    try:
                        self._play_weapon_action_sound(weapon, "pumpforward")
                    except Exception:
                        pass
                elif not weapon.get("bolt_catch"):
                    try:
                        self._play_weapon_action_sound(weapon, "boltback", block = True)
                    except Exception:
                        pass
                    try:
                        self._play_weapon_action_sound(weapon, "boltforward")
                    except Exception:
                        pass
                else:

                    try:
                        self._play_weapon_action_sound(weapon, "boltforward")
                    except Exception:
                        pass

            if current_mag and not weapon.get("infinite_ammo"):

                save_data.get("hands", {}).get("items", []).append(current_mag)

            if not weapon.get("infinite_ammo"):
                weapon["loaded"]= mag_item
                weapon["chambered"]= None
            else:
                weapon["chambered"]= None

            if not weapon.get("infinite_ammo")and is_gun_empty and mag_item.get("rounds", [])and not is_pump_reload_local:
                weapon["chambered"]= mag_item["rounds"].pop(0)
            elif weapon.get("infinite_ammo")and is_gun_empty and not is_pump_reload_local:
                caliber_list = weapon.get("caliber", [])or["Unknown"]
                caliber = caliber_list[0]
                weapon["chambered"]= {"name":f"{caliber} | Infinite", "caliber":caliber, "variant":"infinite"}

            if not weapon.get("infinite_ammo"):
                if location =="hands":
                    if mag_item in save_data.get("hands", {}).get("items", []):
                        save_data["hands"]["items"].remove(mag_item)
                elif location =="equipment":

                    for slot_name, item in save_data.get("equipment", {}).items():
                        if item:
                            if "items"in item and isinstance(item["items"], list):
                                if mag_item in item["items"]:
                                    item["items"].remove(mag_item)
                            if "subslots"in item:
                                for subslot in item["subslots"]:
                                    if subslot.get("current"):
                                        curr = subslot["current"]
                                        if "items"in curr and isinstance(curr["items"], list):
                                            if mag_item in curr["items"]:
                                                curr["items"].remove(mag_item)

            popup.destroy()
            mag_name = mag_item.get("name", "magazine")
            rounds = len(mag_item.get("rounds", []))

            chambered_info = " +1 in chamber"if is_gun_empty and weapon.get("chambered")else ""
            self._popup_show_info("Magazine", f"Loaded {mag_name}({rounds}{chambered_info} rounds)!")
            update_callback()

        button_frame = customtkinter.CTkFrame(popup, fg_color = "transparent")
        button_frame.pack(fill = "x", padx = 10, pady = 10)

        load_btn = customtkinter.CTkButton(
        button_frame,
        text = "Load Magazine",
        command = give_magazine,
        width = 150,
        height = 40
        )
        load_btn.pack(side = "left", padx = 5)

        cancel_btn = customtkinter.CTkButton(
        button_frame,
        text = "Cancel",
        command = popup.destroy,
        width = 150,
        height = 40,
        fg_color = "#444444",
        hover_color = "#555555"
        )
        cancel_btn.pack(side = "left", padx = 5)

        popup.update_idletasks()
        popup_width = popup.winfo_reqwidth()
        popup_height = popup.winfo_reqheight()
        screen_width = popup.winfo_screenwidth()
        screen_height = popup.winfo_screenheight()
        x =(screen_width //2)-(popup_width //2)
        y =(screen_height //2)-(popup_height //2)
        popup.geometry(f"+{x}+{y}")
        popup.deiconify()
        popup.grab_set()
        popup.lift()
        self._safe_focus(popup)

    def _check_for_reloader_item(self, save_data):

        for slot_name, item in save_data.get("equipment", {}).items():

            if isinstance(item, list):
                for sub_item in item:
                    if sub_item and isinstance(sub_item, dict)and sub_item.get("reloader"):
                        return True
                    if sub_item and isinstance(sub_item, dict)and "subslots"in sub_item:
                        for subslot in sub_item.get("subslots", []):
                            if subslot.get("current")and subslot["current"].get("reloader"):
                                return True
                continue

            if item and isinstance(item, dict)and item.get("reloader"):
                return True

            if item and isinstance(item, dict)and "subslots"in item:
                for subslot in item["subslots"]:
                    if subslot.get("current")and subslot["current"].get("reloader"):
                        return True

        for item in save_data.get("hands", {}).get("items", []):
            if item and isinstance(item, dict)and item.get("reloader"):
                return True

        return False

    def _reload_magazine(self, magazine, save_data, max_rounds = None, has_ammo_in_pool = True, on_complete = None, is_loaded_in_weapon = False, weapon = None, variant_filter = None):

        logging.info("_reload_magazine start: capacity=%s, variant_filter=%s", magazine.get("capacity"), variant_filter)

        capacity = magazine.get("capacity", 0)
        current_rounds = magazine.get("rounds", [])
        rounds_to_add = capacity -len(current_rounds)
        if max_rounds is not None:
            try:
                rounds_to_add = min(int(max_rounds), rounds_to_add)
            except Exception:
                pass
        initial_to_add = rounds_to_add

        if rounds_to_add <=0:
            msg = f"Magazine already has {len(current_rounds)} rounds(capacity: {capacity})"
            if on_complete:
                on_complete(msg)
            return msg

        has_reloader = self._check_for_reloader_item(save_data)

        if not has_ammo_in_pool:
            msg = "No loose ammo available in pool to reload this magazine."
            if on_complete:
                on_complete(msg)
            return msg

        is_internal_box = False
        if weapon:
            mag_type = str(weapon.get("magazinetype", "")or "").lower()
            is_internal_box = "internal"in mag_type and "box"in mag_type

        rounds_collected =[]

        def round_matches_filter(r):

            if variant_filter is None:
                return True
            if not isinstance(r, dict):
                return True

            r_variant = r.get("variant")or r.get("name")or "Unknown"
            return str(r_variant).lower()==str(variant_filter).lower()

        try:
            hands_items = save_data.get("hands", {}).get("items", [])
            for hi in range(len(hands_items)-1, -1, -1):
                if rounds_to_add <=0:
                    break
                item = hands_items[hi]
                if not isinstance(item, dict):
                    continue
                if item is magazine:
                    continue

                if item.get('magazinesystem')or item.get('capacity'):
                    continue

                if isinstance(item.get("rounds"), list)and item.get("rounds"):

                    rounds_to_take =[]
                    remaining_rounds =[]
                    for r in item["rounds"]:
                        if round_matches_filter(r)and len(rounds_to_take)<rounds_to_add:
                            rounds_to_take.append(r)
                        else:
                            remaining_rounds.append(r)

                    for r in rounds_to_take:
                        rounds_collected.append(r)
                        rounds_to_add -=1

                    item["rounds"]= remaining_rounds
                    if not item.get("rounds"):
                        try:
                            hands_items.pop(hi)
                        except Exception:
                            pass
                    continue

                if variant_filter is not None:
                    item_variant = item.get("variant")or item.get("name")or "Unknown"
                    if str(item_variant).lower()!=str(variant_filter).lower():
                        continue

                qty = int(item.get("quantity")or 0)if isinstance(item.get("quantity"), (int, float))else 0
                if qty >0 and("caliber"in item or "name"in item):
                    take = min(rounds_to_add, qty)
                    for _ in range(take):
                        r = {k:v for k, v in item.items()if k !="quantity"}
                        rounds_collected.append(r)
                        rounds_to_add -=1
                    item["quantity"]= qty -take
                    if item["quantity"]<=0:
                        try:
                            hands_items.pop(hi)
                        except Exception:
                            pass
                    continue

                if item.get("caliber"):
                    try:
                        hands_items.pop(hi)
                        rounds_collected.append(item)
                        rounds_to_add -=1
                    except Exception:
                        pass
        except Exception:
            logging.exception("Failed to pull rounds from hands during reload")

        loaded_from_hands = len(rounds_collected)

        if loaded_from_hands <=0:
            msg = "No loose rounds available in hands to reload the magazine"
            if on_complete:
                on_complete(msg)
            return msg

        popup = customtkinter.CTkToplevel(self.root)
        popup.title("Reloading Magazine")
        popup.transient(self.root)
        self._center_popup_on_window(popup, 400, 150)
        popup.grab_set()

        status_text = "Using reloader..."if has_reloader else "Loading rounds manually..."
        status_label = customtkinter.CTkLabel(
        popup,
        text = status_text,
        font = customtkinter.CTkFont(size = 14)
        )
        status_label.pack(pady =(20, 10))

        progress_bar = customtkinter.CTkProgressBar(popup, width = 350)
        progress_bar.pack(pady = 10)
        progress_bar.set(0)

        count_label = customtkinter.CTkLabel(
        popup,
        text = f"0 / {loaded_from_hands} rounds",
        font = customtkinter.CTkFont(size = 12)
        )
        count_label.pack(pady = 5)

        reload_state = {
        "index":0,
        "reloader_channel":None,
        "reloader_sound":None
        }

        def play_insert_sound():
            insert_sound = f"bulletinsert{random.randint(0, 1)}"
            try:
                sound_path = os.path.join("sounds", "firearms", "universal", f"{insert_sound}.ogg")
                if os.path.exists(sound_path):
                    sound = pygame.mixer.Sound(sound_path)
                    channel = pygame.mixer.find_channel()
                    if channel:
                        channel.play(sound)
            except Exception as e:
                logging.warning(f"Failed to play {insert_sound}: {e}")

        def start_reloader_sound():
            reloader_sound_path = os.path.join("sounds", "firearms", "universal", "reloaderloop.ogg")
            if os.path.exists(reloader_sound_path):
                channel = pygame.mixer.find_channel()
                if channel:
                    try:
                        sound = pygame.mixer.Sound(reloader_sound_path)
                        channel.play(sound, loops = -1)
                        reload_state["reloader_channel"]= channel
                        reload_state["reloader_sound"]= sound
                    except Exception as e:
                        logging.warning(f"Failed to play reloader sound: {e}")

        def play_reloader_insert_sound():

            try:
                sound_path = os.path.join("sounds", "firearms", "universal", "reloaderroundinsert.ogg")
                if os.path.exists(sound_path):
                    sound = pygame.mixer.Sound(sound_path)
                    channel = pygame.mixer.find_channel()
                    if channel:
                        channel.play(sound)

                        return int(sound.get_length()*1000)
            except Exception as e:
                logging.warning(f"Failed to play reloader insert sound: {e}")
            return 0

        def play_magout_sound():

            if weapon:
                try:
                    self._play_weapon_action_sound(weapon, "magout")

                    return 500
                except Exception as e:
                    logging.warning(f"Failed to play magout sound: {e}")
            return 0

        def play_magin_sound():

            if weapon:
                try:
                    self._play_weapon_action_sound(weapon, "magin")
                except Exception as e:
                    logging.warning(f"Failed to play magin sound: {e}")

        def stop_reloader_sound():
            if reload_state["reloader_channel"]:
                try:
                    reload_state["reloader_channel"].stop()
                except Exception:
                    pass
                reload_state["reloader_channel"]= None

        def reload_step():
            idx = reload_state["index"]

            if idx >=loaded_from_hands:

                stop_reloader_sound()
                magazine["rounds"]= current_rounds

                if has_reloader:
                    message = f"Reloaded {loaded_from_hands} rounds using reloader(total: {len(current_rounds)}/{capacity})"
                else:
                    message = f"Manually reloaded {loaded_from_hands} rounds(total: {len(current_rounds)}/{capacity})"

                logging.info(message)

                if is_loaded_in_weapon:
                    play_magin_sound()

                try:
                    popup.destroy()
                except Exception:
                    pass

                if on_complete:
                    on_complete(message)
                return

            current_rounds.append(rounds_collected[idx])
            reload_state["index"]+=1

            progress = reload_state["index"]/loaded_from_hands
            progress_bar.set(progress)
            count_label.configure(text = f"{reload_state['index']} / {loaded_from_hands} rounds")

            play_insert_sound()

            if has_reloader:
                delay = 100
            else:
                delay = 500

            popup.after(delay, reload_step)

        initial_delay = 100

        is_bolt_action_reload = False
        try:
            if weapon:
                rt_action_raw = weapon.get("action", "")or ""
                if isinstance(rt_action_raw, (list, tuple)):
                    rt_action_raw = rt_action_raw[0]if rt_action_raw else ""
                rt_action = str(rt_action_raw).lower()
                is_bolt_action_reload =(rt_action =="bolt"or "bolt"in rt_action)
        except Exception:
            is_bolt_action_reload = False

        if is_loaded_in_weapon:
            magout_duration = play_magout_sound()
            initial_delay +=magout_duration

        if weapon and is_bolt_action_reload and not is_internal_box:
            try:
                self._play_weapon_action_sound(weapon, "boltback", block = True)
                time.sleep(0.12)
            except Exception:
                pass

        def play_boltback_for_internal(callback):

            if is_internal_box and weapon:
                try:

                    platform = weapon.get("platform", "").lower()
                    wf = os.path.join("sounds", "firearms", "weaponsounds", platform)if platform else None
                    sound_file = None
                    duration_ms = 800

                    if wf:
                        candidates = glob.glob(os.path.join(wf, "boltback*.ogg"))+glob.glob(os.path.join(wf, "boltback*.wav"))
                        if candidates:
                            sound_file = random.choice(candidates)

                    if sound_file and os.path.exists(sound_file):
                        try:
                            sound = pygame.mixer.Sound(sound_file)
                            duration_ms = int(sound.get_length()*1000)+100
                            channel = pygame.mixer.find_channel()
                            if channel:
                                channel.play(sound)
                        except Exception:
                            pass
                    else:

                        self._play_weapon_action_sound(weapon, "boltback", block = False)

                    popup.after(duration_ms, callback)
                    return
                except Exception:
                    pass

            callback()

        if has_reloader:

            insert_duration = play_reloader_insert_sound()

            def start_reloader_after_insert():
                start_reloader_sound()
                popup.after(100, reload_step)

            popup.after(initial_delay +insert_duration, start_reloader_after_insert)
        else:

            def start_reload_after_delay():
                play_boltback_for_internal(reload_step)

            popup.after(initial_delay, start_reload_after_delay)

        return "Reloading..."

    def _unload_magazine_rounds(self, magazine, save_data, max_rounds = None, on_complete = None, is_loaded_in_weapon = False, weapon = None, variant_filter = None):

        logging.info("_unload_magazine_rounds start: rounds=%s, variant_filter=%s", len(magazine.get("rounds", [])), variant_filter)

        current_rounds = magazine.get("rounds", [])
        if not isinstance(current_rounds, list):
            current_rounds =[]
            magazine["rounds"]= current_rounds

        if variant_filter:
            matching_count = sum(1 for r in current_rounds if isinstance(r, dict)and str(r.get('variant', 'Unknown')).lower()==str(variant_filter).lower())
            rounds_to_remove = matching_count
        else:
            rounds_to_remove = len(current_rounds)

        if max_rounds is not None:
            try:
                rounds_to_remove = min(int(max_rounds), rounds_to_remove)
            except Exception:
                pass

        if rounds_to_remove <=0:
            msg = "Magazine is already empty"
            if on_complete:
                on_complete(msg)
            return msg

        has_reloader = self._check_for_reloader_item(save_data)

        popup = customtkinter.CTkToplevel(self.root)
        popup.title("Unloading Magazine")
        popup.transient(self.root)
        self._center_popup_on_window(popup, 400, 150)
        popup.grab_set()

        status_text = "Using reloader..."if has_reloader else "Unloading rounds manually..."
        status_label = customtkinter.CTkLabel(
        popup,
        text = status_text,
        font = customtkinter.CTkFont(size = 14)
        )
        status_label.pack(pady =(20, 10))

        progress_bar = customtkinter.CTkProgressBar(popup, width = 350)
        progress_bar.pack(pady = 10)
        progress_bar.set(0)

        count_label = customtkinter.CTkLabel(
        popup,
        text = f"0 / {rounds_to_remove} rounds",
        font = customtkinter.CTkFont(size = 12)
        )
        count_label.pack(pady = 5)

        unload_state = {
        "index":0,
        "reloader_channel":None,
        "reloader_sound":None,
        "rounds_removed":[]
        }

        def play_insert_sound():
            insert_sound = f"bulletinsert{random.randint(0, 1)}"
            try:
                sound_path = os.path.join("sounds", "firearms", "universal", f"{insert_sound}.ogg")
                if os.path.exists(sound_path):
                    sound = pygame.mixer.Sound(sound_path)
                    channel = pygame.mixer.find_channel()
                    if channel:
                        channel.play(sound)
            except Exception as e:
                logging.warning(f"Failed to play {insert_sound}: {e}")

        def start_reloader_sound():
            reloader_sound_path = os.path.join("sounds", "firearms", "universal", "reloaderloop.ogg")
            if os.path.exists(reloader_sound_path):
                channel = pygame.mixer.find_channel()
                if channel:
                    try:
                        sound = pygame.mixer.Sound(reloader_sound_path)
                        channel.play(sound, loops = -1)
                        unload_state["reloader_channel"]= channel
                        unload_state["reloader_sound"]= sound
                    except Exception as e:
                        logging.warning(f"Failed to play reloader sound: {e}")

        def play_reloader_insert_sound():

            try:
                sound_path = os.path.join("sounds", "firearms", "universal", "reloaderroundinsert.ogg")
                if os.path.exists(sound_path):
                    sound = pygame.mixer.Sound(sound_path)
                    channel = pygame.mixer.find_channel()
                    if channel:
                        channel.play(sound)
                        return int(sound.get_length()*1000)
            except Exception as e:
                logging.warning(f"Failed to play reloader insert sound: {e}")
            return 0

        def play_magout_sound():

            if weapon:
                try:
                    self._play_weapon_action_sound(weapon, "magout")
                    return 500
                except Exception as e:
                    logging.warning(f"Failed to play magout sound: {e}")
            return 0

        def play_magin_sound():

            if weapon:
                try:
                    self._play_weapon_action_sound(weapon, "magin")
                except Exception as e:
                    logging.warning(f"Failed to play magin sound: {e}")

        def stop_reloader_sound():
            if unload_state["reloader_channel"]:
                try:
                    unload_state["reloader_channel"].stop()
                except Exception:
                    pass
                unload_state["reloader_channel"]= None

        def unload_step():
            idx = unload_state["index"]

            if idx >=rounds_to_remove:

                stop_reloader_sound()

                hands_items = save_data.get("hands", {}).get("items", [])
                self._add_rounds_to_container(hands_items, unload_state["rounds_removed"])

                if has_reloader:
                    message = f"Unloaded {len(unload_state['rounds_removed'])} rounds using reloader(remaining: {len(current_rounds)})"
                else:
                    message = f"Manually unloaded {len(unload_state['rounds_removed'])} rounds(remaining: {len(current_rounds)})"

                logging.info(message)

                if is_loaded_in_weapon:
                    play_magin_sound()

                    try:
                        if weapon and is_bolt_action_reload:
                            try:
                                self._play_weapon_action_sound(weapon, "boltforward")
                            except Exception:
                                pass
                    except Exception:
                        pass

                try:
                    popup.destroy()
                except Exception:
                    pass

                if on_complete:
                    on_complete(message)
                return

            if current_rounds:
                try:
                    removed = None
                    if variant_filter:

                        for i in range(len(current_rounds)-1, -1, -1):
                            r = current_rounds[i]
                            if isinstance(r, dict)and str(r.get('variant', 'Unknown')).lower()==str(variant_filter).lower():
                                removed = current_rounds.pop(i)
                                break
                    else:
                        removed = current_rounds.pop()

                    if removed is not None:
                        unload_state["rounds_removed"].append(removed)
                except Exception:
                    pass

            unload_state["index"]+=1

            progress = unload_state["index"]/rounds_to_remove
            progress_bar.set(progress)
            count_label.configure(text = f"{unload_state['index']} / {rounds_to_remove} rounds")

            play_insert_sound()

            if has_reloader:
                delay = 100
            else:
                delay = 500

            popup.after(delay, unload_step)

        initial_delay = 100

        if is_loaded_in_weapon:
            magout_duration = play_magout_sound()
            initial_delay +=magout_duration

        if has_reloader:

            insert_duration = play_reloader_insert_sound()

            def start_reloader_after_insert():
                start_reloader_sound()
                popup.after(100, unload_step)

            popup.after(initial_delay +insert_duration, start_reloader_after_insert)
        else:

            popup.after(initial_delay, unload_step)

        return "Unloading..."

    def _safe_exit(self):
        try:
            autosaved = False
            if currentsave is not None:

                try:
                    global_save = globals().get('save_data')
                    if isinstance(global_save, dict):
                        try:
                            self._save_file(global_save)
                            logging.info("Autosaved current save using globals()['save_data'].")
                            autosaved = True
                        except Exception as e:
                            logging.error(f"Autosave failed for globals()['save_data']: {e}")
                except Exception:
                    pass

                if not autosaved and hasattr(self, '_current_save_data')and isinstance(getattr(self, '_current_save_data'), dict):
                    try:
                        self._save_file(getattr(self, '_current_save_data'))
                        logging.info("Autosaved current save using self._current_save_data.")
                        autosaved = True
                    except Exception as e:
                        logging.error(f"Autosave failed for self._current_save_data: {e}")

                if not autosaved:
                    candidate_names =(
                    'current_save_data', '_current_save_data', 'save_data', '_save_data',
                    'current_data', 'data', '_data'
                    )
                    for name in candidate_names:
                        try:
                            if hasattr(self, name):
                                d = getattr(self, name)
                                if isinstance(d, dict):
                                    try:
                                        self._save_file(d)
                                        logging.info(f"Autosaved current save using attribute '{name}'.")
                                        autosaved = True
                                    except Exception as e:
                                        logging.error(f"Autosave failed using attribute '{name}': {e}")
                                    break
                        except Exception:
                            continue

                if not autosaved:
                    logging.info("Exiting with current save loaded(no in-memory autosave performed).")
            else:
                logging.info("No current save loaded at exit.")

            try:
                self._save_persistent_data()
            except Exception as e:
                logging.error(f"Failed to save persistent data on exit: {e}")

            logging.info("Program exited safely.")
        except Exception as e:
            logging.exception("Error during safe exit: %s", e)
        try:
            self.root.quit()
        except Exception:
            try:
                self.root.destroy()
            except Exception:
                pass

    def _on_window_close(self):

        logging.info("Window close requested; prompting for confirmation.")
        try:
            def on_confirm(result):
                if result:
                    try:
                        self._safe_exit()
                    except Exception:
                        logging.exception("Error while exiting via window close")

            self._popup_confirm(
            "Confirm Exit",
            "Do you want to exit? Any unsaved changes will be autosaved before exiting.",
            on_confirm
            )
        except Exception:
            logging.info("Window close attempted but confirmation unavailable; ignored.")
    def _open_settings(self):
        logging.info("Settings definition called")

        self._clear_window()

        appearance_settings_initial = appearance_settings.copy()
        global_variables_initial = {k:v.copy()if isinstance(v, dict)else v for k, v in global_variables.items()}
        settings_modified =[False]

        builtin_themes =["dark-blue", "blue", "green"]
        themes_dir = os.path.join(os.getcwd(), "themes")
        custom_theme_files =[]
        if os.path.isdir(themes_dir):
            custom_theme_files =[f for f in os.listdir(themes_dir)if f.endswith(".json")]
        theme_sources = {name:name for name in builtin_themes}
        for fname in custom_theme_files:
            name = os.path.splitext(fname)[0]
            theme_sources[name]= os.path.join(themes_dir, fname)
        available_theme_names = list(theme_sources.keys())
        if not available_theme_names:
            available_theme_names =["dark-blue"]
            theme_sources = {"dark-blue":"dark-blue"}

        def update_appearance():
            settings_modified[0]= True
            customtkinter.set_appearance_mode(appearance_settings["appearance_mode"])
            theme_key = appearance_settings.get("color_theme", "dark-blue")
            theme_target = theme_sources.get(theme_key, "dark-blue")
            try:
                customtkinter.set_default_color_theme(theme_target)
            except Exception as e:
                logging.warning(f"Failed to load theme '{theme_target}': {e}")
                appearance_settings["color_theme"]= "dark-blue"
                fallback = theme_sources.get("dark-blue", "dark-blue")
                try:
                    customtkinter.set_default_color_theme(fallback)
                except Exception as e2:
                    logging.error(f"Fallback theme load failed: {e2}")

            try:
                appearance_settings_path = os.path.join(saves_folder or "saves", "appearance_settings.sldsv")
                with open(appearance_settings_path, 'w')as f:
                    json.dump(appearance_settings, f, indent = 4)
                logging.info(f"Appearance settings saved to {appearance_settings_path}")
            except Exception as e:
                logging.error(f"Failed to save appearance settings: {e}")

            self._clear_window()
            self._open_settings()
            try:
                self.root.geometry(appearance_settings["resolution"])
            except Exception as e:
                logging.warning(f"Failed to apply resolution {appearance_settings['resolution']}: {e}")
            self.root.attributes('-fullscreen', appearance_settings.get("fullscreen", False))
            if appearance_settings.get("borderless", False):
                self.root.overrideredirect(True)
            else:
                self.root.overrideredirect(False)

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)
        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew", padx = 20, pady = 20)
        main_frame.grid_columnconfigure((0, 1), weight = 1)
        main_frame.grid_rowconfigure(1, weight = 1)

        title = customtkinter.CTkLabel(main_frame, text = "Settings", font = customtkinter.CTkFont(size = 22, weight = "bold"))
        title.grid(row = 0, column = 0, columnspan = 2, pady =(0, 15))

        content = customtkinter.CTkFrame(main_frame)
        content.grid(row = 1, column = 0, columnspan = 2, sticky = "nsew")
        content.grid_columnconfigure((0, 1), weight = 1)

        appearance_frame = customtkinter.CTkFrame(content)
        appearance_frame.grid(row = 0, column = 0, sticky = "nsew", padx =(0, 10), pady = 10)
        appearance_frame.grid_columnconfigure(1, weight = 1)

        customtkinter.CTkLabel(appearance_frame, text = "Appearance", font = customtkinter.CTkFont(size = 16, weight = "bold")).grid(row = 0, column = 0, columnspan = 2, pady =(10, 5), sticky = "w")

        customtkinter.CTkLabel(appearance_frame, text = "Mode:").grid(row = 1, column = 0, sticky = "w", padx = 10, pady = 4)
        mode_box = customtkinter.CTkOptionMenu(
        appearance_frame,
        values =["system", "dark", "light"],
        command = lambda v:appearance_settings.__setitem__("appearance_mode", v)or update_appearance()
        )
        mode_box.set(appearance_settings.get("appearance_mode", "system"))
        mode_box.grid(row = 1, column = 1, sticky = "ew", padx = 10, pady = 4)

        customtkinter.CTkLabel(appearance_frame, text = "Color Theme:").grid(row = 2, column = 0, sticky = "w", padx = 10, pady = 4)
        theme_box = customtkinter.CTkOptionMenu(
        appearance_frame,
        values = available_theme_names,
        command = lambda v:appearance_settings.__setitem__("color_theme", v)or update_appearance()
        )
        selected_theme = appearance_settings.get("color_theme", "dark-blue")
        if selected_theme not in available_theme_names:
            selected_theme = "dark-blue"
        theme_box.set(selected_theme)
        theme_box.grid(row = 2, column = 1, sticky = "ew", padx = 10, pady = 4)

        customtkinter.CTkLabel(appearance_frame, text = "Resolution:").grid(row = 3, column = 0, sticky = "w", padx = 10, pady = 4)

        screen_w = self.root.winfo_screenwidth()
        screen_h = self.root.winfo_screenheight()

        common_res =[
        "5120x1440", "3840x2400", "3840x2160", "3840x1080", "2560x1600", "2560x1440",
        "2560x1080", "1920x1200", "1920x1080", "1680x1050", "1600x1200", "1600x900",
        "1440x900", "1366x768", "1280x960", "1280x800", "1280x720"
        ]

        def _fits(res_str:str)->bool:
            try:
                w, h = map(int, res_str.split("x"))
                return w <=screen_w and h <=screen_h
            except Exception:
                return False

        def _aspect_label(res_str:str)->str:
            try:
                w, h = map(int, res_str.split("x"))
                ratio = w /h if h else 0

                common_aspects =[
                (16, 9), (16, 10), (21, 9), (32, 9), (4, 3), (5, 4), (3, 2),
                (17, 9), (19, 10), (18, 9)
                ]
                closest = min(common_aspects, key = lambda a:abs(ratio -(a[0]/a[1])))if h else(w, h)
                closest_ratio = closest[0]/closest[1]if closest[1]else ratio

                if h and abs(ratio -closest_ratio)<=0.05:
                    aspect = f"{closest[0]}:{closest[1]}"
                else:
                    g = math.gcd(w, h)
                    aspect = f"{w //g}:{h //g}"if g else f"{w}:{h}"

                return f"{w}x{h}({aspect})"
            except Exception:
                return res_str

        filtered_res =[]
        seen = set()
        for r in common_res:
            if r not in seen and _fits(r):
                filtered_res.append(r)
                seen.add(r)

        current_res = appearance_settings.get("resolution", "1920x1080")
        if current_res not in filtered_res and _fits(current_res):
            filtered_res.insert(0, current_res)

        if not filtered_res:
            filtered_res =[f"{screen_w}x{screen_h}"]

        labeled_values =[_aspect_label(r)for r in filtered_res]

        current_label = _aspect_label(current_res)
        if current_label not in labeled_values and _fits(current_res):
            labeled_values.insert(0, current_label)

        def _on_resolution_change(label_val:str):
            res_val = label_val.split(" ")[0]
            appearance_settings["resolution"]= res_val
            update_appearance()

        resolution_box = customtkinter.CTkOptionMenu(
        appearance_frame,
        values = labeled_values,
        command = _on_resolution_change
        )
        resolution_box.set(current_label if current_label in labeled_values else labeled_values[0])
        resolution_box.grid(row = 3, column = 1, sticky = "ew", padx = 10, pady = 4)

        fullscreen_switch = customtkinter.CTkCheckBox(
        appearance_frame,
        text = "Fullscreen",
        command = lambda:(appearance_settings.__setitem__("fullscreen", bool(fullscreen_switch.get())), update_appearance())
        )
        fullscreen_switch.grid(row = 4, column = 0, columnspan = 2, sticky = "w", padx = 10, pady = 4)
        fullscreen_switch.select()if appearance_settings.get("fullscreen", False)else fullscreen_switch.deselect()

        borderless_switch = customtkinter.CTkCheckBox(
        appearance_frame,
        text = "Borderless",
        command = lambda:(appearance_settings.__setitem__("borderless", bool(borderless_switch.get())), update_appearance())
        )
        borderless_switch.grid(row = 5, column = 0, columnspan = 2, sticky = "w", padx = 10, pady = 4)
        borderless_switch.select()if appearance_settings.get("borderless", False)else borderless_switch.deselect()

        customtkinter.CTkLabel(appearance_frame, text = "Units:").grid(row = 6, column = 0, sticky = "w", padx = 10, pady = 4)
        units_box = customtkinter.CTkOptionMenu(
        appearance_frame,
        values =["imperial", "metric", "cheese"],
        command = lambda v:(appearance_settings.__setitem__("units", v), settings_modified.__setitem__(0, True))
        )
        units_box.set(appearance_settings.get("units", "imperial"))
        units_box.grid(row = 6, column = 1, sticky = "ew", padx = 10, pady = 4)

        customtkinter.CTkLabel(appearance_frame, text = "Sound Volume:").grid(row = 8, column = 0, sticky = "w", padx = 10, pady =(8, 4))
        volume_slider = customtkinter.CTkSlider(
        appearance_frame,
        from_ = 0,
        to = 100,
        number_of_steps = 100,
        command = lambda v:(appearance_settings.__setitem__("sound_volume", int(v)), settings_modified.__setitem__(0, True))
        )
        volume_slider.grid(row = 8, column = 1, sticky = "ew", padx = 10, pady =(8, 4))
        volume_slider.set(appearance_settings.get("sound_volume", 100))

        right_frame = customtkinter.CTkFrame(content)
        right_frame.grid(row = 0, column = 1, sticky = "nsew", padx =(10, 0), pady = 10)
        right_frame.grid_columnconfigure(1, weight = 1)

        customtkinter.CTkLabel(right_frame, text = "Data", font = customtkinter.CTkFont(size = 16, weight = "bold")).grid(row = 0, column = 0, columnspan = 2, pady =(10, 5), sticky = "w")

        customtkinter.CTkLabel(right_frame, text = "Table(.sldtbl):").grid(row = 1, column = 0, sticky = "w", padx = 10, pady = 4)
        try:
            table_files =[f for f in os.listdir("tables")if f.endswith(global_variables.get("table_extension", ".sldtbl"))]
        except FileNotFoundError:
            table_files =[]

        table_display_names =[]
        table_name_map = {}

        for table_file in table_files:
            try:
                table_path = os.path.join("tables", table_file)
                with open(table_path, 'r')as f:
                    table_data = json.load(f)
                pretty_name = table_data.get("prettyname", table_file)
                table_display_names.append(pretty_name)
                table_name_map[pretty_name]= table_file.replace(".sldtbl", "")
            except Exception as e:
                logging.warning(f"Failed to load table pretty name for {table_file}: {e}")
                table_display_names.append(table_file)
                table_name_map[table_file]= table_file.replace(".sldtbl", "")

        if not table_display_names:
            table_display_names =["<none>"]
            table_name_map["<none>"]= None

        table_box = customtkinter.CTkOptionMenu(
        right_frame,
        values = table_display_names,
        state = "disabled"if table_display_names ==["<none>"]else "normal",
        command = lambda v:(global_variables.__setitem__("current_table", table_name_map.get(v)), settings_modified.__setitem__(0, True))
        )

        current_table_val = global_variables.get("current_table")
        current_display_name = "<none>"
        if current_table_val:
            for display_name, filename in table_name_map.items():
                if filename ==current_table_val:
                    current_display_name = display_name
                    break

        table_box.set(current_display_name)
        table_box.grid(row = 1, column = 1, sticky = "ew", padx = 10, pady = 4)

        customtkinter.CTkLabel(right_frame, text = "Developer Flags", font = customtkinter.CTkFont(size = 14, weight = "bold")).grid(row = 2, column = 0, columnspan = 2, pady =(12, 4), sticky = "w")
        dev_enabled = global_variables.get("devmode", {}).get("value", False)

        def make_toggle(row, label, key):
            chk = customtkinter.CTkCheckBox(
            right_frame,
            text = label,
            state = "normal"if dev_enabled else "disabled",
            command = lambda k = key, c = lambda:chk.get():(global_variables[k].__setitem__("value", bool(c())), settings_modified.__setitem__(0, True))
            )
            chk.grid(row = row, column = 0, columnspan = 2, sticky = "w", padx = 10, pady = 4)
            if global_variables[key].get("value", False):
                chk.select()
            else:
                chk.deselect()
            return chk

        dev_chk = make_toggle(3, "Development Mode", "devmode")
        dm_chk = make_toggle(4, "DM Mode", "dmmode")
        debug_chk = make_toggle(5, "Debug Mode", "debugmode")

        if not dev_enabled:
            info_label = customtkinter.CTkLabel(right_frame, text = "Enable devmode to edit these", text_color = "gray")
            info_label.grid(row = 6, column = 0, columnspan = 2, sticky = "w", padx = 10, pady =(0, 8))

        button_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        button_frame.grid(row = 2, column = 0, columnspan = 2, pady =(10, 0))
        button_frame.grid_columnconfigure((0, 1), weight = 1)

        def save_settings():
            try:

                appearance_settings_path = os.path.join(saves_folder or "saves", "appearance_settings.sldsv")
                with open(appearance_settings_path, 'w')as f:
                    json.dump(appearance_settings, f, indent = 4)
                logging.info(f"Appearance settings saved to {appearance_settings_path}")

                settings_path = os.path.join(saves_folder or "saves", "settings.sldsv")
                with open(settings_path, 'w')as f:
                    json.dump(global_variables, f, indent = 4)
                logging.info(f"Global settings saved to {settings_path}")

                settings_modified[0]= False
                self._popup_show_info("Success", "Settings saved successfully!", sound = "success")
            except Exception as e:
                logging.error(f"Failed to save settings: {e}")
                self._popup_show_info("Error", f"Failed to save settings: {e}", sound = "error")

        def go_back():
            if settings_modified[0]:
                def confirm_leave():
                    self._clear_window()
                    self._build_main_menu()
                    confirm_window.destroy()

                def cancel_leave():
                    confirm_window.destroy()

                confirm_window = customtkinter.CTkToplevel(self.root)
                confirm_window.title("Unsaved Changes")
                confirm_window.transient(self.root)
                self._center_popup_on_window(confirm_window, 400, 150)

                msg_label = customtkinter.CTkLabel(
                confirm_window,
                text = "You have unsaved changes.\nDo you want to leave without saving?",
                font = customtkinter.CTkFont(size = 12)
                )
                msg_label.pack(pady = 20)

                button_frame_confirm = customtkinter.CTkFrame(confirm_window, fg_color = "transparent")
                button_frame_confirm.pack(pady = 10)
                button_frame_confirm.grid_columnconfigure((0, 1), weight = 1)

                leave_btn = self._create_sound_button(
                button_frame_confirm,
                "Leave",
                confirm_leave,
                width = 150,
                height = 35
                )
                leave_btn.grid(row = 0, column = 0, padx =(0, 10))

                cancel_btn = self._create_sound_button(
                button_frame_confirm,
                "Cancel",
                cancel_leave,
                width = 150,
                height = 35
                )
                cancel_btn.grid(row = 0, column = 1, padx =(10, 0))

                confirm_window.grab_set()
            else:
                self._clear_window()
                self._build_main_menu()

        save_button = self._create_sound_button(
        button_frame,
        "Save Settings",
        save_settings,
        width = 200,
        height = 40
        )
        save_button.grid(row = 0, column = 0, padx =(0, 10))

        back_button = self._create_sound_button(
        button_frame,
        "Back",
        go_back,
        width = 200,
        height = 40
        )
        back_button.grid(row = 0, column = 1, padx =(10, 0))
    def _open_add_item_by_id_tool(self):
        logging.info("Add Item By ID definition called")

        if currentsave is None:
            self._popup_show_info("Error", "No character loaded.", sound = "error")
            return

        try:
            table_files = glob.glob(os.path.join("tables", "*.sldtbl"))
            if not table_files:
                self._popup_show_info("Error", "No table files found.", sound = "error")
                return

            with open(table_files[0], 'r')as f:
                table_data = json.load(f)

            all_items =[]
            for table_name, items in table_data.get("tables", {}).items():
                for item in items:
                    if item.get("id")is None:
                        continue
                    item_copy = item.copy()
                    item_copy["table_category"]= table_name
                    all_items.append(item_copy)

            all_items.sort(key = lambda x:x.get("id", 999999))

            if not all_items:
                self._popup_show_info("Error", "No items found in table.", sound = "error")
                return
        except Exception as e:
            logging.error(f"Failed to load table: {e}")
            self._popup_show_info("Error", f"Failed to load table: {e}", sound = "error")
            return

        self._clear_window()

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew", padx = 20, pady = 20)
        main_frame.grid_rowconfigure(2, weight = 1)
        main_frame.grid_columnconfigure(0, weight = 1)

        title = customtkinter.CTkLabel(main_frame, text = "Add Item to Inventory By ID", font = customtkinter.CTkFont(size = 20, weight = "bold"))
        title.grid(row = 0, column = 0, pady =(0, 10))

        search_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        search_frame.grid(row = 1, column = 0, sticky = "ew", pady = 10)
        search_frame.grid_columnconfigure(1, weight = 1)

        search_label = customtkinter.CTkLabel(search_frame, text = "Search(ID or Name):", font = customtkinter.CTkFont(size = 13))
        search_label.grid(row = 0, column = 0, padx =(0, 10), sticky = "w")

        search_entry = customtkinter.CTkEntry(search_frame, placeholder_text = "Enter item ID or name...")
        search_entry.grid(row = 0, column = 1, sticky = "ew", padx =(0, 10))

        ITEMS_PER_PAGE = 25
        current_page =[0]
        current_filtered =[all_items]
        search_timer =[None]

        info_label = customtkinter.CTkLabel(search_frame, text = f"Page 1 | {len(all_items)} items total", font = customtkinter.CTkFont(size = 11), text_color = "gray")
        info_label.grid(row = 0, column = 2, padx = 10)

        scroll_frame = customtkinter.CTkScrollableFrame(main_frame, width = 900, height = 450)
        scroll_frame.grid(row = 2, column = 0, sticky = "nsew", pady = 10)
        scroll_frame.grid_columnconfigure(0, weight = 1)

        pagination_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        pagination_frame.grid(row = 3, column = 0, pady = 5)

        def add_item_to_inventory(item):
            try:
                save_path = os.path.join(saves_folder or "", (currentsave or "")+".sldsv")
                save_data = self._read_save_from_path(save_path)
                if save_data is None:
                    file_sd = {}
                else:
                    file_sd = save_data

                item_to_add = {k:v for k, v in item.items()if k !="table_category"}

                item_to_add = add_subslots_to_item(item_to_add)

                try:
                    save_data.setdefault("hands", {})
                    save_data["hands"].setdefault("items", [])
                    save_data["hands"]["items"].append(item_to_add)
                    added_location = "hands"
                except Exception:

                    try:
                        save_data.setdefault("storage", [])
                        save_data["storage"].append(item_to_add)
                        added_location = "storage"
                    except Exception:
                        added_location = "unknown"

                self._save_file(save_data)

                logging.info(f"Added item ID {item.get('id')}({item.get('name')}) to {added_location}")
                self._popup_show_info("Success", f"Added '{item.get('name')}' to {added_location}!", sound = "success")
            except Exception as e:
                logging.error(f"Failed to add item: {e}")
                self._popup_show_info("Error", f"Failed to add item: {e}", sound = "error")

        def create_item_widget(item):

            item_frame = customtkinter.CTkFrame(scroll_frame)
            item_frame.pack(fill = "x", pady = 3, padx = 5)
            item_frame.grid_columnconfigure(1, weight = 1)

            id_label = customtkinter.CTkLabel(
            item_frame,
            text = f"ID: {item.get('id', 'N/A')}",
            font = customtkinter.CTkFont(size = 12, weight = "bold"),
            width = 80,
            fg_color =("gray75", "gray25"),
            corner_radius = 6
            )
            id_label.grid(row = 0, column = 0, padx = 8, pady = 8, sticky = "w")

            details_frame = customtkinter.CTkFrame(item_frame, fg_color = "transparent")
            details_frame.grid(row = 0, column = 1, sticky = "ew", padx = 8, pady = 8)

            name_label = customtkinter.CTkLabel(
            details_frame,
            text = item.get("name", "Unknown"),
            font = customtkinter.CTkFont(size = 13, weight = "bold"),
            anchor = "w"
            )
            name_label.pack(anchor = "w")

            category_label = customtkinter.CTkLabel(
            details_frame,
            text = f"{item.get('table_category', 'N/A')} | {item.get('rarity', 'N/A')} | ${item.get('value', 0)}",
            font = customtkinter.CTkFont(size = 10),
            text_color = "gray",
            anchor = "w"
            )
            category_label.pack(anchor = "w")

            add_button = self._create_sound_button(
            item_frame,
            "Add",
            lambda it = item:add_item_to_inventory(it),
            width = 80,
            height = 30,
            font = customtkinter.CTkFont(size = 11)
            )
            add_button.grid(row = 0, column = 2, padx = 8, pady = 8)

        def display_page(page_num):

            items = current_filtered[0]
            total_pages = max(1, (len(items)+ITEMS_PER_PAGE -1)//ITEMS_PER_PAGE)

            page_num = max(0, min(page_num, total_pages -1))
            current_page[0]= page_num

            for widget in scroll_frame.winfo_children():
                widget.destroy()

            if not items:
                no_results = customtkinter.CTkLabel(scroll_frame, text = "No items found.", font = customtkinter.CTkFont(size = 14), text_color = "gray")
                no_results.pack(pady = 20)
                info_label.configure(text = "No items found")
                update_pagination_controls(0, 0)
                return

            start_idx = page_num *ITEMS_PER_PAGE
            end_idx = min(start_idx +ITEMS_PER_PAGE, len(items))

            for i in range(start_idx, end_idx):
                create_item_widget(items[i])

            info_label.configure(text = f"Page {page_num +1} of {total_pages} | {len(items)} items total")

            update_pagination_controls(page_num, total_pages)

            try:
                scroll_frame._parent_canvas.yview_moveto(0)
            except Exception:
                pass

        def update_pagination_controls(current, total):

            for widget in pagination_frame.winfo_children():
                widget.destroy()

            if total <=1:
                return

            first_btn = customtkinter.CTkButton(
            pagination_frame, text = "<<", width = 40, height = 30,
            command = lambda:display_page(0),
            state = "normal"if current >0 else "disabled"
            )
            first_btn.pack(side = "left", padx = 2)

            prev_btn = customtkinter.CTkButton(
            pagination_frame, text = "<", width = 40, height = 30,
            command = lambda:display_page(current -1),
            state = "normal"if current >0 else "disabled"
            )
            prev_btn.pack(side = "left", padx = 2)

            start_page = max(0, current -3)
            end_page = min(total, start_page +7)
            if end_page -start_page <7:
                start_page = max(0, end_page -7)

            for p in range(start_page, end_page):
                btn = customtkinter.CTkButton(
                pagination_frame,
                text = str(p +1),
                width = 35,
                height = 30,
                fg_color =("gray75", "gray25")if p ==current else None,
                command = lambda page = p:display_page(page)
                )
                btn.pack(side = "left", padx = 1)

            next_btn = customtkinter.CTkButton(
            pagination_frame, text = ">", width = 40, height = 30,
            command = lambda:display_page(current +1),
            state = "normal"if current <total -1 else "disabled"
            )
            next_btn.pack(side = "left", padx = 2)

            last_btn = customtkinter.CTkButton(
            pagination_frame, text = ">>", width = 40, height = 30,
            command = lambda:display_page(total -1),
            state = "normal"if current <total -1 else "disabled"
            )
            last_btn.pack(side = "left", padx = 2)

        def filter_items(search_term):

            search_lower = search_term.lower().strip()

            if search_lower:
                filtered =[
                item for item in all_items
                if search_lower in str(item.get("id", ""))or search_lower in item.get("name", "").lower()
                ]
            else:
                filtered = all_items

            current_filtered[0]= filtered
            current_page[0]= 0
            display_page(0)

        def on_search_change(*args):

            if search_timer[0]is not None:
                try:
                    self.root.after_cancel(search_timer[0])
                except Exception:
                    pass

            search_timer[0]= self.root.after(200, lambda:filter_items(search_entry.get()))# type: ignore

        search_entry.bind("<KeyRelease>", on_search_change)

        display_page(0)

        button_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        button_frame.grid(row = 4, column = 0, pady = 10)

        back_button = self._create_sound_button(
        button_frame,
        "Back",
        lambda:[self._clear_window(), self._open_modify_save_data_tool()],
        width = 200,
        height = 40,
        font = customtkinter.CTkFont(size = 14)
        )
        back_button.pack()
    def _open_modify_save_data_tool(self):
        logging.info("Modify Save Data definition called")
        self._clear_window()
        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.pack(fill = "both", expand = True, padx = 20, pady = 20)
        add_item_button = self._create_sound_button(main_frame, "Add Item to Inventory By ID", self._open_add_item_by_id_tool, width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        add_item_button.pack(pady = 10)
        back_button = self._create_sound_button(
        main_frame,
        "Back",
        lambda:[self._clear_window(), self._open_dev_tools()],
        width = 200,
        height = 40
        )
        back_button.pack(pady = 10)
    def _open_dev_tools(self):
        logging.info("Developer Tools definition called")
        self._clear_window()
        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.pack(fill = "both", expand = True, padx = 20, pady = 20)
        title_label = customtkinter.CTkLabel(main_frame, text = "Developer Tools", font = customtkinter.CTkFont(size = 20, weight = "bold"))
        title_label.pack(pady = 20)
        modify_data = self._create_sound_button(main_frame, "Modify Data", self._open_modify_save_data_tool, width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        modify_data.pack(pady = 10)
        back_button = self._create_sound_button(
        main_frame,
        "Back",
        lambda:[self._clear_window(), self._build_main_menu()],
        width = 500,
        height = 50,
        font = customtkinter.CTkFont(size = 16)
        )
        back_button.pack(pady = 10)
    def _open_dm_tools(self):
        logging.info("DM Tools definition called")
        self._clear_window()

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew")

        title_label = customtkinter.CTkLabel(main_frame, text = "DM Tools", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title_label.pack(pady = 20)

        scroll_frame = customtkinter.CTkScrollableFrame(main_frame)
        scroll_frame.pack(fill = "both", expand = True, padx = 20, pady = 20)

        encounter_roll_button = self._create_sound_button(scroll_frame, "Encounter Roll", self._open_encounter_roll_tool, width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        encounter_roll_button.pack(pady = 10)

        enemy_loot_button = self._create_sound_button(scroll_frame, "Individual Enemy Loot", self._open_enemy_loot_tool, width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        enemy_loot_button.pack(pady = 10)

        create_lootcrate_button = self._create_sound_button(scroll_frame, "Create Loot Crate", self._open_create_lootcrate_tool, width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        create_lootcrate_button.pack(pady = 10)

        create_item_transfer_button = self._create_sound_button(scroll_frame, "Create Item Transfer", self._open_create_item_transfer_tool, width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        create_item_transfer_button.pack(pady = 10)

        create_magazine_transfer_button = self._create_sound_button(scroll_frame, "Create Loaded Magazine Transfer", self._open_create_magazine_transfer_tool, width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        create_magazine_transfer_button.pack(pady = 10)

        create_belt_transfer_button = self._create_sound_button(scroll_frame, "Create Belt Transfer", self._open_create_belt_transfer_tool, width = 500, height = 50, font = customtkinter.CTkFont(size = 16), state = "disabled")
        create_belt_transfer_button.pack(pady = 10)

        modify_settings_button = self._create_sound_button(scroll_frame, "Modify Settings", self._open_modify_settings_tool, width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        modify_settings_button.pack(pady = 10)

        back_button = self._create_sound_button(main_frame, "Back to Main Menu", lambda:[self._clear_window(), self._build_main_menu()], width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        back_button.pack(pady = 20)

    def _open_encounter_roll_tool(self):

        logging.info("Encounter Roll tool called")

        try:
            table_files = glob.glob(os.path.join("tables", "*.sldtbl"))
            if not table_files:
                self._popup_show_info("Error", "No table file found.", sound = "error")
                return
            with open(table_files[0], 'r')as f:
                table_data = json.load(f)
        except Exception as e:
            logging.error(f"Failed to load table: {e}")
            self._popup_show_info("Error", f"Failed to load table: {e}", sound = "error")
            return

        dm_settings_path = os.path.join(saves_folder or "saves", "dm_settings.sldsv")
        enabled_enemies = {}

        if os.path.exists(dm_settings_path):
            try:
                with open(dm_settings_path, 'r')as f:
                    dm_settings = json.load(f)
                    enabled_enemies = dm_settings.get("enabled_enemies", {})
            except Exception as e:
                logging.warning(f"Failed to load DM settings: {e}")

        enemy_list = table_data.get("tables", {}).get("enemy_drops", [])

        available_enemies =[
        enemy for enemy in enemy_list
        if enabled_enemies.get(enemy.get("name"), True)
        ]

        if not available_enemies:
            self._popup_show_info("Error", "No enabled enemies in table.", sound = "error")
            return

        self._clear_window()
        self._play_ui_sound("whoosh1")

        main_frame = customtkinter.CTkFrame(self.root, fg_color = "transparent")
        main_frame.pack(fill = "both", expand = True, padx = 20, pady = 20)

        title_label = customtkinter.CTkLabel(
        main_frame,
        text = "Encounter Roll",
        font = customtkinter.CTkFont(size = 24, weight = "bold")
        )
        title_label.pack(pady = 20)

        info_frame = customtkinter.CTkFrame(main_frame)
        info_frame.pack(fill = "x", pady = 10)

        info_text = """Encounter Difficulty Ranges:
        1 = Miniboss
        2-5 = Hard
        6-10 = Medium
        11-14 = Easy
        15-20 = None/Friendly(50/50)"""

        customtkinter.CTkLabel(
        info_frame,
        text = info_text,
        font = customtkinter.CTkFont(size = 12),
        justify = "left"
        ).pack(padx = 20, pady = 10)

        content_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        content_frame.pack(fill = "both", expand = True, pady = 10)

        loot_list_frame = customtkinter.CTkScrollableFrame(content_frame, width = 400, height = 300)
        loot_list_frame.pack(side = "left", fill = "both", expand = True, padx =(0, 10))

        loot_list_label = customtkinter.CTkLabel(
        loot_list_frame,
        text = "Enemy Loot",
        font = customtkinter.CTkFont(size = 16, weight = "bold")
        )
        loot_list_label.pack(pady = 10)

        right_frame = customtkinter.CTkFrame(content_frame, fg_color = "transparent")
        right_frame.pack(side = "right", fill = "both", expand = True, padx =(10, 0))

        result_label = customtkinter.CTkLabel(
        right_frame,
        text = "",
        font = customtkinter.CTkFont(size = 14),
        wraplength = 400,
        justify = "left"
        )
        result_label.pack(pady = 20)

        encounter_state = {"spawned_enemies":[], "all_loot":[]}

        def clear_loot_list():
            for widget in loot_list_frame.winfo_children():
                if widget !=loot_list_label:
                    widget.destroy()
            encounter_state["spawned_enemies"]=[]
            encounter_state["all_loot"]=[]

        def add_enemy_to_list(enemy_name, difficulty, loot_items):
            enemy_frame = customtkinter.CTkFrame(loot_list_frame)
            enemy_frame.pack(fill = "x", pady = 5, padx = 5)

            header_frame = customtkinter.CTkFrame(enemy_frame, fg_color = "transparent")
            header_frame.pack(fill = "x", padx = 5, pady =(5, 2))

            enemy_header = customtkinter.CTkLabel(
            header_frame,
            text = f"â–¸ {enemy_name}({difficulty})",
            font = customtkinter.CTkFont(size = 13, weight = "bold"),
            anchor = "w"
            )
            enemy_header.pack(side = "left", fill = "x", expand = True)

            if loot_items:
                def save_this_enemy_loot(name = enemy_name, loot = loot_items):
                    self._save_enemy_loot_transfer(name, loot)

                save_btn = customtkinter.CTkButton(
                header_frame,
                text = "Save",
                width = 50,
                height = 24,
                font = customtkinter.CTkFont(size = 11),
                command = save_this_enemy_loot
                )
                save_btn.pack(side = "right", padx = 2)

            if loot_items:
                for item in loot_items:
                    item_name = item.get('name', 'Unknown Item')
                    qty = item.get('quantity', 1)
                    item_text = f" â€¢ {item_name}"
                    if qty >1:
                        item_text +=f" x{qty}"
                    item_label = customtkinter.CTkLabel(
                    enemy_frame,
                    text = item_text,
                    font = customtkinter.CTkFont(size = 11),
                    anchor = "w"
                    )
                    item_label.pack(fill = "x", padx = 10)
                encounter_state["all_loot"].extend(loot_items)
            else:
                no_loot_label = customtkinter.CTkLabel(
                enemy_frame,
                text = "(No items)",
                font = customtkinter.CTkFont(size = 11),
                text_color = "gray",
                anchor = "w"
                )
                no_loot_label.pack(fill = "x", padx = 10)

            encounter_state["spawned_enemies"].append({
            "name":enemy_name,
            "difficulty":difficulty,
            "loot":loot_items
            })

        def perform_roll():
            clear_loot_list()
            roll = random.randint(1, 20)

            if roll ==1:
                difficulty = "Miniboss"
            elif 2 <=roll <=5:
                difficulty = "Hard"
            elif 6 <=roll <=10:
                difficulty = "Medium"
            elif 11 <=roll <=14:
                difficulty = "Easy"
            else:
                is_friendly = random.choice([True, False])
                difficulty = "Friendly"if is_friendly else "None"

            result_text = f"Roll: {roll}\nDifficulty: {difficulty}\n\n"

            if difficulty =="None":
                result_text +="No encounter!"
                result_label.configure(text = result_text)
                return

            if difficulty =="Friendly":
                friendly_enemies =[e for e in available_enemies if e.get("difficulty", "").lower()=="friendly"]
                if not friendly_enemies:
                    friendly_enemies = available_enemies

                selected_enemy = random.choice(friendly_enemies)
                enemy_name = selected_enemy.get('name', 'Unknown')
                result_text +=f"Friendly encounter!\nEnemy: {enemy_name}\n\n"
                result_text +="Friendly enemies have no loot."
                result_label.configure(text = result_text)

                add_enemy_to_list(enemy_name, "Friendly", [])
                return

            matching_enemies =[e for e in available_enemies if e.get("difficulty", "").lower()==difficulty.lower()]

            if not matching_enemies:
                result_text +=f"No enemies found for difficulty: {difficulty}"
                result_label.configure(text = result_text)
                return

            selected_enemy = random.choice(matching_enemies)
            enemy_name = selected_enemy.get('name', 'Unknown')
            result_text +=f"Enemy: {enemy_name}\n\n"

            loot = self._generate_enemy_loot(selected_enemy, table_data)

            result_text +=f"Generated {len(loot)} item(s)"
            result_label.configure(text = result_text)

            add_enemy_to_list(enemy_name, difficulty, loot)

        def save_all_loot():
            if not encounter_state["all_loot"]:
                self._popup_show_info("Info", "No loot to save.", sound = "error")
                return
            enemy_names = ", ".join([e["name"]for e in encounter_state["spawned_enemies"]])
            self._save_enemy_loot_transfer(enemy_names, encounter_state["all_loot"])

        self._create_sound_button(
        right_frame,
        text = "Roll for Encounter",
        command = perform_roll,
        width = 300,
        height = 50,
        font = customtkinter.CTkFont(size = 16)
        ).pack(pady = 10)

        self._create_sound_button(
        right_frame,
        text = "Save All Loot as Transfer",
        command = save_all_loot,
        width = 300
        ).pack(pady = 10)

        back_button = self._create_sound_button(
        right_frame,
        text = "Back to DM Tools",
        command = lambda:[self._clear_window(), self._open_dm_tools()],
        width = 300,
        height = 50,
        font = customtkinter.CTkFont(size = 16)
        )
        back_button.pack(pady = 20)

    def _open_enemy_loot_tool(self):

        logging.info("Individual Enemy Loot tool called")

        try:
            table_files = glob.glob(os.path.join("tables", "*.sldtbl"))
            if not table_files:
                self._popup_show_info("Error", "No table file found.", sound = "error")
                return
            with open(table_files[0], 'r')as f:
                table_data = json.load(f)
        except Exception as e:
            logging.error(f"Failed to load table: {e}")
            self._popup_show_info("Error", f"Failed to load table: {e}", sound = "error")
            return

        dm_settings_path = os.path.join(saves_folder or "saves", "dm_settings.sldsv")
        enabled_enemies = {}

        if os.path.exists(dm_settings_path):
            try:
                with open(dm_settings_path, 'r')as f:
                    dm_settings = json.load(f)
                    enabled_enemies = dm_settings.get("enabled_enemies", {})
            except Exception as e:
                logging.warning(f"Failed to load DM settings: {e}")

        enemy_list = table_data.get("tables", {}).get("enemy_drops", [])

        available_enemies =[
        enemy for enemy in enemy_list
        if enabled_enemies.get(enemy.get("name"), True)
        ]

        if not available_enemies:
            self._popup_show_info("Error", "No enabled enemies in table.", sound = "error")
            return

        self._clear_window()
        self._play_ui_sound("whoosh1")

        main_frame = customtkinter.CTkScrollableFrame(self.root, fg_color = "transparent")
        main_frame.pack(fill = "both", expand = True, padx = 20, pady = 20)

        title_label = customtkinter.CTkLabel(
        main_frame,
        text = "Individual Enemy Loot",
        font = customtkinter.CTkFont(size = 24, weight = "bold")
        )
        title_label.pack(pady = 20)

        customtkinter.CTkLabel(
        main_frame,
        text = "Select an enemy to generate loot:",
        font = customtkinter.CTkFont(size = 14)
        ).pack(pady = 10)

        for enemy in available_enemies:
            enemy_frame = customtkinter.CTkFrame(main_frame)
            enemy_frame.pack(fill = "x", pady = 5, padx = 20)

            enemy_info = f"{enemy.get('name', 'Unknown')} - {enemy.get('difficulty', 'Unknown')} Difficulty"

            customtkinter.CTkLabel(
            enemy_frame,
            text = enemy_info,
            font = customtkinter.CTkFont(size = 12)
            ).pack(side = "left", padx = 10, pady = 10)

            def generate_loot(e = enemy):
                self._show_enemy_loot_result(e, table_data)

            self._create_sound_button(
            enemy_frame,
            text = "Generate Loot",
            command = generate_loot,
            width = 150
            ).pack(side = "right", padx = 10, pady = 5)

        back_button = self._create_sound_button(
        main_frame,
        text = "Back to DM Tools",
        command = lambda:[self._clear_window(), self._open_dm_tools()],
        width = 300,
        height = 50,
        font = customtkinter.CTkFont(size = 16)
        )
        back_button.pack(pady = 20)

    def _show_enemy_loot_result(self, enemy, table_data):

        loot = self._generate_enemy_loot(enemy, table_data)

        dialog = customtkinter.CTkToplevel(self.root)
        dialog.title(f"Loot: {enemy.get('name', 'Unknown')}")
        dialog.transient(self.root)

        if global_variables.get("devmode", {}).get("value", False):
            self._center_popup_on_window(dialog, 700, 700)
        else:
            self._center_popup_on_window(dialog, 500, 600)
        dialog.grab_set()

        customtkinter.CTkLabel(
        dialog,
        text = f"Generated Loot for {enemy.get('name', 'Unknown')}",
        font = customtkinter.CTkFont(size = 16, weight = "bold")
        ).pack(pady = 10)

        scroll_frame = customtkinter.CTkScrollableFrame(dialog)
        scroll_frame.pack(fill = "both", expand = True, padx = 20, pady = 10)

        if global_variables.get("devmode", {}).get("value", False)and loot:
            debug_summary = loot[0].get("_loot_debug_summary", "")
            if debug_summary:
                debug_frame = customtkinter.CTkFrame(scroll_frame, fg_color = "#1a1a2e")
                debug_frame.pack(fill = "x", pady =(0, 15), padx = 5)

                customtkinter.CTkLabel(
                debug_frame,
                text = "ðŸ”§ DEBUG INFO",
                font = customtkinter.CTkFont(size = 12, weight = "bold"),
                text_color = "#00ff88"
                ).pack(anchor = "w", padx = 10, pady =(10, 5))

                debug_text = customtkinter.CTkTextbox(
                debug_frame,
                height = 250,
                font = customtkinter.CTkFont(family = "Consolas", size = 10),
                fg_color = "#0d0d1a",
                text_color = "#88ff88"
                )
                debug_text.pack(fill = "x", padx = 10, pady =(0, 10))
                debug_text.insert("1.0", debug_summary)
                debug_text.configure(state = "disabled")

        if not loot:
            customtkinter.CTkLabel(
            scroll_frame,
            text = "No loot generated",
            font = customtkinter.CTkFont(size = 12)
            ).pack(pady = 20)

            if global_variables.get("devmode", {}).get("value", False):
                customtkinter.CTkLabel(
                scroll_frame,
                text = "(Check logs for debug details)",
                font = customtkinter.CTkFont(size = 10),
                text_color = "gray"
                ).pack()
        else:
            customtkinter.CTkLabel(
            scroll_frame,
            text = "Generated Items:",
            font = customtkinter.CTkFont(size = 14, weight = "bold")
            ).pack(anchor = "w", padx = 10, pady =(10, 5))

            for item in loot:
                item_text = item.get('name', 'Unknown Item')
                if item.get("quantity", 1)>1:
                    item_text +=f" x{item['quantity']}"

                rarity = item.get('rarity', 'Common')
                rarity_colors = {
                'Common':'white',
                'Uncommon':'#00ff00',
                'Rare':'#0088ff',
                'Epic':'#aa00ff',
                'Legendary':'#ffaa00',
                'Special':'#ff0088'
                }
                text_color = rarity_colors.get(rarity, 'white')

                customtkinter.CTkLabel(
                scroll_frame,
                text = f"â€¢ {item_text}[{rarity}]",
                font = customtkinter.CTkFont(size = 12),
                text_color = text_color
                ).pack(anchor = "w", padx = 10, pady = 2)

        def save_loot():
            self._save_enemy_loot_transfer(enemy.get("name"), loot)
            dialog.destroy()

        self._create_sound_button(
        dialog,
        text = "Save as Enemy Loot Transfer",
        command = save_loot,
        width = 250
        ).pack(pady = 10)

        self._create_sound_button(
        dialog,
        text = "Close",
        command = dialog.destroy,
        fg_color = "#8B0000",
        width = 250
        ).pack(pady = 10)

    def _generate_enemy_loot(self, enemy, table_data):

        loot =[]
        debug_lines =[]

        if global_variables.get("devmode", {}).get("value", False):
            debug_lines.append(f"â•â•â• ENEMY LOOT GENERATION DEBUG â•â•â•")
            debug_lines.append(f"Enemy: {enemy.get('name', 'Unknown')}")
            debug_lines.append(f"Difficulty: {enemy.get('difficulty', 'Unknown')}")
            debug_lines.append(f"Total loot entries: {len(enemy.get('items', []))}")
            debug_lines.append("")

        rarity_weights = table_data.get("rarity_weights", {})

        for idx, loot_entry in enumerate(enemy.get("items", [])):

            entry_debug =[]
            if global_variables.get("devmode", {}).get("value", False):
                entry_debug.append(f"--- Entry #{idx +1} ---")
                entry_debug.append(f" Type: {loot_entry.get('type', 'Unknown')}")
                if loot_entry.get('type')=='table':
                    entry_debug.append(f" Table: {loot_entry.get('table', 'Unknown')}")
                elif loot_entry.get('type')=='id':
                    entry_debug.append(f" Item ID: {loot_entry.get('id', 'Unknown')}")
                entry_debug.append(f" Rarity filter: {loot_entry.get('rarity', 'Any')}")
                entry_debug.append(f" Guaranteed: {loot_entry.get('guaranteed', False)}")

            if loot_entry.get("guaranteed"):
                should_drop = True
                if global_variables.get("devmode", {}).get("value", False):
                    entry_debug.append(f" Drop result: âœ“ GUARANTEED")
            else:

                rarity = loot_entry.get("rarity", "Common")
                drop_chance = rarity_weights.get(rarity, 50)/100.0
                roll = random.random()
                should_drop = roll <drop_chance

                if global_variables.get("devmode", {}).get("value", False):
                    entry_debug.append(f" Drop chance for '{rarity}': {drop_chance *100:.1f}%")
                    entry_debug.append(f" Roll: {roll *100:.2f}%")
                    entry_debug.append(f" Drop result: {'âœ“ SUCCESS'if should_drop else 'âœ— FAILED'}")

            if should_drop:
                item = self._resolve_loot_entry(loot_entry, table_data)
                if item:

                    if isinstance(item, list):
                        for it in item:
                            if global_variables.get("devmode", {}).get("value", False):
                                entry_debug.append(f" â†’ Resolved: {it.get('name', 'Unknown')}({it.get('rarity', 'Unknown')})")

                                if it.get("_debug_info"):
                                    entry_debug.append(f"[Resolution details]\n{it.get('_debug_info')}")
                        loot.extend(item)
                    else:
                        if global_variables.get("devmode", {}).get("value", False):
                            entry_debug.append(f" â†’ Resolved: {item.get('name', 'Unknown')}({item.get('rarity', 'Unknown')})")
                        loot.append(item)

            if global_variables.get("devmode", {}).get("value", False):
                debug_lines.extend(entry_debug)
                debug_lines.append("")

        special_chance = rarity_weights.get("Special Chance", 0)
        special_roll = random.random()*100

        if global_variables.get("devmode", {}).get("value", False):
            debug_lines.append(f"--- Special Item Roll ---")
            debug_lines.append(f" Special chance: {special_chance}%")
            debug_lines.append(f" Roll: {special_roll:.2f}")

        if special_roll <special_chance:
            special_table = table_data.get("tables", {}).get("special_items", [])
            if special_table:
                selected_special = random.choice(special_table)
                special_copy = selected_special.copy()
                special_copy["table_category"]= "special_items"
                loot.append(special_copy)

                if global_variables.get("devmode", {}).get("value", False):
                    debug_lines.append(f" â˜… SPECIAL ITEM TRIGGERED! Selected: {selected_special.get('name', 'Unknown')}")
            else:
                if global_variables.get("devmode", {}).get("value", False):
                    debug_lines.append(f" Special roll succeeded but no special_items table found")
        else:
            if global_variables.get("devmode", {}).get("value", False):
                debug_lines.append(f" No special item(needed < {special_chance})")

        if global_variables.get("devmode", {}).get("value", False):
            debug_lines.append("")
            debug_lines.append(f"â•â•â• FINAL RESULT: {len(loot)} item(s) â•â•â•")
            for it in loot:
                debug_lines.append(f" â€¢ {it.get('name', 'Unknown')}({it.get('rarity', 'Unknown')})")

            logging.debug("\n".join(debug_lines))

            if loot:
                loot[0]["_loot_debug_summary"]= "\n".join(debug_lines)

        return loot

    def _save_enemy_loot_transfer(self, enemy_name, loot_items):

        try:

            transfer_data = {
            "type":"enemyloot",
            "enemy_name":enemy_name,
            "items":loot_items,
            "timestamp":datetime.now().isoformat()
            }

            safe_name = enemy_name.replace(" ", "_").lower()
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"enemyloot_{safe_name}_{timestamp}.sldenlt"
            filepath = os.path.join("enemyloot", filename)

            os.makedirs("enemyloot", exist_ok = True)

            with open(filepath, 'wb')as f:
                pickled = pickle.dumps(transfer_data)
                encoded = base64.b85encode(pickled)
                f.write(encoded)

            logging.info(f"Saved enemy loot transfer: {filepath}")
            self._popup_show_info("Success", f"Enemy loot saved as:\n{filename}", sound = "success")

        except Exception as e:
            logging.error(f"Failed to save enemy loot transfer: {e}")
            self._popup_show_info("Error", f"Failed to save: {e}", sound = "error")

    def _open_create_lootcrate_tool(self):
        logging.info("Create Loot Crate tool called")
        self._clear_window()

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew")

        title_label = customtkinter.CTkLabel(main_frame, text = "Create Lootcrate", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title_label.pack(pady = 20)

        create_scratch_btn = self._create_sound_button(main_frame, "Create from Scratch", self._open_create_lootcrate_from_scratch, width = 800, height = 60, font = customtkinter.CTkFont(size = 16))
        create_scratch_btn.pack(pady = 10, padx = 20)

        create_preset_btn = self._create_sound_button(main_frame, "Create from Preset", self._open_create_lootcrate_from_preset, width = 800, height = 60, font = customtkinter.CTkFont(size = 16))
        create_preset_btn.pack(pady = 10, padx = 20)

        back_button = self._create_sound_button(main_frame, "Back to DM Tools", lambda:[self._clear_window(), self._open_dm_tools()], width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        back_button.pack(pady = 20)

    def _open_create_lootcrate_from_preset(self):
        logging.info("Create Loot Crate from Preset called")
        self._clear_window()

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkScrollableFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew")

        title_label = customtkinter.CTkLabel(main_frame, text = "Create Lootcrate from Preset", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title_label.pack(pady = 20)

        try:
            table_files = glob.glob(os.path.join("tables", "*.sldtbl"))
            if not table_files:
                self._popup_show_info("Error", "No table files found.", sound = "error")
                return
            with open(table_files[0], 'r')as f:
                table_data = json.load(f)
        except Exception as e:
            logging.error(f"Failed to load tables for loot crate creator: {e}")
            self._popup_show_info("Error", f"Failed to load tables: {e}", sound = "error")
            return

        def generate_crate_from_preset(crate):

            try:
                crate_copy = json.loads(json.dumps(crate))
                crate_copy.pop("_source_file", None)
                crate_copy.pop("_file_path", None)
                crate_copy["generated_at"]= datetime.now().isoformat()
                os.makedirs("lootcrates", exist_ok = True)
                filename = os.path.join(
                "lootcrates",
                f"lootcrate_{datetime.now().strftime('%Y%m%d_%H%M%S')}{global_variables['lootcrate_extension']}"
                )
                pickled_data = pickle.dumps(crate_copy)
                encoded_data = base64.b85encode(pickled_data).decode('utf-8')
                with open(filename, 'w')as f:
                    f.write(encoded_data)
                self._popup_show_info("Success", f"Generated loot crate '{crate.get('name', 'Loot Crate')}'.", sound = "success")
                logging.info(f"Generated loot crate file: {filename}")
            except Exception as e:
                logging.error(f"Failed to generate loot crate: {e}")
                self._popup_show_info("Error", f"Failed to generate loot crate: {e}", sound = "error")

        def render_preset(crate, parent_frame):

            row = customtkinter.CTkFrame(parent_frame)
            row.pack(fill = "x", padx = 5, pady = 4)
            row.grid_columnconfigure(0, weight = 1)

            name = crate.get("name", "Loot Crate")
            desc = crate.get("description", "")

            title = customtkinter.CTkLabel(row, text = name, font = customtkinter.CTkFont(size = 14, weight = "bold"), anchor = "w")
            title.grid(row = 0, column = 0, sticky = "w", padx = 4, pady =(2, 0))

            if desc:
                desc_label = customtkinter.CTkLabel(row, text = desc, font = customtkinter.CTkFont(size = 11), text_color = "gray", justify = "left", anchor = "w", wraplength = 600)
                desc_label.grid(row = 1, column = 0, sticky = "w", padx = 4, pady =(0, 2))

            preview = self._get_loot_crate_contents_preview(crate, table_data)
            if preview:
                preview_label = customtkinter.CTkLabel(row, text = preview, font = customtkinter.CTkFont(size = 10), text_color = "orange", justify = "left", anchor = "w", wraplength = 600)
                preview_label.grid(row = 2, column = 0, sticky = "w", padx = 4, pady =(0, 4))

            create_btn = self._create_sound_button(row, "Create", lambda c = crate:generate_crate_from_preset(c), width = 130, height = 35, font = customtkinter.CTkFont(size = 12))
            create_btn.grid(row = 0, column = 1, rowspan = 3, sticky = "e", padx = 10, pady = 6)

        presets_from_table = table_data.get("tables", {}).get("lootcrates", [])

        os.makedirs(os.path.join("lootcrates", "presets"), exist_ok = True)
        preset_files = glob.glob(os.path.join("lootcrates", "presets", f"*{global_variables['lootcrate_extension']}"))
        presets_from_folder =[]
        for pf in preset_files:
            try:
                with open(pf, 'r')as f:
                    encoded_data = f.read()
                pickled_data = base64.b85decode(encoded_data.encode('utf-8'))
                pdata = pickle.loads(pickled_data)
                pdata["_source_file"]= pf
                presets_from_folder.append(pdata)
            except Exception as e:
                logging.warning(f"Failed to load preset file {pf}: {e}")

        all_presets = presets_from_table +presets_from_folder
        if all_presets:
            for crate in all_presets:
                render_preset(crate, main_frame)
        else:
            no_presets_label = customtkinter.CTkLabel(main_frame, text = "No presets available.", font = customtkinter.CTkFont(size = 14), text_color = "gray")
            no_presets_label.pack(pady = 20)

        back_button = self._create_sound_button(main_frame, "Back", self._open_create_lootcrate_tool, width = 500, height = 50, font = customtkinter.CTkFont(size = 16))
        back_button.pack(pady = 20)

    def _open_create_lootcrate_from_scratch(self):
        logging.info("Create Loot Crate from Scratch called")
        self._clear_window()

        try:
            table_files = glob.glob(os.path.join("tables", "*.sldtbl"))
            if not table_files:
                self._popup_show_info("Error", "No table files found.", sound = "error")
                return
            with open(table_files[0], 'r')as f:
                table_data = json.load(f)
        except Exception as e:
            logging.error(f"Failed to load tables for loot crate creator: {e}")
            self._popup_show_info("Error", f"Failed to load tables: {e}", sound = "error")
            return

        excluded_tables = {"lootcrates", "special_items", "enemy_drops"}
        all_items =[]
        for table_name, items in table_data.get("tables", {}).items():
            if table_name in excluded_tables:
                continue
            for item in items:
                if item.get("id")is None:
                    continue
                item_copy = item.copy()
                item_copy["table_category"]= table_name
                all_items.append(item_copy)

        all_items.sort(key = lambda x:x.get("id", 999999))

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew", padx = 10, pady = 10)
        main_frame.grid_rowconfigure(2, weight = 1)
        main_frame.grid_columnconfigure(0, weight = 1)
        main_frame.grid_columnconfigure(1, weight = 0)

        title_label = customtkinter.CTkLabel(main_frame, text = "Create Lootcrate from Scratch", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title_label.grid(row = 0, column = 0, columnspan = 2, pady =(0, 10))

        meta_frame = customtkinter.CTkFrame(main_frame)
        meta_frame.grid(row = 1, column = 0, columnspan = 2, sticky = "ew", padx = 10, pady = 10)
        meta_frame.grid_columnconfigure(1, weight = 1)
        meta_frame.grid_columnconfigure(3, weight = 1)

        name_label = customtkinter.CTkLabel(meta_frame, text = "Name:")
        name_label.grid(row = 0, column = 0, padx = 5, pady = 5, sticky = "w")
        name_entry = customtkinter.CTkEntry(meta_frame, placeholder_text = "Loot Crate Name", width = 200)
        name_entry.grid(row = 0, column = 1, padx = 5, pady = 5, sticky = "w")

        desc_label = customtkinter.CTkLabel(meta_frame, text = "Description:")
        desc_label.grid(row = 0, column = 2, padx =(20, 5), pady = 5, sticky = "w")
        desc_entry = customtkinter.CTkEntry(meta_frame, placeholder_text = "Optional description", width = 300)
        desc_entry.grid(row = 0, column = 3, padx = 5, pady = 5, sticky = "ew")

        locked_var = customtkinter.BooleanVar(value = False)
        locked_check = customtkinter.CTkCheckBox(meta_frame, text = "Locked(requires lockpicking)", variable = locked_var)
        locked_check.grid(row = 1, column = 0, columnspan = 2, padx = 5, pady = 5, sticky = "w")

        pulls_label = customtkinter.CTkLabel(meta_frame, text = "Pulls:")
        pulls_label.grid(row = 1, column = 2, padx =(20, 5), pady = 5, sticky = "w")

        pulls_frame = customtkinter.CTkFrame(meta_frame, fg_color = "transparent")
        pulls_frame.grid(row = 1, column = 3, padx = 5, pady = 5, sticky = "w")

        pulls_min_entry = customtkinter.CTkEntry(pulls_frame, placeholder_text = "Min", width = 60)
        pulls_min_entry.pack(side = "left", padx = 2)
        pulls_min_entry.insert(0, "3")

        pulls_dash = customtkinter.CTkLabel(pulls_frame, text = "-")
        pulls_dash.pack(side = "left", padx = 2)

        pulls_max_entry = customtkinter.CTkEntry(pulls_frame, placeholder_text = "Max", width = 60)
        pulls_max_entry.pack(side = "left", padx = 2)
        pulls_max_entry.insert(0, "3")

        pulls_hint = customtkinter.CTkLabel(pulls_frame, text = "(same for fixed)", font = customtkinter.CTkFont(size = 10), text_color = "gray")
        pulls_hint.pack(side = "left", padx = 5)

        content_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        content_frame.grid(row = 2, column = 0, columnspan = 2, sticky = "nsew", pady = 10)
        content_frame.grid_rowconfigure(0, weight = 1)
        content_frame.grid_columnconfigure(0, weight = 1)
        content_frame.grid_columnconfigure(1, weight = 0)

        left_frame = customtkinter.CTkFrame(content_frame)
        left_frame.grid(row = 0, column = 0, sticky = "nsew", padx =(0, 5))
        left_frame.grid_rowconfigure(2, weight = 1)
        left_frame.grid_columnconfigure(0, weight = 1)

        search_frame = customtkinter.CTkFrame(left_frame, fg_color = "transparent")
        search_frame.grid(row = 0, column = 0, sticky = "ew", padx = 10, pady = 5)
        search_frame.grid_columnconfigure(1, weight = 1)

        search_label = customtkinter.CTkLabel(search_frame, text = "Search(ID or Name):", font = customtkinter.CTkFont(size = 12))
        search_label.grid(row = 0, column = 0, padx =(0, 10), sticky = "w")

        search_entry = customtkinter.CTkEntry(search_frame, placeholder_text = "Enter item ID or name...", width = 250)
        search_entry.grid(row = 0, column = 1, sticky = "ew", padx =(0, 10))

        ITEMS_PER_PAGE = 20
        current_page =[0]
        current_filtered =[all_items]
        search_timer =[None]

        info_label = customtkinter.CTkLabel(search_frame, text = f"Page 1 | {len(all_items)} items", font = customtkinter.CTkFont(size = 10), text_color = "gray")
        info_label.grid(row = 0, column = 2, padx = 5)

        table_filter_frame = customtkinter.CTkFrame(left_frame, fg_color = "transparent")
        table_filter_frame.grid(row = 1, column = 0, sticky = "ew", padx = 10, pady = 5)

        table_filter_label = customtkinter.CTkLabel(table_filter_frame, text = "Filter by table:", font = customtkinter.CTkFont(size = 11))
        table_filter_label.pack(side = "left", padx =(0, 5))

        table_names =["All"]+[t for t in table_data.get("tables", {}).keys()if t not in excluded_tables]
        table_filter_var = customtkinter.StringVar(value = "All")
        table_filter_menu = customtkinter.CTkOptionMenu(table_filter_frame, variable = table_filter_var, values = table_names, width = 150)
        table_filter_menu.pack(side = "left", padx = 5)

        scroll_frame = customtkinter.CTkScrollableFrame(left_frame, width = 550, height = 300)
        scroll_frame.grid(row = 2, column = 0, sticky = "nsew", padx = 5, pady = 5)
        scroll_frame.grid_columnconfigure(0, weight = 1)

        pagination_frame = customtkinter.CTkFrame(left_frame, fg_color = "transparent")
        pagination_frame.grid(row = 3, column = 0, pady = 5)

        right_frame = customtkinter.CTkFrame(content_frame)
        right_frame.grid(row = 0, column = 1, sticky = "nsew", padx =(5, 0))
        right_frame.grid_rowconfigure(1, weight = 1)

        loot_label = customtkinter.CTkLabel(right_frame, text = "Loot Table Entries", font = customtkinter.CTkFont(size = 14, weight = "bold"))
        loot_label.pack(pady = 10)

        loot_count_label = customtkinter.CTkLabel(right_frame, text = "0 entries", font = customtkinter.CTkFont(size = 11), text_color = "gray")
        loot_count_label.pack(pady = 2)

        loot_scroll = customtkinter.CTkScrollableFrame(right_frame, width = 320, height = 280)
        loot_scroll.pack(fill = "both", expand = True, padx = 5, pady = 5)

        loot_entries =[]

        def update_loot_display():
            for widget in loot_scroll.winfo_children():
                widget.destroy()

            loot_count_label.configure(text = f"{len(loot_entries)} entries")

            for idx, entry in enumerate(loot_entries):
                entry_frame = customtkinter.CTkFrame(loot_scroll)
                entry_frame.pack(fill = "x", pady = 2, padx = 2)

                entry_type = entry.get("type")
                if entry_type =="id":
                    item_id = entry.get("id")
                    item_name = entry.get("_display_name", f"ID: {item_id}")
                    rarity = entry.get("rarity", "")
                    rarity_text = f"({rarity})"if rarity else ""
                    text = f"ðŸ“¦ {item_name}{rarity_text}"
                elif entry_type =="table":
                    table_name = entry.get("table", "Unknown")
                    rarity = entry.get("rarity", "Any")
                    text = f"ðŸŽ² Random from '{table_name}'({rarity})"
                else:
                    text = f"? Unknown entry type"

                entry_label = customtkinter.CTkLabel(
                entry_frame,
                text = text,
                font = customtkinter.CTkFont(size = 11),
                anchor = "w",
                wraplength = 250
                )
                entry_label.pack(side = "left", fill = "x", expand = True, padx = 5, pady = 4)

                remove_btn = customtkinter.CTkButton(
                entry_frame,
                text = "X",
                width = 25,
                height = 25,
                font = customtkinter.CTkFont(size = 10),
                fg_color = "darkred",
                hover_color = "red",
                command = lambda i = idx:remove_entry(i)
                )
                remove_btn.pack(side = "right", padx = 2, pady = 2)

        def remove_entry(index):
            if 0 <=index <len(loot_entries):
                loot_entries.pop(index)
                update_loot_display()

        def show_add_item_popup(item):
            self._play_ui_sound("popup")
            popup = customtkinter.CTkToplevel(self.root)
            popup.title("Add Item to Loot Table")
            popup.transient(self.root)
            popup.grab_set()

            item_name = item.get("name", "Unknown")
            item_rarity = item.get("rarity", "Common")

            title_label = customtkinter.CTkLabel(popup, text = f"Add: {item_name}", font = customtkinter.CTkFont(size = 14, weight = "bold"))
            title_label.pack(pady =(15, 5))

            info_label = customtkinter.CTkLabel(popup, text = f"Item's inherent rarity: {item_rarity}", font = customtkinter.CTkFont(size = 11), text_color = "gray")
            info_label.pack(pady =(0, 10))

            rarity_weights = table_data.get("rarity_weights", {})
            non_rarity_keys = {"Luck Effect", "Special Chance"}
            rarity_options =[k for k in rarity_weights.keys()if k not in non_rarity_keys]

            total_weight = sum(rarity_weights.get(r, 1)for r in rarity_options)

            rarity_frame = customtkinter.CTkFrame(popup)
            rarity_frame.pack(fill = "x", padx = 20, pady = 10)

            rarity_label = customtkinter.CTkLabel(rarity_frame, text = "Select pull rarity(affects drop chance):", font = customtkinter.CTkFont(size = 12))
            rarity_label.pack(anchor = "w", padx = 10, pady = 5)

            selected_rarity = customtkinter.StringVar(value = item_rarity)

            for rarity in rarity_options:
                weight = rarity_weights.get(rarity, 1)
                percentage =(weight /total_weight *100)if total_weight >0 else 0

                radio_frame = customtkinter.CTkFrame(rarity_frame, fg_color = "transparent")
                radio_frame.pack(fill = "x", padx = 10, pady = 2)

                radio = customtkinter.CTkRadioButton(
                radio_frame,
                text = f"{rarity}",
                variable = selected_rarity,
                value = rarity,
                font = customtkinter.CTkFont(size = 12)
                )
                radio.pack(side = "left")

                pct_label = customtkinter.CTkLabel(
                radio_frame,
                text = f"({percentage:.1f}% chance)",
                font = customtkinter.CTkFont(size = 10),
                text_color = "orange"if rarity ==item_rarity else "gray"
                )
                pct_label.pack(side = "left", padx = 10)

                if rarity ==item_rarity:
                    default_label = customtkinter.CTkLabel(
                    radio_frame,
                    text = "â† default",
                    font = customtkinter.CTkFont(size = 10),
                    text_color = "green"
                    )
                    default_label.pack(side = "left")

            hint_label = customtkinter.CTkLabel(popup, text = "Higher rarity = lower weight = rarer drop", font = customtkinter.CTkFont(size = 10), text_color = "gray")
            hint_label.pack(pady = 5)

            button_frame = customtkinter.CTkFrame(popup, fg_color = "transparent")
            button_frame.pack(pady = 15)

            def confirm_add():
                self._play_ui_sound("click")
                entry = {
                "type":"id",
                "id":item.get("id"),
                "rarity":selected_rarity.get(),
                "_display_name":item.get("name", "Unknown")
                }
                loot_entries.append(entry)
                update_loot_display()
                popup.destroy()

            def cancel_add():
                self._play_ui_sound("click")
                popup.destroy()

            add_btn = customtkinter.CTkButton(button_frame, text = "Add Item", command = confirm_add, width = 120, height = 35)
            add_btn.pack(side = "left", padx = 10)

            cancel_btn = customtkinter.CTkButton(button_frame, text = "Cancel", command = cancel_add, width = 120, height = 35)
            cancel_btn.pack(side = "left", padx = 10)

            popup.update_idletasks()
            width = max(420, popup.winfo_reqwidth()+40)
            height = popup.winfo_reqheight()+20
            self._center_popup_on_window(popup, width, height)
            popup.deiconify()
            popup.lift()

        def add_item_entry(item):
            show_add_item_popup(item)

        def add_table_entry(table_name, rarity = "Common"):
            entry = {
            "type":"table",
            "table":table_name,
            "rarity":rarity
            }
            loot_entries.append(entry)
            update_loot_display()

        table_entry_frame = customtkinter.CTkFrame(right_frame)
        table_entry_frame.pack(fill = "x", padx = 5, pady = 5)

        table_entry_label = customtkinter.CTkLabel(table_entry_frame, text = "Add random table entry:", font = customtkinter.CTkFont(size = 11))
        table_entry_label.pack(anchor = "w", padx = 5, pady = 2)

        table_select_frame = customtkinter.CTkFrame(table_entry_frame, fg_color = "transparent")
        table_select_frame.pack(fill = "x", padx = 5, pady = 2)

        avail_tables =[t for t in table_data.get("tables", {}).keys()if t not in excluded_tables]
        table_select_var = customtkinter.StringVar(value = avail_tables[0]if avail_tables else "")
        table_select_menu = customtkinter.CTkOptionMenu(table_select_frame, variable = table_select_var, values = avail_tables, width = 140)
        table_select_menu.pack(side = "left", padx = 2)

        rarity_weights = table_data.get("rarity_weights", {})
        non_rarity_keys = {"Luck Effect", "Special Chance"}
        rarity_options =[k for k in rarity_weights.keys()if k not in non_rarity_keys]
        rarity_select_var = customtkinter.StringVar(value = rarity_options[0]if rarity_options else "Common")
        rarity_select_menu = customtkinter.CTkOptionMenu(table_select_frame, variable = rarity_select_var, values = rarity_options if rarity_options else["Common"], width = 100)
        rarity_select_menu.pack(side = "left", padx = 2)

        add_table_btn = customtkinter.CTkButton(
        table_select_frame,
        text = "+",
        width = 30,
        height = 28,
        command = lambda:add_table_entry(table_select_var.get(), rarity_select_var.get())
        )
        add_table_btn.pack(side = "left", padx = 2)

        clear_btn = customtkinter.CTkButton(
        right_frame,
        text = "Clear All Entries",
        width = 150,
        height = 30,
        fg_color = "darkred",
        hover_color = "red",
        command = lambda:[loot_entries.clear(), update_loot_display()]
        )
        clear_btn.pack(pady = 5)

        def create_item_widget(item):
            item_frame = customtkinter.CTkFrame(scroll_frame)
            item_frame.pack(fill = "x", pady = 2, padx = 3)
            item_frame.grid_columnconfigure(1, weight = 1)

            id_label = customtkinter.CTkLabel(
            item_frame,
            text = f"ID: {item.get('id', 'N/A')}",
            font = customtkinter.CTkFont(size = 11, weight = "bold"),
            width = 70,
            fg_color =("gray75", "gray25"),
            corner_radius = 4
            )
            id_label.grid(row = 0, column = 0, padx = 5, pady = 5, sticky = "w")

            details_frame = customtkinter.CTkFrame(item_frame, fg_color = "transparent")
            details_frame.grid(row = 0, column = 1, sticky = "ew", padx = 5, pady = 5)

            name_label = customtkinter.CTkLabel(
            details_frame,
            text = item.get("name", "Unknown"),
            font = customtkinter.CTkFont(size = 12, weight = "bold"),
            anchor = "w"
            )
            name_label.pack(anchor = "w")

            category_label = customtkinter.CTkLabel(
            details_frame,
            text = f"{item.get('table_category', 'N/A')} | {item.get('rarity', 'N/A')} | ${item.get('value', 0)}",
            font = customtkinter.CTkFont(size = 9),
            text_color = "gray",
            anchor = "w"
            )
            category_label.pack(anchor = "w")

            add_button = self._create_sound_button(
            item_frame,
            "Add",
            lambda it = item:add_item_entry(it),
            width = 60,
            height = 28,
            font = customtkinter.CTkFont(size = 10)
            )
            add_button.grid(row = 0, column = 2, padx = 5, pady = 5)

        def display_page(page_num):
            items = current_filtered[0]
            total_pages = max(1, (len(items)+ITEMS_PER_PAGE -1)//ITEMS_PER_PAGE)

            page_num = max(0, min(page_num, total_pages -1))
            current_page[0]= page_num

            for widget in scroll_frame.winfo_children():
                widget.destroy()

            if not items:
                no_results = customtkinter.CTkLabel(scroll_frame, text = "No items found.", font = customtkinter.CTkFont(size = 12), text_color = "gray")
                no_results.pack(pady = 20)
                info_label.configure(text = "No items found")
                update_pagination_controls(0, 0)
                return

            start_idx = page_num *ITEMS_PER_PAGE
            end_idx = min(start_idx +ITEMS_PER_PAGE, len(items))

            for i in range(start_idx, end_idx):
                create_item_widget(items[i])

            info_label.configure(text = f"Page {page_num +1}/{total_pages} | {len(items)} items")
            update_pagination_controls(page_num, total_pages)

            try:
                scroll_frame._parent_canvas.yview_moveto(0)
            except Exception:
                pass

        def update_pagination_controls(current, total):
            for widget in pagination_frame.winfo_children():
                widget.destroy()

            if total <=1:
                return

            first_btn = customtkinter.CTkButton(
            pagination_frame, text = "<<", width = 35, height = 28,
            command = lambda:display_page(0),
            state = "normal"if current >0 else "disabled"
            )
            first_btn.pack(side = "left", padx = 1)

            prev_btn = customtkinter.CTkButton(
            pagination_frame, text = "<", width = 35, height = 28,
            command = lambda:display_page(current -1),
            state = "normal"if current >0 else "disabled"
            )
            prev_btn.pack(side = "left", padx = 1)

            start_page = max(0, current -2)
            end_page = min(total, start_page +5)
            if end_page -start_page <5:
                start_page = max(0, end_page -5)

            for p in range(start_page, end_page):
                btn = customtkinter.CTkButton(
                pagination_frame,
                text = str(p +1),
                width = 30,
                height = 28,
                fg_color =("gray75", "gray25")if p ==current else None,
                command = lambda page = p:display_page(page)
                )
                btn.pack(side = "left", padx = 1)

            next_btn = customtkinter.CTkButton(
            pagination_frame, text = ">", width = 35, height = 28,
            command = lambda:display_page(current +1),
            state = "normal"if current <total -1 else "disabled"
            )
            next_btn.pack(side = "left", padx = 1)

            last_btn = customtkinter.CTkButton(
            pagination_frame, text = ">>", width = 35, height = 28,
            command = lambda:display_page(total -1),
            state = "normal"if current <total -1 else "disabled"
            )
            last_btn.pack(side = "left", padx = 1)

        def filter_items(*args):
            search_term = search_entry.get().lower().strip()
            table_filter = table_filter_var.get()

            filtered = all_items

            if table_filter !="All":
                filtered =[item for item in filtered if item.get("table_category")==table_filter]

            if search_term:
                filtered =[
                item for item in filtered
                if search_term in str(item.get("id", ""))or search_term in item.get("name", "").lower()
                ]

            current_filtered[0]= filtered
            current_page[0]= 0
            display_page(0)

        def on_search_change(*args):
            if search_timer[0]is not None:
                try:
                    self.root.after_cancel(search_timer[0])
                except Exception:
                    pass
            search_timer[0]= self.root.after(200, filter_items)# type: ignore

        search_entry.bind("<KeyRelease>", on_search_change)
        table_filter_var.trace_add("write", lambda *a:filter_items())

        display_page(0)

        def save_lootcrate(as_preset = False):
            try:
                crate_name = name_entry.get().strip()
                if not crate_name:
                    self._popup_show_info("Error", "Please enter a crate name.", sound = "error")
                    return

                if not loot_entries:
                    self._popup_show_info("Error", "Please add at least one loot entry.", sound = "error")
                    return

                crate_desc = desc_entry.get().strip()
                locked = locked_var.get()

                try:
                    pulls_min = int(pulls_min_entry.get()or 3)
                    pulls_max = int(pulls_max_entry.get()or 3)
                except ValueError:
                    self._popup_show_info("Error", "Pulls must be numbers.", sound = "error")
                    return

                if pulls_min ==pulls_max:
                    pulls = pulls_min
                else:
                    pulls = {"min":min(pulls_min, pulls_max), "max":max(pulls_min, pulls_max)}

                clean_loot_entries =[]
                for entry in loot_entries:
                    clean_entry = {k:v for k, v in entry.items()if not k.startswith("_")}
                    clean_loot_entries.append(clean_entry)

                crate_data = {
                "name":crate_name,
                "description":crate_desc,
                "locked":locked,
                "pulls":pulls,
                "loot_table":clean_loot_entries,
                "created_at":datetime.now().isoformat(),
                "dm_created":True
                }

                if as_preset:
                    os.makedirs(os.path.join("lootcrates", "presets"), exist_ok = True)
                    safe_name = "".join(c if c.isalnum()or c in " _-"else "_"for c in crate_name).strip()
                    filename = os.path.join(
                    "lootcrates", "presets",
                    f"{safe_name}_{datetime.now().strftime('%Y%m%d_%H%M%S')}{global_variables['lootcrate_extension']}"
                    )
                else:
                    os.makedirs("lootcrates", exist_ok = True)
                    filename = os.path.join(
                    "lootcrates",
                    f"lootcrate_{datetime.now().strftime('%Y%m%d_%H%M%S')}{global_variables['lootcrate_extension']}"
                    )

                pickled_data = pickle.dumps(crate_data)
                encoded_data = base64.b85encode(pickled_data).decode('utf-8')
                with open(filename, 'w')as f:
                    f.write(encoded_data)

                if as_preset:
                    self._popup_show_info("Success", f"Saved preset '{crate_name}' to presets folder.\nIt will now appear in 'Create from Preset'.", sound = "success")
                    logging.info(f"Saved preset loot crate to {filename}")
                else:
                    self._popup_show_info("Success", f"Generated loot crate '{crate_name}'.", sound = "success")
                    logging.info(f"Generated loot crate file: {filename}")

            except Exception as e:
                logging.error(f"Failed to save loot crate: {e}")
                self._popup_show_info("Error", f"Failed to save loot crate: {e}", sound = "error")

        button_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        button_frame.grid(row = 3, column = 0, columnspan = 2, pady = 10)

        save_crate_btn = self._create_sound_button(
        button_frame,
        "Save Lootcrate",
        lambda:save_lootcrate(as_preset = False),
        width = 180,
        height = 40,
        font = customtkinter.CTkFont(size = 14)
        )
        save_crate_btn.pack(side = "left", padx = 10)

        save_preset_btn = self._create_sound_button(
        button_frame,
        "Save as Preset",
        lambda:save_lootcrate(as_preset = True),
        width = 180,
        height = 40,
        font = customtkinter.CTkFont(size = 14)
        )
        save_preset_btn.pack(side = "left", padx = 10)

        back_btn = self._create_sound_button(
        button_frame,
        "Back",
        self._open_create_lootcrate_tool,
        width = 120,
        height = 40,
        font = customtkinter.CTkFont(size = 14)
        )
        back_btn.pack(side = "left", padx = 10)

    def _open_create_item_transfer_tool(self):
        logging.info("Create Item Transfer tool called")
        self._clear_window()

        try:
            table_files = glob.glob(os.path.join("tables", "*.sldtbl"))
            if not table_files:
                self._popup_show_info("Error", "No table files found.", sound = "error")
                return
            with open(table_files[0], 'r')as f:
                table_data = json.load(f)
        except Exception as e:
            logging.error(f"Failed to load tables for item transfer: {e}")
            self._popup_show_info("Error", f"Failed to load tables: {e}", sound = "error")
            return

        all_items =[]
        for table_name, items in table_data.get("tables", {}).items():
            for item in items:
                if item.get("id")is None:
                    continue
                item_copy = item.copy()
                item_copy["table_category"]= table_name
                all_items.append(item_copy)

        all_items.sort(key = lambda x:x.get("id", 999999))

        if not all_items:
            self._popup_show_info("Error", "No items found in table.", sound = "error")
            return

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew", padx = 20, pady = 20)
        main_frame.grid_rowconfigure(3, weight = 1)
        main_frame.grid_columnconfigure(0, weight = 1)
        main_frame.grid_columnconfigure(1, weight = 0)

        title_label = customtkinter.CTkLabel(main_frame, text = "Create Item Transfer", font = customtkinter.CTkFont(size = 24, weight = "bold"))
        title_label.grid(row = 0, column = 0, columnspan = 2, pady =(0, 10))

        top_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        top_frame.grid(row = 1, column = 0, columnspan = 2, sticky = "ew", pady = 10)
        top_frame.grid_columnconfigure(1, weight = 1)

        money_label = customtkinter.CTkLabel(top_frame, text = "Money Amount:")
        money_label.grid(row = 0, column = 0, padx =(0, 10), sticky = "w")
        money_entry = customtkinter.CTkEntry(top_frame, placeholder_text = "0", width = 120)
        money_entry.grid(row = 0, column = 1, sticky = "w", padx =(0, 30))

        search_label = customtkinter.CTkLabel(top_frame, text = "Search(ID or Name):", font = customtkinter.CTkFont(size = 13))
        search_label.grid(row = 0, column = 2, padx =(0, 10), sticky = "w")

        search_entry = customtkinter.CTkEntry(top_frame, placeholder_text = "Enter item ID or name...", width = 250)
        search_entry.grid(row = 0, column = 3, sticky = "ew", padx =(0, 10))

        ITEMS_PER_PAGE = 25
        current_page =[0]
        current_filtered =[all_items]
        search_timer =[None]
        selected_items =[]

        info_label = customtkinter.CTkLabel(top_frame, text = f"Page 1 | {len(all_items)} items total", font = customtkinter.CTkFont(size = 11), text_color = "gray")
        info_label.grid(row = 0, column = 4, padx = 10)

        content_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        content_frame.grid(row = 3, column = 0, columnspan = 2, sticky = "nsew", pady = 10)
        content_frame.grid_rowconfigure(0, weight = 1)
        content_frame.grid_columnconfigure(0, weight = 1)
        content_frame.grid_columnconfigure(1, weight = 0)

        scroll_frame = customtkinter.CTkScrollableFrame(content_frame, width = 600, height = 350)
        scroll_frame.grid(row = 0, column = 0, sticky = "nsew", padx =(0, 10))
        scroll_frame.grid_columnconfigure(0, weight = 1)

        selected_frame = customtkinter.CTkFrame(content_frame)
        selected_frame.grid(row = 0, column = 1, sticky = "nsew")

        selected_label = customtkinter.CTkLabel(selected_frame, text = "Selected Items", font = customtkinter.CTkFont(size = 14, weight = "bold"))
        selected_label.pack(pady = 10)

        selected_count_label = customtkinter.CTkLabel(selected_frame, text = "0 items selected", font = customtkinter.CTkFont(size = 11), text_color = "gray")
        selected_count_label.pack(pady = 5)

        selected_scroll = customtkinter.CTkScrollableFrame(selected_frame, width = 280, height = 300)
        selected_scroll.pack(fill = "both", expand = True, padx = 5, pady = 5)

        def update_selected_display():
            for widget in selected_scroll.winfo_children():
                widget.destroy()

            selected_count_label.configure(text = f"{len(selected_items)} item(s) selected")

            for idx, item in enumerate(selected_items):
                item_row = customtkinter.CTkFrame(selected_scroll)
                item_row.pack(fill = "x", pady = 2, padx = 2)

                item_label = customtkinter.CTkLabel(
                item_row,
                text = f"ID {item.get('id', '?')}: {item.get('name', 'Unknown')[:25]}",
                font = customtkinter.CTkFont(size = 11),
                anchor = "w"
                )
                item_label.pack(side = "left", fill = "x", expand = True, padx = 5)

                remove_btn = customtkinter.CTkButton(
                item_row,
                text = "X",
                width = 25,
                height = 25,
                font = customtkinter.CTkFont(size = 10),
                fg_color = "darkred",
                hover_color = "red",
                command = lambda i = idx:remove_item(i)
                )
                remove_btn.pack(side = "right", padx = 2)

        def remove_item(index):
            if 0 <=index <len(selected_items):
                selected_items.pop(index)
                update_selected_display()
                display_page(current_page[0])

        def add_item_to_transfer(item):
            item_copy = item.copy()
            selected_items.append(item_copy)
            update_selected_display()
            display_page(current_page[0])

        def is_item_selected(item):
            item_id = item.get("id")
            for sel in selected_items:
                if sel.get("id")==item_id:
                    return True
            return False

        pagination_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        pagination_frame.grid(row = 4, column = 0, columnspan = 2, pady = 5)

        def create_item_widget(item):
            item_frame = customtkinter.CTkFrame(scroll_frame)
            item_frame.pack(fill = "x", pady = 3, padx = 5)
            item_frame.grid_columnconfigure(1, weight = 1)

            id_label = customtkinter.CTkLabel(
            item_frame,
            text = f"ID: {item.get('id', 'N/A')}",
            font = customtkinter.CTkFont(size = 12, weight = "bold"),
            width = 80,
            fg_color =("gray75", "gray25"),
            corner_radius = 6
            )
            id_label.grid(row = 0, column = 0, padx = 8, pady = 8, sticky = "w")

            details_frame = customtkinter.CTkFrame(item_frame, fg_color = "transparent")
            details_frame.grid(row = 0, column = 1, sticky = "ew", padx = 8, pady = 8)

            name_label = customtkinter.CTkLabel(
            details_frame,
            text = item.get("name", "Unknown"),
            font = customtkinter.CTkFont(size = 13, weight = "bold"),
            anchor = "w"
            )
            name_label.pack(anchor = "w")

            category_label = customtkinter.CTkLabel(
            details_frame,
            text = f"{item.get('table_category', 'N/A')} | {item.get('rarity', 'N/A')} | ${item.get('value', 0)}",
            font = customtkinter.CTkFont(size = 10),
            text_color = "gray",
            anchor = "w"
            )
            category_label.pack(anchor = "w")

            already_selected = is_item_selected(item)
            add_button = self._create_sound_button(
            item_frame,
            "Added"if already_selected else "Add",
            lambda it = item:add_item_to_transfer(it),
            width = 80,
            height = 30,
            font = customtkinter.CTkFont(size = 11)
            )
            if already_selected:
                add_button.configure(state = "disabled", fg_color = "gray")
            add_button.grid(row = 0, column = 2, padx = 8, pady = 8)

        def display_page(page_num):
            items = current_filtered[0]
            total_pages = max(1, (len(items)+ITEMS_PER_PAGE -1)//ITEMS_PER_PAGE)

            page_num = max(0, min(page_num, total_pages -1))
            current_page[0]= page_num

            for widget in scroll_frame.winfo_children():
                widget.destroy()

            if not items:
                no_results = customtkinter.CTkLabel(scroll_frame, text = "No items found.", font = customtkinter.CTkFont(size = 14), text_color = "gray")
                no_results.pack(pady = 20)
                info_label.configure(text = "No items found")
                update_pagination_controls(0, 0)
                return

            start_idx = page_num *ITEMS_PER_PAGE
            end_idx = min(start_idx +ITEMS_PER_PAGE, len(items))

            for i in range(start_idx, end_idx):
                create_item_widget(items[i])

            info_label.configure(text = f"Page {page_num +1} of {total_pages} | {len(items)} items total")

            update_pagination_controls(page_num, total_pages)

            try:
                scroll_frame._parent_canvas.yview_moveto(0)
            except Exception:
                pass

        def update_pagination_controls(current, total):
            for widget in pagination_frame.winfo_children():
                widget.destroy()

            if total <=1:
                return

            first_btn = customtkinter.CTkButton(
            pagination_frame, text = "<<", width = 40, height = 30,
            command = lambda:display_page(0),
            state = "normal"if current >0 else "disabled"
            )
            first_btn.pack(side = "left", padx = 2)

            prev_btn = customtkinter.CTkButton(
            pagination_frame, text = "<", width = 40, height = 30,
            command = lambda:display_page(current -1),
            state = "normal"if current >0 else "disabled"
            )
            prev_btn.pack(side = "left", padx = 2)

            start_page = max(0, current -3)
            end_page = min(total, start_page +7)
            if end_page -start_page <7:
                start_page = max(0, end_page -7)

            for p in range(start_page, end_page):
                btn = customtkinter.CTkButton(
                pagination_frame,
                text = str(p +1),
                width = 35,
                height = 30,
                fg_color =("gray75", "gray25")if p ==current else None,
                command = lambda page = p:display_page(page)
                )
                btn.pack(side = "left", padx = 1)

            next_btn = customtkinter.CTkButton(
            pagination_frame, text = ">", width = 40, height = 30,
            command = lambda:display_page(current +1),
            state = "normal"if current <total -1 else "disabled"
            )
            next_btn.pack(side = "left", padx = 2)

            last_btn = customtkinter.CTkButton(
            pagination_frame, text = ">>", width = 40, height = 30,
            command = lambda:display_page(total -1),
            state = "normal"if current <total -1 else "disabled"
            )
            last_btn.pack(side = "left", padx = 2)

        def filter_items(search_term):
            search_lower = search_term.lower().strip()

            if search_lower:
                filtered =[
                item for item in all_items
                if search_lower in str(item.get("id", ""))or search_lower in item.get("name", "").lower()
                ]
            else:
                filtered = all_items

            current_filtered[0]= filtered
            current_page[0]= 0
            display_page(0)

        def on_search_change(*args):
            if search_timer[0]is not None:
                try:
                    self.root.after_cancel(search_timer[0])
                except Exception:
                    pass

            search_timer[0]= self.root.after(200, lambda:filter_items(search_entry.get()))# type: ignore

        search_entry.bind("<KeyRelease>", on_search_change)

        display_page(0)

        def save_transfer():
            try:
                transfer_money = int(money_entry.get()or 0)
            except ValueError:
                self._popup_show_info("Error", "Money amount must be a number.", sound = "error")
                return
            try:
                if not selected_items and transfer_money ==0:
                    self._popup_show_info("Error", "Add money or select at least one item.", sound = "error")
                    return
                items_to_send =[]
                for item in selected_items:
                    itm = {k:v for k, v in item.items()if k !="table_category"}
                    itm = add_subslots_to_item(itm)
                    items_to_send.append(itm)
                transfer_data = {
                "money":transfer_money,
                "items":items_to_send,
                "timestamp":datetime.now().isoformat(),
                "from_character":"DM"
                }
                pickled_data = pickle.dumps(transfer_data)
                encoded_data = base64.b85encode(pickled_data).decode('utf-8')
                os.makedirs("transfers", exist_ok = True)
                filename = os.path.join("transfers", f"transfer_dm_{datetime.now().strftime('%Y%m%d_%H%M%S')}{global_variables['transfer_extension']}")
                with open(filename, 'w')as f:
                    f.write(encoded_data)
                self._popup_show_info("Success", f"Saved transfer with ${transfer_money} and {len(items_to_send)} items.", sound = "success")
                logging.info(f"Saved DM transfer to {filename}")
                self._open_dm_tools()
            except Exception as e:
                logging.error(f"Failed to save item transfer: {e}")
                self._popup_show_info("Error", f"Failed to save item transfer: {e}", sound = "error")

        def clear_selected():
            selected_items.clear()
            update_selected_display()
            display_page(current_page[0])

        button_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        button_frame.grid(row = 5, column = 0, columnspan = 2, pady = 10)

        clear_button = self._create_sound_button(button_frame, "Clear Selection", clear_selected, width = 150, height = 40, font = customtkinter.CTkFont(size = 14))
        clear_button.pack(side = "left", padx = 10)

        save_button = self._create_sound_button(button_frame, "Save Transfer", save_transfer, width = 200, height = 40, font = customtkinter.CTkFont(size = 14))
        save_button.pack(side = "left", padx = 10)

        back_button = self._create_sound_button(button_frame, "Back to DM Tools", lambda:[self._clear_window(), self._open_dm_tools()], width = 200, height = 40, font = customtkinter.CTkFont(size = 14))
        back_button.pack(side = "left", padx = 10)

    def _open_create_magazine_transfer_tool(self):

        logging.info("Create Loaded Magazine Transfer tool called")

        try:
            table_files = glob.glob(os.path.join("tables", "*.sldtbl"))
            if not table_files:
                self._popup_show_info("Error", "No table file found.", sound = "error")
                return
            with open(table_files[0], 'r')as f:
                table_data = json.load(f)
        except Exception as e:
            logging.error(f"Failed to load table: {e}")
            self._popup_show_info("Error", f"Failed to load table: {e}", sound = "error")
            return

        magazines = table_data.get("tables", {}).get("magazines", [])

        if not magazines:
            self._popup_show_info("Error", "No magazines found in table.", sound = "error")
            return

        all_magazines = sorted(magazines, key = lambda x:x.get("name", "").lower())

        self._clear_window()
        self._play_ui_sound("whoosh1")

        self.root.grid_rowconfigure(0, weight = 1)
        self.root.grid_columnconfigure(0, weight = 1)

        main_frame = customtkinter.CTkFrame(self.root)
        main_frame.grid(row = 0, column = 0, sticky = "nsew", padx = 20, pady = 20)
        main_frame.grid_rowconfigure(2, weight = 1)
        main_frame.grid_columnconfigure(0, weight = 1)

        title_label = customtkinter.CTkLabel(
        main_frame,
        text = "Create Loaded Magazine Transfer",
        font = customtkinter.CTkFont(size = 24, weight = "bold")
        )
        title_label.grid(row = 0, column = 0, pady =(0, 10))

        top_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        top_frame.grid(row = 1, column = 0, sticky = "ew", pady = 10)
        top_frame.grid_columnconfigure(1, weight = 1)

        search_label = customtkinter.CTkLabel(top_frame, text = "Search(Name or Caliber):", font = customtkinter.CTkFont(size = 13))
        search_label.grid(row = 0, column = 0, padx =(0, 10), sticky = "w")

        search_entry = customtkinter.CTkEntry(top_frame, placeholder_text = "Enter magazine name or caliber...", width = 300)
        search_entry.grid(row = 0, column = 1, sticky = "w", padx =(0, 20))

        ITEMS_PER_PAGE = 20
        current_page =[0]
        current_filtered =[all_magazines]
        search_timer =[None]

        info_label = customtkinter.CTkLabel(top_frame, text = f"Page 1 | {len(all_magazines)} magazines total", font = customtkinter.CTkFont(size = 11), text_color = "gray")
        info_label.grid(row = 0, column = 2, padx = 10)

        scroll_frame = customtkinter.CTkScrollableFrame(main_frame, height = 400)
        scroll_frame.grid(row = 2, column = 0, sticky = "nsew", pady = 10)
        scroll_frame.grid_columnconfigure(0, weight = 1)

        pagination_frame = customtkinter.CTkFrame(main_frame, fg_color = "transparent")
        pagination_frame.grid(row = 3, column = 0, pady = 5)

        def create_mag_widget(mag):
            mag_frame = customtkinter.CTkFrame(scroll_frame)
            mag_frame.pack(fill = "x", pady = 3, padx = 5)
            mag_frame.grid_columnconfigure(1, weight = 1)

            mag_info = f"{mag.get('name', 'Unknown')}"
            mag_details = f"Caliber: {', '.join(mag.get('caliber', ['Unknown']))} | Capacity: {mag.get('capacity', 0)}"
            if mag.get("magazinesystem"):
                mag_details +=f" | System: {mag.get('magazinesystem')}"

            name_label = customtkinter.CTkLabel(
            mag_frame,
            text = mag_info,
            font = customtkinter.CTkFont(size = 13, weight = "bold"),
            anchor = "w"
            )
            name_label.grid(row = 0, column = 0, padx = 10, pady =(8, 2), sticky = "w")

            details_label = customtkinter.CTkLabel(
            mag_frame,
            text = mag_details,
            font = customtkinter.CTkFont(size = 11),
            text_color = "gray",
            anchor = "w"
            )
            details_label.grid(row = 1, column = 0, padx = 10, pady =(0, 8), sticky = "w")

            def create_mag_transfer(m = mag):
                self._create_loaded_magazine_dialog(m, table_data)

            create_btn = self._create_sound_button(
            mag_frame,
            text = "Create Transfer",
            command = create_mag_transfer,
            width = 140,
            height = 32
            )
            create_btn.grid(row = 0, column = 1, rowspan = 2, padx = 10, pady = 8, sticky = "e")

        def display_page(page_num):
            items = current_filtered[0]
            total_pages = max(1, (len(items)+ITEMS_PER_PAGE -1)//ITEMS_PER_PAGE)
            page_num = max(0, min(page_num, total_pages -1))
            current_page[0]= page_num

            for widget in scroll_frame.winfo_children():
                widget.destroy()

            if not items:
                no_results = customtkinter.CTkLabel(scroll_frame, text = "No magazines found.", font = customtkinter.CTkFont(size = 14), text_color = "gray")
                no_results.pack(pady = 20)
                info_label.configure(text = "No magazines found")
                update_pagination_controls(0, 0)
                return

            start_idx = page_num *ITEMS_PER_PAGE
            end_idx = min(start_idx +ITEMS_PER_PAGE, len(items))

            for i in range(start_idx, end_idx):
                create_mag_widget(items[i])

            info_label.configure(text = f"Page {page_num +1} of {total_pages} | {len(items)} magazines total")
            update_pagination_controls(page_num, total_pages)

            try:
                scroll_frame._parent_canvas.yview_moveto(0)
            except Exception:
                pass

        def update_pagination_controls(current, total):
            for widget in pagination_frame.winfo_children():
                widget.destroy()

            if total <=1:
                return

            first_btn = customtkinter.CTkButton(pagination_frame, text = "<<", width = 40, height = 30, command = lambda:display_page(0), state = "normal"if current >0 else "disabled")
            first_btn.pack(side = "left", padx = 2)

            prev_btn = customtkinter.CTkButton(pagination_frame, text = "<", width = 40, height = 30, command = lambda:display_page(current -1), state = "normal"if current >0 else "disabled")
            prev_btn.pack(side = "left", padx = 2)

            start_page = max(0, current -3)
            end_page = min(total, start_page +7)
            if end_page -start_page <7:
                start_page = max(0, end_page -7)

            for p in range(start_page, end_page):
                btn = customtkinter.CTkButton(pagination_frame, text = str(p +1), width = 35, height = 30, fg_color =("gray75", "gray25")if p ==current else None, command = lambda page = p:display_page(page))
                btn.pack(side = "left", padx = 1)

            next_btn = customtkinter.CTkButton(pagination_frame, text = ">", width = 40, height = 30, command = lambda:display_page(current +1), state = "normal"if current <total -1 else "disabled")
            next_btn.pack(side = "left", padx = 2)

            last_btn = customtkinter.CTkButton(pagination_frame, text = ">>", width = 40, height = 30, command = lambda:display_page(total -1), state = "normal"if current <total -1 else "disabled")
            last_btn.pack(side = "left", padx = 2)

        def filter_magazines(search_term):
            search_lower = search_term.lower().strip()

            if search_lower:
                filtered =[
                mag for mag in all_magazines
                if search_lower in mag.get("name", "").lower()
                or any(search_lower in cal.lower()for cal in mag.get("caliber", []))
                or search_lower in mag.get("magazinesystem", "").lower()
                ]
            else:
                filtered = all_magazines

            current_filtered[0]= filtered
            current_page[0]= 0
            display_page(0)

        def on_search_change(*args):
            if search_timer[0]is not None:
                try:
                    self.root.after_cancel(search_timer[0])
                except Exception:
                    pass
            search_timer[0]= self.root.after(200, lambda:filter_magazines(search_entry.get()))# type: ignore

        search_entry.bind("<KeyRelease>", on_search_change)

        display_page(0)

        back_button = self._create_sound_button(
        main_frame,
        text = "Back to DM Tools",
        command = lambda:[self._clear_window(), self._open_dm_tools()],
        width = 300,
        height = 50,
        font = customtkinter.CTkFont(size = 16)
        )
        back_button.grid(row = 4, column = 0, pady = 20)

    def _create_loaded_magazine_dialog(self, magazine, table_data):

        dialog = customtkinter.CTkToplevel(self.root)
        dialog.title(f"Create: {magazine.get('name', 'Magazine')}")
        dialog.transient(self.root)
        self._center_popup_on_window(dialog, 600, 700)
        try:
            dialog.wait_visibility()
            dialog.grab_set()
        except Exception as e:
            logging.warning("Dialog grab_set failed: %s", e)

        customtkinter.CTkLabel(
        dialog,
        text = f"Configure {magazine.get('name', 'Magazine')}",
        font = customtkinter.CTkFont(size = 16, weight = "bold")
        ).pack(pady = 10)

        quantity_frame = customtkinter.CTkFrame(dialog)
        quantity_frame.pack(fill = "x", padx = 20, pady = 10)

        customtkinter.CTkLabel(
        quantity_frame,
        text = "Number of magazines:",
        font = customtkinter.CTkFont(size = 12)
        ).pack(side = "left", padx = 10)

        quantity_var = customtkinter.StringVar(value = "1")
        quantity_entry = customtkinter.CTkEntry(quantity_frame, textvariable = quantity_var, width = 100)
        quantity_entry.pack(side = "right", padx = 10)

        customtkinter.CTkLabel(
        dialog,
        text = "Select ammunition type:",
        font = customtkinter.CTkFont(size = 14, weight = "bold")
        ).pack(pady = 10)

        mag_calibers = magazine.get("caliber", [])
        ammunition_table = table_data.get("tables", {}).get("ammunition", [])

        compatible_ammo =[
        ammo for ammo in ammunition_table
        if ammo.get("caliber")in mag_calibers
        ]

        if not compatible_ammo:
            customtkinter.CTkLabel(
            dialog,
            text = "No compatible ammunition found!",
            font = customtkinter.CTkFont(size = 12),
            text_color = "red"
            ).pack(pady = 20)

            self._create_sound_button(
            dialog,
            text = "Close",
            command = dialog.destroy,
            fg_color = "#8B0000"
            ).pack(pady = 10)
            return

        selected_ammo = customtkinter.StringVar(value = compatible_ammo[0].get("name", ""))
        selected_variant = customtkinter.StringVar(value = "")

        ammo_scroll = customtkinter.CTkScrollableFrame(dialog, height = 200)
        ammo_scroll.pack(fill = "x", padx = 20, pady = 10)

        for ammo in compatible_ammo:
            ammo_frame = customtkinter.CTkFrame(ammo_scroll)
            ammo_frame.pack(fill = "x", pady = 2)

            radio = customtkinter.CTkRadioButton(
            ammo_frame,
            text = ammo.get("name", "Unknown"),
            variable = selected_ammo,
            value = ammo.get("name", ""),
            font = customtkinter.CTkFont(size = 12)
            )
            radio.pack(anchor = "w", padx = 10, pady = 5)

            if ammo.get("variants"):
                variant_frame = customtkinter.CTkFrame(ammo_frame)
                variant_frame.pack(fill = "x", padx = 30)

                for variant in ammo["variants"]:
                    var_radio = customtkinter.CTkRadioButton(
                    variant_frame,
                    text = variant.get("name", "Unknown Variant"),
                    variable = selected_variant,
                    value = f"{ammo.get('name')}|{variant.get('name')}",
                    font = customtkinter.CTkFont(size = 11)
                    )
                    var_radio.pack(anchor = "w", padx = 10, pady = 2)

        fill_frame = customtkinter.CTkFrame(dialog)
        fill_frame.pack(fill = "x", padx = 20, pady = 10)

        customtkinter.CTkLabel(
        fill_frame,
        text = "Fill level(% of capacity):",
        font = customtkinter.CTkFont(size = 12)
        ).pack(side = "left", padx = 10)

        fill_var = customtkinter.StringVar(value = "100")
        fill_entry = customtkinter.CTkEntry(fill_frame, textvariable = fill_var, width = 100)
        fill_entry.pack(side = "right", padx = 10)

        def create_transfer():
            try:
                qty = int(quantity_var.get())
                fill_percent = int(fill_var.get())

                if qty <=0 or fill_percent <0 or fill_percent >100:
                    raise ValueError("Invalid quantity or fill percentage")

                ammo_obj = None
                for ammo in compatible_ammo:
                    if ammo.get("name")==selected_ammo.get():
                        ammo_obj = ammo
                        break

                if not ammo_obj:
                    raise ValueError("No ammunition selected")

                variant_info = None
                if selected_variant.get():
                    variant_parts = selected_variant.get().split("|")
                    if len(variant_parts)==2:
                        for var in ammo_obj.get("variants", []):
                            if var.get("name")==variant_parts[1]:
                                variant_info = var
                                break

                if not variant_info:
                    variants = ammo_obj.get("variants", [])
                    if variants:
                        variant_info = variants[0]

                magazines =[]
                capacity = magazine.get("capacity", 30)
                rounds_to_load = int(capacity *(fill_percent /100.0))

                for i in range(qty):
                    mag_copy = json.loads(json.dumps(magazine))
                    mag_copy["rounds"]=[]

                    if not mag_copy.get("magazinesystem"):
                        mag_copy["magazinesystem"]= magazine.get("magazinesystem", "Unknown")

                    for j in range(rounds_to_load):
                        caliber = ammo_obj.get("caliber", "Unknown")
                        if isinstance(caliber, list):
                            caliber = caliber[0]if caliber else "Unknown"

                        round_data = {
                        "caliber":caliber,
                        "name":f"{caliber} | {variant_info.get('name', 'FMJ')if variant_info else 'FMJ'}",
                        "variant":variant_info.get("name", "FMJ")if variant_info else "FMJ"
                        }

                        if variant_info:
                            if variant_info.get("type"):
                                round_data["type"]= variant_info.get("type")
                            if variant_info.get("pen"):
                                round_data["pen"]= variant_info.get("pen")
                            if variant_info.get("tip"):
                                round_data["tip"]= variant_info.get("tip")
                            if variant_info.get("modifiers"):
                                round_data["modifiers"]= variant_info.get("modifiers")

                        mag_copy["rounds"].append(round_data)

                    magazines.append(mag_copy)

                self._save_magazine_transfer(magazines)
                dialog.destroy()

            except ValueError as e:
                self._popup_show_info("Error", f"Invalid input: {e}", sound = "error")

        self._create_sound_button(
        dialog,
        text = "Create Transfer",
        command = create_transfer,
        width = 200
        ).pack(pady = 10)

        self._create_sound_button(
        dialog,
        text = "Cancel",
        command = dialog.destroy,
        fg_color = "#8B0000",
        width = 200
        ).pack(pady = 5)

    def _save_magazine_transfer(self, magazines):

        try:
            transfer_data = {
            "type":"magazines",
            "items":magazines,
            "timestamp":datetime.now().isoformat()
            }

            mag_name = magazines[0].get("name", "magazine").replace(" ", "_").lower()
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"mag_{mag_name}_{len(magazines)}x_{timestamp}.sldtrf"
            filepath = os.path.join("transfers", filename)

            os.makedirs("transfers", exist_ok = True)

            with open(filepath, 'wb')as f:
                pickled = pickle.dumps(transfer_data)
                encoded = base64.b85encode(pickled)
                f.write(encoded)

            logging.info(f"Saved magazine transfer: {filepath}")
            self._popup_show_info("Success", f"Magazine transfer saved as:\n{filename}", sound = "success")

        except Exception as e:
            logging.error(f"Failed to save magazine transfer: {e}")
            self._popup_show_info("Error", f"Failed to save: {e}", sound = "error")

    def _open_create_belt_transfer_tool(self):

        logging.info("Create Belt Transfer tool called")

        try:
            table_files = glob.glob(os.path.join("tables", "*.sldtbl"))
            if not table_files:
                self._popup_show_info("Error", "No table file found.", sound = "error")
                return
            with open(table_files[0], 'r')as f:
                table_data = json.load(f)
        except Exception as e:
            logging.error(f"Failed to load table: {e}")
            self._popup_show_info("Error", f"Failed to load table: {e}", sound = "error")
            return

        magazines = table_data.get("tables", {}).get("magazines", [])
        belt_links =[mag for mag in magazines if mag.get("beltlink")]

        if not belt_links:
            self._popup_show_info("Error", "No belt links found in table.", sound = "error")
            return

        self._clear_window()
        self._play_ui_sound("whoosh1")

        main_frame = customtkinter.CTkScrollableFrame(self.root, fg_color = "transparent")
        main_frame.pack(fill = "both", expand = True, padx = 20, pady = 20)

        title_label = customtkinter.CTkLabel(
        main_frame,
        text = "Create Loaded Belt Transfer",
        font = customtkinter.CTkFont(size = 24, weight = "bold")
        )
        title_label.pack(pady = 20)

        customtkinter.CTkLabel(
        main_frame,
        text = "Select a belt link type to create:",
        font = customtkinter.CTkFont(size = 14)
        ).pack(pady = 10)

        for belt in belt_links:
            belt_frame = customtkinter.CTkFrame(main_frame)
            belt_frame.pack(fill = "x", pady = 5, padx = 20)

            belt_info = f"{belt.get('name', 'Unknown')}\n"
            belt_info +=f"Caliber: {', '.join(belt.get('caliber', ['Unknown']))}\n"
            belt_info +=f"Belt Link: {belt.get('beltlink')}"

            customtkinter.CTkLabel(
            belt_frame,
            text = belt_info,
            font = customtkinter.CTkFont(size = 12),
            justify = "left"
            ).pack(side = "left", padx = 10, pady = 10)

            def create_belt_transfer(b = belt):
                self._create_loaded_belt_dialog(b, table_data)

            self._create_sound_button(
            belt_frame,
            text = "Create Transfer",
            command = create_belt_transfer,
            width = 150
            ).pack(side = "right", padx = 10, pady = 5)

        back_button = self._create_sound_button(
        main_frame,
        text = "Back to DM Tools",
        command = lambda:[self._clear_window(), self._open_dm_tools()],
        width = 300,
        height = 50,
        font = customtkinter.CTkFont(size = 16)
        )
        back_button.pack(pady = 20)

    def _create_loaded_belt_dialog(self, belt_link, table_data):

        dialog = customtkinter.CTkToplevel(self.root)
        dialog.title(f"Create: {belt_link.get('name', 'Belt')}")
        dialog.transient(self.root)
        self._center_popup_on_window(dialog, 600, 700)
        dialog.grab_set()

        customtkinter.CTkLabel(
        dialog,
        text = f"Configure {belt_link.get('name', 'Belt')}",
        font = customtkinter.CTkFont(size = 16, weight = "bold")
        ).pack(pady = 10)

        count_frame = customtkinter.CTkFrame(dialog)
        count_frame.pack(fill = "x", padx = 20, pady = 10)

        customtkinter.CTkLabel(
        count_frame,
        text = "Number of rounds in belt:",
        font = customtkinter.CTkFont(size = 12)
        ).pack(side = "left", padx = 10)

        count_var = customtkinter.StringVar(value = "100")
        count_entry = customtkinter.CTkEntry(count_frame, textvariable = count_var, width = 100)
        count_entry.pack(side = "right", padx = 10)

        customtkinter.CTkLabel(
        dialog,
        text = "Select ammunition type:",
        font = customtkinter.CTkFont(size = 14, weight = "bold")
        ).pack(pady = 10)

        belt_calibers = belt_link.get("caliber", [])
        ammunition_table = table_data.get("tables", {}).get("ammunition", [])

        compatible_ammo =[
        ammo for ammo in ammunition_table
        if ammo.get("caliber")in belt_calibers
        ]

        if not compatible_ammo:
            customtkinter.CTkLabel(
            dialog,
            text = "No compatible ammunition found!",
            font = customtkinter.CTkFont(size = 12),
            text_color = "red"
            ).pack(pady = 20)

            self._create_sound_button(
            dialog,
            text = "Close",
            command = dialog.destroy,
            fg_color = "#8B0000"
            ).pack(pady = 10)
            return

        selected_ammo = customtkinter.StringVar(value = compatible_ammo[0].get("name", ""))
        selected_variant = customtkinter.StringVar(value = "")

        ammo_scroll = customtkinter.CTkScrollableFrame(dialog, height = 250)
        ammo_scroll.pack(fill = "x", padx = 20, pady = 10)

        for ammo in compatible_ammo:
            ammo_frame = customtkinter.CTkFrame(ammo_scroll)
            ammo_frame.pack(fill = "x", pady = 2)

            radio = customtkinter.CTkRadioButton(
            ammo_frame,
            text = ammo.get("name", "Unknown"),
            variable = selected_ammo,
            value = ammo.get("name", ""),
            font = customtkinter.CTkFont(size = 12)
            )
            radio.pack(anchor = "w", padx = 10, pady = 5)

            if ammo.get("variants"):
                variant_frame = customtkinter.CTkFrame(ammo_frame)
                variant_frame.pack(fill = "x", padx = 30)

                for variant in ammo["variants"]:
                    var_radio = customtkinter.CTkRadioButton(
                    variant_frame,
                    text = variant.get("name", "Unknown Variant"),
                    variable = selected_variant,
                    value = f"{ammo.get('name')}|{variant.get('name')}",
                    font = customtkinter.CTkFont(size = 11)
                    )
                    var_radio.pack(anchor = "w", padx = 10, pady = 2)

        def create_transfer():
            try:
                round_count = int(count_var.get())

                if round_count <=0:
                    raise ValueError("Invalid round count")

                ammo_obj = None
                for ammo in compatible_ammo:
                    if ammo.get("name")==selected_ammo.get():
                        ammo_obj = ammo
                        break

                if not ammo_obj:
                    raise ValueError("No ammunition selected")

                belt_copy = json.loads(json.dumps(belt_link))
                belt_copy["rounds"]=[]

                variant_info = None
                if selected_variant.get():
                    variant_parts = selected_variant.get().split("|")
                    if len(variant_parts)==2:
                        for var in ammo_obj.get("variants", []):
                            if var.get("name")==variant_parts[1]:
                                variant_info = var
                                break

                if not variant_info:
                    variants = ammo_obj.get("variants", [])
                    if variants:
                        variant_info = variants[0]

                for i in range(round_count):
                    caliber = ammo_obj.get("caliber")
                    if isinstance(caliber, list):
                        caliber = caliber[0]if caliber else "Unknown"

                    round_data = {
                    "caliber":caliber,
                    "name":f"{caliber} | {variant_info.get('name', 'FMJ')if variant_info else 'FMJ'}",
                    "variant":variant_info.get("name", "FMJ")if variant_info else "FMJ"
                    }

                    if variant_info:
                        if variant_info.get("type"):
                            round_data["type"]= variant_info.get("type")
                        if variant_info.get("pen"):
                            round_data["pen"]= variant_info.get("pen")
                        if variant_info.get("tip"):
                            round_data["tip"]= variant_info.get("tip")
                        if variant_info.get("modifiers"):
                            round_data["modifiers"]= variant_info.get("modifiers")

                    belt_copy["rounds"].append(round_data)

                self._save_belt_transfer(belt_copy, round_count)
                dialog.destroy()

            except ValueError as e:
                self._popup_show_info("Error", f"Invalid input: {e}", sound = "error")

        self._create_sound_button(
        dialog,
        text = "Create Transfer",
        command = create_transfer,
        width = 200
        ).pack(pady = 10)

        self._create_sound_button(
        dialog,
        text = "Cancel",
        command = dialog.destroy,
        fg_color = "#8B0000",
        width = 200
        ).pack(pady = 5)

    def _save_belt_transfer(self, belt, round_count):

        try:
            transfer_data = {
            "type":"belt",
            "items":[belt],
            "timestamp":datetime.now().isoformat()
            }

            belt_name = belt.get("beltlink", "belt").replace(" ", "_").lower()
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"belt_{belt_name}_{round_count}rds_{timestamp}.sldtrf"
            filepath = os.path.join("transfers", filename)

            os.makedirs("transfers", exist_ok = True)

            with open(filepath, 'wb')as f:
                pickled = pickle.dumps(transfer_data)
                encoded = base64.b85encode(pickled)
                f.write(encoded)

            logging.info(f"Saved belt transfer: {filepath}")
            self._popup_show_info("Success", f"Belt transfer saved as:\n{filename}", sound = "success")

        except Exception as e:
            logging.error(f"Failed to save belt transfer: {e}")
            self._popup_show_info("Error", f"Failed to save: {e}", sound = "error")

    def _open_modify_settings_tool(self):

        logging.info("Modify Settings tool called")

        try:
            table_files = glob.glob(os.path.join("tables", "*.sldtbl"))
            if not table_files:
                self._popup_show_info("Error", "No table file found.", sound = "error")
                return
            with open(table_files[0], 'r')as f:
                table_data = json.load(f)
        except Exception as e:
            logging.error(f"Failed to load table: {e}")
            self._popup_show_info("Error", f"Failed to load table: {e}", sound = "error")
            return

        dm_settings_path = os.path.join(saves_folder or "saves", "dm_settings.sldsv")
        dm_settings = {"enabled_enemies":{}}

        if os.path.exists(dm_settings_path):
            try:
                with open(dm_settings_path, 'r')as f:
                    dm_settings = json.load(f)
                    if "enabled_enemies"not in dm_settings:
                        dm_settings["enabled_enemies"]= {}
            except Exception as e:
                logging.warning(f"Failed to load DM settings: {e}")

        enemy_list = table_data.get("tables", {}).get("enemy_drops", [])

        for enemy in enemy_list:
            enemy_name = enemy.get("name")
            if enemy_name and enemy_name not in dm_settings["enabled_enemies"]:
                dm_settings["enabled_enemies"][enemy_name]= True

        self._clear_window()
        self._play_ui_sound("whoosh1")

        main_frame = customtkinter.CTkScrollableFrame(self.root, fg_color = "transparent")
        main_frame.pack(fill = "both", expand = True, padx = 20, pady = 20)

        title_label = customtkinter.CTkLabel(
        main_frame,
        text = "DM Settings - Enemy Spawn Control",
        font = customtkinter.CTkFont(size = 24, weight = "bold")
        )
        title_label.pack(pady = 20)

        customtkinter.CTkLabel(
        main_frame,
        text = "Toggle enemies on/off for encounter rolls and loot generation:",
        font = customtkinter.CTkFont(size = 14)
        ).pack(pady = 10)

        enemy_vars = {}

        for enemy in enemy_list:
            enemy_name = enemy.get("name", "Unknown")
            enemy_frame = customtkinter.CTkFrame(main_frame)
            enemy_frame.pack(fill = "x", pady = 5, padx = 20)

            enemy_info = f"{enemy_name} - {enemy.get('difficulty', 'Unknown')} Difficulty"

            customtkinter.CTkLabel(
            enemy_frame,
            text = enemy_info,
            font = customtkinter.CTkFont(size = 12)
            ).pack(side = "left", padx = 10, pady = 10)

            var = customtkinter.BooleanVar(value = dm_settings["enabled_enemies"].get(enemy_name, True))
            enemy_vars[enemy_name]= var

            toggle = customtkinter.CTkSwitch(
            enemy_frame,
            text = "Enabled",
            variable = var,
            font = customtkinter.CTkFont(size = 12)
            )
            toggle.pack(side = "right", padx = 10, pady = 10)

        buttons_frame = customtkinter.CTkFrame(main_frame)
        buttons_frame.pack(fill = "x", pady = 20, padx = 20)

        def save_settings():

            try:

                for enemy_name, var in enemy_vars.items():
                    dm_settings["enabled_enemies"][enemy_name]= var.get()

                with open(dm_settings_path, 'w')as f:
                    json.dump(dm_settings, f, indent = 4)

                logging.info(f"DM settings saved to {dm_settings_path}")
                self._popup_show_info("Success", "DM settings saved successfully!", sound = "success")

            except Exception as e:
                logging.error(f"Failed to save DM settings: {e}")
                self._popup_show_info("Error", f"Failed to save settings: {e}", sound = "error")

        def enable_all():

            for var in enemy_vars.values():
                var.set(True)

        def disable_all():

            for var in enemy_vars.values():
                var.set(False)

        self._create_sound_button(
        buttons_frame,
        text = "Save Settings",
        command = save_settings,
        width = 200
        ).pack(side = "left", padx = 10)

        self._create_sound_button(
        buttons_frame,
        text = "Enable All",
        command = enable_all,
        width = 150,
        fg_color = "#006400"
        ).pack(side = "left", padx = 10)

        self._create_sound_button(
        buttons_frame,
        text = "Disable All",
        command = disable_all,
        width = 150,
        fg_color = "#8B0000"
        ).pack(side = "left", padx = 10)

        back_button = self._create_sound_button(
        main_frame,
        text = "Back to DM Tools",
        command = lambda:[self._clear_window(), self._open_dm_tools()],
        width = 300,
        height = 50,
        font = customtkinter.CTkFont(size = 16)
        )
        back_button.pack(pady = 20)
if __name__ =="__main__":
    app = App()
